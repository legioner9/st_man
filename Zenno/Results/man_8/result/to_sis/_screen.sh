#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 screen (8)   screen  (1)   ( Solaris man: Команды и прикладные программы пользовательского уровня )   screen  (1)   ( Linux man: Команды и прикладные программы пользовательского уровня )   screen  (4)   ( FreeBSD man: Специальные файлы /dev/* ) >>  screen  (8)   ( Русские man: Команды системного администрирования ) Ключ  screen  обнаружен в базе ключевых слов. 
{{header}}
{{translator-igorchubin}}
 http://linux.die.net/man/1/screen 
 
Эта страница является переводом официальной man-страницы программы GNU Screen,
текстового оконного менеджера, эмулирующего терминал VT100/ANSI.
 
   
  Имя  

 

screen  оконный менеджер с эмуляцией терминала VT100/ANSI
 
   
  Синтаксис  

 

 
 
        screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]

 

 

 
   
  Описание  

 

 
Screen это полноэкранный оконный менеджер, который мультиплексирует физический терминал 
между несколькими процессами (обычно, интерактивными оболочками).
Каждый терминал обладает функциональностью терминала DEC VT100
и некоторыми управляющими функциями из стандартов ISO 6429 (ECMA 49, ANSI X3.64) 
и ISO 2022 (вставка/удаление строки и поддержка множеств символов).
Для каждого виртуального терминала есть буфер истории и механизм обмена, позволяющий
копировать текст между окнами.
 
При вызове screen создаёт отдельное окно, в котором запускает оболочку командного интерпретатора
(или заданную программу), и вы можете работать с ней как и обычно.
Потом, в любое время, можно создавать новые (полноэкранные) окна,
в которых будут исполняться другие программы (в том числе различные оболочки),
закрывать существующие окна, просматривать список окон, включать/выключать запись,
просматривать буфер прокрутки, переключаться между окнами самыми разнообразными способами
и выполнять множество других действий.
Все окна работают полностью независимо друг от друга.
Программы продолжают работать, даже если они невидимы в настоящий момент,
или вообще весь сеанс screen полностью отключён от терминала пользователя.
Когда программа завершается, screen (по умолчанию) закрывает то окно, 
в котором она исполнялась. Если это окно было активным, screen активирует предыдущее;
если окон не осталось, screen завершается.
 
Всё, что вы набираете внутри screen, отправляется программе, работающей
в текущем окне.  Единственное исключение --- комбинация клавиш,   которая
показывает, что сейчас вы  хотите работать с самим оконным  менеджером.
По умолчанию, команды работы с оконным менеджером  начинаются  нажатием
Control-a (далее C-a), за которым следует  нажатие одной  клавиши.  Эта
и другие управляющие комбинации могут быть настроены иначе, но они
обязательно должны состоять из двух символов.
 
Программа screen не понимает префикс "C-" как обозначение нажатия Ctrl.
Вместо этого нужно использовать запись с символом ^ (например, ^A вместо C-a).
Это может пригодиться,  например,  как аргумент опции -e.  Кроме этого,
управляющие символы screen выводит в этом же формате.
 
Стандартный способ создать новое окно --- нажать "C-a c".
Окно создаётся мгновенно, и screen сразу же делает его активным, независимо
от того, в каком состоянии находится процесс, выполняющийся в текущем окне.
Аналогично можно создавать новые окна, в которых будет выполняться какая-то своя команда.
Для этого сначала нужно привязать команду к комбинации клавиш (это делается через
конфигурационный файл 
 
 

 

  или через режим командной строки  C-a : ,
а потом, когда будет нужно, просто использовать эту комбинацию клавиш.
Кроме всего прочего, новые окна можно создавать при помощи команды:
 
 
     screen emacs prog.c

 

 

которая вызывается в командном интерпретаторе, работающем внутри screen.
Новая копия screen создаваться не будет, а вместо этого команда будет передана
текущему менеджеру (информация о том кто именно является текущим менеджером
находится в переменной окружения 
 
 $STY
 

 

), который и создаст 
новое окно.
В приведённом выше примере запускается редактор  emacs  (в котором открывается prog.c)
и окно с этим редактором становится активным.
 
Если файл 
 
 /var/run/utmp
 

 

  доступен screen для изменения, 
он сделает соответствующие записи для каждого окна при их создании, 
и удалит при их закрытии. Это очень полезно при использовании
таких программ как  talk ,  script ,  shutdown ,  rsend ,  sccs 
и многими другими, которые используют файл 
 
 utmp
 

 

,
для того чтобы определить кто вы (то есть, какой пользователь работает с каким терминалом).
До тех пор пока screen активен на терминале, запись про собственно этот 
терминал удаляется. Также смотрите  C-a L .
 
   
  С чего начать?  

 

 
Перед тем как приступить к работе  со  screen'ом,  нужно убедиться, что
установлен правильный тип терминала (как и для других программ, которые
используют tercap/terminfo). Это можно сделать,   например,   с помощью
программы  tset .
 
Если вы хотите побыстрее  начать  работу со screen  и  не углубляться в
долгое чтение,  вам нужно запомнить только одну команду: "C-a ?".  Если
нажать эту комбинацию  клавиш,  будет показан список  доступных  команд
screen и привязок комбинаций  клавиш  к  ним.  Каждая комбинация клавиш
обсуждается   в  разделе  "Привязки  клавиш".  Раздел   "Индивидуальная
настройка" рассказывает о том, что может быть в  конфигурационном файле
 
 
 

 

 
Если ваш терминал - это настоящий терминал с авто-отступом (auto-marign)
(не позволяет обновить последнюю позицию экрана без прокрутки), возможно
вам стоит использовать такую версию termcap  для  вашего  терминала,  в
которой автоматические отступы выключены.  В этом случае  screen  будет
правильно обновлять экран при любых обстоятельствах. Сегодня у большинства
терминалов есть  волшебные  отступы  (magic margins)  -  автоматические
отступы и используемая последняя колонка, что соответствует стилю VT100
и отлично подходит для screen. Если у вас терминал с авто-отступами, 
screen может его использовать, но обновление последнего символа в строке
может быть невозможным без прокрутки или перемещения символа в другую
позицию  каким-то  иным  способом.  Задержку, связанную  с  этим, можно
сократить, если использовать терминал, у которого есть возможность 
вставки символов.
 
   
  Опции командной строки  

 

У программы  screen  такие ключи командной строки:
 
 
 -a 

 
 

  включать все возможности (за некоторыми небольшими исключениями) в termcap каждого окна, даже если screen должен перерисовывать 
часть экрана для реализации функции. 
 -A 

 
 

     Адаптирует  размеры  всех  окон  под  размер  текущего  терминала.  По умолчанию screen пытается восстановить старый размер 
окна (при подключении к терминалам с изменяемыми размерами (те у кого  есть "WS" в описании, например, suncmd или xterm). 
 
 -c   file 

 
 

     использовать  file  вместо стандартного "$HOME/.screenrc" в качестве конфигурационного
 
 -d | -D  [ pid.tty.host ]

 
 

     не запускает новый сеанс,  а отключает вместо этого уже запущенный ранее.  Достигается тот же эффект, что и в с случае нажатия 
клавиш "C-a d" на управляющем терминале screen. Ключ -D эквивалентен ключу power detach. Если ни к одному сеансу  нельзя 
  обратиться,   опция игнорируется.  В связке с -r/-R могут быть достигнуты другие более интересные эффекты: 
 -d -r 

 
 

  Подключить к сеансу, и если необходимо, сначала отключить его.
 
 -d -R 

 
 

  Переподключиться к сеансу. Если необходимо  сначала  отключить или создать сеанс.
 
 -d -RR 

 
 

  Переподключиться к сеансу. Если необходимо  сначала  отключить или создать сеанс.  Воспользоваться первой сессией, если 
больше одной сессии создать нельзя. 
 -D -r 

 
 

  Подключиться к сеансу. Если необходимо, сначала отключить его удалённо и разрегистрироваться.
 
 -D -R    

 
 

  Подключиться здесь и сейчас. Это значит: если сессия  работает, переподключиться. Если необходимо, сначала отключиться 
удалённо.  Если не работала  создать  и  сообщить  об  этом пользователю.  Любимый ключ авторов. 
 -D -RR 

 
 

  Подключиться прямо сейчас.  Не важно, что будет, просто сделать это. 
 

  Замечание: хорошая идея всегда проверять состояние сеансов screen с помощью "screen -list"
 
 -e   xy 

 
 

     Устанавливает  управляющий  символ равным  x  и  символ, который генерирует сам этот символ в  y  (после ввода командного 
символа).  По умолчанию это "C-a" и "a",  что можно явным образом указать как "-e^Aa".  При  создании  сеанса  screen  эта  опция 
  устанавливает управляющий символ. В многопользовательских сеансах все добавляемые пользователи будут использовать 
указанный символ.  При подключении к существующей сессии,  опция меняет управляющий символ только для пользователя, выполняющего 
подключение. Опция эквивалентна командам "defescape" и "escape" соответственно. 
 -f ,  -fn  и  -fa 

 
 

      включить,   выключить   или   перевести   в  автоматический  режим flow-control.  Аналогичный результат достигается с помощью 
команды "defflow" конфигурационного файла. 
 -h   num 

 
 

     Установить размер истории буфера прокрути равным  num  строк.
 
 -i 

 
 

  приводит к тому что клавиша прерывания (C-c) срабатывает мгновенно если включено аппаратное управление потоком. См. 
команду  defflow .  Использование этой опции не рекомендуется. 
 -l  и  -ln 

 
 

     Включает или выключает login-режим (для обновления /var/run/utmp).  Это же можно задать с помощью команды  deflogin  
в файле .RS
 ~/.screenrc
 


 
 -ls  и  -list 

 
 

     не запускает screen, а показывает вместо этого список идентифицирующих сеансы screen строк pid.tty.host.  Сеансы, которые 
отмечены словом "detached" могут быть продолжены  с помощью  команды  "screen -r".  Сеансы, которые отмечены словом "attached", 
работают, и у них есть управляющий терминал. Если сеанс  работает в многопользовательском режиме, он отмечен словом "multi". 
Сеансы, которые отмечены словом "unreachable" или работают на другом хосте, или умерли (dead).  Недоступный  (unreachable) 
  сеанс  считается мёртвым, если его имя соответствует или имени локального хоста, или указанному параметру (если такой 
есть).  Как описывать строки для выбора рассказывается в описании ключа -r. Сеансы, отмеченные как "dead", нужно проверить 
и удалить. Если вы не уверены, нужно ли удалять какой-то сеанс, вы можете обратиться к системному администратору (если 
это не вы сами, иначе может возникнуть бесконечная рекурсия).  Удалить сеансы можно с помощью опции -wipe. 
 -L 

 
 

  Включить автоматическую запись (logging) для окон.
 
 -m 

 
 

  Заставляет   screen   игнорировать  переменную окружения $TTY.  При использовании "screen -m" создаётся новый сеанс, независимо 
от того вызывается ли screen изнутри другого сеанса screen  или  нет.  Этот флаг имеет особое значение, если вызывается с опцией: 
 
 -d -m 

 
 

  Запустить сеанс в "отключенном" режиме. Сессия создаётся, но  к ней  не  выполняется  подключение.  Это полезно для загрузочных 
системных скриптов. 
 -D -m 

 
 

  Тоже запускает  screen  в "отключенном" режиме, но не создаёт новый процесс. Команда завершается, если сессия прерывается. 
 
 -O 

 
 

  использует более оптимальный режим вывода вашим терминалом,  чем в случае  с  обычной  эмуляцией VT100  (касается  только auto-margin 
терминалов без поддержки LP). Такого же результата можно  достичь, если установить OP в команде termcap. 
 -p   number_or_name 

 
 

  Заранее выбирает окно. Полезно, когда вы  хотите  переподключиться к конкретному окну или если вы хотите с помощью опции 
-X отправить команду в конкретное окно.  Как и в случае с командой select, знак "-" означает пустое окно.  Если вместо номера 
указать символ =, то при подключении появится меню windowlist с списком окон. 
 -q 

 
 

  Подавляет вывод сообщений об ошибках. В сочетании с "-ls" возвращает код завершения: 9 - нет каталога с сеансами; 10 - 
каталог есть, но нет сеансов, к которым можно подключиться. 11 (или больше) говорит что есть 1 (или больше) рабочий сеанс. 
В сочетании с "-r" возвращает код завершения: 10 - нет сеансов, которые можно возобновить; 12 (или больше) что есть 2 (или 
больше) сеанса, работу которых можно возобновить, и  нужно  выбрать  какой-то  один.  Во всех остальных случаях ключ " .RS
 -q
 


" эффекта не имеет.  
 
 -r  [ pid.tty.host ]

 
 -r   sessionowner /[ pid.tty.host ]

 
 

     возобновляет работу отключённого сеанса. Никакие другие опции  (за исключением комбинаций  с 
 
 -d
 

 

/
 
 -D
 

 

   не  допускаются).  Необязательный параметр [ pid .] tty.host  может указываться для того чтобы определить 
какой именно сеанс из множества отключённых имеется в виду. Вторая форма используется для подключения к работающему в 
многопользовательском режиме сеансу другого пользователя.  Эта опция говорит о том,  что файл нужно искать в каталоге другого 
пользователя. Требует наличия бита setuid-root у программы screen. 
 -R 

 
 

  пытается  возобновить  работу   первого  попавшегося  отключённого сеанса.   Если попытка успешная, все остальные аргументы 
командной строки  игнорируются.  Если  отключённых  сеансов  нет,  запускает новый сеанс с учётом заданных опций, так как будто 
 
 -R
 

 

   вообще и не указано.  Эта  опция  подразумевается  по  умолчанию, когда screen вызывается как login-оболочка (если быть точным, 
  то в этом случае подразумеваются опции " .RS
 -xRR
 


"). О том, что происходит, если вызвать screen в сочетании с опциями 
 
 -d
 

 

/
 
 -D
 

 

, написано в описании этих опций.
 
 -s 

 
 

  устанавливает оболочку по умолчанию равной заданной программе (без опции в качестве оболочки по умолчанию используется 
программа, что указана в $SHELL или "/bin/sh", если никакая не указана). Такой же эффект  может  быть  получен  с  помощью  команды 
 shell  в файле ".screenrc". 
 -S   sessionname 

 
 

     Эта опция может  использоваться  для задания  имени сеансу при его создании.  Имя  используется  для  идентификации при вызове 
"screen -list"  и  "screen -r".  Оно  заменяет префикс "tty.host", использующийся по умолчанию. 
 -t   name 

 
 

     установить заголовок для командного интерпретатора или указанной программы. См. также команду  shelltitle  для 

 -U 

 
 

  Запустить  screen  в режиме UTF-8. Эта опция говорит  screen , что терминал посылает и понимает символы в кодировке 
UTF-8. Этот ключ также устанавливает кодировку по умолчанию для окон .RS
 utf8
 


 
 -v 

 
 

    Показать номер версии.
 
 -wipe  [ match ]

 
 

     работает также как "screen -ls", только удаляет файлы уничтоженных сеансов вместо того чтобы помечать их как "dead" (мёртвые). 
Сеанс, который   не   отвечает,   считается   мёртвым,  или  если его имя соответствует имени локального хоста, или указанному 
явно параметру  match . См. описание ключа -r, где рассказаны правила составления  match . 
 -x 

 
 

  Подключиться к активной (not detached) сессии screen. (Многодисплейный режим).
 
 -X 

 
 

  Отправить  указанную  команду  в  работающий  сеанс  screen.  Можно указать ключ 
 
 -d
 

 

  или 
 
 -r
 

 

, чтобы screen смотрел только на подключённые (attached) или отключённые (detached) сеансы.  Обратите внимание на то, 
что команда не сработает, если сеанс защищён с помощью пароля. 
 
   
  Привязки клавиш  

 

 
Каждая управляющая последовательность screen состоит из комбинации "C-a",
за которой идёт один символ.  Для удобства все команды, которые привязаны
к символу в нижнем регистре также привязаны к комбинации этого символа с
Ctrl (за исключением "C-a a"; см. ниже). Так, например, "C-a c" работает
также как "C-a C-c"  создаёт новое  окно.  См.  раздел  " Индивидуальная настройка " для описания команд. 
В таблице показаны привязки клавиш по умолчанию:
 
 
        C-a '       (select)      Спросить название или имя окна, в которое нужно
                                 переключиться.

       C-a "       (windowlist -b)
                                 Представить список всех окон для выбора.

       C-a 0       (select 0)
        ...           ...
       C-a 9       (select 9)
       C-a -       (select -)    Переключиться в окно с номером 0  -  9 или в пустое окно.

       C-a tab     (focus)       Переключить фокус ввода на следующий регион.

       C-a C-a     (other)       Переключиться в ранее активное окно.
                                 (по умолчанию команда привязана к управляющему символу, 
                                 нажатому дважды  например, если вы вызовите screen
                                 с опцией "-e]x", команда будет вызываться символами "]]").

       C-a a       (meta)        Отправить C-a в окно. См. также команду  escape 

       C-a A       (title)       Ввести заголовок текущего окна.

       C-a b
       C-a C-b     (break)       Отправить break в окно.

       C-a B       (pow_break)   Повторно открыть терминальную линию и отправить break.

       C-a c
       C-a C-c     (screen)      Создать новое окно с запущенным интерпретатором
                                 и переключиться в это окно.

       C-a C       (clear)       Очистить экран.

       C-a d
       C-a C-d     (detach)      Отключить screen от этого терминала.

       C-a D D     (pow_detach)  Отключиться и разрегистрироваться.

       C-a f
       C-a C-f     (flow)        Включить/выключить/перевести в автоматический режим 
                                 управление потоком (flow control).

       C-a F       (fit)         Изменить размер окна под размер текущего региона.

       C-a C-g     (vbell)       Переключить режим visual-bell 

       C-a h       (hardcopy)    Записать копию текущего окна в файл "hardcopy.n".

       C-a H       (log)         Начать/закончить запись сессии работы в текущем окне в файл
                                 "screenlog.n".

       C-a i
       C-a C-i     (info)        Показать информацию о текущем окне.

       C-a k
       C-a C-k     (kill)        Уничтожить текущее окно.

       C-a l
       C-a C-l     (redisplay)   Полностью обновить текущее окно.

       C-a L       (login)       Переключить login-запись этого окна. Доступно только в случае, 
                                 когда screen настроен на обновление базы utmp.

       C-a m
       C-a C-m     (lastmsg)     Повторить последнее сообщение, показанное в строке сообщений.

       C-a M       (monitor)     Включить/выключить мониторинг в текущем окне.

       C-a space
       C-a n
       C-a C-n     (next)        Переключиться на следующее окно.

       C-a N       (number)      Показать номер (и заголовок) текущего окна.

       C-a backspace
       C-a h
       C-a p
       C-a C-p     (prev)        Переключиться на предыдущее окно (противоположно C-a n).

       C-a q
       C-a C-q     (xon)         Отправить CTRL-q в текущее окно.

       C-a Q       (only)        Удалить все регионы за исключением текущего.

       C-a r
       C-a C-r     (wrap)        Включить/выключить настройку line-wrap текущего окна
                                 (включает и выключает автоматические отступы (automatic margins))

       C-a s
       C-a C-s     (xoff)        Отправить control-s в текущее окно.

       C-a S       (split)       Разделить текущий регион на два новых.

       C-a t
       C-a C-t     (time)        Показать информацию о системе.

       C-a v       (version)     Показать версию и дату сборки.

       C-a C-v     (digraph)     Ввести диграф.

       C-a w
       C-a C-w     (windows)     Показать список окон.

       C-a W       (width)       Переключить количество колонок: 80/132

       C-a x
       C-a C-x     (lockscreen)  Заблокировать текущий терминал.

       C-a X       (remove)      Закрыть текущий регион.

       C-a z
       C-a C-z     (suspend)     Приостановить (suspend) screen. Система должна поддерживать 
                                 управление работами (job-control) в стиле BSD.

       C-a Z       (reset)       Сбросить виртуальные терминалы в их исходные значения.

       C-a .       (dumptermcap) Записать файл ".termcap"

       C-a ?       (help)        Показать привязки клавиш.

       C-a C-\     (quit)        Закрыть все окна и завершить screen.

       C-a :       (colon)       Перейти в режим ввода командной строки screen.

       C-a [
       C-a C-[
       C-a esc     (copy)        Перейти в режим копирования/прокрутки.

       C-a ]       (paste .)     Записать содержимое буфера обмена в стандартный поток 
                                 ввода текущего окна.

       C-a {
       C-a }       (history)     Скопировать и вставить предыдущую командную строку.

       C-a >       (writebuf)    Записать буфер обмена в файл.

       C-a <       (readbuf)     Прочитать файл обмена (screen-exchange) в буфер обмена. 

       C-a =       (removebuf)   Удалить файл, использующийся вместе с C-a < и C-a >.

       C-a ,       (license)     Показать информацию о программе GNU Screen.

       C-a _       (silence)     Включить/выключить режим слежения за неактивностью текущего окна.

       C-a *       (displays)    Показать список всех подключенных сейчас дисплеев.

 

 

----------------
 
   
  Индивидуальная настройка  

 

 
По умолчанию каталог для сокетов (socket directory) это или $HOME/.screen, 
или /tmp/screens, или, скорее всего, /var/run/screen; задаётся при компиляции.
Если screen имеет бит setuid-root, каталог для сокетов
обязательно должен находиться не на NFS-разделе. Если screen не имеет бита setuid, 
пользователь может указывать каталог через переменную 
 
 $SCREENDIR
 

 

 
У этого каталога должен быть режим доступа 700.
 
При вызове screen исполняет настроечные команды из файла 
 
 /etc/screenrc
 

 

 
и файла 
 
 

 

, что расположен в домашнем каталоге.
Имена этих файлов -- настройки по умолчанию, которые можно перекрыть 
одним из следующих способов:
глобальный настроечный файл указывается 
при помощи переменной окружения 
 
 $SYSSCREENRC
 

 

  (эта возможность может 
быть отключена при компиляции),
пользовательский настроечный файл ищется по пути, указанном в 
 
 $SCREENRC
 

 

,
и в файле 
 
 $HOME/.screenrc
 

 

  Есть ещё опция командной строки 
 
 -c
 

 

,
которая имеет приоритет над перечисленными выше настройками имён конфигурационных файла.
 
Команды в этих файлах используются для того чтобы задавать опции, привязывать
действия к функциональным клавишам, открывать несколько окон при старте сеанса screen.
Команды записываются по одной в строке. Пустые строки игнорируются.
Аргументы команд разделяются табуляцией или пробелами и могут объединяться с помощью
двойных кавычек. Строки, которые нельзя распознать, игнорируются. При этом для каждой такой строки
выдаётся предупреждение.
В командах могут использоваться ссылки на переменные окружения. Синтаксис такой же 
как в командном интерпретаторе: 
 
 $VAR
 

 

  или 
 
 ${VAR}
 

 

  Обратите внимание, 
что этот способ записи несовместим с предыдущими версиями screen, потому что сейчас 
символ $, если мы хотим передать именно его, нужно экранировать с помощью символа 
 
 \
 

 

 
От подстановки переменных также защищают одинарные кавычки.
 
В дистрибутив входит два конфигурационных файла-примера: 
 
 etc/etcscreenrc
 

 

 
и 
 
 etc/screenrc
 

 

  В этих файлах есть много хороших примеров различных конфигурационных
команд GNU Screen.
 
Настраивать GNU Screen можно и в on-line режиме. Для того чтобы перейти в режим командной строки,
нажмите 
 
 C-a :
 

 

  Команды, начинающиеся с "def" меняют настройки по умолчанию,
а остальные меняют текущие настройки.
 
Доступны следующие команды:
 
 
 acladd   usernames  [ crypted-pw ]

 
 addacl   usernames 

 
 

  Даёт пользователю возможность получения доступа к сеансу screen. В качестве параметра  usernames  может задаваться 
имя пользователя или имена нескольких пользователей, разделённых запятыми. Команда разрешает подключаться к screen 
и в том числе выполняет действия аналогичные действию команды  aclchg usernames +rwx "#?" . Для того чтобы добавить 
пользователя с ограниченным доступом, нужно использовать команду  aclchg  указанную ниже.  В качестве опционального 
параметра  crypted-pw  может указываться зашифрованный пароль для заданного пользователя.  Команда  addacl  
--- синоним команды  acladd .  Только для многопользовательского режима. 
 aclchg   usernames   permbits   list 

 
 chacl   usernames   permbits   list 

 
 

  Изменить права для пользователей. Список пользователей  usernames  состоит из имён пользователей, разделённых 
запятыми. Права представлены символами .RS
 r
 


, 
 
 w
 

 

  и 
 
 x
 

 

  Префикс 
 
 +
 

 

  обозначает добавление права, а префикс 
 
 -
 

 

  снятие его. Третий параметр,  list  это список команд и/или окон, заданных с помощью номеров или названий. Специальный 
список .RS
 #
 


  обозначает все окна, а 
 
 ?
 

 

  -- все команды.  Если параметр 
 
 *
 

 

  состоит из одного единственного символа 
 
 *
 

 

, команда применяется ко всем пользователям.  Пользователь может выполнить команду, если у него есть бит "x" для этой команды. 
Пользователь может вводить данные в окно, если у него есть бит "w" для этого окна, и оно никем не заблокировано. Другие биты 
пока что игнорируются.  Для того чтобы отозвать блокировку записи в окно 2 выполненную другим пользователем, нужно выполнить 
команду: " .RS
 aclchg username -w+w 2
 


". Для того чтобы предоставить доступ только для чтения: 
 
 aclchg username -w "#"
 

 

   Как только имя пользователя становится известно screen, этот пользователь может подключаться к сеансу и по умолчанию 
у него есть права на исполнение всех команд со всеми окнами.  Право на исполнение acl-команд,  at  и прочих нужно тоже 
удалить, иначе пользователь сможет восстановить себе права на запись сам.  Права специального пользователя nobody изменить 
нельзя (подробности в описании команды  su ).  Команда  chacl  это синоним для  aclchg . Только для многопользовательского 
режима. 
 acldel   username 

 
 

  Удалить пользователя из списка контроля доступа screen. Если у пользователя есть подключенные экраны, все они отключаются. 
И больше подключится он не может. Это только в многопользовательском режиме. 
 aclgrp   username  [ groupname ]

 
 

  Создаёт группу пользователей с одинаковыми правами доступа. Название группы совпадает с названием лидера группы. Все 
члены группы наследуют права лидера группы. Это означает, что если пользователю доступ не дали, делается выполняется 
проверка для лидера. Пользователь удаляется изо всех групп, если в качестве имени группы используется специальное слово 
 none . Если второй параметр не указан, на экран выводятся все группы, в которых состоит пользователь. 
 aclumask [[ users ]+ bits  |[ users ]- bits  .... ]

 
 umask [[ users ]+ bits  |[ users ]- bits  .... ]

 
 
 
  Команда определяет, какие права будут у пользователей при доступе к окнам, которые создаст тот, кто вызывает эту команду. 
       Аргумент  users  может отсутствовать или, если он есть, это список пользователей, разделённых запятыми.  Если список 
пользователей  users  не указан, подразумевается что перечислены все известные пользователи.  Аргумент  bits  
это любая комбинация битов контроля доступа, которые могут использоваться в команде  aclchg .  Специальное имя пользователя 
 
 ?
 

 

  определяет какие права доступа к окнам будут выдаваться пока неизвестным пользователям.       Специальное имя пользователя 
 
 ??
 

 

  определяет какие права вызова команд будут выдаваться пока неизвестным пользователям.  Права для специального пользователя 
nobody менять нельзя (см. команду "su").  Команда  umask  это синоним команды  aclumask . .RE
 
 
 activity   message 

 
 

  Если в окне, которое находится под наблюдением, возникает какая-то активность, screen показывает строку предупреждения. 
Текст предупреждения можно переопределить с помощью строки  message . Символ .RS
 %
 

 
 

  в сообщении заменяется номером окна, в котором возникла активность, а символ 
 
 ^G
 

 

  заменяется на определение звонка (bell) из termcap-файла (обычно ему соответствует звуковой звонок). Сообщение по 
умолчанию выглядит так: 
 
     "Activity in window %n"

 

 

 
  Обратите внимание на то, что мониторинг по умолчанию выключен. Его можно включить командой (C-a M). .RE
 
 
 allpartial   on | off 

 
 

  Если установлен, обновляется только строка, содержащая курсор. Действует на все окна. Полезно для медленных линий. Предыдущие 
настройки обновления восстанавливаются при вызове  allpartial off . Команда влияет на глобальный флаг, перекрывающий 
их собственные настройки. Команда не влияет на новые окна и их отрисовку. 
 altscreen   on | off 

 
 

  Если установлен, включается поддержка альтернативного экрана (alternate screen), как в xterm (например, когда вы выходите 
из man и то что бы на консоли восстанавливается). Начальная настройка "off". 
 at  [ identifier ][#|*|%]  command  [ args  ... ]
 
  Выполнить команду на другом окне или дисплее, так будто бы она была вызвана там.  Команда  at  меняет контекст (текущее 
окно или дисплей).  Если первый аргумент описывает не уникальный контекст, команда будет выполнена многократно. .RE
 
  Если первый параметр задан в форме 
 
 id*
 

 

, тогда  id  проверяется на соответствие именам пользователей.  Команда выполняется по разу для каждого дисплея заданного 
пользователя.  Если идентификатор  identifier  задан в форме  id% , он проверяется на соответствие дисплеям. 
  Дисплеи именуются в соответствии с названиями терминалов, к которым они подключаются.  Префиксы .RS
 /dev/
 

 

  и 
 
 /dev/tty
 

 

  указывать в идентификаторе не обязательно.  Если идентификатор заканчивается 
 
 #
 

 

  или никаких специальных символов в конце нет, он проверяется на соответствие номера и названиям окон. .RE
 
  Если не указать идентификатор перед 
 
 #
 

 

  
 
 *
 

 

  или 
 
 %
 

 

  будут выбраны все пользователи, все дисплеи или все окна соответственно.  На экране появится короткое сообщение, описывающее, 
что происходит.  Обратите внимание, что символ "#" работает как комментарий, если перед ним поставить #.  Экранировать 
символ можно с помощью .RS
 \
 

 

   Разрешения проверяются для того, кто вызвал команду  at , а не для владельца дисплея, на котором будет выполняться 
команда. .RE
 
  Замечание: При поиске соответствия именам окон, команда выполняется как минимум по разу для каждого окна. Команды, которые 
меняют порядок окон (как  other ) могут вызываться более одного раза.  В окнах, подключенных к нескольким дисплеям, 
команда будет выполняться для каждого дисплея.  Осторожно с переключающими (toggle) программами типа  login !  Некоторые 
программы (например, "process") требуют чтобы экран был подключен к целевому окну. Такие команды могут не очень корректно 
работать, когда  at  обходит окна. .RE
 
 
 attrcolor   attrib  [ attribute / color-modifier ]

 
 

  Команда предназначена для того чтобы подсвечивать атрибуты путём смены цвета текста.  Если используется атрибут  attrib , 
применяется модификатор attribute/color.  Если модификатор не задан, удаляются текущие.       Подробнее о синтаксисе читайте 
в разделе "Escape-последовательности". .br
  Программа screen понимает два псевдо-атрибута: "i" обозначает яркий цвет буквы и "I" обозначает яркий цвет фона. 
 
   Примеры:

  attrcolor b "R"
       Выводить ярко-красным цветом текст, который должен быть полужирным.

  attrcolor u "-u b"
       Выводить текст синим цветом вместо подчёркнутого.

  attrcolor b ".I"
       Использовать яркие цвета для вывода полужирного текста. Большинство терминалов и так это делает. 
  attrcolor i "+b"
       Сделать чтобы яркий текст был ещё и полужирным.

 

 

 autodetach   on | off 

 
 

  Будет ли экран отключаться (detach) при разрыве связи с терминалом (hangup). В результате отключения команды, работающие 
в screen, должны продолжать работать и не завершаться. Восстановить подключение можно с помощью команды  screen -r . 
Если опция выключена ( off ), при разрыве связи с терминалом все процессы получат сигнал потери связи с терминалом 
(hangup, HUP) и (скорее всего) завершатся. По умолчанию:  on  
 autonuke   on | off 

 
 

  Указывает, должна ли команда очистки экрана удалять вывод, который ещё не был отправлен на терминал.  См также.  obuflimit . 
 
 backtick  id   lifespan   autorefresh   cmd   args ...

 
 backtick  id 

 
 
 
  Программирует backtick-команду (командную подстановку) с заданным идентификатором  id .  Вывод этой команды 
используется для замены строковой последовательности .RS
 %`
 

 

  (
 
 % номер `
 

 

).  Заданный промежуток времени  lifespan  определяет количество секунду в течение которых вывод может считаться 
действительным. Когда время заканчивается, если встретится соответствующая escape-последовательность, программа 
должна запускаться заново.  Параметр  autorefresh  включает автоматическое обновление заголовков после заданного 
количества секунд. 
 

  Если и  lifespan , и  autorefresh  равны 0, предполагается, что программа должна уйти в фон и изредка генерировать 
вывод. В этом случае команда запускается сразу же, и screen сохраняет последнюю строчку вывода. Если печатается новая 
строка, screen автоматически обновляет заголовки или hardstatus.  Вторая форма команды удаляет bactick с идентификатором 
 id . .RE
 
 bce  [ on | off ]

 
 

  Настройка background-color-erase (цвет фона при очистке). Если bce установлено, все символы, которые в настоящий 
момент очищаются,вставляются, выводятся из буфера-прокрутки или очищаются, будут выводиться с текущим цветом фона. 
В противном случае используется цвет фона, заданный по умолчанию. 
 bell_msg  [ message ]

 
 

  Когда символ звонка (bell character) выводится в фоновом окне, screen показывает сообщение-предупреждение.  Это сообщение 
предупреждение можно переопределить командой  bell_msg .  Каждый символ " .RS
 %
 

 
 

" в сообщение заменяется номером окна в котором прозвучал звонок; а каждая последовательность "
 
 ^G
 

 

" заменяется на обозначения звонка из termcap (обычно, звуковым звонком).  По умолчанию сообщение такое: 
 
         "Bell in window %n"

 

 

 
  Можно подавить вывод сообщения, если задать пустое сообщение в качестве аргумента (
 
 bell_msg ""
 

 

). При вызове  bell_msg  безе параметров показывается текущее сообщение.
 

 
 
 bind  [-c  class ]  key  [ command  [ args ]]

 
 
 
  Привязать команду к комбинации клавиш. По умолчанию, большинство команд, которые есть в screen уже привязаны к каким-то 
клавишам или их комбинациям (см.  "Привязки клавиш").  Так, например, команда создания окна привязана к клавише "c" или 
"C-c".  С помощью команды  bind  можно переопределять существующие привязки или создавать новые.  Аргумент  key  
это или один символ, или последовательность из двух символов в виде "^x" (означающая Ctrl-x), обратный слеш за которым 
идет восьмеричное число (обозначающее код ASCII-символа) или обратный слеш, за котором идёт другой, экранированный, 
символ (например, \^ или \\).  Этот аргумент можно брать в кавычки. Если больше аргументов нет, удаляется сделанная 
ранее привязка к этому ключу.  В качестве аргумента  command  может использоваться любая команда, описанная в этом 
разделе. .RE
 
  Если при помощи опции 
 
 -c
 

 

  указан класс команды, ключ привязывается к команде указанного класса. Класс активируется с помощью команды  command . 
Классы команд можно использовать для создания множественных комбинаций или многосимвольных привязок. .RE
 
  Некоторые примеры:
 

 
     bind   windows
    bind ^k
    bind k
    bind K kill
    bind ^f screen telnet foobar
    bind \033 screen -ln -t root -h 1000 9 su

 

 

 
  последовательность привязывает пробел к команде, которая показывает список окон (и команда, которая обычно доступна 
через C-a C-w теперь доступа и по нажатию C-a пробел).  Следующие три строки удаляют привязку kill с комбинаций "C-a 
C-k" и "C-a k".  После чего kill привязывается к "C-a K". Потом комбинация клавиш "C-f" привязывается к команде "создать 
окно с TELNET-подключением к foobar", а клавишу "escape"  к команде, которая создаёт с именем root в слоте 0, с командным 
интерпретатором, запущенным от имени суперпользователя и буфером прокрутки на 1000 строк. .RE
 
 
     bind -c demo1 0 select 10
    bind -c demo1 1 select 11
    bind -c demo1 2 select 12
    bindkey "^B" command -c demo1

 

 

 
  Сделать так что бы "C-b 0" выбирало окно 0, "C-b 1" окно 11 и т. д.       
 

 
 
     bind -c demo2 0 select 10
    bind -c demo2 1 select 11
    bind -c demo2 2 select 12
    bind - command -c demo2

 

 

 
  Сделать так что бы "C-a - 0" выбирало окно 10, "C-a - 1" окно 11 и так далее.
 

 
 
 bindkey  [-d] [-m] [-a] [ [-k|-t]  string  [ cmd   args ] ]

 
 

     Команда предназначена для управления таблицами трансляции screen. Каждая запись в таблице говорит screen как реагировать 
на нажатие определённых последовательностей клавиш при работе в разных режимах. Есть три таблицы: в одной хранятся действия, 
запрограммированные пользователем; во второй действия по умолчанию при эмуляции терминала; и одну для управления курсором 
в режиме копирования.  В разделе "Трансляция при вводе" приводится список привязок по умолчанию.  Если задана опция .RS
 -d
 

 
 

,  bindkey изменяет таблицу по умолчанию,  
 
 -m
 

 

  изменяет таблицу для режима копирования, и если ключей не задавать вообще  выбирается пользовательская таблица. Аргумент 
 string  это последовательность из двух символов, к которой привязывается действие.  Это может быть или строка или 
имя клавиатурной termcap возможность (выбор при помощи .RS
 -k
 

 

).  На терминале VT100 некоторые клавиши могут отправлять другие последовательности, если включен режим приложения (например, 
клавиши управления курсором).  У таких клавиш в таблице трансляции две записи. Выбор режима приложения выполняется с помощью 
ключа .RS
 -a
 

 

   Опция 
 
 -t
 

 

  говорит screen, что ненужно делать межсимвольный тайминг.  Нельзя отключить тайминг, если используюся termcap capability. 
  Аргумент  cmd  может быть любой командой screen с произвольным количеством аргументов.  Если  cmd  не указано, 
привязка удаляется из таблицы. 
 
  Вот некоторые примеры привязок:
 

 
 
     bindkey -d

 

 

 
  Показать все привязки клавиш. Записи приложений (application mode entries) отмечаются символом 
 
 [A]
 

 

         
 

 
 
     bindkey -k k1 select 1

 

 

 
  F1 переключает на окно 1.
 

 
 
     bindkey -t foo stuff barfoo

 

 

 
  Сделать слово  foo  сокращением для слова  barfoo . Таймаут отключён, поэтому можно набирать медленно. .RE
 
 
     bindkey "\024" mapdefault

 

 

 
  Сделать "^T" escape-последовательностью для привязок клавиш. Если вы выполнили предыдущую команду, теперь слово "foo" 
нужно будеть вводить через "^T": "^Tfoo". Если вы хотите вставить "^T", надо нажать её дважды.  (т.е. экранировать второе 
нажатие с помощью первого). .RE
 
 
     bindkey -k F1 command

 

 

 
  Сделать F11 (не F1!) альтернативой escape-символу (^A).
 

 
 
 break  [ duration ]

 
 

  Отправляет сигнал разрыва (break) длительностью duration*0.25 секунд. Для не-POSIX систем число секунд может округляться 
до целого. Наиболее полезно в том случае, когда символьное устройство подключено к окну, а не процессу командного интерпретатора 
(см. Типы окон). Максимальная длительность сигнала ограничена величиной 15 секунд. 
 blanker 

 
 

  Активирует хранитель экрана. Сначала очищается экран. Потом, если хранитель экрана не задан, выключается курсор; если 
же курсор задан, он запускается и его вывод направляется на экран. По первому нажатию клавиши хранитель завершается, а 
его вывод стирается. Нажатая клавиша не запоминается. Обычно, эта команда используется совместно с командой  idle . 
 
 blankerprg  [ program args ]

 
 

       Указывает какая программа должна использоваться в качестве хранителя экрана. Или отключает хранитель экрана вообще, 
если этот параметр не задан. 
 breaktype  [tcsendbreak|TIOCSBRK |TCSBRK]

 
 

  Выбрать один из доступных способов генерирования сигнала разрыва (break) для терминальных устройств. Команда должна 
действовать только на текущее окно, но до сих пор она работает как  defbreaktype . В будущем это изменится. Если вызвать 
 breaktype  без параметров, будет выведена текущая настройка. 
 bufferfile  [ exchange-file ]

 
 

  Изменить имя файла, использующегося для чтения и записи буфера обмена. Если имя файла не указано, реактивируется настройка 
по умолчанию ( .RS
 /tmp/screen-exchange
 

 
 

). В этом примере системный файл 
 
 passwd
 

 

  копируется в окно (при помощи буфера обмена, в котором остаётся копия):
 
 
     C-a : bufferfile /etc/passwd
    C-a < C-a ]
    C-a : bufferfile

 

 

 
 c1  [ on | off ]

 
 
 
  Изменяет обработку кода c1. Если включить (C1 on), screen будет обрабатывать символы с кодом в диапазоне от 128 до 159 как 
специальные управляющие последовательности. Он будет воспринимать 8-битный код как комбинацию ESC и аналогичного 
7-битного. По умолчанию обработка кодов C1 включена (настройку по умолчанию можно изменить при помощи команды  defc1 ). 
Пользователь, которому нужны символы с кодами на позициях относящихся к C1, может выключить эту функцию. .RE
 
 
 caption   always | splitonly  [ string ]

 
 caption   string  [ string ]

 
 
 
  Команда управляет отображением заголовков окон. По умолчанию, заголовки показываются только если на экране больше одного 
окна (режим split screen). Если же включен режим  caption always , заголовок будет показываться всегда. По умолчанию 
включён режим  splitonly . 
 

  Вторая форма вызова изменяет текст заголовка. Можно использовать escape-последовательности (см. раздел Escape-последовательности). 
По умолчанию заголовок: "%3n %t". Можно смешивать обе формы и задавать строку как дополнительный аргумент. .RE
 
 
 charset   set 

 
 

  Изменяет текущее назначение слотов и привязку кодировок.  Первые четыре символа рассматриваются как описание кодировки, 
а пятый и шестой должны находиться в диапазоне и задавать настройку отображения GL/GR. В каждой позиции символ "." может 
указывать на то, что соответствующая кодировка не должна меняться (множество добивается внутри screen символами . до 
6).  У новых окон будет кодировка по умолчанию "BBBB02", кроме тех случаев, когда активна команда "encoding".
 
 
  Текущие настройки можно посмотреть при помощи команды  info .
 

 
 chdir  [ directory ]

 
 

  Изменяет текущий каталог screen на заданный или, если команда вызвана без аргументов, на домашний каталог пользователя 
(значение переменной .RS
 $HOME
 

 
 

). У всех программ, которые запускаются в окнах, создающихся при помощи команды  screen  из 
 
 

 

, или при помощи C-a c, или при помощи  C-a : screen ...  будет этот текущий каталог. Без вызова команды  chdir  
текущим каталогом будет тот, из которого вызывался  screen . Hardcopy-файл и файл-журнал пишутся в текущий каталог 
окна (а не процесса, который работает в этом окне). Можно многократно использовать эту команду в файле .RS
 

 
 

: например, для того чтобы создавать различные окна с различными рабочими каталогами. Последний вызов  chdir  будет 
влиять на окна, которые создаются интерактивно. 
 clear 

 
 

       Очищает текущее окно и сохраняет его образ в буфер прокрутки.
 
 colon  [ prefix ]

 
 

  Позволяет вводить командные строки 
 
 

 

  Полезно для выполнения изменений привязки клавиш на лету, хитрого управления окнами. Обратите внимание на то, что ключевое 
слово  set  больше не существует. Как правило, команды воздействуют на текущее окно, а не на настройки для будущих 
окон. Если нужно поменять настройки для будущих окон, используются команды, начинающиеся словом  def... . .br
  Вы можете воспринимать этот режим как режим Ex в screen, а режим вызываемый по комбинации  C-a esc   как командный режим 
по аналогии с редактором Vi. 
 command  [-c  class ]

 
 

  Это команда делает то же самое, что и комбинация клавиш ^A. По всей видимости, толк от неё есть только при описании привязок 
комбинаций клавиш. Если задан ключ .RS
 -c
 

 
 

, определяется класс команды. См. также  bind  и  bindkey .
 
 compacthist  [on|off]

 
 

       Говорит  screen , нужно ли подавлять последние пустые строки при прокрутке текста в буфере истории. 
 console  [ on | off ]

 
 

       Захватывает (или отпускает захват) системной консоли текущим окном. Захватить консоль может только владелец файла /dev/console. 
Кроме того, система должна поддерживать ioctl TIOCCONS. 
 copy 

 
 
 
  Переходит в режим копирования/прокрутки. В этом режиме можно скопировать текст из текущего окна и его истории в буфер обмена. 
  В этом режиме активируется vi-подобный интерфейс: .RE
 
  Клавиши для передвижения:
 
 

* h, j, k, l перемещают курсор на одну строку или одну колонку.
 
 

* 0,  ^  и  $  перемещают курсов в самую левую колонку, в первую или последнюю позицию, где стоит непробельный символ. 
 

* H, M и L перемещают курсор в самую левую колнонку верхней, средней или нижней строки экрана.
 
 

* + и - перемещают на одну строку вверих или вниз.
 
 

* G переходит на строку с заданным номеромt (по умолчанию: до конца буфера).
 
 

* | переходят на колонку с заданным номером.
 
 

* w, b, e передвижение по словам.
 
 

* B, E передвижение по СЛОВАМ (как в vi).
 
 

* C-u  и  C-d  прокручивает экран вверх/вниз на заданное количество строк, сохраняя при этом позицию курсора 
 

* (По умолчанию: пол-экрана).
 
 

* C-b и C-f прокручивают на один экран ввер/вниз.
 
 

* g переходит в начало буфера.
 
 

* % переходит на указанный процент буфера.
 

 
  Замечание:
 
 

  Команды перемещения в стиле Emacs можно настроит с помощью 
 
 

 

  (Например, markkeys "h=^B:l=^F:$=^E"). Нет простого способа для полной раскладки в стиле Emacs, поскольку нужно задействовать 
многосимвольные коды. .RE
 
   Маркировка :
 
 

  Область копирования определяется двумя отметками. Текст между отметками подсвечивается. Отметки ставятся при помощи 
пробела. 
 

* Y и y маркируют всю строку или с начала строки.
 
 

* W маркирует ровно одно слово.
 

 
   Повтор :
 
 

  Любую команду можно вводить после числа, которое обозначает количество повторов при вызове этой команды. 
 

* 0..9 обозначает количество повторов.
 
 

  Пример:  "C-a  C-[  H  10 j 5 Y" копирует строки с 11 по 15 в буфер обмена.
 

 
   Поиск :
 
 

* / Поиск вперёд в стиле Vi
 
 

* ? Поиск назад в стиле Vi
 
 

* C-a s Инкрементальный поиск вперёд в стиле Emacs
 
 

* C-r Обратный интерактивный поиск в стиле Emacs
 

 
   Отличия от vi :
 
 

  Есть несколько клавиш, которые работают не как в vi.  Vi (не vim) не позволяет работать с прямоугольными блоками текста, 
а screen позволяет. 
 

* c или C to задаёт левый или правый отступ соответственно.
 
 

   Если не задан повтор, отступ будет соответствовать текущей позиции курсора.
 
 

   Пример: Попробуйте такую последовательность: "C-a [ M 20 l SPACE c 10 l 5 j C SPACE".  перейти на среднюю линию, сдвинуться 
на 20 колонку, ометить начало буфера, установить левую колонку, перейти на 5 строк вниз, установить правую колонку, отметить 
конец буфера обмена. 
 

            Теперь попробуйте: "C-a [ M 20 l SPACE 10 l 5 j SPACE" и обратите внимание на то, сколько текста скопировалось на этот раз. 
 

 
* J  объединить строки. Он переключается между 4 режимами: строки разделяются символом новой строки (new line, 012), объединяются 
бесшовно, разделяются одним пробелом или разделяются запятой.  Можно сдедать так, что бы перед символом новой строки (new 
line) выводился символ перевода каретки (carriage return), для этого нужно дать команду  crlf on . 
 

* v нужна пользователям vi, которые включают ":set numbers" - переключает величину отступа между 9 и 1. 
 

* a переключает в режим добавления (append mode). Содержимое буфера обмена не будет стёрто, а дописано. 
 

* A переключает режим ввода (append mode) и ставит вторую отметку.
 
 

* > ставит вторую отметку и записывает выделенный текст в файл screen-exchnage (по умолчанию 
 
 /tmp/screen-exchange
 

 

) и выходит из режима копирования.
 

 
  Пример как записать весь буфер прокрутки в тот файл: "C-A [ g SPACE G $ >".
 
 

* C-g показывает информацию о текущей строке и колонке.
 
 

* x  меняет местами первую отметку и текущую позицию курсора. Можно использовать для того чтобы передвинуть уже установленную 
отметку. 
 

* @ ничего не делает. Даже не выходит из режима копирования.
 

 
  Все клавиши, которые не были описаны здесь, завершают режим копирования.
 

 
 
 copy_reg  [ key ]

 
 

  Больше не существует, используйте  readreg .
 
 crlf  [ on | off ] 

 
 

  Команда влияет на копирование блоков текста с помощью комбинации клавиш  C-a [ . Если установить её в  on , строки 
будут разделяться символами CR  LF. В противном случае (по умолчанию) они будут разделяться только LF. При вызове без параметров, 
состояние переключается. 
 debug  [ on | off ]

 
 

  Включает или выключает отладку. Если программа screen откомпилирована с опцией 
 
 -DDEBUG
 

 

, отладка включена по умолчанию. Обратите внимание на то, что команда действует на отладочный вывод только главного процесса 
screen. Отладочный вывод attacher-процессов можно только выключить, да и то только один раз. 
 defc1   on | off 

 
 

  То же, что и команда  c1 , но настройка изменяется в том числе и для новых окон. По умочанию, равна  on . 
 defautonuke   on | off 

 
 

  То же, что и команда  autonuke , но настройка изменяется по умолчанию и для новых окон. Начальная настройка равна  off . 
Обратите внимание, что вы можете использовать специальную возможность (capability) AN терминала, если вы хотите чтобы 
действие зависело от типа терминала. 
 defbce   on | off 

 
 

  То же, что и команда  bce , но настройка изменяется в том числе и для новых окон. По умочанию, равна  off . 
 defbreaktype  [ tcsendbreak | TIOCSBRK  | TCSBRK ]

 
 
 
  Выбрать один из трёх доступных методов генерирования сигнала разрыва (break signal) для терминальных устройств.  Предпочитально 
использовать методы  tcsendbreak  и  TIOCSBRK . Третий метод,  TCSBRK , полностью блокирует сеанс screen 
на протяжении разрыва, но в некоторых случаях это может быть единственным рабочим способом сделать длинный разрыв.  Tcsendbreak  
и  TIOCSBRK  могут делать, а могут не делать длинные разрывы с шипами (long breaks with spikes) (например, 4 в секунду). 
Это зависит не только от системы, но и от драйверов последовательных адаптеров. Если вызвать "defbreaktype" без параметров, 
будут показаны текущие настройки. .RE
 
 
 defcharset  [ set ]

 
 

  То же, что и команда  charset , но настройка изменяется в том числе и для новых окон. Если вызвать без аргументов, показывает 
текущую настройку. 
 defescape   xy 

 
 

  Задаёт командный символ. То же, что и escape, за исключением того, что может быть полезно только в многпользовательских 
сеансах. В многопользовательских сеансах  escape  меняет настройку только для вызвавшего эту команду пользователя, 
а  defescape  меняет настройку для пользователей, которые будут добавлены позже. 
 defflow   on | off | auto  [ interrupt ]

 
 

  То же, что и команда  flow , но настройка изменяется в том числе и для новых окон. Начальная настройка  auto . Вызов 
 defflow auto interrupt  равносилен использованию при вызове ключей командной строки .RS
 -fa
 

 
 

  и 
 
 -i
 

 

 
 defgr   on | off 

 
 

  То же, что и команда  gr , но изменяет настройку в том числе для новых окон. По умочанию, равна  off . 
 defhstatus  [ status ]

 
 

  Статусная строка (hardstatus) во всех новых окнах инициализируется строкой  status . Команда нужна дла того чтобы 
в окнах screen в строке состояний выводить номера окон, их заголовки и тому подобное. В строке статуса могут использоваться 
те же директивы, что и в сообщениях для окон, только в качестве escape-символа используется " .RS
 ^E
 

 
 

" (восьмиричное 005) вместо "
 
 %
 

 

". Это сделано специально: чтобы уменьшить вероятность ошибочного распознавания сгенерированных программно статусных 
строк. Если параметр  status  не задан, показывается текущая строка статуса по умолчанию. По умолчанию hardstatus 
строка окон пустая. 
 
 defencoding   enc 

 
 

  То же, что и команда  encoding , но изменяет настройку в том числе для новых окон. Начальная настройка берётся из свойств 
терминала. 
 deflog   on | off 

 
 

  То же, что и команда  log , но изменяет настройку в том числе для новых окон. По умочанию, равна  off . 
 deflogin   on | off 

 
 

  То же, что и команда  login , но изменяет настройку в том числе для новых окон. По умочанию, равна  on  (см. config.h.in 
в исходниках). 
 defmode   mode 

 
 

  Режим доступа (права), которые устанавливаются для каждого нового псевдотерминала. Режим задаётся в виде восьмиричного 
числа. По умолчанию 0622. 
 defmonitor   on | off 

 
 

  То же, что и команда  monitor , но настройка изменяется в том числе и для новых окон. Настройка по умолчанию:  off . 
 
 defnonblock   on | off | numsecs 

 
 

  То же, что и команда  nonblock , но настройка изменяется в том числе и для новых окон. Настройка по умолчанию:  off . 
 
 defobuflimit   limit 

 
 

  То же, что и команда  obuflimit , но изменяется в том числе и настройка по умолчанию для новых окон. Начальное значение: 
 256 байтов . Если вы хотите, чтобы параметр зависел от типа терминала, вы можете использовать специальную возможность 
(capability) терминала, которая называется  OL . 
 defscrollback   num 

 
 

  То же, что и команда  scrollblock , но изменяется в том числе и настройка по умолчанию для новых окон. Начальное значение: 
 100 . 
 defshell   command 

 
 

  Синоним команды  shell . Смотрите эту команду.
 
 defsilence   on | off 

 
 

  То же, что и команда  silence , но изменяется настройка по умолчанию для новых окон. Начальное значение:  off . 
 
 defslowpaste   msec 

 
 

  То же, что и команда '''slowpaste'', только меняет настройку для новых окон. Начальная настройка: 0 мс, означающая ''off''. 
 
 defutf8   on | off 

 
 

  То же, что и команда '''utf8'', только меняет настройку для новых окон. Начальная настройка: ''off'' или ''on'', если screen 
был запущен с ключом .RS
 -U
 

 
 

 
 defwrap   on | off 

 
 

  То же, что и команда '''wrap'', только меняет настройку для новых окон. Начальная настройка ''on'', может быть изменена 
командой ''wrap'' ''on''|''off'' (или с помощью "C-a r"). 
 defwritelock   on | off | auto 

 
 

  То же, что и команда '''writelock'', только меняет настройку для новых окон. Начальная настройка ''off''. 
 defzombie  [ keys ]

 
 

       Синоним команды  zombie . В настоящий момент обе они меняют настройки по умолчанию. Смотрите эту команду. 
 detach  [ -h ]

 
 

  Отключить сеанс screen (отключить от терминала и отправить в фон). Происходит возврат в интерпретатор, из которого вызывался 
screen. Отключенный screen можно восстановить при помощи опции .RS
 -r
 

 
 

  (см. "Опции командной строки"). Опция 
 
 -h
 

 

  говорит, что нужно разорвать соединение с терминалом (hangup).
 
 dinfo 

 
 

       Показывает, что screen думает о вашем терминале. Может пригодится, если нужно узнать почему не работают цвет или альтернативная 
кодировка. 
 displays 

 
 

  Показывает таблицу с списком подключенных в настоящиё момент пользователей. Очень полезная команда для многопользовательского 
режима работы GNU Screen. 
 digraph  [ preset ]

 
 

  Ввести диграф. Выдаётся приглашение пользователю для ввода двухсимвольной последовательности. По введённым двум символам 
в встроенной таблице ищется диграф, найденный символ вставляется в окно. Например, если ввести .RS
 a:
 

 
 

, будет вставлен a-умляут. Если первый символ это 0 (ноль), screen будет рассматривать следующие символы как восьмеричное 
число. Опциональный аргумент  preset  рассматривается как обозначение нажатого символа, т.е. с его помощью можно 
сделать, например, умляут-клавишу.  Если сделать привяку " .RS
 bindkey ^K digraph :
 


", пользователь сможет вводить а-умляют при помощи комбинации Ctrl-K a.
 
 dumptermcap 

 
 
 
  Сохранить записи termcap для текущего окна в .termcap-файл в каталог 
 
 

 

  в домашнем каталоге пользователя  "
 
 $HOME/.screen
 

 

" (или в другой каталог, где screen хранит свои сокеты. См. раздел "Файлы").  Эта запись termcap идентична значению переменной 
 
 $TERMCAP
 

 

, которую screen устанавливает для каждого окна. Для систем с terminfo нужно будет запускать конвертер наподобие  captoinfo , 
а потом компилировать запись при помощи  tic . .RE
 
 
 echo  [-n]  message 

 
 

  Команда может использоваться для того чтобы распространять "сообщение дня". Обычно её добавляют в 
 
 /etc/screenrc
 

 

  При вызове с ключом 
 
 -n
 

 

  конечный перевод строки не выводится. См. также  sleep . Ещё может пригодиться для online-проверки переменных 
окружения. 
 encoding   enc  [ enc ]

 
 
 
  Говорит screen как интерпретировать ввод/вывод. Первый аргумент устанавливает кодироку текущего окна. Каждое окно 
может эмулировать отдельную кодировку. Второй опциональный параметр перебивает кодировку присоединённого терминала. 
Обычно этот параметр не нужен, потому что screen может определить кодировку из настроек локали. Можно ещё выбирать кодировку 
терминала в зависимости от типа терминала, с помощью записи " .RS
 KJ
 

 

" в termcap.
 
 

 
  Поддерживаются кодировки eucJP, SJIS, eucKR, eucCN, Big5,  GBK,  KOI8-R, CP1251,  UTF-8,  ISO8859-2, ISO8859-3, ISO8859-4, 
ISO8859-5, ISO8859-6, ISO8859-7, ISO8859-8, ISO8859-9, ISO8859-10, ISO8859-15, jis. .RE
 
  См. также "defencoding", который меняет настройки по умолчанию для новых окон.
 

 
 
 escape   xy 

 
 

  Устанавливает управляющий символ равным x (похоже на опцию 
 
 -e
 

 

), а символ генерирующий литерал управляющего символа равным y. Каждый параметр (x и y) это или отдельный символ, или два 
символа в форме "^x" (обозначает "C-x"), или обратный слэш, за которым идёт восьмеричное число (ASCII-код символа), 
или обратный слэш за которым идёт ещё один символ (например, .RS
 \^
 

 
 

  или 
 
 \\
 

 

). По умолчанию "
 
 ^Aa
 

 

".
 
 eval   command1  [ command2  ...]

 
 

       Разбирает и выполняет каждый аргумент как отдельную команду.
 
 exec   fdpat ]  newcommand  [ args  ...

 
 
 
  Запускает подпроцесс UNIX (соответствующий  newcommand  и её аргументам) в текущем окне.  Соединение потоков (atdin/stdout/stderr) 
команды  newcommand ,  процесса, работающего в окне, и собственно screen определяется шаблоном  fdpat .  Шаблон 
 fdpat  это фактически трёхсимвольная последовательность, представляющая стандартный поток ввода, стандартный 
поток вывода и стандартный поток ошибок команды  newcommand .  Символ  точка  (.) подсоединяет файловый дескриптор 
к screen.  Символ  восклицательный знак  (!) говорит о том, что файловый дескриптор должен быть присоединён к приложению. 
  Символ  двоеточие  (:) сочетает в себе действие двух предыдущих.  Данные, которые вводятся пользователем, передаются 
новой команде за исключением тех случаев, когда она подключена к потоку вывода приложения, работающего в окне (первый 
символ  fdpats  это .RS
 !
 

 

  или 
 
 :
 

 

), и когда в конце  fdpat  стоит символ канала (|).  Если вызывать  exec  без аргументов, будут показаны именя и 
аргументы процессов, работающих в текущем окне.  В каждом окне за раз может исполняться только один подпроцесс.  Если подпроцесс 
работает, команда  kill  подействует на него, а не на процесс, работающий в окне.  В файле .RS
 doc/fdpat.ps
 


  проиллюстрированы все 21 комбинация соединений. На каждом рисунке есть цифры 2,1,0 соответствующие трём файловым дескрипторам 
команды  newcomand . Прямоугольник  W  это псевдотерминал, к которому с подчинённой стороны (slave side) подключено 
приложение.  Прямоугольник  P  это вторичный псевдотерминал, к которому с главной стороны (master side) подключен 
screen. .RE
 
  Сокращения:
 
 

  Пробелы между словом  exec  и  fdpat  можно пропустить.  Точки в конце  fdpat  писать не обязательно;  fdpat , 
состоящий из одних только точек, писать не обязательно.  Символ " .RS
 |
 

 

" это синоним для шаблона "!..|"; cлово  exec  в данном случае писать не обязательно, вместо него можно указать символ 
 
 !
 

 

 

 
  Примеры:
 

 
     exec ... /bin/sh
    exec /bin/sh
    !/bin/sh

 

 

 
  Создаёт новый интерпретатор, в то время как первый продолжает работать.  Вывод обоих интерпретаторов попадает в окно, 
а ввод отправляется новому интерпретатору. .RE
 
 
     exec !.. stty 19200
    exec ! stty 19200
    !!stty 19200

 

 

 
  Устанавливается скорость терминала окна. Если программа  stty  работает со стандартным потоком ввода, добавьте 
ещё один знак " .RS
 !
 

 

".
 

 
 
     exec !..| less
    |less

 

 

К выводу подключается pager. Специальный символ "|" нужен для того чтобы дать пользователю возможность управлять этим 
пейджером, несмотря на то, что данные он получает от процесса, работающего в окне.  Это работает, потому что less слушает 
стандартный поток ошибок (поведение, которое screen не ожидал бы без символа " .RS
 |
 


") когда стандартный поток ввода не терминал.   Less  новее чем версия 177 будет сбоить; а старый добрый  pg  работает. 
 
 
     !:sed -n s/.*Error.*/\007/p

 

 

 
  Отправляет вывод на экран пользователю и на вход команде  sed . Команда вставляет дополнительный символ звонка (восьмиричное 
007) в вывод screen. Поэтому при каждом появлении на экране слова "Error" в строку статуса выводится сообщение " .RS
 Bell in window x
 

 

". 

 
 fit 

 
 

  Изменить размер текущего размера под текущую область. Команда может пригодиться, когда screen не перестраивает размер 
окна, когда оно показывается больше чем один раз. 
 flow  [ on | off | auto ]

 
 

  Настроить режим управления потоком окна. При вызове без параметров команда циклически переключает настройки  auto , 
 on ,  off . Подробнее в разделе "Flow-control". Имейте в виду, что это настройка может поменяться в будущих 
выпусках screen. Настройка по умолчанию задаётся при помощи  defflow . 
 focus  [ up | down | top | bottom ]

 
 
 
  Переместить фокус ввода на следующих регион. Выполняется циклически, поэтому верхний регион выбирается после самого 
нижнего. Если подкоманда не задана, подразумевается  down . Подкоманда  up  перемещает фокус в противоположном 
порядке, а  top  и  bottom  переводят фокус на самый верхний или самый нижний регион. Полезные привязки .RE
(
 
 j
 

 

  и 
 
 k
 

 

  как в vi)
 
 
     bind j focus down
    bind k focus up
    bind t focus top
    bind b focus bottom

 

 

 
 gr  [ on | off ]

 
 
 
  Включает/выключает GR-переключение (GR charset switching). Когда screen встречает 8-битный символ, он использует 
charset записанный в GR-слоте и выводит символ с удалённым восьмым битом. По умолчанию (см. также  defgr )  GR не обрабатываются, 
потому что иначе символы ISO88591 перестанут работать. .RE
 
 
 hardcopy  [ -h ] [ file ]

 
 

  Записывает изображение текущего терминала в файл  file  или, если имя файла не задано, в файл 
 
 hardcopy.n
 

 

  в текущем каталоге, где  n  --- это номер текущего окна. Файл или дописывается или переписывается сверху (см. ниже). 
Если указан ключ -h, скидывается и содержимое буфера прокрутки. 
 hardcopy_append   on | off 

 
 

  Если включено ( on ), screen будет дописывать файлы созданные по нажатию "C-a h" в конец файла .RS
 hardcopy.n
 

 
 

, в противном случае он будет переписываться сверху. По умолчанию:  off .
 
 hardcopydir   directory 

 
 

  Определяет каталог, в котором будет размешён hardcopy-файл. Если не задан, файлы будут размещаться в текущем каталоге 
программы screen. 
 hardstatus  [ on | off ]

 
 hardstatus  [ always ] lastline | message | ignore  [ string ]

 
 hardstatus   string  [ string ]

 
 
 
  Команда настраивает использование или эмуляцию hardstatus-строки терминала. Первая форма переключает использование 
аппаратной  статусной строки (hardware status line) для отображения сообщений. Если флаг установлен в  off , сообщения 
выводятся в реверсивном видео на экране. Настройка по умолчанию:  on . .RE
 
  Вторая форма говорит screen что делать в том случае, когда у терминала нет строки  hardstatus  (то есть, в termcap/terminfo 
не установлены "hs", "ts","fs" и "ds"). Если используется тип  lastline , screen резервирует последнюю строку экрана 
для строки статуса; тип  message  говорит screen о том, что надо использовать механизм сообщений screen и  ignore  
-- что нужно не показывать hardstatus вообще. Если добавить слово  always  перед типом строки, screen будет использовать 
его даже в том случае, если терминал поддерживает hardstatus. .RE
 
  Последняя форма описывает содержимое строки hardstatus. По умолчанию используется строка "%h", т.е. показывается статус 
текущего окна (устанавливается строками " .RS
 ESC]0;<string>^G
 

 

" или "
 
 ESC_<string>ESC\
 

 

"). Можно настроить строку как угодно, для этого нужно использовать Escape-последовательности (см. раздел "Escape-последовательности"). 
Если вызвать команду без аргументов, будет показана текущая настройка. .RE
 
  Можно смешивать вторую и третью формы --- задавать строку как дополнительный аргумент или нет.
 

 
 
 height  [-w|-d] [ lines  [ cols ]]

 
 

  Задаёт высоту отображения равной количеству строк  lines . Когда аргумент не задан, выполняется переключение между 
24 и 42 строками. Можно определить и ширину, если нужно изменить оба значения. Опция .RS
 -w
 

 
 

  говорит, что нужно оставить размер экрана неизменным и менять только размер окна, а опция 
 
 -d
 

 

  наоборот.
 
 
 help  [-c  class ]

 
 

  Не совсем помощь, а просто картинка со списком комбинаций клавиш. На первой странице показаны все внутренние команды и 
их текущие привязки. На последующих страницах показаны пользовательские привязки, по одной команде на одну комбинацию. 
Пробел переходит к следующей странице; enter -- завершает просмотр. Все остальные символы игнорируются. Если задана 
опция .RS
 -c
 

 
 

, выводится список всех команд указанного класса  class . См. также раздел "Привязка клавиш".
 
 history 

 
 

  В командных интерпретаторах легко посмотреть или использовать вызванные ранее команды. Например, в csh есть .RS
 !!
 

 
 

, которая повторяет последнюю вызванную команду. В screen есть простой механизм вызова команд, начинающихся с определённой 
последовательности: нужно набрать интересующую последовательность, почле чего нажать "C-a {" и screen попытается 
найти строку, начинающуюся с текста слева от курсора (с символом приглашения, приглашение character).  Найденная строка 
вставляется в окно. Этот механизм может использоваться как грубая замена механизма истории в командном интерпретаторе 
(в историю подставляются варианты как из видимой части окна, так и из буфера прокрутки). 
 hstatus   status 

 
 

  Изменить строку статуса окна на status
 
 idle  [ timeout  [ cmd   args ]]

 
 

  Указывает команды, которая запускается после того как проходит заданное количество секунд без активности. Обычно в качестве 
команды указывается команда  blanker , которая вызывает хранитель экрана screen. Если команда не задана, определяется 
только величина таймаута. Таймаут равный нулю (или специальное слово  off ) отключает таймер вообще. Если аргументы 
не заданы, показывается текущая настройка. 
 ignorecase  [on|off]

 
 

       Говорит screen, что нужно игнорировать регистр символа при поиске. По умолчанию выключено.
 
 info 

 
 

  Выводит информацию о текущем окне: позиция курсора в форме  "(column,row)", начиная с "(1,1)",  ширина и высота терминала 
плюс размер буфера прокрутки в строках, например "(80,24)+50",  текущее состояние управления потоком (flow control) 
окна XON/XOFF, показанное в виде (см. также раздел "Flow Control"): 
 
     +flow     автоматический контроль потока (automatic flow control), включен
    -flow     автоматический контроль потока (automatic flow control), выключен
    +(+)flow  контроль потока включен. Совпадает с автоматическим контролем потока
    -(+)flow  контроль потока выключен. Не совпадает с автоматическим контролем потока
    +(-)flow  контроль потока включен. Не совпадает с автоматическим контролем потока
    -(-)flow  контроль потока выключен. Совпадает с автоматическим контролем потока

 

 

 
  Показываются настройки переноса ("
 
 +wrap
 

 

" говорит, что перенос включён; "
 
 -wrap
 

 

" говорит, что перенос выключен).
 

 
  Флаги "ins", "org", "app", "log", "mon" или "nored" показываются в том случае, если окно находится в режиме вставки (insert), 
исходном (origin),  приложения (application-keypad), если в нём включена журнализация вывода (output logging), мониторинг 
активности (activity monitoring) или частичная отрисовка (partial redraw). .RE
 
  Показываются активный набор символов (character set; G0, G1, G2 или G3) и в квадратных скобках символы терминала, которые 
выделены для G0-G3. Если окно в режиме UTF-8, вместо всего этого показывается строка .RS
 UTF-8
 

 

 
 

 
  В конце строки статуса выводятся дополнительные режимы (см. также "Типы окон"). Если машина состояний эмулятора терминала 
находится не в нормальном состоянии, строка info начинается со строки, идентифицирующей текущее состояние. Для получения 
системной информации используется команда  time . .RE
 
 
 ins_reg  [ key ]

 
 

  Больше не существует. Используйте  paste 
 
 kill 

 
 

  Завершает текущее окно. Если выполняется команда 
 
 exec
 

 

, она завершается. Если нет, процесс (командный интерпретатор), работающий в окне, получает сигнал HANGUP, структура 
окна удаляется и screen переключается на другое окно. Когда последнее окно закрывается, screen завершает свою работу. 
После закрытия окна screen переключается на окно, которое отображалось до того. .br
  Замечание: Пользователи Emacs (да и не только Emacs, но и других программ имитирующих интерфейс Emacs, в частности bash) 
должны помнить об этой команде, когда удаляются текст до конца строки. Или лучше не использовать "C-a" как escape-последовательность 
или привязать kill на "C-a K". 
 lastmsg 

 
 

  Повторно показать содержимое статусной строки. Полезно, когда вы случайно сбили сообщение при наборе (сообщение пропадает, 
если нажать любую клавишу), а потом хотите его посмотреть. См. также  msgwait  и  msgminwait  (тонкая настройка 
режима показа сообщения). 
 license 

 
 

  Показать страницу-disclaimer. Она показывается при запуске screen без опций, что происходит достаточно часто. См. 
также команду  startup_message . 
 lockscreen 

 
 
 
  Блокирует дисплей. Вызывается специальную программу блокировки (
 
 /local/bin/lck
 

 

  или 
 
 /usr/bin/lock
 

 

  или встроенную, если других нет). Screen не обрабатывает никакие клавиши и комбинации клавиш до тех пор пока эта программа 
не завершится. Тем временем исполнение процессов в окнах может продолжаться, а сами окна находятся в отключённом (detached) 
состоянии. Программу screenlock можно укзать при помощи переменной .RS
 $LOCKPRG
 

 

, которая устанавливается в интерпретаторе, из которого вызывается screen. Программа выполняется от имени и с правами 
пользователя, который выполняет screen. .RE
 
  Предупреждение: если вы оставляете другие оболочки разблокированными и на screen не стоит пароль, толку от блокировки 
никакого. Можно легко подключиться к screen из другой оболочки. Правильонее было бы назвать эту фукнцию "lockterminal". 
 

 
 log  [ on | off ]

 
 

  Начинает/останавливает запись журнала действий в текущем окне в файл 
 
 screenlog.n
 

 

  в текущем каталоге окна (где  n  -- номер текущего окна). Имя файла можно изменить при помощи команды  logfile . 
Если команда вызывается без парамеров, состояние переключается на противоположное. Журнал дописывается в конец файла 
(если файл уже есть). Текущее состояние экрана и буфер прокрутки не включаются в журнал. По умолчанию:  off . 
 logfile   filename 

 
 logfile   flush   secs 

 
 
 
  Определяет имя файла журнала. По умолчанию "screenlog.%n". Вторая форма определяет количество секунд, которые screen 
будет ждать прежде чем сбросить буфер файла журнала на диск. По умолчанию 10 секунд. .RE
 
 
 login  [ on | off ]

 
 
 
  Добавляет или удаляет запись в базе данных utmp для текущего окна. Фактически, регистрирует (log in) окно. При вызове без 
параметров переключается состояние (регистрирует/разрегистрирует). Помимо этого, удобно когда есть комбинации клавиш 
для регистрации и разрегистрации. Например, " .RS
 bind I login on
 

 

" и "
 
 bind O login off
 

 

" привязывают эти действия
 
 

к "C-a I" и "C-a O". Настройка по умолчанию (в 
 
 config.h.in
 

 

) должна быть  on  для окон, наботающих с установленным битом suid-root. Состояние "по умолчанию" для новых окон 
задаётся при помощи команды  deflogin . Обе команды есть только в том случае, если screen откомпилирован с поддержкой 
utmp. 
 logtstamp  [ on | off ]

 
 logtstamp   after  [ secs ]

 
 logtstamp   string  [ string ]

 
 
 
  Команда управляет временными метками в файле-журнале (logfile). Если временные метки включены, после двух минут без 
активности screen выводит в журнал строку, содержащую текущее время. Когда вывод продолжается больше двух минут, добавляется 
второй вывод (When output  continues  и  more  than another two minutes have passed).  Величину таймаута можно изменить с помощью 
второй формы команды.  Третья форма предназначена для настройки формата строки временных меток (по умолчанию " .RS
 -- %n:%t -- time-stamp  -- %M/%d/%y %c:%s --\n
 

 

").
 
 

 
 mapdefault 

 
 

  Говорит screen о том, что следующий символ он должен искать в стандартной таблице привязки клавиш. См. также  bindkey . 
 
 mapnotnext 

 
 

  Как  mapdefault , но не смотреть таблицу bindkey 
 
 maptimeout  [ timo ]

 
 

  Задержка между симолами (в мс) при распознавании входных последовательностей. По умолчанию 300мс. При вызове без аргументов 
показывает текущую настройку. См. также  bindkey . 
 markkeys   string 

 
 
 
  Изменить привязку клавиш для режима копирования/истории. Строка  string  состоит из пар 
 
 oldchar=newchar
 

 

, разделённых двоеточиями.
 
 

  Пример: Строка "B=^B:F=^F" меняет привязку клавиш "C-b" и "C-f" на привязку в стиле vi (прокрутка вверх/вниз).  По умолчанию 
это привязка для клавиш  B  и  F .  Команда " .RS
 markkeys h=^B:l=^F:$=^E
 

 

" меняет привязку клавиш на привязку в стиле GNU Emacs.  Если терминал отправляет символы, они снимают режим копирования, 
и здесь может помочь эта команда, которая отключает любое действие у этих символов. Символ " .RS
 @
 


" это символ no-op, он используется так: вызов "
 
 markkeys @=L=H
 

 

" отключает действие команд H и L. Как показано в примере, к одной функции за раз можно привязать множество клавиш. .RE
 
 maxwin   num 

 
 

  Максимальное количество окон, которые можно создать. Не влияет на уже существующие окна. Число можно только уменьшать. 
 
 meta 

 
 

  Вставляет управляющий символ (C-a) в текущий поток ввода окна.
 
 monitor  [ on | off ]

 
 
 
  Включает/выключает наблюдение за активностью в окнах. Когда мониторинг включен для какого-то окна, и оно уходит в фон, 
система следит за активностью в нём и отправляет предупреждающее сообщение в строку статуса, как только хотя бы один символ 
будет выведен в окно. Название окна будет отмечено символом " .RS
 @
 

 

". По умолчанию мониторинг отключён для всех окон. 

 
 msgminwait   sec 

 
 

  На протяжении какого времени обязательно показывается сообщение, даже если на экране есть какая-то другая активность. 
По умолчанию 1 секунда. 
 msgwait   sec 

 
 

  На протяжении какого времени показывается сообщение, если никакой другой активности нет. По умолчанию 5 секунд. 
 multiuser   on | off 

 
 
 
  Переключается между однопользовательским и многопользовательским режимом. Стандартный режим работы  однопользовательский. 
В многопользовательском работают команды  acladd',  aclchg ,  aclgrp  и  acldel''. Они нужны для того 
чтобы дать (или забрать) доступ пользователям к сеансу screen. .RE
 
 
 nethack   on | off 

 
 

  Изменяет вид сообщений об ошибках, которые выводит screen.  Если вы знакомы с игорой "nethack", возможно вам по нраву сообщения, 
в которых факты немного искажаются. Так немного веселее. В любом случае, и стандартные сообщения не всегда можно понять. 
  Опция доступна только, когда screen откомпилирован с флагом .RS
 NETHACK
 

 
 

   Настройки по умолчанию определяются значением переменной 
 
 $NETHACKOPTIONS
 

 

 
 next 

 
 

  Переключиться на следующее окно. Команда может использовать многократно, для того чтобы циклически обойти все окна. 
 
 nonblock  [ on | off | numsecs ]

 
 

  Говорит screen что нужно делать с интерфейсами (дисплеями), которые отказываются принимать ввод. Такое может произойти, 
например, если пользователь нажмёт ^S или разорвётся TCP/модемное соединение. Если nonblock выключен (так по умолчанию), 
screen ждёи пока дисплей перезапустится и будет готов принимать ввод.Если nonblock включен, screen подождёт окончания 
таймаута. Если не указано особо, таймаут составляет 1 секунду. Если дисплей за это время не станет принимать символы, он 
считается заблокированным и больше символы туда не отправляются. Если через некоторое время символы начнут приниматься, 
экран будет разблокирован и его содержимое обновлено. 
 number  [ n ]

 
 

  Изменят текущий номер окна. Если заданный номер  n  уже занят, окна меняются номерами. Если номер не задан, выводится 
номер (и имя) текущего окна. 
 obuflimit  [ limit ]

 
 

  Если буфер вывода содержит количество байтов больше заданного предела, новые данные из окон считываться не будут.  По умолчанию: 
256.  Для быстрых дисплеев (например, для xterm) можно установить значение побольше.  Если аргумент не задан, выводится 
текущее значение. 
 only 

 
 

  Убить все регионы, за исключением текущего.
 
 other 

 
 

  Переключиться на другое окно, которое было активным до этого. Если того окна уже нет,  other  работает как  next  
 
 partial   on | off 

 
 

  Определяет должен ли дисплей перерисовываться (как при  redisplay ) при переходе на текущее окно. Команда действует 
только на текущее окно. Чтобы подействовать на все окна сразу, нужно использовать команду  allpartial . По умолчанию: 
 off . Это значение по умолчанию фиксированное, команды  defpartial  нет. 
 password  [ crypted_pw ]

 
 

  Задаёт зашифрованный пароль, который screen спросит, если кто-то попытается подключиться к нему и возобновить его работу 
из отключённого состояния. Полезно, если в screen работают привилегированные программы и вы бы хотели защитись сеанс 
от других пользователей, замаскировавшихся под ваш uid (даже от суперпользователя). Если зашифрованный пароль не задан, 
screen дважды попросит ввести пароль и запомнит зашифрованный пароль в своём буфере обмена (paste buffer). По умолчанию 
 none , что отключает парольную проверку вообще. 
 paste  [ registers  [ dest_reg ]]

 
 

  Вывести содержимое указанных регистров на стандартный поток ввода текущего окна.  Регистр "." обозначает буфер обмена 
screen (paste buffer).  Если параметров не задать, имя регистра запрашивается у пользователя.  В буфер обмена screen (paste 
buffer) информация попадает при помощи команд  copy ,  history  и  readbuf . В другие регистры информация 
попадает при помощи команд  register ,  readreg  и  paste . Если  paste  вызывается со вторым аргументом, 
содержимое регистров вклеивается не в текущее окно, а в регистр с заданным названием. Если в качестве второго аргумента 
указана ".", данные вклеиваются в буфер обмена дисплея (displays paste buffer). Обратите внимание, что  paste , 
если указать второй аргумент, даже не требуется окно; если манипуляции происходят только с регистрами, даже не обязательно 
чтобы screen был подключен к экрану. Буфер обмена привязан к процессу screen; если с этим процессом работает несколько 
пользователей, буфер для них общий. 
 pastefont  [ on | off ]

 
 

  Сообщает screen нужно ли включать информацию о шрифтах в бувер вставки. По умолчанию включать не нужно. Эта команда имеет 
особо важное значение для многобайтных кодировкок, таких, например, как kanji. 
 pow_break 

 
 

  Повторно открыть (reopen) термиинальную линию окна (window's терминал line) и отправить символ разрыва (break condition). 
См. также  break  
 pow_detach 

 
 

  Отключение питания (power detach). Очень похоже на обычное отключение (detach), но отправляется сигнал HANGUP родительскому 
процессу screen. .br
  Предупреждение. Вызов этой команды приведёт к завершению сеанса работы, если screen был запущен из login-оболочки. 
 
 pow_detach_msg  [ message ]

 
 

  Задаёт сообщение, которое выводится при выполнении 
 
 Power detach
 

 

   Может использоваться как замена для logout-сообщения или для сброса настроек линии (baud rate и т.д.).  При вызове без 
параметров показывается текущее сообщение. 
 prev 

 
 

  Переключиться на предыдущее окно. Команда может использовать многократно, для того чтобы циклически обойти все окна. 
 
 printcmd  [ cmd ]

 
 

  Если  cmd  не пустая, screen, когда встретит Escape-последовательность 
 
 ESC [ 5
 

 

, не будет использовать возможности (capabilities) терминала 
 
 po/pf
 

 

, а запустит вместо этого команду  cmd  и передаст вывод ей.  В качестве  cmd  хорошо подойдут команды  lpr  
или " cat  .RS
 > /tmp/scrprint
 


" .  Если вызвать  printcmd  без команды, она покажет текущую настройку.  ANSI-последовательность ESC \ прекращает 
печать и закрывает канал. .br
  Предупреждение. Будьте осторожны с этой командой! Если у других пользователей есть доступ на запись в ваш терминал, они 
смогут запустить процесс печати. 
 process  [ key ]

 
 

  Вывести содержимое указанного регистра в буфер ввода. Если аргумент не задан, нужно будет ввести имя регистра с клавиатуры. 
Текст обрабатывается так, как будто он был введён с клавиатуры пользователя. Команда может использоваться для того чтобы 
привязать несколько действий к одному ключу. 
 quit 

 
 

  Убить все окна и завершить screen. Обратите внимание на то, что в VT100 сигналы C-4 и C-\ идентичны. Из-за этого стандартная 
привязка становится опасной: можно случайно нажать C-a C-4, когда выбираешь 4е окно. Для того чтобы отключить всякие 
действия от этой комбинации клавиш, можно вызывать пустой  bind : " .RS
 bind ^\
 


".
 
 readbuf  [-e  encoding ] [ filename ]

 
 

  Считывает содержимое указанного файла в буфер обмена.  Можно указать screen'у кодировку этого файла с помощью ключа -e. 
Если файл не указан, используется стандартный файл (см. screen-exchange). См. также команду  buffer-file . 
 readreg  [-e  encoding ] [ register  [ filename ]]

 
 

  Делает одно из двух, в зависимости от количества аргументов: без аргументов или с одним аргументов содержимое буфера обмена 
дублируется в указанном в команде или введённом в приглашение регистре. При вызове с двумя аргументами содержимое файла 
считывается в регистр, точно также как при вызове команды .RS
 readbuf
 


  содержимое файла 
 
 screen-exchange
 

 

  считывается в буфер обмена. Кодировку файла можно задать при помощи опции 
 
 -e
 

 

  В приведённый ниже примере содержимое файла 
 
 /etc/passwd
 

 

  вставляется в окно screen (с использованием регистра 
 
 p
 

 

, в котором остаётся копия):
 
 
     C-a : readreg p /etc/passwd
    C-a : paste p

 

 

 redisplay 

 
 

  Перерисовать текущее окно. Используется для того чтобы выполнить полную перерисовку при работе в режиме частичной отрисовки 
(partial redraw). 
 register  [-e  encoding ]  key   string 

 
 

  Сохранить указанную строку в регистр с заданным ключом  key . Кодировка строки может быть задана с помощью опции .RS
 -e
 


  Также смотрите опцию  command .
 
 remove 

 
 

  Уничтожить текущий регион. Это команда не имеет эффекта, если регион только один.
 
 removebuf 

 
 

  Удалить файл screen-exchange, который использовался командами  writebuf  и  readbuf .
 
 reset 

 
 

  Приводит настройки виртуального терминала в исходное состояние. Полезно, когда на терминале из-за некорректного использования 
приложений появлюятся странные символы, типа квадратиков, вместо того чтобы выводился текст. 
 resize 

 
 

  Изменить размер текущего региона. Пространство будет добавлено или удалено из нижнего региона или, если его не хватит, 
из региона который выше. 
 
     resize +N   увеличить высоту региона на N
    resize -N   уменьшить высоту региона на N
    resize  N   установить высоту региона равной N
    resize  =   сделать все регионы одинаковой высоты
    resize  max сделать текущий регион максимально высоким
    resize  min сделать текущий регион максимально низким

 

 

 screen  [- opts ] [ n ] [ cmd  [ args ]]

 
 
 
  Создать новое окно. В команде могут быть указаны опции управления потоком (
 
 -f
 

 

,  
 
 -fn
 

 

   и  
 
 -fa
 

 

), опция названия (
 
 -t
 

 

), опции регистрации (
 
 -l
 

 

  и 
 
 -ln
 

 

) , опция типа терминала (
 
 -T
 

 

   term ), опция флага всех возможностей (all-capability flag) (
 
 -a
 

 

) и опция буфера прокрутки (
 
 -h
 

 

   num ).  Опция 
 
 -M
 

 

  включает мониторинг окна. Опция 
 
 -L
 

 

  включает журнализацию вывода окна. Если задан опциональный номер  n  из диапазона 0..9, этот номер присваивается 
созданному окну (или,  если номер уже используется, следующий свободный).  Если после screen указана команда, она (вместе 
с заданными аргументами) запускается в окне; в противном случае создаётся окно с командным интерпретатором. Так, например, 
если в .RS
 

 

  есть строки:

 
     # example for .screenrc:
    screen 1
    screen -fn -t foobar -L 2 telnet foobar

 

 

 
  screen создаст окно интерпретатора (в окне #1) и окно с TELNET-соединением на машину foobar (с отключённым flow-control, 
с заголовком "foobar", в окне #2) и будет писать журнал ("screenlog.2") сеанса работы в Telnet. Обратите внимание, что 
в отличие от предыдущих версий screen дополнительных окон не создаётся, если в .RS
 

 

  есть хотя бы одна команда  screen . Когда инициализации окончена, screen переключается на последнее окно, описанное 
в файле .RS
 


, или, если таковых нет, открывает окно #0. В screen встроена некоторая функциональность  cu  и  telnet . См. 
также раздел "Типы окон". .RE
 
 scrollback   num 

 
 

  Устанавливает размер буфера прокрутки для текущих окон равным  num  строк. По умолчанию: 100. См. также команду  defscrollback , 
которая устанавливает размер буфера прокрутки по умолчанию, а также комбинацию клавиш  C-a i , которая показывает 
текущую настройку. 
 select  [ WindowID ]

 
 
 
  Выбрать окно с идентификатором WindowID. Это может быть или номер окна или префикс в имени окна (алфавитно-цифровое имя). 
Если параметр не указывать, система попросит ввести идентификатор. При создании окон берётся первый незанятый номер. 
Поэтому переход на самое первое окно выполняется по команде .RS
 select 0
 

 

  Максимальное количество окон ограничивается при компиляции параметром 
 
 MAXWIN
 

 

  Есть два специальных обозначения: "-" для внутреннего окна и "." для текущего окна. Последнее очень полезно при использовании 
с " .RS
 screen -X
 


".

 
 sessionname  [ name ]

 
 

  Переименовать текущий сеанс. Обратите внимание, что в выводе 'screen -list' имя показывается с идентификатором процесса. 
Если аргумент  name  опущен, просто показывается имя сеанса. .br
  Предупреждение: переменная 
 
 $STY
 

 

  после переименования всё равно содержит старое имя. Это может привести к путанице. По умолчанию имя составляется из названия 
терминала и имени хоста. 
 setenv  [ var  [ string ]]

 
 

  Установить переменную окружения  var  равной  string . Если указать только  var , система попросит ввести 
значение. Если параметры не заданы вообще, система попросит ввести и название переменной и значение. Среда окружения 
будет наследоваться всеми оболочками, которые будут запущены из screen. 
 setsid  [ on | off ]

 
 
 
  В нормальном режиме screen использует отдельные группы сеансов и процессов для своих окон. Если выключить  setsid , 
так больше не происходит, и все окна находятся в одной группе процессов, с основным процессом screen (screen backend proccess). 
Обратите внимание, что в этом случае не будет работать управление работами (job control). По умолчанию  setsid  включен. 
Команда редко когда может оказаться полезной. .RE
 
 
 shell   command 

 
 

  Задаёт команду, которая должна использоваться при создании новой оболочки. Этот параметр перекрывает значение переменной 
окружения .RS
 $SHELL
 

 
 

  Полезно, если вы любите запускать расширитель терминала (tty-enhancer), который запускает программу, указанную в 
 
 $SHELL
 

 

  Если команда начинается символом 
 
 -
 

 

, оболочка будет запущена как login-оболочка (login-shell).
 
 shelltitle   title 

 
 

  Задаёт заголовок для всех окон с командным интерпретатором, которые создаются при запуске или при нажатии  C-a C-c . 
Подробнее в разделе  Заголовки (наименования окон) . 
 silence  [ on | off | sec ]

 
 

  Управляет наблюдением за тишиной (silence monitoring) в окнах. Когда silence для окна включен, и в течение некоторого 
времени в нём нет изменений, в статусной строке появляется соответствующее сообщение.  Длительность ожидания можно изменять 
с помощью команды  sliencewait  или путём указания количества секунд в качестве аргумента (вместо  on  или  off ). 
По умолчанию:  off . 
 silencewait   sec 

 
 

  Определяет время, в течение которого в окнах, в которых отслеживается тишина, должно не происходить никаких действий, 
прежде чем выводить соответствующее сообщение. По умолчанию 30 секунд. 
 sleep   num 

 
 

  Приостанавливает выполнение файла .screenrc на заданное количество секунд. Любая клавиатурная активность останавливает 
ожидание. Это может пригодиться, когда нужно сделать чтобы пользователь мог прочитать сообщение, выводимое с помощью 
 echo . 
 slowpaste   msec 

 
 
 
  Определяет скорость, с которой текст будет вставляться в текущее окно при вызове команды  paste  (нажатии "C-a ]"). 
Если значение slowpaste отлично от 0, текст вводится посимвольно и screen делает паузу  msec  миллисекунд после каждого 
символа, для того чтобы приложение могло успеть обработать ввод. Команду  slowpaste  нужно использовать только 
в тех случаях, когда доступная через screen система обрабатывает большие объёмы мгновенно вставляемого текста с ошибками. 
 

 
 source   file 

 
 

  Прочитать и выполнить команды из файла  file . Команда  source  может быть вложенной, с максимальной глубиной 
рекурсии до 10. Если имя  file  не содержит абсолютного пути и screen сейчас выполняет команду  source , новый 
файл ищется в родительском каталоге текущей команды  source , и если там ничего не найдено, выполняется поиск в текущем 
каталоге. .br
  Обратите внимание, что команды  termcap ,  terminfo  и  termcapinfo  работают только при запуске и при 
повторном подключении (reattach); поэтому, для того чтобы они имели эффект, их нужно вызывать из файлов screenrc. 
 sorendition  [ attr  [ color ]]

 
 

  Указывает способ, который screen использует для подсветки текста и печатаемых сообщений. Синтаксис модификаторов описан 
в разделе  "Escape-последовательности". Сейчас по умолчанию "=s dd" (standout, цвета по умолчанию). 
 split 

 
 

  Разделить текущий регион на два новых. Размеры всех регионов на экране меняются для того чтобы освободить место для ного 
региона. В новом регионе отображается пустое окно. Удалить регион можно с помощью команды  remove  или  only . 
 
 startup_message   on | off 

 
 

  Должно ли показывать сообщение с информацией о правах на программу при её старте. По умолчанию  on , как уже можно было 
убедиться. 
 stuff   string 

 
 

  Вставляет строку  string   в текущее окно. Похоже на команду  paste , но с меньшими накладными расходами. С помощью 
команды  stuff  нельзя вставить большие объёмы текста. Очень полезно для управления привязками клавиш. См. также 
 bindkey . 
 su [ username  [ password  [ password2 ]]

 
 

  Изменить пользователя дисплея. Команда спросит все параметры, которые не указаны как аргументы. Если в качестве аргументов 
указываются пароли, они должны указываться не в зашифрованном виде. Первый пароль проверяется через системную базу паролей, 
а второй -- через собственную базу screen (в которую пароли попали через команды  acladd  и  password ). Команда 
 su  может пригодиться для администраторов screen, которые хотя проверить многопользовательские настройки. Если 
аутентификацию не пройти, доступ есть только к командам, доступным пользователю nobody. К этим командам относятся " detach ", 
  " license ",  " version ", " help " и " displays ". 
 suspend 

 
 

  Приостановить screen. Окна всё это время находятся в отключённом состоянии. Данная особенность полагается на возможности 
командного интерпретатора по управлению работами (job control). 
 term   term 

 
 

  В каждом окне, которое открывает screen, переменная 
 
 $TERM
 

 

  устанавливается по умолчанию равной 
 
 screen
 

 

  Но, когда в локальных базах данных termcap и terminfo нет поддержки screen, надо установить 
 
 $TERM
 

 

  равной, скажем, 
 
 vt100
 

 

   В этом нет ничего страшного, посколько screen совместим с VT100/ANSI. Не рекомендуется использовать эту команду за исключением 
тех случаев, когда задаются настройки по умолчанию. Например, в случае, когда нужно задать настройки терминала для одной 
команды, скажем для .RS
 screen  rlogin  othermachine
 


, лучше использовать вызов "
 
 screen -T vt100 rlogin othermachine
 

 

" чем устанавливать или сбрасывать настройки по умолчанию.
 
 termcap   term   terminal-tweaks  [ window-tweaks ]

 
 terminfo   term   terminal-tweaks  [ window-tweaks ]

 
 termcapinfo   term   terminal-tweaks  [ window-tweaks ]

 
 
 
  Команда модифицирует termcap-запись терминала без необходимости выполнениях хитрых операций, связанных с созданием 
собственной termcap-записи.  Кроме того, с её помощью можно подстраивать termcap-записи сгенерированные для окон. 
  Эти команды имеет смысл размещать только в .RS
 screenrc
 

 

, поскольку после того как screen запущен, команды уже не нужны. Если в системе используется база данных terminfo, а не termcap, 
screen поймёт команду  terminfo , у которой такой же эффект как и у команды  termcap .  Две отдельные команды существуют 
из-за нескольких тонких синтаксических отличий, в частности, там где выполняется интерполяция " .RS
 %
 


" параметров.  Обратите внимание, что даже с  terminfo  нужно использовать имена возможностей (capabilities) от 
termcap.  Во многих случаях, когда аргументы подходят как для  terminfo , так и для  termcap , можно использовать 
команду  termcapinfo , которая является сокращением для пары команды ( termcap  и  terminfo ) с идентичными 
аргументами. .RE
 
  Первый аргумент указывает на какой терминал (или терминалы) должно подействовать определение. Можно задавать множество 
имён терминалов через .RS
 |
 

 

, 
 
 *
 

 

  обозначает все терминалы, а 
 
 vt*
 

 

  -- все терминалы, начинающиеся на 
 
 vt
 

 

 

 
  Каждый аргумент  tweak  содержит одно (или более) определение termcap (разделённых сиволом ":"), которые вставляются 
в начало соответствующей записи termcap, дополняя или перекрывая существующие значения.  Первый  tweak   изменяет 
termcap вашего терминала. Он содержит определения, которые терминал использует для выполнения определённых функций. 
Если указать пустую строку "", чтобы не делать никаких изменений.  Второй (опциональный)  tweak  изменяет  termcap'ы 
окон, он должен содержать определения, которые screen поймёт (см. раздел "Виртуальный терминал"). .RE
 
  Некоторые примеры:
 

 
 
     termcap xterm*  LP:hs@

 

 

 
  Говорит screen о том, что у всех терминало, имя типа которых начинается с "
 
 xterm
 

 

", должны быть жёсткие автоотступы (firm auto-margins), которые позволят обновляеть последнюю позицию экрана (LP), 
и у которых нет статусной строки, hardstatus (нет "hs" --- если добавить " .RS
 @
 

 

" в конец записи, она выключается).
 

 
        

 

 

 
  Обратите внимание, что "
 
 LP
 

 

" подразумевается для всех терминалов, имя типа которых начинается с 
 
 vt
 

 

, за исключением тех терминалов, для которых указана команда  termcap .
 

 
 
     termcap vt*  LP
    termcap vt102|vt220  Z0=\E[?3h:Z1=\E[?3l

 

 

 
  Определяет возможность (capability) "
 
 LP
 

 

" для всех терминалов, название типа которых начинается с "
 
 vt
 

 

".  Вторая строка добавляет поддержку escape-последовательностей для переключения в режим 132 символа на строку (Z0) 
и из него (Z1) для терминалов VT102 и VT220 (для того чтобы использовать команды по изменению ширины, нужно указать Z0 и Z1 
в файле termcap) .RE
 
 
     termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4

 

 

 
  Здесь termcap vt100 остаётся нетронутым, а в termcap-записи окон добавляются метки функциональных клавиш. .RE
 
 
     termcap h19|z19  am@:im=\E@:ei=\EO  dc=\E[P

 

 

 
  В termcap'ах h19 и z19 выключаются автоотступы (
 
 am@
 

 

, auto margin) и включаются режим вставки (
 
 im
 

 

, insert mode) и конец вставки (
 
 ei
 

 

, end-insert) (символ "
 
 @
 

 

"  в строке "
 
 im
 

 

" идёт после "
 
 =
 

 

", так что это часть строки).  Если добавить определения "
 
 im
 

 

" и "
 
 ei
 

 

" в termcap терминала, где запущен screen, они автоматически будут передаваться в termcap каждого окна.В каждом окне появляется 
новая возможность (capability): удаление символа delete-character (dc), которое screen транслирует в обновление 
строки терминала (предполагается, что терминал не имеет возможности удалять символ). .RE
 
  Если нужно полностью задать записть termcap, лучше использовать переменную 
 
 $SCREENCAP
 

 

, которую установить до запуска screen. Подробнее в разделе "Виртуальный терминал" и в man-странице  termcap (5), где 
подробно рассказывается об определениях termcap. .RE
 
 
 time  [ string ]

 
 

  Показать в строке сообщений время, имя хоста и нагрузку (load average) за 1, 5 и 15 минут (если это поддерживается в системе). 
Для получения информации об окне используйте команду  info . .br
  Если задан аргумент  string , формат меняется как описано в разделе "Escape-последовательности". По умолчанию 
" .RS
 %c:%s %M %d %H%? %l%?
 

 
 

".
 
 
 title  [ windowtitle ]

 
 

  Задаёт имя текущего окна. Если имя не указано, screen выдаёт приглашение для его ввода. В более ранних версиях screen команда 
была известнка как  aka . 
 unsetenv   var 

 
 

  Удалить переменную окружения.
 
 utf8  [ on | off  [ on | off ]]

 
 
 
  Изменяет кодировку текущего окна. Если включён utf8, строки отправляемые в окно, будут перекодированы в UTF-8 (и наоборот). 
Если не задавать параметры, настройки переключаются на противоположные. Если задан второй параметр, меняется также 
настройка отображения (display encoding); обычно это делается с помощью опции командной строки -U. Также, смотрите 
команду  defutf8 , которая меняет начальные настройки для новых окон. .RE
 
 
 vbell  [ on | off ]

 
 
 
  Настройка визуального звонка для окна. Если вызвать без параметра, настройка переключается. Если визуальный звонок 
включен, но терминал не поддерживает его, при поступлении символа звонка (^G) в строке статуса выводится сообщение  vbell-message . 
Поддержка визуального звонка терминалом определяется переменной termcap .RS
 vb
 

 

  (или 
 
 flash
 

 

  в terminfo). По умолчанию vbell выключен и используется звуковой звонок. См. также  bell_msg .
 
 

 
 vbell_msg  [ message ]

 
 
 
  Задаёт сообщение для визуального звонка (visual bell). Сообщение  message  выводится в строке статуса в момент, 
когда в окно выводится символ звонка (bell character, ^G) и при этом vbell включен, но терминал не поддерживает visual vell. 
По умолчанию выводится сообщение .RS
 Wuff, Wuff!!
 

 

  Если вызывать команду безе параметров, будет показано текущее сообщение.
 
 

 
 
 vbellwait   sec 

 
 

  Определяет задержку в секундах для каждого вывода визуального звонка (visual bell) в screen. По умолчанию, 1 секунда. 
 
 verbose  [ on | off ]

 
 

  Если включено, при создании (или восстановлении) окна, выводится имя вызванной команды. По умолчанию выключено. При 
вызове без параметров показывается текущая настройка. 
 version 

 
 

  Вывести текущую версию и дату компиляции в строку статуса.
 
 wall   message 

 
 

  Вывести сообщения на все окна. Это сообщение будет показано в строке статуса терминала.
 
 width  [-w|-d] [ cols  [ lines ]]

 
 
 
  Переключает ширину окна между 80 и 132 (или устанавливает равной заданной, при условии, если она указана). Требует поддержки 
со стороны терминала (записи Z0 и Z1). См. команду  termcap . Можно менять не только ширину6 но и высоту. Для этого нужно 
указать второй аргумент. Если задать ключ -w, меняется только ширина окна; если задать ключ -d, меняется только размер 
видимой области (display size). .RE
 
 
 windowlist  [-b] [-m]

 
 windowlist   string  [ string ]

 
 windowlist   title  [ title ]

 
 
 
  Показывает список всех окон в виде таблицы для того чтобы можно было выбрать окно визуально. Окно выбирается стандартными 
клавишами управления курсором (см. команды  copy ) и активируется клавишей  return . Если задана опция .RS
 -b
 

 

, screen перед тем как показать список переключится на пустое окно, поэтому текущее окно можно тоже будет выбрать. Опция 
 
 -m
 

 

  задаёт порядок окон: вместо того чтобы сортировать их в порядке возрастания номеров, они сортируются по принципу, кто 
использовался последним. .RE
 
  Формат таблицы можно изменить опциями  string  и  title ; в качестве заголовка таблицы показывается  title , 
а строки создаются на основе строк  string . По умолчанию: заголовок "Num Name%=Flags" и строки "%3n %t%=%f". См. 
раздел "Escape-последовательности", где описано большее число кодов (в том числе цветовых). .RE
 
 
 windows 

 
 
 
  Выводит в строке сообщений список всех окон. Каждое окно выводится с номером и именем процесса, который запущен в этом окне 
(или заголовком); текущее окно отмечено символом "*", а предыдущее --- символом "-"; все окна, которые зарегистрированы 
(logged in) отмечены символом " .RS
 $
 

 

"; фоновые окна, в которых был звонок (bell), отмечены символом "
 
 !
 

 

"; фоновые окна, за которыми выполняется наблюдение, и в которых была замечена активность, отмечаются символом " .RS
 @
 

 
 

"; окна, в которых включена запись (logging),  отмечены символом "
 
 (L)
 

 

"; окна, занятые другим пользователем, отмечены символом "
 
 &
 

 

"; окна, находящиеся в состоянии зомби, отмечены символом "
 
 Z
 

 

". Если список окон слишком большой и не влазит полностью на терминал, выводится только его часть.
 
 

 
 wrap  [ on | off ]

 
 

  Задаёт настройки переноса (line-wrap) для текущего окна. Если line-wrap включен, символ, следующий за последним выведенным 
в строке, будет выводиться на следующей строке. Backspace (^H) при этом будет переходить на предыдущую строку через левый 
край. По умолчанию:  on  
 writebuf  [-e  encoding ] [ filename ]

 
 

  Выводит содержимое буфера обмена в указанный файл или в общедоступный файл screen-exchnage, если никакой файл не указан. 
Эту команду можно использовать для организации примитивного обмена данными между пользователями screen, работающими 
на одном компьютере. Если указана кодировка, текст налету перекодируется. Имя файла для обмена задаётся с помощью команды 
 bufferfile ; по умолчанию равно .RS
 /tmp/screen-exchange
 

 
 

 
 
 writelock  [ on | off | auto ]

 
 

  В дополнение к спискам контроля доступа есть еще ограничение, которое запрещает писать нескольким пользователем в одно 
окно одновременно. По умолчанию, writelock находится в режиме  auto  и эксклюзивный доступ на запись предоставляется 
тому пользователю, который первым переключился в это окно. Когда этот пользователь покидает окно, другие пользователи 
могут захватить блокировку (автоматически). Блокировка записи в текущее окно может быть отключена при помощи команды 
 writelock off . Если пользователь даст команду  writelock on , он сохранит за собой экслюзивную блокировку 
даже на время переключения в другие окна. 
 xoff 

 
 xon 

 
 

       Вставляет символ CTRL-s / CTRL-q в поток stdin текущего окна.
 
 zmodem  [ off | auto | catch | pass ]

 
 zmodem   sendcmd  [ string ]

 
 zmodem   recvcmd  [ string ]

 
 
 
  Настройка поддержки zmodem. Когда программа screen видит запрос zmodem, она понимает два режима работы:  pass  и 
 catch . Если задан режим  pass , screen будет ретранслировать все данные, до тех пор пока передача не окончится. 
В режиме  cactch  screen сам работает как конечная точка zmodem и выполняет соответствующие команды rz/sz. Если включен 
режим  auto , screen смотрит является ли окно терминалом tty (например, последовательным портом) и переходит в режим 
 cacth , иначе использует  pass . Можно задавать шаблоны для режима  catch  при помощи второй и третьей 
формы вызова. 
 

   Это экспериментальная возможность! 
 

 
 zombie  [ keys ]

 
 defzombie  [ keys ]

 
 

  По умолчанию окна screen удаляются из списка, как только процессы окон (т.е. оболочки) завершаются. Если вызвать команду 
 zombie  с аргументом из двух ключей, мёртвые окна будут оставаться. Убить такое окно можно с помощью команды kill. 
  Нажатие первой кнопки в мёртвом окне делает то же самое.  Если нажать вторую кнопку, screen пытается оживить окно. Процесс, 
который изначально работал в окне, запускается снова.  Если вызвать  zombie  без параметров, настройки собьются, 
то есть окна будут исчезать, как только процессы в них завершаются. .br
  Посколько настройки для зомби задаются одновременно на все окна, эту команду правильнее было бы назвать  defzombie . 
Пока не возникнет необходимость в команде действующей на отдельное окно, команды  zombie  и  defzombie  синонимы. 
 
 
 
 
   
  Строка сообщений  

 

 
Screen выводит информационные и другие диагностические сообщения в строку сообщений (message line).
По умолчанию она показывается в самом низу окна, но при компиляции можно задать, 
чтобы эта строка показывалась вверху. Если у терминала есть статусная строка (status line),
будет использоваться она. Иначе, вывод на текущий экран будет временно переписан сверху.
Сообщение удаляется после нескольких секунд задержки, но оно может быть удалено и раньше, 
если начать печатать.
 
Строку сообщение можно использовать в приложениях с помощью управляющей последовательности
ANSI Privacy message. Например, можно в командном интерпретаторе дать команду:
 
 
     echo '<esc>^Hello world from window '$WINDOW'<esc>\\'

 

 

Здесь <esc>  это escape, 
 
 ^ 
 

 

  это стрелка вверх, а 
 
 \\
 

 

  превращается в обратный слэш.
 
   
  Типы окон  

 

 
У screen есть три различных типа окон.
Новые окна создаются при помощи команды  screen  (см. соответствующую запись в разделе Индивидуальная настройка). 
Первый аргумент команды screen задаёт тип создаваемого окна. Различные типы окон  это модификации
нормального типа.  Они были сделаны для эффективной работы при количестве окон от 100 и выше.
 
 

   *   Нормальное окно, в котором запущен командный интерпретатор (по умолчанию) или любая другая команда, которая должна 
исполняться изнутри интерпретатора. 
 

   *   Если в качестве первого параметра указан специальный файл устройства (например, "/dev/ttya"), screen напрямую пытается 
к нему подключиться.  Окно этого типа равносильно окну, в котором запущено "screen cu -l /dev/ttya".  Нужны права на чтение 
и запись для соответствующего файла устройства; для того чтобы показать что линия занята, screen пытается открыть файл 
эксклюзивно.  Опциональный параметр может принимать значение разделённого запятыми списка флагов в нотации  stty : 
 
 
 <baud_rate> 

 
 

                  Обычно 300,  1200, 9600 или 19200. Влияет как на скорость передачи, так и на скорость приёма. 
 cs8 или cs7 

 
 

                  Задаёт передачу восьми или семи битов на байт.
 
 ixon или -ixon 

 
 

                  Включает (или выключает) программное управление потоком (CTRL-S/CTRL-Q) при передаче данных. 
 ixoff или -ixon 

 
 

                  Включает (или выключает) программное управление потоком при приёме данных.
 
 istrip или -istrip 

 
 

                  Удаляет (или сохраняет) восьмой бит в каждом полученном байте.
 
 
  Можно указывать столько этих опций сколько нужно.  Если опции не задавать, решение о значении параметров соединения принимает 
драйвер терминала.  Эти значения зависят от системы. Они могут или принимать значения по умолчанию или значения, сохранённые 
с прошлого соединения. .RE
 
  Для tty-окон команда  info  показывает в строке статуса состояние управляющих линий модема.  В их числе могут быть 
"RTS", "CTS",  "DTR", "DSR",  "CD"  и другие.  Список линий зависит от того какие ioctl() доступны, от системных заголовчных 
файлов, а также от физических возможностей платы последовательных портов.  Перед названием неактивных (low level) сигналов 
ставится восклицательный знак (!).  Если знака нет, значит сигнал активен (high level).  Сигналы, которые не поддерживаются 
оборудованием, но доступны через ioctl(), обычно показываются выключенными (low level).  Если локальный бит состояния 
CLOCAL включен, весь набор сигналов модема выводится в фигурных скобках ({ и }).  Если установлен бит CRTSCTS или TIOCSOFTCAR, 
в скобках показываются сигналы "CTS" или "CD",  соответственно. .RE
 
  Для tty-окон команда  break  переводит линию передачи данных (Data transmission line) (TxD) в неактивное состояние 
на заданный период времени. На той стороне это должно проинтерпретироваться как сигнал разрыва.  При нажатии break данные 
не отправляются, линии управления модемом не трогаются. .RE
 

   *   Если первый параметр это "//telnet",  второй параметр должен быть именем хоста, опциональный третий параметр  номером 
порта (по умолчанию 23, десятиричное).  Screen подсоединится к удалённому серверу при помощи протокола Telnet.  Для telnet-окон 
команда  info  показывает в конце статусной строки в квадратных скобках ([ и ]) детальную информацию о соединении. 
 
 
     b      BINARY. Соединение в двоичном (бинарном) режиме.
    e      ECHO. Локальное эхо выключено.
    c      SGA.  Соединение в символьном режиме (character mode). По умолчанию в режиме строки (line mode).     t      TTYPE. Тип терминала был запрошен удалённым хостом.
        Screen отправляет имя "screen", если не задано ничего другого
        (см. также команду  term ).
    w      NAWS. Удалённая система предупреждается об изменении размера окна.
    f      LFLOW.  Удалённый хост отправит информацию об управлении потоком.
        (Сейчас игнорируется.)

 

 

Дополнительные флаги для отладки: 
 
 x
 

 

, 
 
 t
 

 

  и 
 
 n
 

 

  (XDISPLOC, TSPEED  и NEWENV).
 
Для окон telnet команда  break  отправляет удалённому хосту Telnet-код IAC BREAK (десятичный 243). 
Этот тип окна доступен только в том случае, если screen был откомпилирован с опцией BUILTIN_TELNET.
 
 
 
 
 
   
  Escape-последовательности  

 

 
У screen есть механизм escape-последовательностей,  с  помощью которых
в сообщения или имена  файлов  можно  вставлять  различную  информацию,
например, такую  как текущее время.  Escape-символ это всегда символ %,
за одним исключением: внутри строки hardstatus используется ^% (^E).
 
Полный список поддерживаемых escape-последовательностей:
 
 
        %      сам escape-символ
       a      или "am", или "pm" 
       A      или "AM", или "PM"
       c      текущее время HH:MM в 24-часовом формате
       C      текущее время HH:MM в 12-часовом формате
       d      номер дня
       D      название дня недели
       f      флаги окна
       F      устанавливает %? равным true (истина), если окно получает фокус
       h      статус окна (hardstatus)
       H      имя системы (hostname)
       l      текущий уровень нагрузки на систему
       m      номер месяца
       M      имя месяца
       n      номер окна
       s      секунды
       t      заголовок окна
       u      остальные пользователи на этом окне
       w      номера и имена всех окон. С символом "-" до текущего окна; с символом "+"
              после текущего окна
       W      номера и имена всех окон за исключением текущего 
       y      последние две цифры года
       Y      полный год
       ?      показывается часть до следующего знака %? (только если % внутри этой части 
              раскрывается в не пустую строку)
       :      часть else %?

       =      заполнить строку на ширину экрана (как hfill в TeX). Если задан номер, 
              number is specified, pad  to  the  percentage  of  the  windows
              width.   Квалификатор  "0"  говорит о том, что номер надо воспринимать как 
              абсолютную позицию.
              You can specify to pad relative to the  last
              absolute  pad position by adding a "+" qualifier or to pad rela
              tive to the right margin by using "-". The padding truncates the
              string  if  the specified position lies before the current posi
              tion. Для того чтобы изменить это, нужно использовать квалификатор "L".

       <      то же что и "%=", но только обрезать, и не заполнять пробелами

       >      поставить отметку в текущей позиции для следующей обрезки.
              Когда screen должен сделать обрезку, он старается сделать её так,
              что бы маркированная позиция переместилась на заданный процент 
              области вывода.
              (Область начинается с последней абсолютной позиции заполнителя
              и заканчивается в месте, заданном оператором обрезки).
              Дополнительный символ "L" говорит screen о том, что нужно отметить
              обрезанный кусочек символами "...".

       {      строка-модификатор атрибута/цвета, заканчивающаяся следующим "}"

       `      Заменить команды внутри кавычек результатом их выполнения. The  length
              qualifier is misused to identify one of the commands.

 

 

С последовательностями "c"  и "C" можно использовать квалификатор "0"  тогда для заполнения пустого пространства будет использоваться "0", а не пробел. Если использовать квалификатор "0", в escape-последовательности 
"=" позиции начинают восприниматься как абсолютные.
Escape-коды "n" и "=" понимают квалификатор длины
(например, "%3n"); перед "D" и "M" можно ставить "L" для того чтобы генерировать длинные имена "L", а если поставить "L" 
перед "w" или "W", будут показываться флаги окон.
 
Модификатор атрибута/цвета используется для изменения настроек атрибута
или цвета. Его формат "[модификатор атрибута] [описание цвета]".   Если 
модификатор атрибута можно перепутать с описанием цвета, перед ним надо
ставить специальный индикатор изменения типа.   Это  один  из следующих
символов:
 
 
     +      добавляет указанное множество к текущим атрибутам 
    -      удаляет указанное множество из текущих атрибутов
    !      инвертирует множество текущих атрибутов
    =      заменяет множество текущих атрибутов на указанное множество

 

 

Множество атрибутов может быть задано или в виде шестнадцатеричного числа 
или в виде комбинации следующих букв:
 
 
     d      тусклый
    u      подчёркнутый
    b      полужирный
    r      реверсивный
    s      выдающийся
    B      мигающий

 

 

Цвета или кодируются шестнадцатеричным числом или комбинацией двух букв,
указывающих цвет фона и цвет символа (в таком порядке). Известны  такие
цвета:
 
 
     k      чёрный
    r      красный
    g      зелёный
    y      жёлтый
    b      синий
    m      фиолетовый
    c      цвета морской волны
    w      белый 
    d      по умолчанию
    .      оставить цвет без изменения

 

 

Буквы в верхнем регистре обозначают яркие цвета. Можно использовать букву
псевдо-цвет "i", которая меняет яркость, но оставляет сам цвет таким же.
A  one digit/letter color description is treated as foreground or back
ground color dependant on the current attributes: если установлен реверсивный режим, 
меняется фон, а не цвет символа.
Если поставить перед цветом ".", так происходить не будет. 
Если нужно такое же поведение, как при двусимвольном описании цвета,
нужно тоже ставить ".".
Особый случай, "%{ - }" восстанавливает атрибуты и цвет, которые были 
установлены до того как были сделаны последние изменения (грубо говоря, 
выталкивает один уровень изменений цвета из стека).
 
Примеры:
 
 
     "G"    установить ярко-зелёный цвет

    "+b r" использовать красный полужирный

    "= yd" стереть все атрибуты, писать цветом по умолчанию на жёлтом фоне

    %-Lw%{= BW}%50>%n%f* %t%{ - }%+Lw%<
            Список окон обрезанный до доступной величины (слева и справа). Имя
            текущего окна выводится белым на синем фоне. Можно использовать
            вместе с "hardstatus alwayslastline".

    %?%F%{.R.}%?%3n %t%? [%h]%?
            Номер окна, заголовок и hardstatus, если он установлен. Красный 
            фон, если есть фокус. Удобно для строки заголовка.

 

 

 
   
  Управление потоком  

 

 

 
У каждого окна есть настройки управления потоком (flow-control), которые определяют,
как screen будет работать с XON и XOFF символами (и, возможно, символом разрыва).
Когда управление потоком включено, screen игнорирует XON и XOFF символы, 
и пользователю для того чтобы отправить их в программу, нужно просто нажать их
(это полезно, например, для редактора Emacs).
Минус в том, что обычной программе нужно больше времени для того чтобы 
остановиться, когда она увидит XOFF. Если управление потоком включено,
XON и XOFF немедленно останавливают вывод в текущее окно.
Эти символы по-прежнему можно отправить программе, но для этого нужно 
использовать соответствующие двухсимвольные команды screen ("C-a q" (xon) и "C-a s" (xoff)).
Команды xon/xoff также полезны для передачи симолов C-s и C-q в обход терминала,
который перехватывает эти символы.
 
У каждого окна есть начальная настройка управления потоком, которая задаётся
или опцией 
 
 -f
 

 

  или командой  defflow  из файла 
 
 

 

 
По умолчанию окна настроены на автоматическое переключение потока.
Потом состояние можно интерактивно переключать с помощью комбинации
клави "C-a f" или команды "flow" между вариантами
"fixed on", "fixed off" и "automatic".
 
Режим автоматического переключения потока (automatic flow-switching mode)
работает с управлением потоком через режим TIOCPKT  (как "rlogin"). Если драйвер терминала не поддерживает TIOCPKT, screen пытается найти правильный режим исходя из текущих настроек
клавиш приложения (application keypad)  когда он включен, управление потоком выключено
и наоборот. Конечно, если нужно можно манипулировать управлением потоком вручную,
то такая возможность есть.
 
Если screen работает с включённым аппаратным управлением потоком,
и нажатие клавиши прерывания (обычно C-c) срабатывает не сразу, а 
после того как прокрутятся ещё 6-8 строк, нужно попробовать запустить
screen с опцией "interrupt" (нужно добавить флаг "interrupt" к команде "flow" в файле 
 
 

 

 
или использовать опцию 
 
 -i
 

 

).
В этом случае вывод, который screen накопил от интерактивных программ,
очищается.
Минус заключается в том, что память виртуального терминала 
хранит не выведенный вывод, что иногда может приводить к неточностям
при отображении.  Например, если переключить экран, а потом вернуться,
или обновить экран при помощи "C-a l",
на экране будет вывод такой же, как если бы "interrupt" был выключен.
Если выполнять программу, которой нужно передать символ прерывания как ввод
(например, прервать вывод виртуального терминала на физический),
нужно выключать управление потоком (или использовать режим auto-flow для того чтобы выключать его автоматически) В этой ситуации простое обновление экрана screen с помощью "C-a l" вернёт всё в исходное состояние. Можно попробовать все режимы, и использовать тот, который удобнее.
 
   
  Названия (именование окон)  

 

 
Имена окон (которые выводятся, например, по команде  windows , "C-a w")
можно настраивать одной из команд  title .
Обычно имя окна это имя команды, запущенной в этом окне.
Но иногда хочется что бы окна с одной командой как-то отличались,
или что бы имя менялось на ходу и отражало текущее состояние окна.
 
Имя по умолчанию для всех окон с оболчками (shell windows) можно задать командой  shelltitle 
из файла 
 
 

 

  Имена окон, которые создаются по команде screen, 
можно задать при помощи ключа 
 
 -t
 

 

  в этой команде.
Для интерактивной смены есть escape-последовательность
(<esc>kname<esc>\)  и команда  title  (C-a A).
В первом случае строку может выводить приложение, работающее в окне, автоматически,
а во втором  имя вводится интерактивно в соответствующее приглашение.
И ещё можно создавать привязки установку предопределённых имён
на комбинации клавиш и не вводить их каждый раз.
 
Кроме всего прочего, у screen есть специальный механизм,
который включается путём установки имени окна равным "search|name".
Для этого нужно чтобы в приглашение выводилась специальная невидимая
escape-последовательность.
Часть "search" задаёт строку которая будет считаться концом приглашения,
а часть "name" определяет имя по умолчанию для этого окна.
Если имя оканчивается на ":", screen дописывает имя текущей команды (с его точки зрения), работающей в окне, к названию оболочки окна (например, "name:cmd"). Иначе имя команды, пока она выполняется, перекрывает имя оболочки. 
 
Вот как это работает:  нужно изменить приглашение командного интерпретатора
так, чтобы невидимая строка title-escape-sequence (<esc>k<esc>\) выводилась как его часть.
Последняя часть приглашения должна быть в точности равна 
строке, которая была задана как строка для поиска заголовка окна.
При такой настройке screen при помощи title-escape-sequence будет очищать название предыдущей
команды и ждать следующей.
Потом, когда он увидит что от оболочки получен перевод строки, он ищет окончание приглашения.
Если находит, первое слово после него считает именем команды.
Если команда начинается с "!", "%" или "^", screen возьмёт имя не из этой строки, а из следующей за ней. Это нужно для тех, кто пользуется механизмами управления работами (job control) и истории.
 
Вот несколько примеров команд из .screenrc:
 
 
     screen -t top 2 nice top

 

 

Если добавить эту строку в файл .screenrc, то на окне 2 будет запускаться 
top с пониженным приоритетом (через nice).  Окно будет называться "top",
а не "nice".
 
 
     shelltitle '> |csh'
    screen 1

 

 

В результате  выполнения  команды  будет  запущена  оболочка  с  заданным
заголовком shelltitle. 
Заголовок автоматический, который предполагает что 
приглашение  и  команда выглядят следующим образом:
 
 
     /usr/joe/src/dir> trn

 

 

(имя команды ищется после 
 
 >
 

 

).
В строке статуса окна будет "trn" пока команда выполнятся 
и "csh", после того как она завершится.
 
 
     bind R screen -t '% |root:' su

 

 

Если добавить такую команду в файл .screenrc, комбинация клавиш 'C-a R'
будет привязана к команде "su" (с заголовком "root:"). Если это автоматическое именование работает, будет происходить 
так: 
 
     % !em
    emacs file.c

 

 

Здесь пользователь ввёл команду истории "!em", которая вызвала введённую ранее
команду  emacs .  Статусная строка окна во время исполнения команды 
будет показывать "root:emacs", а после того как она завершится, 
превратится в просто "root:".
 
 
     bind o title
    bind E title ""
    bind u title (unknown)

 

 

У  первой  привязки  нет  аргументов, поэтому при нажатии "C-a o" нужно
будет ввести заголовок. При нажатии второй комбинации "C-a E" очищаются настройки 
текущие автоматического заголовка (auto-title).
Третья привязка: по нажатию C-a u 
устанавливать заголовок текущего окна равным "(unknown)".
 
При добавлении невидимой строки в приглашение нужно помнить, что некоторые интерпретаторы 
(такие как csh) учитывают все неуправляющие символы 
при вычислении длины приглашения.
Если число этих невидимых символов не кратно 8, то при удалении табуляции с помощью backspace
появится ошибки при отображении.
Один способ обойти эту проблему  использовать
приглашение наподобие такого:
 
 
     set prompt='^[[0000m^[k^[\% '

 

 

Escape-последовательность "<esc>[0000m" не только нормализует атрибуты символов,
но и округляет нулями число невидимых символов до кратного 8.
Пользователи  bash  могут задавать escape-последовательности в
переменной 
 
 PROMPT_COMMAND
 

 

:
 
 
     PROMPT_COMMAND='echo -n -e "\033k\033\134"'

 

 

(Здесь используется строка "134" для вывода символа \ из за ошибки в версии 1.04).
 
   
  Виртуальный терминал  

 

 
Каждое окно в сеансе screen эмулирует терминал VT100 с некоторыми дополнительными функциями.
Может эмулироваться только VT100, это жёстко зашитое ограничение screen.
Как правило, screen старается выполнять эмуляцию как можно ближе к VT100/ANSI.
Но если у терминала, на котором выполняется screen, не хватает некоторых возможностей,
эмуляция будет частичной. 
В этом случае screen должен сообщить приложению, что некоторых возможностей
не будет. Это несложно на машинах, использующих termcap, 
потому что screen может использовать переменную 
 
 $TERMCAP
 

 

 
для подстройки своего стандартного termcap.
 
Но при удалённом заходе на машину, которая поддерживает только terminfo, 
этот метод работать не будет. У screen есть способ, который он использует
в этой ситуации.
 
Когда screen хочет определить имя терминала для себя,
сначала он пытается найти запись "screen.<term>", где <term> это содержимое переменной
$TERM.  Если такой записи нет, screen пробует найти "screen"
(или  "screen-w" для широких терминалов (132 колонки или больше)).  Если и эту запись найти не удаётся, используется "vt100" как заменитель.
 
Если терминал не поддерживает важную функцию (например, удаление символа или очистку до конца строки), можно сделать новую запись termcap/terminfo для screen (и назвать её "screen.<dumbterm>"),
в которой эта возможность будет отключена. 
 
Когда такая запись есть на машине, при удалённом заходе на неё termcap/termifo-запись будет правильной. Имя терминала указывается в переменной  $TERM новых окон.
Кроме этого, screen устанавливает переменную 
 
 $TERMCAP
 

 

, так что бы она отражала возможности
эмулируемого терминала. Следует заметить, что на машинах, где используется
база данных terminfo, эта переменная ничего не значит.
И ещё в переменной $WINDOW устанавливается номер окна.
 
Действительное множество возможностей, поддерживаемых виртуальным терминалом, 
зависит от того какие возможности поддерживаются физическим терминалом.
Если, физический терминал не поддерживает, скажем, режим подчёркивания,
screen не указывает возможности  us  и  ue  в переменной 
 
 $TERMCAP
 

 

 
для окон. Тем не менее, для того чтобы screen работал, минимум возможностей
терминалом должен поддерживаться всё равно; в частности, прокрутка, очистка,
прямая адресация курсора (кроме того, screen не будет работать на hardcopy-терминалах
и на overstrike-терминалах).
 
Значение переменной 
 
 $TERMCAP
 

 

  можно изменить с помощью 
команды .screenrc  "termcap" или, если задать переменную 
 
 $SCREENCAP
 

 

  
до запуска screen.
В последнем случае её значение копируется в неизменном виде в переменную TERMCAP для каждого окна.
В ней может быть или полное определение терминала или имя файла, где 
определён терминал "screen" и/или "screen-w".
 
Если в системе используется база данных terminfo, а не termcap,
имейте в виду, что у screen есть команда  terminfo .
 
Если в записи termcap терминала, на котором был вызван screen, присутствует 
булевая возможность "G0", терминал поддерживает несколько наборов символов (charsets).
Это даёт возможность приложению использовать,
например, или псевдографическое множество символов, или множество символов национального алфавита
в терминале VT100.  Поддерживаются следующие управляющие функции из ISO 2022: 
lock  shift  G0  (SI), lock shift G1 (SO), lock shift G2, lock
shift G3, single shift G2, и single shift G3.  При создании или сбросе виртуального терминала
таблица символов ASCII назначается на G0, G1, G2 и G3.
Если есть возможность "G0" возможность, screen вычисляет возможности
"S0", "E0", и "C0", если есть. "S0" это последовательность, которую
терминал использует для того, чтобы включить псевдографический набор символов вместо SI.
"E0"  соответствующая замена для SO. "C0" даёт строку посимвольного соответствия.
Эта строка используется в псевдографическом режиме.
Строка строится так же как и возможность "acsc" terminfo.
 
Если в termcap-записи терминала присутствуют возможности "po" и "pf",
приложения, работающие в screen, могут отправлять вывод на печать
через порт печати терминала.
Приложение в одном окне отправляет данные на принтер, подсоединённый к терминалу,
а другие окна при этом продолжают работать
(порт принтера активируется и деактивируется заново для каждой порции выводимых данных).
Побочный эффект: программы, работающие в разных окнах одновременно, могут отправлять данные на печать одновременно. 
Данные, которые отправляются на печать, не показываются в окне.
Пока печать активна, команда  info  будет показывать строку, начинающуюся символами 
 
 PRIN
 

 

 
Каждому экрану screen предоставляет статусную строку hardstatus.  Когда какое-то окно становится
активным, hardstatus дисплея обновляется, и он отражает hardstatus соответствующего окна.
Если у дисплея нет строки hardstatus, строка показывается как обычное сообщение screen.
Строку hardstatus можно поменять с помощью  ANSI   Application   Program   Command   (APC):
"ESC_<string>ESC\". Для удобства пользователей xterm принимается строка "ESC]0..2;<string>^G".
 
Некоторые возможности только тогда указываются в переменной $TERMCAP для виртуального терминала,
если они могут быть эффективно реализованы с помощью физического терминала.
Например, "dl" (delete line) указывается в переменной $TERMCAP только при условии, если терминал 
поддерживает или удаление строки, или прокрутку регионов.
При переподключении с другого терминала может возникнуть путаница,
потому что значение 
 
 $TERMCAP
 

 

  родительские процессы у дочерних
уже изменить не смогут.
 
Альтернативный экран (alternate  screen) не включен по умолчанию. Для того чтобы его включить, 
нужно вызвать команду  altscreen .
 
Ниже приводится список управляющих последовательностей,
которые распознаёт screen.
"(V)" и "(A)" обозначают функции специфичные для VT100- и для ANSI- или ISO- соответственно.
 
 
        ESC E                      Следующая строка
       ESC D                      Индекс
       ESC M                      Обратный индекс
       ESC H                      Horizontal Tab Set
       ESC Z                      Send VT100 Identification String
       ESC 7                 (V)  Save Cursor и Attributes
       ESC 8                 (V)  Восстановить курсор и атрибуты
       ESC [s                (A)  Save Cursor и Attributes
       ESC [u                (A)  Restore Cursor и Attributes
       ESC c                      Сбросить в начальное состояние
       ESC g                      Визуальный звонок
       ESC Pn p                   Видимость курсора (97801)
           Pn = 6                 Невидимый
                7                 Видимый
       ESC =                 (V)  Режим клавиатуры приложения
       ESC >                 (V)  Режим цифровой клавиатуры
       ESC # 8               (V)  Заполнить экран E
       ESC \                 (A)  Завершение строки (string terminator)
       ESC ^                 (A)  Privacy Message String
       ESC !                      Global Message String
       ESC k                      A.k.a. Definition String
       ESC P                 (A)  Device Control  String.   Выводит строку прямо на терминал,
                                  без обработки.
       ESC _                 (A)  Команда приложения (Hardstatus)
       ESC ] 0 ; string ^G   (A)  Команда операционной систем (Hardstatus, xterm title hack)
       ESC ] 83 ; cmd ^G     (A)  Выполнить команду screen. Работает только если в screen вкомпилирована                                   многопользовательская поддержка.
                                  При проверке acl используется псевдопользователь ":window:".
                                  Команда "addacl  :window:  -rwx  #?"  создаёт пользователя без прав,                                   разрешает ему только нужные команды.
       Control-N             (A)  Lock Shift G1 (SO)
       Control-O             (A)  Lock Shift G0 (SI)
       ESC n                 (A)  Lock Shift G2
       ESC o                 (A)  Lock Shift G3
       ESC N                 (A)  Single Shift G2
       ESC O                 (A)  Single Shift G3
       ESC ( Pcs             (A)  Designate character set as G0
       ESC ) Pcs             (A)  Designate character set as G1
       ESC * Pcs             (A)  Designate character set as G2
       ESC + Pcs             (A)  Designate character set as G3
       ESC [ Pn ; Pn H            Прямая адресация курсора
       ESC [ Pn ; Pn f            то же
       ESC [ Pn J                 Удалить на экране
             Pn = None or 0       От курсора до конца экрана
                  1               От начала экрана до курсора
                  2               Весь экран
       ESC [ Pn K                 Удалить в строке
             Pn = None or 0       От курсора до конца строки
                  1               От начала строки до курсора
                  2               Всю строку
       ESC [ Pn X                 Удалить символ
       ESC [ Pn A                 Курсор вверх
       ESC [ Pn B                 Курсор вниз
       ESC [ Pn C                 Курсор вправо
       ESC [ Pn D                 Курсор влево
       ESC [ Pn E                 Курсор на следующую строку (cursor next line)
       ESC [ Pn F                 Курсор на предыдущую строку (cursor previous line)
       ESC [ Pn G                 Горизонтальная позиция курсора
       ESC [ Pn '                 то же
       ESC [ Pn d                 Вертикальная позиция курсора
       ESC [ Ps ;...; Ps m        Выбрать графическое начертание
             Ps = None or 0       Стандартное начертание
                  1               Полужирный
                  2          (A)  Бледный (faint)
                  3          (A)  Выделяющийся (ANSI: курсив)
                  4               Подчеркнутый
                  5               Мигающий
                  7               Инвертированный
                  22         (A)  Нормальная интенсивность
                  23         (A)  Выделение выключено (ANSI: курсив выключен)
                  24         (A)  Без подчёркивания
                  25         (A)  Не мигать
                  27         (A)  Позитивное изображение
                  30         (A)  Цвет символов чёрный
                  31         (A)  Цвет символов красный
                  32         (A)  Цвет символов зелёный
                  33         (A)  Цвет символов жёлтый
                  34         (A)  Цвет символов синий
                  35         (A)  Цвет символов фиолетовый
                  36         (A)  Цвет символов морской волны
                  37         (A)  Цвет символов белый
                  39         (A)  Цвет символов по умолчанию
                  40         (A)  Цвет фона чёрный
                  ...
                  49         (A)  Цвет фона по умолчанию
       ESC [ Pn g                 Удалить табуляцию
             Pn = None or 0       Удалить табуляцию на текущей позиции
                  3               Стереть все табуляции
       ESC [ Pn ; Pn r       (V)  Задать регион прокрутки
       ESC [ Pn I            (A)  Горизонтальная табуляция
       ESC [ Pn Z            (A)  Обратная табуляция
       ESC [ Pn L            (A)  Вставить строку
       ESC [ Pn M            (A)  Удалить строку
       ESC [ Pn @            (A)  Вставить символ
       ESC [ Pn P            (A)  Удалить символ
       ESC [ Pn S                 Прокрутить область прокрутки вверх
       ESC [ Pn T                 Прокрутить область прокрутки вниз
       ESC [ Pn ^                 то же
       ESC [ Ps ;...; Ps h        Режим Set
       ESC [ Ps ;...; Ps l        Режим Reset
             Ps = 4          (A)  Режим вставки (Insert)
                  20         (A)  Режим автоматической прокрутки (Automatic Linefeed)
                  34              Нормальная видимость курсора
                  ?1         (V)  Клавиши управления курсором приложения
                  ?3         (V)  Изменить ширину терминала на 132 колонки
                  ?5         (V)  Реверсивное видео
                  ?6         (V)  Origin-режим
                  ?7         (V)  Wrap-режим
                  ?9              Отслеживание мыши X10
                  ?25        (V)  Видимый курсор

                  ?47             Alternate Screen (old xterm code)
                  ?1000      (V)  Отслеживание мыши VT200
                  ?1047           Альтернативный экран (новый xterm-код)
                  ?1049           Альтернативный экран (новый xterm-код)

       ESC [ 5 i             (A)  Начать ретрансляцию на принтер (ANSI Media Copy)
       ESC [ 4 i             (A)  Остановить ретрансляцию на принтер (ANSI Media Copy)
       ESC [ 8 ; Ph ; Pw t        Изменить размер для Resize the window to  "Ph"  lines  и  "Pw"
                                  колонок (для SunView)
       ESC [ c                    Отправить идентификационную строку VT100
       ESC [ x                    Отправить отчёт с параметрами терминала
       ESC [ > c                  Отправить строку атрибутов вторчного устройства VT220 
                                  (VT220   Secondary  Device  Attributes)
       ESC [ 6 n                  Отправить отчёт о позиции курсора

 

 

 
   
  Трансляция при вводе  

 

 
Для того чтобы полностью эмулировать VT100 
screen должен определять, нажатием какой клавиши
была сгенерирована последовательность во входном потоке,
и превращать её в последовательность подходящую VT100.
 
Screen очень гибок в этом вопросе  он позволяет привызывать произвольные команды
к произвольным последовательностям символов.
В случае простой эмуляции VT100 команда будет вставлять 
строку в буфер ввода окна (см. команду  stuff ).
Последовательности, которые генерируются по нажатию клавиши,
могут измениться при подключении из терминала с другим типом.
Чтобы обойти эту проблему, можно привязывать команды к termcap-именам клавиш.
Screen будет делать правильные привязки после каждого повторного подключения.
Более подробная информация и примеры использования есть в описании команды  bindkey .
 
Ниже представлена таблица привязок по умолчанию (default key bindings). (A) обозначает,
что команда выполняется, если клавиатура переключена в режим приложения.
 
 
        Клавиша           Имя termcap     Команда
       ______________________________________________________
       Курсор вверх          ku          stuff \033[A
                                         stuff \033OA    (A)
       Курсор вниз           kd          stuff \033[B
                                         stuff \033OB    (A)
       Курсор вниз           kr          stuff \033[C
                                         stuff \033OC    (A)
       Курсор влево          kl          stuff \033[D
                                         stuff \033OD    (A)
       F0                    k0          stuff \033[10~
       F1                    k1          stuff \033OP
       F2                    k2          stuff \033OQ
       F3                    k3          stuff \033OR
       F4                    k4          stuff \033OS
       F5                    k5          stuff \033[15~
       F6                    k6          stuff \033[17~
       F7                    k7          stuff \033[18~
       F8                    k8          stuff \033[19~
       F9                    k9          stuff \033[20~
       F10                   k;          stuff \033[21~
       F11                   F1          stuff \033[23~
       F12                   F2          stuff \033[24~
       Home                  kh          stuff \033[1~
       End                   kH          stuff \033[4~
       Insert                kI          stuff \033[2~
       Delete                kD          stuff \033[3~
       Page up               kP          stuff \033[5~
       Page down             kN          stuff \033[6~
       Серый  0              f0          stuff 0
                                         stuff \033Op    (A)
       Серый  1              f1          stuff 1
                                         stuff \033Oq    (A)
       Серый  2              f2          stuff 2
                                         stuff \033Or    (A)
       Серый  3              f3          stuff 3
                                         stuff \033Os    (A)
       Серый  4              f4          stuff 4
                                         stuff \033Ot    (A)
       Серый  5              f5          stuff 5
                                         stuff \033Ou    (A)
       Серый  6              f6          stuff 6
                                         stuff \033Ov    (A)
       Серый  7              f7          stuff 7
                                         stuff \033Ow    (A)
       Серый  8              f8          stuff 8
                                         stuff \033Ox    (A)
       Серый  9              f9          stuff 9
                                         stuff \033Oy    (A)
       Серый  +              f+          stuff +
                                         stuff \033Ok    (A)
       Серый  -              f-          stuff -
                                         stuff \033Om    (A)
       Серый  *              f*          stuff *
                                         stuff \033Oj    (A)
       Серый  /              f/          stuff /
                                         stuff \033Oo    (A)
       Серый  =              fq          stuff =
                                         stuff \033OX    (A)
       Серый  .              f.          stuff .
                                         stuff \033On    (A)
       Серый  ,              f,          stuff ,
                                         stuff \033Ol    (A)
       Серый  enter          fe          stuff \015
                                         stuff \033OM    (A)

 

 

 
   
  Специальные возможности терминала  

 

 
Приведённая ниже таблица описывает все возможности терминала, которые распознаются screen, и отсутствуют в руководстве  termcap (5) . Можно поместить эти возможности в записи termcap (в файле 
 
 /etc/termcap
 

 

) или 
использовать их с командами  termcap ,  terminfo  и  termcapinfo  в файле
screenrc. Добавить возможности внутрь базы terminfo чаще всего нельзя.
 
 
 
    LP   (bool)  У терминала есть отступы в стиле  VT100 ("волшебные отступы", "magic margins"). Эта                  возможность устаревшая, screen использует стандартную xn вместо неё.
    Z0   (str)   Установить ширину равной 132 колонкам.
    Z1   (str)   Установить ширину равной 80 колонкам.
    WS   (str)   Изменить размер экрана. Желаемая ширина и высота передаются как аргументы.
                 Пример для SunView(tm): "\E[8;%d;%dt".
    NF   (bool)  Терминалу не нужно управление потоком. Передавать ^S и ^Q  непосредственно приложению.                  То же, что и "flow off". Возможность противоположная "nx".
    G0   (bool)  Терминал может работать с последовательностями выбора шрифта ISO 2022.
    S0   (str)   Переключить charset "G0" на заданный. По умолчанию "\E(%.".
    E0   (str)   Переключить charset "G0" обратно на стандартный.  По умолчанию "\E(B".
    C0   (str)   Использовать строку как таблицу преобразования для шрифта "0". См. также возможность "AC".     CS   (str)   Переключить клавиши управления курсором в режим приложения.
    CE   (str)   Переключить клавиши управления курсором обратно в нормальный режим.
    AN   (bool)  Включить autonuke. См. команду  autonuke   
    OL   (num)   Задаёт лимит буфера вывода. См. команду  obuflimit .
    KJ   (str)   Задать кодировку терминала. Для списка допустимых кодировок см. "encoding".
    AF   (str)   Изменить цвет символов способом соответствующим ANSI.
                 Эта возможность почти всегда равна "\E[3%dm"
                 (или "\E[3%p1%dm" на машинах с terminfo).

    AB   (str)   То же, что и "AF", но изменяет фон.
    AX   (bool)  Понимает ANSI-последовательности для установки цвета букв и цвета фона (\E[39m / \E[49m).     XC   (str)   Описать преобразование символов в строки в зависимости от текущего шрифта. Детали в следующем разделе.     XT   (bool)  Терминал понимает специальные последовательности xterm (OSC, слежение за мышью).
    C8   (bool)  Терминалу нужен полужирный текст для того чтобы выводить цвета высокой яркости (например, eterm).     TF   (bool)  Добавляет недостающие возможности в  запись termcap/info.  (Установлено по умолчанию). 
 

 

 
   
  Преобразование кодировки символов  

 

 
У screen есть мощный механизм трансляции символов в зависимости
от текущего шрифта и типа терминала.
Эту возможность можно использовать, когда возникает необходимость
со стандартным набором символов на терминалах,
работающих с какими-то более экзотическими наборами.
 
Синтаксис:
 
 
     XC=<charset-mapping>{,,<charset-mapping>}
    <charset-mapping> := <designator><template>{,<mapping>}
    <mapping> := <char-to-be-mapped><template-arg>

 

 

Элементы, заключённые в скобки, могут повторяться произвольное число раз.
 
Последовательность <charset-mapping> говорит screen как отображать символы в кодировке <designator> ("B": ASCII, 
"A": UK, "K":  german и т.д.) в строки. Каждый <mapping> описывает какие символы преобразуются в какие.
Используется механизм шаблонов, поскольку чаще всего кодировки имеют много общего
(например, строки которые нужны для того чтобы переключиться на другую и с другой кодировки).
Каждое вхождение символа "%" в шаблон <template> заменяется на
<template-arg>, заданный вместе с символом. 
Если строки вообще не похожи, нужно использовать "%" как шаблон и задавать полную строку в <template-arg>. Для использования настоящего символа "%" есть специальный механизм экранирования:
символ "\" экранирует специальные символы "\", "%" и ",".
 
Вот пример:
 
 
     termcap hp700 "XC=B\E(K%\E(B,\304[,\326\\\\,\334]"

 

 

 

 
Строка говорит screen как транслировать символы с умляутами в верхнем регистре в кодировке ISOlatin1 (кодировка "B") 
на терминале hp700, на котором немецкая "german" кодировка:  "\304" транслируется в "\E(K[\E(B"  и так далее. 
Прежде чем построится внутренняя таблица поиска эти строки подвергаются обработке в три прохода,
поэтому для того чтобы вставить обычный "\" нужно столько экранов.
 
Для того чтобы эмуляция была лучше, сделано ещё одно расширение: 
Если отображение транслирует неэкранированный символ "%",
он отправляет на терминал каждый раз когда screen переключается на 
соответствующую кодировку <designator>.
 
В этом особенном случае предполагается что шаблон это просто "%", 
потому что последовательность смены кодировок и отображение символом
имеют мало общего.
 
В этом примере показан один из способов использования расширения:
 
 
     termcap xterm XC=K%,%\E(B,[\304,\\\\\326,]\334

 

 

Здесь на xterm эмулируется часть немецкого ("K") набора символов (charset).
Если screen нужно будет перейти на набор символов "K", он отправит на терминал 
символ "\E(B", т.е. будет использоваться кодировка ASCII.
Шаблон это просто "%", поэтому отображение прямое: "[" на "\304", "\" на "\326" и "]" на "\334". 
   
  Переменные окружения  

 

 
 
     COLUMNS        Количество столбцов терминала (перекрывает запись termcap)
    HOME           Каталог, в котором нужно искать файл 
 

 

 
 
     LINES          Количество строк терминала (перекрывает запись termcap)
    LOCKPRG        Программа блокирования (lock) терминала 
    NETHACKOPTIONS Включает опцию nethack
    PATH           Используется для обнаружения программ перед запуском
    SCREENCAP      Для модификации значения TERMCAP терминала
    SCREENDIR      Альтернативный катало для сокетов
    SCREENRC       Альтернативный конфигурационный файл .screenrc
    SHELL          Имя интерпретатора, который используется для открытия окон (по умолчанию
                   "/bin/sh").
    STY            Альтернативное имя сокета
    SYSSCREENRC    Альтернативный системный конфигурационный файл 
 screenrc
 

 

 
 
     TERM           Имя терминала
    TERMCAP        Описание терминала
    WINDOW         Номер окна (в момент создания)

 

 

 


   
  Файлы  

 

 
 
        .../screen-4.?.??/etc/screenrc
       .../screen-4.?.??/etc/etcscreenrc Примеры в пользовательского и глобального
                                         инициализационных файлов,
                                         входящие в дистрибутив  screen 
       $SYSSCREENRC
       /etc/screenrc                     Команды инициализации screen
       $SCREENRC
       $HOME/.screenrc                   Считывается после /etc/screenrc
       $SCREENDIR/S-<login>
       /var/run/screen/S-<login>         Каталог с гнёздами(сокетами) screen (по умолчанию)
       /usr/tmp/screens/S-<login>        Альтернативный каталог с гнёздами
       <socket directory>/.termcap       Записанный функцией вывода "termcap"
       /usr/tmp/screens/screen-exchange  
       /tmp/screen-exchange              Буфер для межпроцессного взаимодействия screen
       hardcopy.[0-9]                    Образы screen, созданные функцией hardcopy
       screenlog.[0-9]                   Журнал, созданный функцией log
       /usr/lib/terminfo/?/* или
       /etc/termcap                      База данных возможностей терминала (Terminal capability databases)        /var/run/utmp                     Записи о входе в систему
       $LOCKPRG                          Программа, которая блокирует (lock) терминал

 

 

 
   
  См. также  

 

 
 termcap (5),  utmp (5),  vi (1),  captoinfo (1),  tic (1)
 
   
  Авторы  

 

Изначально программа была создана Оливером Ломанном (Oliver Laumann).
Последняя (эта) версия была сделана 
Вайеном Дэвисоном (Wayne Davison), Юргеном Вигертом (Juergen Weigert)
и Михаелем Шрёдером (Michael Schroeder).
 
   
  COPYLEFT  

 

 
Copyright (C) 1993-2003
 
 

   *     Juergen Weigert ( jnweiger@immd4.informatik.uni-erlangen.de )
 

   *     Michael Schroeder ( mlschroe@immd4.informatik.uni-erlangen.de )
 
Copyright (C) 1987 Oliver Laumann
 
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published  by  the
Free  Software  Foundation;  either  version 2, or (at your option) any
later version.
 
This program is distributed in the hope that it  will  be  useful,  but
WITHOUT  ANY  WARRANTY;  without  even  the  implied  warranty  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
GNU  General Public License for more details.
 
You should have received a copy of the GNU General Public License along
with this program (see the file COPYING); if not,  write  to  the  Free
Software  Foundation,  Inc.,  59  Temple  Place - Suite 330, Boston, MA
02111-1307, USA
 
   
  Вклад  

 

 
В развитие  GNU screen  сделали вклад:
 
 

   *  Ken Beal ( kbeal@amber.ssd.csd.harris.com ),
 

   *  Rudolf Koenig ( rfkoenig@immd4.informatik.uni-erlangen.de ),
 

   *  Toerless Eckert ( eckert@immd4.informatik.uni-erlangen.de ),
 

   *  Wayne Davison ( davison@borland.com ),
 

   *  Patrick Wolfe ( pat@kai.com , kailand!pat),
 

   *  Bart Schaefer ( schaefer@cse.ogi.edu ),
 

   *  Nathan Glasser ( nathan@brokaw.lcs.mit.edu ),
 

   *  Larry W. Virden ( lvirden@cas.org ),
 

   *  Howard Chu ( hyc@hanauma.jpl.nasa.gov ),
 

   *  Tim MacKenzie ( tym@dibbler.cs.monash.edu.au ),
 

   *  Markku Jarvinen (mta@{cc,cs,ee}.tut.fi),
 

   *  Marc Boucher ( marc@CAM.ORG ),
 

   *  Doug Siebert ( dsiebert@isca.uiowa.edu ),
 

   *  Ken Stillson ( stillson@tsfsrv.mitre.org ),
 

   *  Ian Frechett ( frechett@spot.Colorado.EDU ),
 

   *  Brian Koehmstedt ( bpk@gnu.ai.mit.edu ),
 

   *  Don Smith ( djs6015@ultb.isc.rit.edu ),
 

   *  Frank van der Linden ( vdlinden@fwi.uva.nl ),
 

   *  Martin Schweikert ( schweik@cpp.ob.open.de ),
 

   *  David Vrona ( dave@sashimi.lcu.com ),
 

   *  E. Tye McQueen ( tye%spillman.UUCP@uunet.uu.net ),
 

   *  Matthew Green ( mrg@eterna.com.au ),
 

   *  Christopher Williams ( cgw@pobox.com ),
 

   *  Matt Mosley ( mattm@access.digex.net ),
 

   *  Gregory Neil Shapiro ( gshapiro@wpi.WPI.EDU ),
 

   *  Johannes Zellner ( johannes@zellner.org ),
 

   *  Pablo Averbuj ( pablo@averbuj.com ).
 
   
  Версия  

 

 
Документация написана для  screen  версии 4.0.2.
Она основана на объединении версии 2.3 Вайана Дэвисона (Wayne Davison)
и нескольких улучшений к версии 2.0 Оливера Ломанна (Oliver Laumann).
Следует иметь в виду, что все версии 2.x принадлежат
Оливеру Ломанну (Oliver Laumann).
 
   
  Доступность  

 

 
Последний официальный релиз  screen 
доступен с помощью анонимного FTP на
gnudist.gnu.org, nic.funet.fi 
и других сайтах, распространяющих GNU.
Домашний сайт  screen  это   ftp.uni-erlangen.de ,
каталог 
 
 pub/utilities/screen
 

 

 
Подкаталог 
 
 private/
 

 

 
содержит последний тестовый бета-релиз.
Если вы хотите помочь, 
отправьте сообщение на 
 
 screen@uni-erlangen.de 
 

 

 
   
  Баги  

 

 

   *   "dm" (delete mode, режим удаления) и "xs" не обрабатываются корректно, они игнорируются. "xn" воспринимается как волшебный 
индикатор отступа. .br
   *   Screen ничего не знает о символах двойной высоты и двойной ширины. Но это единственное место, где vttest может не работать. 
 

   *   При подключении из-под терминала с другим типом нет возможности поменять переменную окружения $TERMCAP .br
   *   Поддержка terminfo-систем очень ограничена. Добавление новых возможностей в $TERMCAP не будет иметь должного эффекта. 
 

   *   Screen не использует аппаратные табы.
 

   *   В большинстве случаев screen должен быть установлен с битом set-uid и пользователем root. Это нужно для того, чтобы он 
мог корректно менять владельца tty-устройства для каждого окна. Особые права ещё могут понадобиться для того, чтобы 
изменять файл "/var/run/utmp". .br
   *   Записи в "/var/run/utmp" не удаляются, когда screen завершается по SIGKILL.  В результате некоторые программы (такие 
как "w" или "rwho") показывают, что пользователь зарегистрирован в системе, когда его на самом деле нет. .br
   *   Screen может выдавать странное сообщение, когда для терминала нед записи в utmp
 

   *   Если модемная линия разорвалась, screen может и не отключиться (или завершиться) автоматически, если драйвер устройства 
не настроен так, что отправляет сигнал HANGUP signal.   Для отключения сеанса screen нужно использовать опции командной 
строки .RS
 -D
 


  или 
 
 -d
 

 

 

   *   Опции -d и -D отключают сеанс без спроса, даже если установлен пароль.
 

   *   И  "breaktype",  и  "defbreaktype"  меняют способ генерирования разрыва для всех терминальных устройств. Правда, первый 
меняет только текущие настройки, а второй  задаёт настройки для новых, будущих окон. .br
   *   При подключении к многопользовательскому сеансу файл .screenrc пользователя не обрабатывается. Настройки пользователей 
должны быть включены в файл .screenrc пользователя, который запускает screen, или их нужно задавать вручную, когда screen 
уже работает. .br
   *   Для того чтобы воспользоваться всеми фичами, нужно иметь весьма незаурядное воображение.
 

   *   Сообщения об ошибках, исправления, улучшения, футболки, деньги, пиво и пиццу отправляйте по адресу  screen@uni-erlangen.de . 
 
   
  Перевод  

 

 
 

   *  Игорь Чубин <igor ar chub.in>
 

 
   Index 
 
  Имя  
  Синтаксис  
  Описание  
  С чего начать?  
  Опции командной строки  
  Привязки клавиш  
  Индивидуальная настройка  
  Строка сообщений  
  Типы окон  
  Escape-последовательности  
  Управление потоком  
  Названия (именование окон)  
  Виртуальный терминал  
  Трансляция при вводе  
  Специальные возможности терминала  
  Преобразование кодировки символов  
  Переменные окружения  
  Файлы  
  См. также  
  Авторы  
  COPYLEFT  
  Вклад  
  Версия  
  Доступность  
  Баги  
  Перевод  
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename