
<!--+++++++++++++++++++++++++++++++++++++++++++  0  +++++++++++++++++++++++++++++++++++++++++++--->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Проект OpenNet: MAN bash (8) Команды системного администрирования (FreeBSD и Linux)</title><meta name="KeyWords" content="man, manual, MAN, системное руководство, linux, FreeBSD, OpenBSD, Solaris, ядро, программы, системный вызов, bash"><meta name="viewport" content="width=device-width, initial-scale=1"></head>


<body link="#0000FF" vlink="#000080" text="#000000" bgcolor="#E3E4D0" alink="#FF00FF">
<link rel="stylesheet" href="/opennet4.css" type="text/css">
<!--htdig_noindex-->
<form method="get" action="https://www.opennet.ru/search.shtml">
<aside>
<div style="width: 100%; text-align: right; font-size: 70%; background: #E9EAD6; margin-bottom:-10px;">
Профиль: <b><a href="/~" rel="nofollow" title="/~ - сводная страница участника"><u>Аноним</u></a></b> (<a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=login">вход</a> | <a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=user_register">регистрация</a>)</div>

<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody><tr>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" valign="BOTTOM" bgcolor="#E9EAD6" width="300">
<a href="https://www.opennet.ru/"><img src="/opennet2.gif" alt="The OpenNET Project" height="60" width="249" border="0"></a><br>
</td>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" bgcolor="#E9EAD6" align="CENTER" width="100">

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:10px;" bgcolor="#E9EAD6" align="CENTER" width="50%">
<table width="100%" border="0">
<tbody><tr>
<td width="22%">
 <a href="https://www.opennet.ru/opennews/" class="h"><b>НОВОСТИ</b></a> (<a href="https://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="18%%">
  <a href="https://www.opennet.ru/mp/" class="h"><b>КОНТЕНТ</b></a>
</td><td width="14%">
  <a href="http://wiki.opennet.ru" class="h"><b>WIKI</b></a>
</td><td width="14%">
   <a href="https://www.opennet.ru/man.shtml" class="h"><b>MAN'ы</b></a>
</td><td width="16%">
   <a href="https://www.opennet.ru/forum/" class="h"><b>ФОРУМ</b></a>
</td><td width="16%">
<a href="https://www.opennet.ru/search.shtml" class="h" onmouseover="document.getElementById('form12').style.display='block';">Поиск</a>&nbsp;(<a href="https://www.opennet.ru/keywords/" class="h">теги</a>)
<input id="form12" style="display: none;" size="10" name="words" value="" title="для поиска в google наберите &quot;g фраза&quot;" type="text">
</td></tr>
</tbody></table>

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:5px;" bgcolor="#E9EAD6" align="right" width="20%">

<a href="https://www.opennet.ru/opennews/opennews_all_utf.rss"><img src="/img/rss.png" alt="RSS" title="RSS" height="16" width="16" border="0"></a>&nbsp;<a href="https://twitter.com/opennetru"><img src="/twitter.png" alt="twitter" title="Twitter" height="16" width="16" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="/img/vkontakte.gif" title="ВКонтакте" height="16" width="16" border="0"></a>&nbsp;<a href="https://zen.yandex.ru/opennet"><img src="/img/zen.gif" title="Yandex Zen" height="16" width="16" border="0"></a>&nbsp;<a href="https://www.facebook.com/OpenNet.News/"><img src="/img/facebook.gif" title="Facebook" height="16" width="16" border="0"></a>&nbsp;<a href="https://telegram.space/opennet_ru"><img src="/img/telegram2.png" title="Telegram" height="16" width="16" border="0"></a>
</td></tr></tbody></table>
</aside>

<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class="hdr_mobile">
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url('/back.gif') repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<a href="https://www.opennet.ru"><img src="/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" alt="The OpenNET Project / Index page"></a>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="/opennews/">новости</a>&nbsp;/<a href="/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">+++</a> | <a href="/forum/">форум</a> | <a href="http://wiki.opennet.ru">wiki</a> | <a href="/keywords/">теги</a>
| <a href="tg://resolve?domain=opennet_ru"><img src="/img/telegram2.png" title="Telegram" style="margin-bottom: -4px;" height="16" width="16" border="0"></a>
]</small>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id="adv">
</div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id="adv2">
</div>
<div style="width: 279;float: right;" id="adv3">
</div>
<div style="clear: both;"></div>
<br>
</form>
<!--/htdig_noindex-->

<center><h3><font color="#000088">Интерактивная система просмотра системных руководств (man-ов)</font></h3></center>
<form method="GET" action="/man.shtml"> 
<table cellspacing="0" cellpadding="1" bgcolor="#B0B190" align="center" width="600" border="0">
<tbody><tr>
<td valign="TOP">

<table cellspacing="0" cellpadding="0" bgcolor="#E9EAD6" align="center" width="100%" border="0">
<tbody><tr><td>&nbsp;<font color="#555555">Тема</font></td><td><font color="#555555">Набор</font></td><td><font color="#555555">Категория</font></td><td>&nbsp;</td></tr>
<tr><td>

&nbsp;<input size="20" name="topic" value="bash" type="text"></td><td><select name="russian">
<option value="4">Solaris man
</option><option value="1">FreeBSD man
</option><option value="3">Разные man
</option><option value="0" selected="">Русские man
</option><option value="2">Linux man
</option><option value="5">POSIX man
</option></select></td>
<td><select size="1" name="category">
	  <option value="" selected="">All
	  </option><option value="1">1
	  </option><option value="2">2
	  </option><option value="3">3
	  </option><option value="4">4
	  </option><option value="5">5
	  </option><option value="6">6
	  </option><option value="7">7
	  </option><option value="8">8
	  </option><option value="9">9
</option></select></td>

<td><input name="submit" value="Показать man" type="submit"></td></tr>
<script async="" src="https://www.google-analytics.com/analytics.js"></script><script language="JavaScript" src="/print.js"></script>
<tr><td colspan="4" align="left">&nbsp;[<a href="/man.shtml">Cписок руководств</a> | <a href="#" onclick="pr('none');">Печать</a>]</td></tr>
</tbody></table>
</td></tr></tbody></table>
</form>
<h3></h3><font size="+2">bash (8)</font><hr><li> <a href="/man.shtml?topic=bash&amp;category=1&amp;russian=4"><u>bash</u></a> (1) <font color="#555555"> ( Solaris man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=bash&amp;category=1&amp;russian=0"><u>bash</u></a> (1) <font color="#555555"> ( Русские man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=bash&amp;category=1&amp;russian=2"><u>bash</u></a> (1) <font color="#555555"> ( Linux man: Команды и прикладные программы пользовательского уровня )</font></li><li>&gt;&gt; <a href="/man.shtml?topic=bash&amp;category=8&amp;russian=0"><u>bash</u></a> (8) <font color="#555555"> ( Русские man: Команды системного администрирования )</font></li>
<table width="100%" border="0">
<tbody><tr>
<td><h1>Пользовательские команды</h1></td>
<td><h1 align="right">bash(1)</h1></td>
</tr>
</tbody></table>

<h2><a name="name">НАЗВАНИЕ</a></h2>
<p><b>bash</b> - командный интерпретатор GNU Bourne-Again SHell</p>

<h2>СИНТАКСИС</h2>
<dl><dt></dt><dd><tt>
	bash [<b>опции</b>] [<b>файл</b>]
</tt></dd></dl>

<h2><a name="copyright">АВТОРСКИЕ ПРАВА</a></h2>

<p>Командный интерпретатор <b>bash</b> создан Фондом свободно 
распространяемого программного обеспечения. 
Copyright (C) 1989-1999 by the Free Software Foundation, Inc.</p>

<h2><a name="description">ОПИСАНИЕ</a></h2>

<p><b>bash</b> - это <b>sh</b>-совместимый интерпретатор командного языка,
выполняющий команды, прочитанные со стандартного входного потока
или из файла. Командный интерпретатор <b>bash</b> также включает
полезные средства командных интерпретаторов <b>Korn</b> и <b>C</b> (<b>ksh</b> и <b>csh</b>).</p>

<p>Командный интерпретатор <b>bash</b> создавался как соответствующий
спецификации командного интерпретатора и инструментальных средств 
IEEE POSIX (<a href="http://gopher.std.com/obi/Standards/posix/1003.2/toc">IEEE 
POSIX Shell and Tools specification</a>)
(IEEE Working Group 1003.2).</p>

<h2><a name="options">ОПЦИИ</a></h2>

<p>Помимо однобуквенных опций командного интерпретатора, представленных
в описании встроенной команды <a href="#set"><b>set</b></a>, <b>bash</b> 
интерпретирует при вызове следующие опции:</p>

<table cellspacing="4" width="100%" border="0">
<tbody><tr><td valign="top" width="20%"><a name="c"><b>-c строка</b></a></td><td>
Если указана опция <b>-c</b>, команды читаются из строки. Если после строки
есть аргументы, их значения присваиваются позиционным параметрам, 
начиная с <b>$0</b>.
</td></tr>
<tr><td valign="top"><a name="r"><b>-r</b></a></td><td>
Если указана опция <b>-r</b>, командный интерпретатор становится ограниченным
(см. "<a href="#restricted_shell"><b>ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</b></a>" ниже).
</td></tr>
<tr><td valign="top"><a name="i"><b>-i</b></a></td><td>
Если указана опция <b>-i</b>, командный интерпретатор работает как
интерактивный.
</td></tr>
<tr><td valign="top"><a name="s"><b>-s</b></a></td><td>
Если указана опция <b>-s</b> или если после обработки опций аргументов
не остается, команды читаются из стандартного входного потока.
Эта опция позволяет устанавливать позиционные параметры
при вызове интерактивного командного интерпретатора.
</td></tr>
<tr><td valign="top"><a name="D"><b>-D</b></a></td><td>
Список всех строк в двойных кавычках с префиксом <b>$</b>
выдается в стандартный выходной поток. Это строки,
которые необходимо перевести на соответствующий язык, если
текущая локаль отличается от <b>C</b> или <b>POSIX</b>. При этом неявно
предполагается опция <b>-n</b>; никакие команды выполняться не будут.
</td></tr>
<tr><td valign="top"><a name="dephises"><b>--</b></a></td><td>
Пара дефисов (<b>--</b>) обозначает конец опций и отключает их дальнейшую
обработку. Любые аргументы после <b>--</b> рассматриваются как имена файлов
и аргументы. Аргумент <b>-</b> эквивалентен <b>--</b>.
</td></tr>
</tbody></table>

<p>Командный интерпретатор <b>bash</b> также интерпретирует несколько
многосимвольных опций. Эти опции, чтобы они были распознаны, должны
указываться в командной строке перед односимвольными опциями.</p>

<dl>
<dt><a name="dump-po"><b>--dump-po-strings</b></a></dt><dd>
Аналогична опции <a href="#D"><b>-D</b></a>, но результат выдается в формате файла GNU 
gettext po (portable object - <i>переносимый объект</i>).
<br><br></dd>
<dt><a name="dump-strings"><b>--dump-strings</b></a></dt><dd>
Аналогична опции <a href="#D"><b>-D</b></a>.
<br><br></dd>
<dt><a name="help"><b>--help</b></a></dt><dd>
Выдает в стандартный выходной поток сообщение об использовании и
успешно завершает работу.
<br><br></dd>
<dt><a name="login"><b>--login</b></a></dt><dd>
Заставляет <b>bash</b> работать так, как если бы он был вызван в качестве
<i>начального командного интерпретатора</i> 
(см. <a href="#invocation">"<b>ВЫЗОВ</b>"</a> ниже).
<br><br></dd>
<dt><a name="noediting"><b>--noediting</b></a></dt><dd>
Не использует библиотеку GNU <b>readline</b> для чтения командных строк в
интерактивном режиме.
<br><br></dd>
<dt><a name="noprofile"><b>--noprofile</b></a></dt><dd>
Не читает ни общесистемный файл начального запуска 
<b>/etc/profile</b>, ни любой из персональных файлов инициализации
пользователя <b>~/.bash_profile</b>, <b>~/.bash_login</b> или <b>~/.profile</b>.
По умолчанию, <b>bash</b> читает эти файлы при вызове в качестве
начального командного интерпретатора (см. <a href="#invocation">"<b>ВЫЗОВ</b>"</a> ниже).
<br><br></dd>
<dt><a name="norc"><b>--norc</b></a></dt><dd>
Не читает и не выполняет персональный файл инициализации
<b>~/.bashrc</b>, если командный интерпретатор работает интерактивно. Эта опция
по умолчанию включена, если интерпретатор вызван как <b>sh</b>.
<br><br></dd>
<dt><a name="posix"><b>--posix</b></a></dt><dd>
Изменяет на стандартное поведение <b>bash</b> в тех случаях, когда оно
отличается от предполагаемого стандартом POSIX  1003.2.
<br><br></dd>
<dt><a name="rcfile"><b>--rcfile файл</b></a></dt><dd>
Выполняет команды из указанного <b>файла</b> вместо стандартного персонального
файла инициализации <b>~/.bashrc</b>, если командный интерпретатор работает 
интерактивно (см. <a href="#invocation">"<b>ВЫЗОВ</b>"</a> ниже).
<br><br></dd>
<dt><a name="restricted"><b>--restricted</b></a></dt><dd>
Командный интерпретатор становится ограниченным
(см. "<a href="#restricted_shell"><b>ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</b></a>" ниже).
<br><br></dd>
<dt><a name="verbose"><b>--verbose</b></a></dt><dd>
Аналогична опции <a href="#v"><b>-v</b></a>.
<br><br></dd>
<dt><a name="version"><b>--version</b></a></dt><dd>
Выдает информацию о версии данного экземпляра <b>bash</b> в стандартный выходной поток
и успешно завершает работу.
</dd>
</dl>

<h2><a name="arguments">АРГУМЕНТЫ</a></h2>

<p>Если после обработки опций остались аргументы и не указаны опции
<a href="#c"><b>-c</b></a> или <a href="#s"><b>-s</b></a>, 
первый аргумент считается именем файла, содержащего
команды интерпретатора. Если <b>bash</b> вызван таким образом, параметр <b>$0</b>
устанавливается равным имени файла, а значениями позиционных параметров
становятся другие аргументы. Командный интерпретатор <b>bash</b> читает и
выполняет команды из этого файла, а затем завершает работу. Статусом
выхода <b>bash</b> является статус выхода последней команды, выполненной в сценарии.
Если ни одна команда не выполнена, статус выхода - 0.</p>

<h2><a name="invocation">ВЫЗОВ</a></h2>

<p><i>Начальный командный интерпретатор</i> (login shell) - это интерпретатор,
первый символ нулевого аргумента которого является дефисом (<b>-</b>) или
который запущен с опцией <a href="#login"><b>--login</b></a>.</p>

<p><i>Интерактивным</i> является командный интерпретатор, стандартный входной и 
выходной потоки которого подключены к терминалам (что определяется
с помощью функции <b>isatty(3)</b>), или запущенный 
с опцией <a href="#i"><b>-i</b></a>. Переменная
среды <b>PS1</b> устанавливается и флаги (<b>$-</b>) включают <b>i</b>, только если <b>bash</b> является
интерактивным интерпретатором, что позволяет проверить это в файле
начального запуска или в сценарии командного интерпретатора.</p>

<p>Следующие абзацы описывают, как <b>bash</b> выполняет свои файлы начального
запуска. Если любой из этих файлов существует, но не может быть
прочитан, <b>bash</b> выдает сообщение об ошибке. Символы <i>тильды</i> (<b>~</b>) 
в именах файлов заменяются так, как описано в подразделе 
"<a href="#tilde_expansion"><b>Замена тильды</b></a>" раздела 
"<a href="#expansion"><b>ЗАМЕНЫ</b></a>".</p>

<p>При вызове <b>bash</b> как интерактивного начального командного интерпретатора,
или как неинтерактивного интерпретатора с опцией 
<a href="#login"><b>--login</b></a>, он сначала
читает и выполняет команды из файла <b>/etc/profile</b>, если этот файл существует.
После прочтения этого файла, он последовательно ищет файлы <b>~/.bash_profile</b>,  
<b>~/.bash_login</b> и <b>~/.profile</b>, читает и выполняет команды из первого же из
них, который существует и доступен на чтение. Опция <a href="#noprofile"><b>--noprofile</b></a> может
использоваться при запуске командного интерпретатора, чтобы отменить
это действие.</p>

<p>При завершении работы в качестве начального командного интерпретатора
<b>bash</b> читает и выполняет команды в файле <b>~/.bash_logout</b>, если он существует.</p>

<p>При запуске интерактивного командного интерпретатора, не являющегося
начальным, <b>bash</b> читает и выполняет команды из файла <b>~/.bashrc</b>, если
он существует. Это действие можно отменить с помощью 
опции <a href="#norc"><b>--norc</b></a>.
Опция <a href="#rcfile"><b>--rcfile файл</b></a> заставляет <b>bash</b>
читать и выполнять команды из указанного <b>файла</b> вместо <b>~/.bashrc</b>.</p>

<p>При неинтерактивном запуске <b>bash</b>, например, для выполнения сценария,
командный интерпретатор ищет в среде переменную <b>BASH_ENV</b>, 
получает ее значение и использует его в качестве имени файла, который 
необходимо прочитать и выполнить. <b>bash</b> ведет себя так, как
если бы была выполнена следующая команда:</p>

<dl><dt></dt><dd><tt>
          if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
</tt></dd></dl>

<p>но при поиске имени файла не используется значение переменной <b>PATH</b>.</p>

<p>Если <b>bash</b> вызван с именем <b>sh</b>, он пытается, наколько это возможно, 
имитировать поведение при запуске старых версий интерпретатора <b>sh</b>, 
соответствуя при этом стандарту POSIX. При вызове в качестве
интерактивного начального командного интерпретатора или 
неинтерактивного, но с опцией <a href="#login"><b>--login</b></a>, он сначала пытается читать и
выполнять команды последовательно из файлов <b>/etc/profile</b> и <b>~/.profile</b>.
Для отмены этого действия можно использовать 
опцию <a href="#noprofile"><b>--noprofile</b></a>. При вызове
в качестве интерактивного командного интерпретатора с именем
<b>sh</b>, <b>bash</b> ищет переменную среды <b>ENV</b>, получает ее значение, если оно задано,
и использует это значение в качестве имени файла, который необходимо
прочитать и выполнить. Поскольку интерпретатор, вызванный как <b>sh</b>, не
пытается читать и выполнять команды в других файлах начального запуска,
опция <a href="#rcfile"><b>--rcfile</b></a> не действует. Неинтерактивный командый интерпретатор,
вызванный с именем <b>sh</b>, не пытается читать и выполнять никакие файлы начального
запуска. При вызове по имени <b>sh</b>, командный интерпретатор <b>bash</b> входит в режим
<b>posix</b> после прочтения файлов начального запуска.</p>

<p>При запуске <b>bash</b> в режиме <b>posix</b>, например, с помощью опции командной строки
<a href="#posix"><b>--posix</b></a>, он следует стандарту POSIX при работе с файлами начального запуска.
В этом режиме интерактивные командные интерпретаторы 
берут значение переменной среды <b>ENV</b>, читают и выполняют команды из
соответствующего файла. Никакие другие файлы начального
запуска не читаются.</p>

<p>Командный интерпретатор <b>bash</b> пытается определить, не запущен ли он
демоном удаленного командного интерпретатора, обычно, <b>rshd</b>.  Если
оказывается, что <b>bash</b> запущен демоном <b>rshd</b>, он читает и выполняет
команды из файла <b>~/.bashrc</b>, если этот файл существует и доступен
на чтение. Командный интерпретатор <b>bash</b> так не делает, если запущен
как <b>sh</b>. Для отмены этого действия можно использовать опцию
<a href="#norc"><b>--norc</b></a>, а с помощью опции 
<a href="#rcfile"><b>--rcfile</b></a> можно заставить читать другой файл, 
но обычно демон <b>rshd</b> не задает эти опции командному интерпретатору и не 
позволяет их указать.</p>

<p>Если командный интерпретатор запущен с эффективным идентификатором
пользователя (группы), не совпадающим с реальным идентификатором
пользователя (группы), и не указана опция <a href="#p"><b>-p</b></a>, файлы
начального запуска не читаются, функции командного интерпретатора не
наследуются из среды, переменная <b>SHELLOPTS</b>, если она задана в среде,
игнорируется, а эффективный идентификатор пользователя устанавливается
равным реальному. Если при вызове задана опция <a href="#p"><b>-p</b></a>, 
файлы начального запуска
тоже не читаются, но эффективный идентификатор пользователя не сбрасывается.</p>

<h2><a name="definitions">ОПРЕДЕЛЕНИЯ</a></h2>

<p>В оставшейся части документа используются следующие термины.</p>

<dl>
<dt><i>пробел</i></dt><dd>
Символ пробела или символ табуляции.
<br><br></dd>
<dt><i>слово</i></dt><dd>
Последовательность символов, рассматриваемая командным интерпретатором
как единое целое. Также называется <i>лексемой</i> (token).
<br><br></dd>
<dt><i>имя</i></dt><dd>
Слово, состоящее только из алфавитноцифровых символов и символов подчеркивания,
и начинающееся с буквы или символа подчеркивания. Также
называется <i>идентификатором</i>.
<br><br></dd>
<dt><i>метасимвол</i></dt><dd>
Символ, разделяющий слова, если он не замаскирован. Один из следующих
символов:
<dl><dt></dt><dd><tt>
          |  &amp; ; ( ) &lt; &gt; пробел табуляция
</tt></dd></dl>
<br><br></dd>
<dt><i>управляющий оператор</i></dt><dd>
Лексема, выполняющая функцию управления. Это один из следующих символов:
<dl><dt></dt><dd><tt>
          || &amp; &amp;&amp; ; ;; ( ) | &lt;перевод строки&gt;
</tt></dd></dl>
</dd>
</dl>

<h2><a name="reserved">ЗАРЕЗЕРВИРОВАННЫЕ СЛОВА</a></h2>

<p>Зарезервированными являются слова, имеющие специальное значение для
командного интерпретатора. Следующие слова распознаются как 
зарезервированные, если не замаскированы и являются либо первым словом
простой команды (см. <a href="#shell_syntax"><b>"СИНТАКСИС КОМАНД"</b></a> ниже),
либо третьим словом команды <a href="#case"><b>case</b></a> или 
<a href="#for"><b>for</b></a>:</p>

<b>!</b> <b>case</b> <b>do</b> <b>done</b> <b>elif</b> <b>else</b>
<b>esac</b> <b>fi</b> <b>for</b> <b>function</b> <b>if</b> <b>in</b>
<b>select</b> <b>then</b> <b>until</b> <b>while</b> <b>{ }</b>
<b>time</b> <b>[[ ]]</b>

<h2><a name="shell_syntax">СИНТАКСИС КОМАНД</a></h2>

<h3>&nbsp;&nbsp;&nbsp;  <a name="simple_command">Простые команды</a></h3>

<p><i>Простая команда</i> - это завершающаяся <i>управляющим оператором</i> 
последовательность необязательных присваиваний значений переменным,
после которых идут слова, разделенные пробелами, и
перенаправления потоков. Первое слово задает команду, которую 
надо выполнить. Оставшиеся слова передаются как аргументы вызванной
команде.</p>

<p>Возвращаемым значением <i>простой команды</i> является ее
статус выхода, или 128+<b>n</b>, если команда завершена сигналом <b>n</b>.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="pipeline">Конвейеры</a></h3>

<p><i>Конвейер</i> - это последовательность одной или более команд,
разделенных символом <b>|</b>. Конвейер имеет следующий формат:</p>
<dl><dt></dt><dd><tt>
          [time [-p]] [ ! ] <b>команда</b> [ | <b>команда2</b> ... ]
</tt></dd></dl>
<p>Стандартный выходной поток <b>команды</b> связывается со стандартным входным
потоком <b>команды2</b>. Эта связь выполняется раньше, чем любые перенаправления,
задаваемые командой (см. <a href="#redirection">"<b>ПЕРЕНАПРАВЛЕНИЕ</b>"</a> ниже).</p>

<p>Если перед конвейером указано зарезервированное слово <b>!</b>,
статус выхода такого конвейера является логическим отрицанием
статуса выхода последней команды. В противном случае, статус
выхода конвейера совпадает со статусом выхода последней команды.
Прежде, чем возвращать значение, командный интерпретатор ждет завершения
всех команд в конвейере.</p>

<p>Если перед конвейером идет зарезервированное слово <b>time</b>,
после завершения конвейера выдается общее, пользовательское и 
системное время, потраченное на его выполнение. 
Опция <a href="#p"><b>-p</b></a> изменяет
формат вывода на задаваемый стандартом POSIX. Переменная
<b>TIMEFORMAT</b> может задавать строку формата выдачи информации о времени;
см. описание переменной <b>TIMEFORMAT</b> в разделе 
<a href="#shell_vars">"<b>Переменные командного интерпретатора</b>"</a> ниже.</p>

<p>Каждая команда в конвейере выполняется как отдельный процесс
(т.е. в порожденном интерпретаторе).</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="lists">Списки</a></h3>

<p><i>Список</i> - это последовательность одного или более конвейеров, 
разделенных одним из операторов <b>;</b>, <b>&amp;</b>, <b>&amp;&amp;</b> 
или <b>||</b>, и не обязательно завершающаяся одним из операторов
<b>;</b>, <b>&amp;</b> или &lt;перевод строки&gt;.</p>

<p>Из этих операторов списка <b>&amp;&amp;</b> и <b>||</b> имеют равный приоритет, причем
больший, чем <b>;</b> и <b>&amp;</b>, тоже имеющие равный приоритет.</p>

<p>Если команда завершается управляющим оператором <b>&amp;</b>, интерпретатор
выполняет команду в <i>фоновом режиме</i> в порожденном интерпретаторе.
Командный интерпретатор не ждет завершения команды, а статус 
выхода в этом случае - 0. Команды, разделенные <b>;</b> выполняются
последовательно; командный интерпретатор ждет поочередно завершения каждой
из команд. Статус возврата списка в этом случае совпадает со
статусом возврата последней выполненной команды.</p>

<p>Управляющие операторы <b>&amp;&amp;</b> и <b>||</b> обозначают, соответственно, И-списки
и ИЛИ-списки. <i>И-список</i> имеет вид</p>
<dl><dt></dt><dd><tt>
    <b>команда</b> &amp;&amp; <b>команда2</b>
</tt></dd></dl>
<p><b>Команда2</b> выполняется только и если только <b>команда</b> вернула статус
выхода ноль.</p>

<p><i>ИЛИ-список</i> имеет вид</p>
<dl><dt></dt><dd><tt>
	<b>команда</b> || <b>команда2</b>
</tt></dd></dl>
<p><b>Команда2</b> выполняется только и если только команда вернула ненулевой
статус выхода. И- и ИЛИ-списки возвращают статус последней команды,
выполненной в списке.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="compound_command">Составные команды</a></h3>

<p><i>Составными</i> называют следующие команды:</p>
<dl>
<dt>(<b>список</b>)</dt>
<dd><b>Список</b> выполняется в порожденном командном интерпретаторе.
Присваивания переменным и встроенные команды, влияющие на 
среду командного интерпретатора, не действуют после завершения
команды. Статусом возврата является статус выхода <b>списка</b>.<br><br></dd>

<dt>{ <b>список</b>; }</dt>
<dd><b>Список</b> просто выполняется в среде текущего командного интерпретатора.
Список должен завершаться переводом строки или точкой с запятой.
Эту команду называют <i>командой группировки</i>. Статусом возврата
является статус выхода <b>списка</b>.<br><br></dd>

<dt>((<b>выражение</b>))</dt>
<dd><b>Выражение</b> вычисляется в соответствии с правилами, описанными ниже
в разделе 
"<a href="#arithmetic_eval"><b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b></a>". Если <b>выражение</b>
имеет ненулевое значение, статус возврата равен 0; в противном
случае - 1. Эта конструкция эквивалентна конструкции <b>let "выражение"</b>.<br><br></dd>

<dt>[[ <b>выражение</b> ]]</dt>
<dd>Возвращает статус 0 или 1 в зависимости от значения указанного
условного выражения. Выражения состоят из компонентов, описанных
ниже в разделе "<a href="#conditional_expr"><b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b></a>". 
Деление слов и подстановка
имен файлов в словах между <b>[[</b> и <b>]]</b> не выполняется; 
выполняется замена тильды, подстановка значений параметров и переменных,
арифметическая подстановка, подстановка результатов команд и 
подстановка процессов, а также удаление кавычек.

<p>При использовании операторов <b>==</b> и <b>!=</b> строка справа оператора
считается образцом и сопоставляется по правилам, описанным ниже в
подразделе "<a href="#pattern_matching"><b>Сопоставление с образцом</b></a>". Возвращается значение
0 если строка, соответственно, сопоставляется и не сопоставляется
с образцом, и 1 в противном случае. Любая часть образца может быть 
взята в кавычки, чтобы сопоставление с ней шло буквально.</p>

<p>Выражения можно комбинировать с помощью следующих операторов,
перечисленных в порядке снижения приоритета:</p>
<dl>
<dt>( <b>выражение</b> )</dt>
<dd>Возвращает значение <b>выражения</b>. Круглые скобки можно использовать
для изменения обычного приоритета операторов.<br><br></dd>

<dt>! <b>выражение</b></dt>
<dd>Истинно, если <b>выражение</b> ложно.<br><br></dd>

<dt><b>выражение1</b> &amp;&amp; <b>выражение2</b></dt>
<dd>Истинно, если истинны оба выражения, <b>выражение1</b> и 
<b>выражение2</b>.<br><br></dd>

<dt><b>выражение1</b> || <b>выражение2</b></dt>
<dd>Истинно, если истинно <b>выражение1</b> или <b>выражение2</b>.<br><br></dd>
</dl>

Операторы <b>&amp;&amp;</b> и <b>||</b> не вычисляют <b>выражение2</b>, если
значения <b>выражения1</b> достаточно для определения возвращаемого
значения всего условного выражения.<br><br></dd>

<dt><a name="for">for</a> <b>имя</b> [ in <b>список_слов</b> ] ; do <b>список</b> ; done</dt>
<dd>Выполняются подстановки в <b>списке_слов</b> после <b>in</b>, в результате чего
получается список элементов. Переменная с соответствующим
<b>именем</b> последовательно получает значение каждого элемента этого
списка, и каждый раз выполняется <b>список</b>. Если слово <b>in</b> не указано,
команда <b>for</b> выполняет <b>список</b> для каждого установленного позиционного 
параметра (см. раздел "<a href="#parameters"><b>ПАРАМЕТРЫ</b></a>" ниже). Сатусом возврата
является статус выхода последней выполненной команды. Если в 
результате подстановок элементов <b>списка_слов</b> после <b>in</b> получается
пустой список, команды не выполняются и возвращается статус 0.<br><br></dd>

<dt><a name="select">select</a> <b>имя</b> [ in <b>список_слов</b> ] ; do <b>список</b> ; done</dt>
<dd>Выполняются подстановки в <b>списке_слов</b> после <b>in</b>, в результате чего
получается список элементов. Набор полученных после подстановки
слов выдается в стандартный поток ошибок, причем перед каждым
элементом выдается его порядковый номер. Если слово <b>in</b> не указано,
выдаются установленные позиционные параметры
(см. раздел "<a href="#parameters"><b>ПАРАМЕТРЫ</b></a>" ниже). Затем выдается приглашение <b>PS3</b>
и читается строка со стандартного входного потока. Если эта строка
содержит число, соответствующее одному из выданных слов, то переменная
<b>имя</b> получает его значение. Если строка пустая, слова и приглашение
выдаются снова. Если прочитан символ конца файла (<b>EOF</b>), команда
заврешается. При вводе любого другого значения переменная <b>имя</b>
получает пустое значение. Прочитанная строка сохраняется в
переменной <b>REPLY</b>. <b>Список</b> выполняется после каждого выбора, пока не 
будет выполнена команда <b>break</b> или <b>return</b>. Статусом выхода
команды <b>select</b> является статус выхода последней команды в списке, 
или 0, если ни одна команда не была выполнена.<br><br></dd>

<dt><a name="case">case</a> <b>слово</b> in [ ( <b>образец</b> [ | <b>образец</b> ] ... ) <b>список</b> ;; ] ... esac</dt>
<dd>Команда <b>case</b> сначала подставляет значение <b>слова</b> и пытается
его сопоставить поочередно с каждым <b>образцом</b>, используя те же
правила сопоставления, что и для имен файлов (см. подраздел "<b>Подстановка
имен файлов</b>"). Если найден сопоставляющийся <b>образец</b>, 
выполняется соответствующий <b>список</b>. После нахождения первого 
сопоставления дальнейшее сопоставление не выполняется и команда
завершается. Статус выхода равен 0, если ни один <b>образец</b> не сопоставился.
В противном случае, он равен статусу выхода последней выполненной 
команды из соответствующего <b>списка</b>.<br><br></dd>

<dt><a name="if">if</a> <b>список</b>; then <b>список</b>; [ elif <b>список</b>; then <b>список</b>; ] ... [ else <b>список</b>; ] fi</dt>
<dd>Выполняется <b>список</b> после <b>if</b>. Если его статус выхода - 0,
выполняется <b>список</b> после <b>then</b>. В противном случае, выполняется
последовательно <b>список</b> в очередной конструкции <b>elif</b>, и если его
статус выхода - 0, выполняется соответствующий <b>список</b> после <b>then</b>
и команда завершается. Если все конструкции <b>elif</b> проверены
и ни один из <b>списков</b> не вернул статус 0, выполняется <b>список</b> после <b>else</b>,
если эта конструкция задана. Статусом выхода является
статус выхода последней выполненной команды или 0, если ни одно из условий
не оказалось истинным.<br><br></dd>

<dt><a name="while">while</a> <b>список</b>; do <b>список</b>; done<br>
<a name="until">until</a> <b>список</b>; do <b>список</b>; done</dt>
<dd>Команда <b>while</b> циклически выполняет <b>список</b> после <b>do</b>, пока
последняя команда <b>списка</b> возвращает статус выхода 0.
Команда <b>until</b> идентична команде <b>while</b>, но условие завершения - 
противоположно; <b>список</b> после <b>do</b> выполняется, пока последняя команда 
<b>списка</b> возвращает ненулевой статус выхода. Статусом выхода команд
<b>while</b> и <b>until</b> является статус выхода последней выполненной
команды <b>списка</b> или 0, если ни одна команда не выполнена.<br><br></dd>

<dt>[ <a name="function">function</a> ] <b>имя</b> () { <b>список</b>; }</dt>
<dd>Эта команда определяет функцию с указанным <b>именем</b>. <i>Тело
функции</i> образует <b>список</b> команд между фигурными скобками 
<b>{</b> и <b>}</b>. Этот <b>список</b> выполняется каждый раз, когда 
<b>имя</b> функции указывается как имя простой команлы. Статусом выхода функции
является статус выхода последней команды, выполненной в теле 
функции. (См. раздел "<a href="#functions"><b>ФУНКЦИИ</b></a>" ниже.)<br><br></dd>
</dl>

<h2><a name="comments">КОММЕНТАРИИ</a></h2>

<p>В неинтерактивном командном интерпретаторе или в интерактивном с
включенной опцией <b>interactive_comments</b> встроенной команды
<a href="#shopt"><b>shopt</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже), слово,
начинающиеся символом <b>#</b>, влечет игнорирование этого слова и последующих
символов в строке.  Интерактивный командный интерпретатор с не включенной
опцией <b>interactive_comments</b> не допускает использования комментариев.
Опция <b>interactive_comments</b> по умолчанию включается в интерактивных командных
интерпретаторах.</p>

<h2><a name="quoting">МАСКИРОВКА</a></h2>

<p><i>Маскировка</i> (quoting) используется для отмены специального значения для
командного интерпретатора определенных символов или слов. 
Маскировку можно использовать для отмены специфической обработки специальных
символов, для предотвращения распознавания зарезервированных слов, а также
для предотвращения подстановки параметров.</p>

<p>Каждый из метасимволов, перечисленных выше в разделе "<a href="#definitions"><b>ОПРЕДЕЛЕНИЯ</b></a>",
имеет специальное значение для командного интерпретатора и должен 
маскироваться, если используется буквально. Имеется три механизма маскировки:
<i>символ маскировки</i> (escape character), одиночные кавычки и двойные кавычки.</p>

<p>Незамаскированная обратная косая черта (<b>\</b>) является символом маскировки. Он
требует использовать следующий за ним символ (за исключением перевода строки) 
буквально. Если введена пара символов <b>\&lt;перевод строки&gt;</b> и сама обратная
косая не замаскирована, эта пара обрабатывается как признак продолжения строки
(т.е. она удаляется из входного потока и, по сути, игнорируется).</p>

<p>Все символы в одиночных кавычках используются буквально. Символ одиночной
кавычки (апостроф) не должен указываться между одиночными кавычками, даже если
он предваряется обратной косой.</p>

<p>Символы в двойных кавычках используются буквально, за исключением символов
<b>$</b>, <b>`</b> и <b>\</b>. Символы <b>$</b> и <b>`</b> в двойных кавычках имеют то же специальное значение.
Обратная косая имеет специальное значение только если после нее идет один
из следующих символов: <b>$</b>, <b>`</b>, <b>"</b>, <b>\</b> или &lt;перевод строки&gt;. Двойную кавычку можно 
указывать в двойных кавычках, замаскировав обратной косой.</p>

<p>Специальные параметры <b>*</b> и <b>@</b> имеют специальное значение при указании в двойных
кавычках (см. раздел <a href="#parameters">"<b>ПАРАМЕТРЫ</b>"</a> ниже).</p>

<p>Слова вида <b>$'строка'</b> обрабатываются особым образомy. Слово заменяется
строкой, в которой предваренные обратной косой символы заменяются в соответствии
со стандартом ANSI C. Управляющие последовательности, начинающиеся с обратной
косой, декодируются следующим образом:</p>

<table cellspacing="4" width="100%" border="0">
<tbody><tr><td valign="top" width="20%"><b>\a</b></td><td>
тревога (звонок)</td></tr>
<tr><td valign="top"><b>\b</b></td><td>
забой</td></tr>
<tr><td valign="top"><b>\e</b></td><td>
управляющий символ</td></tr>
<tr><td valign="top"><b>\f</b></td><td>
прогон страницы (form feed)</td></tr>
<tr><td valign="top"><b>\n</b></td><td>
перевод строки (new line)</td></tr>
<tr><td valign="top"><b>\r</b></td><td>
carriage return (возврат каретки)</td></tr>
<tr><td valign="top"><b>\t</b></td><td>
табуляция</td></tr>
<tr><td valign="top"><b>\v</b></td><td>
вертикальная табудяция</td></tr>
<tr><td valign="top"><b>\\</b></td><td>
обратная косая</td></tr>
<tr><td valign="top"><b>\nnn</b></td><td>
символ, ASCII-код которого совпадает с восьмеричным значением <b>nnn</b> 
(от одной до трех цифр)</td></tr>
<tr><td valign="top"><b>\xnnn</b></td><td>
символ, ASCII-код которого совпадает с шестнадцатеричным значением <b>nnn</b> 
(от одной до трех цифр)</td></tr>
</tbody></table>

<p>Преобразованный результат помещается в одиночные кавычки, как если бы
символа доллара просто не было.</p>

<p>Строка в двойных кавычках, перед которой идет символ доллара (<b>$</b>), будет
преобразована в соответствии с текущей локалью. Если текущая локаль - 
<b>C</b> или <b>POSIX</b>, символ доллара игнорируется. Если строка преобразована
и заменена, результат помещается в двойные кавычки.</p>

<h2><a name="parameters">ПАРАМЕТРЫ</a></h2>

<p><i>Параметр</i> - это сущность, хранящая значение. Это может быть
имя, число или один из специальных символов, перечисленных ниже в
разделе <a href="#special">"<b>Специальные параметры</b>"</a>. В контексте 
интерпретатора, <i>переменная</i> - это параметр, обозначаемый <i>именем</i>.</p>

<p>Параметр устанавливается, если ему присвоено значение. Пустая строка является
допустимым значением. После того, как переменная установлена, она может быть
удалена только с помощью встроенной команды <a href="#unset"><b>unset</b></a> 
(см. раздел "<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже).</p>

<p>Значение переменной может быть присвоено с помощью оператора вида</p>
<dl><dt></dt><dd><tt>
          <b>имя</b>=[<b>значение</b>]
</tt></dd></dl>

<p>Если <b>значение</b> не задано, переменной присваивается пустая строка. Во всех
<b>значениях</b> выполняется замена тильды, подстановка значений параметров и
переменных, обработка строк, подстановка результатов выполнения команд,
арифметические вычисления и удаление символов маскировки (см.
раздел "<a href="#expansion"><b>ОБРАБОТКА</b></a>" ниже). Если для переменной
установлен атрибут целочисленная (integer) 
(см. <a href="#declare"><b>declare</b></a> в разделе 
"<a href="#shell_builin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>"
ниже), ее значение арифметически вычисляется, даже если арифметическое 
вычисление <b>$((...))</b> не указано явно (см. подраздел 
"<a href="#arithmetic"><b>Арифметическое вычисление</b></a>" ниже). Разбиение на слова не выполняется, за исключением
значения <b>"$@"</b>, как объяснено ниже в подразделе 
<a href="#special">"<b>Специальные параметры</b>"</a>. 
Подстановка имен файлов не выполняется.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="positional">Позиционные параметры</a></h3>

<p><i>Позиционный параметр</i> - это параметр, обозначаемый одной или несколькими
цифрами, кроме цифры 0. Позиционным параметрам значения присваиваются на 
основе аргументов, переданных при вызове командного интерпретатора, и могут
быть переприсвоены с помощью встроенной команды <a href="#set"><b>set</b></a>. Позиционным
параметрам нельзя присваивать значения с помощью операторов присваивания.
Позиционные параметры временно заменяются при выполнении функции командного
интерпретатора (см. раздел "<a href="#functions"><b>ФУНКЦИИ</b></a>" ниже).</p>

<p>Когда позиционный параметр состоит из нескольких цифр, его надо брать
в скобки (см. раздел "<a href="#expansion"><b>ОБРАБОТКА</b></a>" ниже).</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="special">Специальные параметры</a></h3>
  
<p>Командный интерпретатор обрабатывает ряд параметров специальным образом.
Можно только ссылаться на значения этих параметров - присваивания им не
разрешены.</p>

<table cellspacing="4" width="100%" border="0">
<tbody><tr><td valign="top" width="10%"><b>*</b></td><td>
Заменяется позиционными параметрами, начиная с первого. 
Когда такая замена выполняется в двойных кавычках, результат будет
одним словом, в котором значения параметров разделены первым символом
значения специальной переменной <b>IFS</b>. То есть, <b>"$*"</b> эквивалентно
<b>"$1c$2c..."</b>,  где <b>c</b> - первый символ значения переменной <b>IFS</b>. Если переменная
<b>IFS</b> не установлена, значения параметров разделяются пробелами. Если переменная
<b>IFS</b> имеет пустое значение, значения параметров просто конкатенируются, без
разделителей.
</td></tr>
<tr><td valign="top"><b>@</b></td><td>
Заменяется позиционными параметрами, начиная с первого. 
Когда такая замена выполняется в двойных кавычках, каждый параметр
заменяется отдельным словом. То есть, <b>"$@"</b>  эквивалентно 
<b>"$1"</b> <b>"$2"</b> ...  Когда позиционных параметров нет, <b>"$@"</b> 
и <b>$@</b> заменяются пустой строкой (т.е. они просто удаляются).
</td></tr>
<tr><td valign="top"><b>#</b></td><td>
Заменяется десятичным значением количества позиционных параметров.
</td></tr>
<tr><td valign="top"><b>?</b></td><td>
Заменяется статусом последнего выполненного в приоритетном режиме конвейера.
</td></tr>
<tr><td valign="top"><b>-</b></td><td>
Заменяется флагами текущих опций, заданных при вызове, с помощью 
встроенной команды <a href="#set"><b>set</b></a> или установленных самим командным
интерпретатором (как, например, опция <a href="#i"><b>-i</b></a>).
</td></tr>
<tr><td valign="top"><b>$</b></td><td>
Заменяется идентификатором процесса командного интерпретатора.
В порожденном командном интерпретаторе, запущенном с помощью <b>()</b>, заменяется
идентификатором процесса основного интерпретатора, а не порожденного.
</td></tr>
<tr><td valign="top"><b>!</b></td><td>
Заменяется идентификатором последнего процесса, запущенного в фоновом 
(асинхронном) режиме.
</td></tr>
<tr><td valign="top"><b>0</b></td><td>
Заменяется именем командного интерпретатора или сценария. Это значение
устанавливается при инициализации командного интерпретатора. Если 
<b>bash</b> вызван с командным файлом, <b>$0</b> будет установлен равным имени
этого файла. Если <b>bash</b> запущен с опцией <a href="#c"><b>-c</b></a>, 
<b>$0</b> получает значение
первого аргумента после строки, которую надо выполнить, если он задан. 
В противном случае, этот специальный параметр получает значение имени
файла, использованного для вызова <b>bash</b>, которое задается нулевым
аргументом.
</td></tr>
<tr><td valign="top"><b>_</b></td><td>
При запуске командного интерпретатора устанавливается равным <i>полному
имени файла</i> (absolute file name) командного интерпретатора или выполняемого 
сценария, переданного в списке аргументов. В последствии,
заменяется последним аргументом предыдущей команды, с учетом всех замен.
Также устанавливается равным полному имени файла каждой выполняемой внешней 
команды и помещается в среду, экспортируемую для этой команды. При проверке
почты этот параметр содержит имя проверяемого файла почты.
</td></tr>
</tbody></table>

<h3>&nbsp;&nbsp;&nbsp;  <a name="variables">Переменные командного интерпретатора</a></h3>

<p>Командный интерпретатор устанавливает следующие переменные:</p>

<table cellspacing="4" width="100%" border="0">
<tbody><tr><td valign="top" width="20%"><b>PPID</b></td><td>
Идентификатор родительского процесса для командного интерпретатора. 
Эта переменная доступна только для чтения.
</td></tr>
<tr><td valign="top"><b>PWD</b></td><td>
Текущий рабочий каталог, установленный с помощью команды <a href="#cd"><b>cd</b></a>.
</td></tr>
<tr><td valign="top"><b>OLDPWD</b></td><td>
Предыдущий рабочий каталог, который был установлен с помощью команды 
<a href="#cd"><b>cd</b></a>.
</td></tr>
<tr><td valign="top"><b>REPLY</b></td><td>
Устанавливается равной значению, прочитанному встроенной командой
<a href="#read"><b>read</b></a>, при вызове ее без аргументов.
</td></tr>
<tr><td valign="top"><b>UID</b></td><td>
Идентификатор текущего пользователя - устанавливается при запуске командного
интерпретатора. Эта переменная доступна только для чтения.
</td></tr>
<tr><td valign="top"><b>EUID</b></td><td>
Эффективный идентификатор текущего пользователя - устанавливается 
при запуске командного интерпретатора. Эта переменная доступна 
только для чтения.
</td></tr>
<tr><td valign="top"><b>GROUPS</b></td><td>
Переменная-массив, содержащая список групп, в которые входит текущий
пользователь. Эта переменная доступна только для чтения.
</td></tr>
<tr><td valign="top"><b>BASH</b></td><td>
Полное имя файла, использованное для вызова данного экземпляра <b>bash</b>.
</td></tr>
<tr><td valign="top"><b>BASH_VERSION</b></td><td>
Строка, описывающая версию данного экземпляра <b>bash</b>.
</td></tr>
<tr><td valign="top"><b>BASH_VERSINFO</b></td><td>
Доступный только для чтения массив, элементы которого содержат информацию
о версии для данного экземпляра <b>bash</b>. Элементы массива имеют следующие
значения:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top"><b>BASH_VERSINFO[0]</b></td><td>
Главный номер версии (релиз).</td></tr>
<tr><td valign="top"><b>BASH_VERSINFO[1]</b></td><td>
Второстепенный номер версии (версия).</td></tr>
<tr><td valign="top"><b>BASH_VERSINFO[2]</b></td><td> 
Уровень исправлений.</td></tr>
<tr><td valign="top"><b>BASH_VERSINFO[3]</b></td><td>
Версия сборки.</td></tr>
<tr><td valign="top"><b>BASH_VERSINFO[4]</b></td><td>
Статус релиза (например, <b>beta1</b>).</td></tr>
<tr><td valign="top"><b>BASH_VERSINFO[5]</b></td><td>
Значение переменной <b>MACHTYPE</b>.</td></tr>
</tbody></table>
</td></tr>
<tr><td valign="top"><b>SHLVL</b></td><td>
Увеличивается на 1 при каждом запуске порожденного интерпретатора <b>bash</b>.
</td></tr>
<tr><td valign="top"><b>RANDOM</b></td><td>
При каждом обращении к этому параметру генерируется случайное число
от 0 до 32767. Конкретная последовательность случайных чисел
может быть проинициализирована путем присваивания значения переменной 
<b>RANDOM</b>. Если переменная <b>RANDOM</b> удаляется с помощью 
<a href="#unset"><b>unset</b></a>, она 
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</td></tr>
<tr><td valign="top"><b>SECONDS</b></td><td>
При каждом обращении к этому параметру возвращается количество секунд,
прошедших с момента вызова данного командного интерпретатора. Если переменной
<b>SECONDS</b> присваивается значение, при последующем обращении будет получено
количество секунд, прошедшее с момента присваивания, плюс присвоенное
значение. Если переменная <b>SECONDS</b> удаляется 
с помощью <a href="#unset"><b>unset</b></a>, она
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</td></tr>
<tr><td valign="top"><b>LINENO</b></td><td>
При каждом обращении к этому параметру командный интерпретатор
подставляет десятичное число, представляющее порядковый номер текущей
строки (начиная с 1) в сценарии или функции. При вызове не из
сценария или функции, не гарантируется подстановка осмысленного значения.
Если переменная <b>LINENO</b> удаляется 
с помощью <a href="#unset"><b>unset</b></a>, она 
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</td></tr>
<tr><td valign="top"><b>HISTCMD</b></td><td>
Исторический номер команды, или индекс текущей команды в списке выполненных 
команд. Если переменная <b>HISTCMD</b> удаляется 
с помощью <a href="#unset"><b>unset</b></a>, она 
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</td></tr>
<tr><td valign="top"><b>DIRSTACK</b></td><td>
Переменная-массив (см. раздел "<a href="#arrays"><b>Массивы</b></a>" далее), 
в которой хранится текущее содержимое
стека каталогов. Каталоги находятся в стеке в том же порядке, в котором
выдаются встроенной командой <a href="#dirs"><b>dirs</b></a>. 
Путем присваивания элементам этого
массива можно изменять каталоги, уже находящиеся в стеке, но для
добавления и удаления каталогов надо использовать встроенные команды
<a href="#pushd"><b>pushd</b></a> и <a href="#popd"><b>popd</b></a>. 
Присваивание значения этой переменной не меняет текущий каталог.
Если переменная <b>DIRSTACK</b> удаляется 
с помощью <a href="#unset"><b>unset</b></a>, она 
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</td></tr>
<tr><td valign="top"><b>PIPESTATUS</b></td><td>
Переменная-массив (см. раздел "<a href="#arrays"><b>Массивы</b></a>" далее), содержащая список значений
статусов выхода процессов в последнем выполненном в приоритетном режиме
конвейере (который может состоять и всего из одной команды).
</td></tr>
<tr><td valign="top"><b>OPTARG</b></td><td>
Значение последнего аргумента-опции, обработанного встроенной командной
<a href="#getopts"><b>getopts</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже).
</td></tr>
<tr><td valign="top"><b>OPTIND</b></td><td>
Индекс следующего аргумента, который должен быть обработан встроенной
командой <a href="#getopts"><b>getopts</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже).
</td></tr>
<tr><td valign="top"><b>HOSTNAME</b></td><td>
Автоматически устанавливается равной имени текущего хоста.
</td></tr>
<tr><td valign="top"><b>HOSTTYPE</b></td><td>
Автоматически устанавливается равной строке, уникально описывающей тип
машины, на которой выполняется <b>bash</b>. Стандартное значение зависит от системы.
</td></tr>
<tr><td valign="top"><b>OSTYPE</b></td><td>
Автоматически устанавливается равной строке, описывающей операционную систему,
на которой выполняется командный интерпретатор <b>bash</b>. Стандартное значение
зависит от системы.
</td></tr>
<tr><td valign="top"><b>MACHTYPE</b></td><td>
Автоматически устанавливается равной строке, полностью описывающей тип системы,
на которой выполняется <b>bash</b>, в стандартном для GNU формате
<b>процессор-компания-система</b>. Стандартное значение зависит от системы.
</td></tr>
<tr><td valign="top"><b>SHELLOPTS</b></td><td>
Список установленных опций командного интерпретатора через двоеточие.
Каждое слово в списке - допустимый аргумент для опции <b>-o</b> встроенной
команды <a href="#set"><b>set</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже).
Опции, упоминающиеся в списке <b>SHELLOPTS</b>, совпадают с выдаваемыми 
как установленные командой <a href="#set-o"><b>set -o</b></a>. 
Если эта переменная экспортирована в среду
при запуске командного интерпретатора <b>bash</b>, все упомянутые в списке
опции будут установлены до чтения любых файлов начального запуска.
Эта перменная доступна только для чтения.
</td></tr>
</tbody></table>

<p>Следующие переменные используются командным интерпретатором. В некоторых 
случаях <b>bash</b> присваивает переменным стандартные значения; эти случаи указаны 
ниже.</p>

<table cellspacing="4" width="100%" border="0">
<tbody><tr><td valign="top" width="20%"><b>IFS</b></td><td>
<i>Внутренний разделитель полей</i> (Internal Field Separator), используемый
для выделения слов после всех подстановок и для разбиения на слова строк,
прочитанных с помощью встроенной команды <a href="#read"><b>read</b></a>. 
Стандартное значение - <b>"&lt;пробел&gt;&lt;табуляция&gt;&lt;перевод строки&gt;"</b>.
</td></tr>
<tr><td valign="top"><b>PATH</b></td><td>
Путь поиска команд. Это список каталогов через двоеточие, в которых
командный интерпретатор ищет команды 
(см. раздел "<a href="#command_exec"><b>ВЫПОЛНЕНИЕ КОМАНД</b></a>"
ниже). Стандартный путь поиска зависит от системы и задается администратором,
устанавливающим <b>bash</b>. Типичное значение:
"<tt>/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.</tt>".
</td></tr>
<tr><td valign="top"><b>HOME</b></td><td>
Начальный каталог текущего пользователя; стандартный аргумент для встроенной
команды <a href="#cd"><b>cd</b></a>. Значение этой переменной также используется 
при замене тильды.
</td></tr>
<tr><td valign="top"><b>CDPATH</b></td><td>
Путь поиска для команды <a href="#cd"><b>cd</b></a>. Это список каталогов через
двоеточие, в которых командный интерпретатор ищет целевые каталоги, указанные 
по имени в команде <a href="#cd"><b>cd</b></a>. Пример возможного 
значения - "<tt>.:~:/usr</tt>".
</td></tr>
<tr><td valign="top"><b>BASH_ENV</b></td><td>
Если этот параметр установлен при выполнении командным интерпретатором
<b>bash</b> сценария, его значение интерпретируется как имя файла, содержащего команды
инициализации интерпретатора, аналогично <b>~/.bashrc</b>.
В значении <b>BASH_ENV</b> перед интерпретацией выполняется подстановка значений 
параметров, подстановка результатов выполнения команд и арифметические 
вычисления. Переменная <b>PATH</b> не используется для поиска результирующего имени
файла.
</td></tr>
<tr><td valign="top"><b>MAIL</b></td><td>
Если этот параметр установлен равным имени файла 
и не установлена переменная <b>MAILPATH</b>, <b>bash</b> информирует пользователя
о получении электронной почты в указанный файл.
</td></tr>
<tr><td valign="top"><b>MAILCHECK</b></td><td>
Задает частоту проверки (в секундах) электронной почты командным 
интерпретатором <b>bash</b>. Стандартное значение - 60 секунд.  
Когда приходит время проверять наличие новой почты, командный
интерпретатор делает это перед выдачей первичного приглашения.
Если эта переменная не установлена, проверка почты командным
интерпретатором отключается.
</td></tr>
<tr><td valign="top"><b>MAILPATH</b></td><td>
Список имен файлов через двоеточие, в которых нужно проверять наличие
новых почтовых сообщений. Можно задавать сообщение, которое должно
выдаваться при поступлении почты в конкретный файл, отделяя сообщение от
имени файла вопросительным знаком (<b>?</b>). В тексте этого 
сообщения метасимвол <b>$_</b> заменяется именем текущего файла почты. Например:<br>
<br> 
<tt>MAILPATH='/usr/spool/mail/bfox?"You have mail":~/shell-mail?"$_ has mail!"'</tt>
<p>
Командный интерпретатор <b>bash</b> поддерживает стандартное значение 
для этой переменной, но используемое при этом местонахождение файлов почты
пользователя зависит от системы (например, <b>/usr/spool/mail/$USER</b>).</p>
</td></tr>
<tr><td valign="top"><b>PS1</b></td><td>
Значение этого параметра обрабатывается (см. 
раздел "<a href="#prompting"><b>ПРИГЛАШЕНИЯ</b></a>" ниже) и
используется для установки строки первичного приглашения. Стандартное
значение - <tt>"\s-\v\$ "</tt>.
</td></tr>
<tr><td valign="top"><b>PS2</b></td><td>
Значение этого параметра обрабатывается, как и <b>PS1</b>, и
используется для установки строки вторичного приглашения. 
Стандартное значение - <tt>"&gt; "</tt>.
</td></tr>
<tr><td valign="top"><b>PS3</b></td><td>
Значение этого параметра используется в качестве 
приглашения для команды <a href="#select"><b>select</b></a> 
(см. раздел "<a href="#shell_syntax"><b>СИНТАКСИС КОМАНД</b></a>" выше).
</td></tr>
<tr><td valign="top"><b>PS4</b></td><td>
Значение этого параметра обрабатывается, как и <b>PS1</b>, и
выдается перед каждой командой, показываемой интерпретатором
<b>bash</b> в ходе трассировки выполнения. Первый символ <b>PS4</b>
повторяется необходимое количество раз, показывая уровень
вложенности. Стандартное значение - <tt>"+"</tt>.
</td></tr>
<tr><td valign="top"><b>TIMEFORMAT</b></td><td>
Значение этого параметра используется в качестве строки, задающей формат
выдачи информации о времени выполнения для конвейеров, перед которыми
задано зарезервированное слово <b>time</b>. Символ <b>%</b> начинает управляющую 
последовательность, заменяемую значением времени или другой информацией.
Управляющие последовательности имеют следующие значения (в квадратных
скобках представлены необязательные части):

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="15%"><b>%%</b></td><td>
Символ <b>%</b>.</td></tr>
<tr><td valign="top"><b>%[p][l]R</b></td><td>
Время выполнения, в секундах.</td></tr>
<tr><td valign="top"><b>%[p][l]U</b></td><td>
Количество секунд работы процессора в пользовательском режиме.</td></tr>
<tr><td valign="top"><b>%[p][l]S</b></td><td>
Количество секунд работы процессора в системном режиме.</td></tr>
<tr><td valign="top"><b>%P</b></td><td>
Процент использования процессора, вычисляемый как (<b>%U</b> + <b>%S</b>) / <b>%R</b>.</td></tr>
</tbody></table>

Необязательный параметр <b>p</b> - это цифра, задающая точность,
количество знаков (долей секунды) после запятой. Значение 0
отменяет выдачу долей секунды. Максимальная точность - три знака после запятой;
значения <b>p</b> больше 3 заменяются на 3. Если <b>p</b> не задано, используется значение 3.

<p>Необязательный параметр <b>l</b> задает длинный формат, включая минуты, в виде
<b>MMmSS.FFs</b>. Значение праметра <b>p</b> определяет, включаются доли секунды или нет.</p>

<p>Если эта переменная не установлена, <b>bash</b> действует так, как если бы
она имела значение <b>$'\nreal\t%3lR\nuser\t%3lU\nsys%3lS'</b>. Если установлено
пустое значение, информация о времени выполнения не выдается.
При выводе строки по формату добавляется перевод строки.</p>
</td></tr>
<tr><td valign="top"><b>HISTSIZE</b></td><td>
Количество команд, которые необходимо запоминать в <i>списке истории</i> (см.
раздел "<b>ИСТОРИЯ КОМАНД</b>" ниже). Стандартное значение - 500.
</td></tr>
<tr><td valign="top"><b>HISTFILE</b></td><td>
Имя файла, в котором сохраняется история команд (см. раздел 
"<a href="#history"><b>ИСТОРИЯ КОМАНД</b></a>" ниже). 
Стандартное значение - <b>~/.bash_history</b>.
Если эта переменная не установлена, история команд не сохраняется при
завершении работы интерактивного командного интерпретатора.
</td></tr>
<tr><td valign="top"><b>HISTFILESIZE</b></td><td>
Максимальное количество строк, содержащееся в файле истории.
Если этой переменной присвоено значение, файл истории, при необходимости,
усекается, и будет содержать не больше, чем указанное количество строк.
Стандартное значение - 500. Файл истории также усекается до этого размера после
записи при выходе из интерактивного командного интерпретатора.
</td></tr>
<tr><td valign="top"><b>OPTERR</b></td><td>
Если имеет значение 1, <b>bash</b> показывает сообщения об ошибках, выдаваемые
встроенной командой <a href="#getopts"><b>getopts</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>"
ниже). Переменная <b>OPTERR</b> инициализируется значением 1 при каждом вызове 
командного интерпретатора или выполнении сценария.
</td></tr>
<tr><td valign="top"><b>LANG</b></td><td>
Используется для определения локали для всех категорий, не заданных явно с 
помощью переменной, имя которой начинается с <b>LC_</b>.
</td></tr>
<tr><td valign="top"><b>LC_ALL</b></td><td>
Эта переменная переопределяет значение переменной <b>LANG</b> и всех остальных
переменных <b>LC_</b>, задающих категорию локали.
</td></tr>
<tr><td valign="top"><b>LC_COLLATE</b></td><td>
Эта переменная задает порядок сортировки, используемый при сортировке 
полученных по шаблону имен файлов, и определяет интерпретацию диапазонов,
<i>классов эквивалентостей</i> и правила сравнения символов для подстановки имен
файлов и сопоставления с образцом.
</td></tr>
<tr><td valign="top"><b>LC_CTYPE</b></td><td>
Эта переменная определяет интерпретацию символов и принадлежность символов
к определенному классу для подстановки имен файлов и сопоставления с образцом.
</td></tr>
<tr><td valign="top"><b>LC_MESSAGES</b></td><td>
Эта переменная определяет локаль, используемую для обработки строк в двойных
кавычках, перед которыми указан символ <b>$</b>.
</td></tr>
<tr><td valign="top"><b>PROMPT_COMMAND</b></td><td>
Если значение задано, оно выполняется как команда перед выдачей каждого 
первичного приглашения.
</td></tr>
<tr><td valign="top"><b>IGNOREEOF</b></td><td>
Управляет действием командного интерпретатора при получении <i>символа
конца файла</i> (<b>EOF</b>) как единственного символа в строке. Если
эта переменная установлена, ее значение интерпретируется как количество
подряд идущих символов <b>EOF</b>, с которых должна начинаться строка, чтобы в 
результате работа командного интерпретатора <b>bash</b> завершилась. Если
переменная существует, но не имеет числового значения или не имеет значения вообще,
по умолчанию используется значение 10. Если эта переменная не существует,
<b>EOF</b> означает конец входных данных для командного интерпретатора.
</td></tr>
<tr><td valign="top"><b>TMOUT</b></td><td>
Если установлено значение больше нуля, оно интерпретируется как количество
секунд ожидания ввода после выдачи первичного приглашения. Командный
интерпретатор <b>bash</b> завершает работу по истечении этого времени, если не
введена команда.
</td></tr>
<tr><td valign="top"><b>FCEDIT</b></td><td>
Задает стандартный редактор для встроенной команды <a href="#fc"><b>fc</b></a>.
</td></tr>
<tr><td valign="top"><b>FIGNORE</b></td><td>
Список суффиксов через двоеточие, которые необходимо игнорировать при
завершении имен файлов (см. раздел 
"<a href="#readline"><b>БИБЛИОТЕКА READLINE</b></a>" ниже). Имя файла,
суффикс которого совпадает с одним из указанных в <b>FIGNORE</b>
значений, исключается из списка соответствующих имен файлов.
Пример значения - <b>".o:~"</b>.
</td></tr>
<tr><td valign="top"><b>GLOBIGNORE</b></td><td>
Список шаблонов через двоеточие, задающих набор имен файлов, которые
надо игнорировать при подстановке имен. Если имя файла, соответствующее шаблону,
также соответствует одному из шаблонов в <b>GLOBIGNORE</b>, оно удаляется
из списка соответствующих.
</td></tr>
<tr><td valign="top"><b>INPUTRC</b></td><td>
Имя файла начального запуска <b>readline</b>, переопределяющего стандартные
установки в файле <b>~/.inputrc</b> (см. раздел 
"<a href="#readline"><b>БИБЛИОТЕКА READLINE</b></a>" ниже).
</td></tr>
<tr><td valign="top"><b>HISTCONTROL</b></td><td>
Если имеет значение <b>ignorespace</b>, строки, начинающиеся символом
пробела, не попадают в список выполненных команд. Если имеет значение
<b>ignoredups</b>, строки, совпадающие с последней выполненной командой, в список
выполненных команд не попадают. Значение <b>ignoreboth</b> сочетает действие
обеих представленных опций. Если переменной нет или она имеет какое-то другое
значение, кроме перечисленных выше, все строки, прочитанные синтаксическим 
анализатором, сохраняются в списке истории, с учетом значения переменной
<b>HISTIGNORE</b>. Действие этой переменной переопределяется переменной
<b>HISTIGNORE</b>. Вторая и следующие строки многострочной составной команды не
проверяются, и добавляются в список истории независимо от значения 
<b>HISTCONTROL</b>.
</td></tr>
<tr><td valign="top"><b>HISTIGNORE</b></td><td>
Список шаблонов через двоеточие, используемых для принятия решения о сохранении
командных строк в списке истории. Каждый шаблон привязывается к началу 
строки и должен задавать всю строку ('<b>*</b>' неявно не добавляется). Каждый
шаблон сравнивается со строкой после проверок, задаваемых
переменной <b>HISTCONTROL</b>. Кроме обычных символов сопоставления с образцом 
в командном интерпретаторе, символ '<b>&amp;</b>' сопоставляется с предыдущей строкой
в списке истории. Символ '<b>&amp;</b>' можно экранировать с помощью обратной косой. Перед
сопоставлением обратная косая убирается. Вторая и последующая строки составной
многострочной команды не проверяются и добавляются в список истории независимо от
значения переменной <b>HISTIGNORE</b>.
</td></tr>
<tr><td valign="top"><b>histchars</b></td><td>
Два или три символа, управляющих подстановкой и разбиением на лексемы
уже выполненных команд (см. раздел 
"<a href="#history_expansion"><b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ВЫПОЛНЕННЫХ</b></a>"
ниже). Первый символ - это символ подстановки из списка, который
означает начало работы со списком истории. Обычно это символ '<b>!</b>'. 
Второй символ - это символ быстрой подстановки, используемый для быстрого
повторения предыдущей введенной команды, с подстановкой указанной строки вместо
другой, заданной в этой команде. По умолчанию используется символ '<b>^</b>'. 
Необязательный третий символ - это символ, указывающий, если является
первым символом слова, что остаток строки - это комментарий. Обычно в этом 
качестве используется символ '<b>#</b>'. Символ комментария для списка истории
приводит к отказу от подстановки из истории для оставшихся слов в командной
строке. Он не обязательно приводит к обработке синтаксическим анализатором
оставшейся части строки как комментария.
</td></tr>
<tr><td valign="top"><b>HOSTFILE</b></td><td>
Содержит имя файла того же формата, что и файл <b>/etc/hosts</b>, который
будет читаться при необходимости подстановки имени хоста. Этот файл
можно менять интерактивно; при следующей попытке подстановки имени
хоста <b>bash</b> добавит содержимое нового файла к уже существующей базе данных.
</td></tr>
<tr><td valign="top"><b>auto_resume</b></td><td>
Эта переменная управляет взаимодействием командного интерпретатора с
пользователем и средствами управления заданиями. Если она установлена,
простые команды из одного слова и без перенаправлений рассматриваются
как указатели возможного возобновления существующих остановленных заданий.
Неоднозначность не допускается; если с введенной строки начинается 
более одного задания, выбирается последнее по времени приостановки задание.
Имя остановленного задания, в этом контексте, - это командная строка,
использовавшаяся для его запуска. Если эта переменная имеет значение
<b>exact</b>, введенная строка должна точно совпадать с именем остановленного задания;
Если же задано значение <b>substring</b>, введенная строка должна быть
подстрокой имени остановленного задания. Это аналогично по возможностям
идентификатору задания <b>%?</b>
(см. раздел "<a href="#job_control"><b>УПРАВЛЕНИЕ ЗАДАНИЯМИ</b></a>" ниже). 
Если установлено любое другое 
значение, введенная строка должна быть префиксом имени остановленного
задания; это аналогично по возможностям идентификатору задания <b>%</b>.
</td></tr>
</tbody></table>

<h3>&nbsp;&nbsp;&nbsp;  <a name="arrays">Массивы</a></h3>

<p>Командный интерпретатор <b>bash</b> поддерживает <i>одномерные массивы</i>.
Любая переменная может использоваться как массив; встроенная
процедура <a href="#declare"><b>declare</b></a> позволяет объявить массив явно. 
Нет ограничения на рамер массива или требования непрерывности индексов. Массивы
индексируются целыми числами, начиная с нуля.</p>

<p>Массив создается автоматически при присваивании любой переменной значения
с помощью конструкции <b>имя[индекс]=значение</b>. Индекс обрабатывается как
арифметическое выражение, которое должно иметь неотрицательное значение.
Для явного объявления массива используется команда <b>declare -a имя</b>
(см. раздел "<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>"
ниже). Конструкция <b>declare -a имя[индекс]</b> также поддерживается; 
индекс просто игнорируется. Для переменной типа массив можно задать атрибуты 
с помощью встроенных команд <a href="#declare"><b>declare</b></a> и 
<a href="#"><b>readonly</b></a>. Атрибут применяется ко всем элементам массива.</p>

<p>Присваивания массивам выполняются с помощью конструкций вида 
<b>имя=(значение1  ...  значениеn)</b>, где каждое <b>значение</b> имеет вид
<b>[индекс]=строка</b>. Обязательно задавать только <b>строку</b>. Если необязательные
квадратные скобки и <b>индекс</b> указаны, присваивание выполняется элементу с
соответствующим индексом; в противном случае, в качестве индекса элемента 
используется индекс последнего элемента, которому было присвоено значение,
плюс один. Индексация начинается с нуля. Эту же конструкцию присваивания можно
использовать и во встроенной команде <a href="#declare"><b>declare</b></a>. 
Значения отдельным элементам массива присваиваются с помощью представленной 
выше конструкции <b>имя[индекс]=значение</b>.</p>

<p>На любой элемент массива можно сослаться с помощью конструкции 
<b>${имя[индекс]}</b>. Фигурные скобки необходимы, чтобы избежать конфликтов при
подстановке имен файлов. Если в качестве индекса указан символ <b>@</b> или <b>*</b>,
слово заменяется всеми элементами массива с указанным именем. Эти индексы
интерпретируются по-разному только если слово указано в двойных кавычках.
Если слово указано в двойных кавычках, конструкция <b>${имя[*]}</b> заменяется
одним словом, значение которого строится как значения каждого элемента
массива, разделенные первым символом из значения переменной среды <b>IFS</b>, а
конструкция <b>${имя[@]}</b> заменяет каждый элемент массива <b>имя</b> отдельным словом.
Когда массив пустой, <b>${имя[@]}</b> заменяется пустой строкой. Это аналогично замене
специальных параметров <b>*</b> и <b>@</b> (см. 
подраздел "<a href="#special"><b>Специальные параметры</b></a>" выше).
Конструкция <b>${#имя[индекс]}</b> заменяется длиной элемента <b>${имя[индекс]}</b>.
Если в качестве индекса указан символ <b>*</b> или <b>@</b>, подставляется количество элементов
массива. Ссылка на переменную-массив без индекса эквивалентна ссылке на
элемент с индексом ноль.</p>

<p>Для уничтожения массивов используется встроенная команда 
<a href="#unset"><b>unset</b></a>.
Команда <b>unset имя[индекс]</b> уничтожает элемент массива с указанным индексом. 
Команда <b>unset name</b>, где <b>name</b> - имя массива, или <b>unset имя[индекс]</b>,
где индекс - <b>*</b> или <b>@</b>, удаляет весь массив.</p>

<p>Встроенные команды <a href="#declare"><b>declare</b></a>, 
<a href="#local"><b>local</b></a> и <a href="#readonly"><b>readonly</b></a>
воспринимают опцию <b>-a</b> для указания массива. 
Встроенная команда <a href="#read"><b>read</b></a> воспринимает опцию <b>-a</b>
для присваивания массиву списка слов, прочитанных из станадартного
входного потока. Встроенные команды <a href="#set"><b>set</b></a> и 
<a href="#declare"><b>declare</b></a> выдают значения массивов
так, что их можно повторно использовать в присваиваниях.</p>

<h2><a name="expansion">ЗАМЕНЫ</a></h2>

<p>Замена выполняется в командной строке после разбиения ее на слова.
Выполняется семь видов замен: замена выражений в фигурных скобках,  
замена тильды, подстановка значений переменных и параметров, подстановка
результатов выполнения команд, подстановка значений арифметических
выражений, разбиение слов и подстановка имен файлов.</p>

<p>Замена выполняется в следующем порядке: замена выражений в фигурных скобках,
замена тильды, подстановка значений переменных, параметров, арифметических 
выражений и результатов выполнения команд (слева направо), разбиение слов
и подстановка имен файлов.</p>

<p>В системах, где это может поддерживаться, выполняется дополнительная замена -
подстановка процессов.</p>

<p>Только замена выражений в фигурных скобках, разбиение слов 
и подстановка имен файлов может изменить количество слов в командной
строке; при других заменах одно слово просто заменяется другим. Единственное
исключение - подстановка <b>"$@"</b> и <b>"${имя[@]}"</b>, как объяснялось выше
(см. раздел "<a href="#parameters"><b>ПАРАМЕТРЫ</b></a>").</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="brace_expansion">Замена выражений в фигурных скобках</a></h3>

<p><i>Замена выражений в фигурных скобках</i> - это механизм генерации произвольных 
строк. Он аналогичен подстановке имен файлов, но генерируемые имена
не обязательно должны существовать. Шаблоны в фигурных скобках имеют вид
необязательного префикса, за которым идет набор строк через запятую в фигурных 
скобках, после чего - необязательный суффикс. Префикс добавляется в начало 
каждой строки, содержащейся в фигурных скобках, а затем к каждой полученной 
так (слева направо) строке добавляется суффикс.</p>

<p>Выражения в фигурных скобках могут быть вложенными. Результаты каждой замены не
сортируются; порядок слева направо сохраняется. Например, конструкция
<b>a{d,c,b}e</b> заменяется на '<b>ade ace abe</b>'.</p>

<p>Замена выражений в фигурных скобках выполняется перед любыми другими заменами, и
в результате сохраняются все символы, имеющие специальное значение для других 
замен. Эта замена - строго текстуальная. Командный интерпретатор <b>bash</b> никак
не учитывает контекст подстановки или текст в фигурных скобках.</p> 

<p>Корректное выражение в фигурных скобках должно содержать незамаскированные
открывающую и закрывающую фигурную скобку и, по крайней мере, одну незамаскированную 
запятую. Любое некорректное выражение в фигурных скобках остается неизменным.
Символ <b>{</b> или <b>,</b> может маскироваться обратной косой для предотвращения его 
интерпретации на этапе замены выражений в фигурных скобках.</p>

<p>Эта конструкция обычно используется для сокращенной записи группы строк с
общим префиксом, более длинным чем в представленном выше примере:

</p><dl><dt></dt><dd><tt>
          mkdir /usr/local/src/bash/{old,new,dist,bugs}
</tt></dd></dl>
или
<dl><dt></dt><dd><tt>
          chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
</tt></dd></dl>

Замена выражений в фигурных скобках вносит небольшое рассогласование
с историческими версиями <b>sh</b>. Командный интерпретатор <b>sh</b> не рассматривает
открывающую и закрывающую фигурные скобки в слове специальным образом
и просто сохраняет их. Командный интерпретатор <b>bash</b> удаляет фигурные скобки
из слова при замене. Например, слово, введенное в <b>sh</b> как <b>file{1,2}</b>,
остается без изменений. Это же слово заменяется парой слов
<b>file1 file2</b> после замены выражения в фигурных скобках в <b>bash</b>.
Если требуется полная совместимость с <b>sh</b>, командный интерпретатор <b>bash</b>
надо запускать с опцией <a href="#B"><b>+B</b></a> или отключать с помощью опции 
<b>+B</b> команды <a href="#set-B"><b>set</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже).<p></p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="tilde_expansion">Замена тильды</a></h3>

<p>Если слово начинается незамаскированным символом тильда (<b>~</b>),
все символы до первой незамаскированной косой черты (или все символы,
если незамаскированной косой черты в слове нет) считаются <i>тильда-префиксом</i>.
Если ни один из символов тильда-префикса не замаскирован, его символы после 
тильды рассматриваются как возможное регистрационное имя. Если это 
регистрационное имя представляет собой пустую строку, тильда заменяется
значением переменной <b>HOME</b>. Если переменная <b>HOME</b> не установлена, подставляется
начальный каталог пользователя, выполняющего процесс командного интерпретатора.
Если же тильда-префикс не пустой, подставляется начальный каталог 
соответствующего пользователя.</p>

<p>Если тильда-префикс имеет вид <b>~+</b>, вместо него подставляется значение
переменной <b>PWD</b>. Если тильда-префикс имеет вид <b>~-</b>, вместо него подставляется
значение переменной <b>OLDPWD</b>, если эта переменная установлена. 
Если среди символов после тильды в тильда-префиксе имеется число
<b>N</b>, с необязательными префиксами <b>+</b> или <b>-</b>, тильда-префикс заменяется
соответствующим элементом из стека каталогов, который был бы выдан
встроенной командой <a href="#dirs"><b>dirs</b></a> при вызове с тильда-префиксом в
качестве аргумента. Если символы после тильды содержат число без начального знака
<b>+</b> или <b>-</b>, предполагается <b>+</b>.</p>

<p>Если соответствующего регистрационного имени не существует или
замену тиильды выполнить не удалось, исходное слово остается без изменений.</p>

<p>Присваивания значений переменным проверяются на наличие незамаскированных
тильда-префиксов сразу после <b>:</b> или <b>=</b>. В этих случаях также выполняется 
замена тильды. Соответственно, можно использовать имена файлов с тильдами в
присваиваниях переменным <b>PATH</b>, <b>MAILPATH</b> и <b>CDPATH</b>, и командный
интерпретатор выполнит необходимые замены.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="parameter_expansion">Подстановка значений параметров</a></h3>

<p>Символ <b>$</b> обозначает подстановку значений параметров, подстановку
реультатов выполнения команд или подстановку значений арифметических выражений.
Имя параметра можно брать в фигурные скобки, что позволяет отделить его
от идущих непосредственно за ним символов, которые не являются частью имени.</p>

<p>При использовании фигурных скобок, завершающей считается первая скобка
<b>}</b>, не замаскированная обратной косой, не входящая в строку в кавычках, встроенное
арифметическое выражение или подставляемую команду, или в подстановку значения
другого параметра.</p>
<dl>
<dt><b>${параметр}</b></dt><dd>
Подставляется значение указанного параметра. Фигурные скобки необходимы,
если параметр является позиционным и номер позиции состоит из нескольких
цифр или когда после параметра идет символ, не входящий в его имя.
</dd>
</dl>

<p>Если первый символ параметра - восклицательный знак, начинается косвенная
подстановка. Командный интерпретатор <b>bash</b> использует значение переменной, имя
которой задается остальной частью параметра, в качестве имени переменной,
значение которой необходимо подставить, а не собственно значения. Это 
называется косвенной заменой.</p>

<p>В каждом из описанных ниже случаев в полученном слове выполняется замена тильды,
подстановка значений параметров, подстановка результатов выполнения команд и
вычисление арифметических выражений. Если не выполняется подстановка подстрок,
<b>bash</b> проверяет, не является ли параметр не установленным или не имеет ли он
пустого значения; если не указать двоеточие, проверяется только, установлен ли
параметр.</p>

<dl>
<dt><b>${параметр:-слово}</b></dt><dd>
Использовать стандартное значение. Если параметр не установлен или имеет пустое 
значение, подставляется значение указанного <b>слова</b>. Иначе подставляется значение
<b>параметра</b>.
</dd>
<dt><b>${параметр:=слово}</b></dt><dd>
Присвоить стандартное значение. Если <b>параметр</b> не установлен или имеет пустое
значение, <b>параметр</b> получает значение указанного слова. Затем подставляется значение <b>параметра</b>. Присваивать таким образом значения позиционным и 
специальным параметрам нельзя.
</dd>
<dt><b>${параметр:?слово}</b></dt><dd>
Выдавать ошибку если <b>параметр</b> не установлен или имеет пустое значение.
Если параметр имеет пустое значение или не установлен, указанное <b>слово</b> (или стандартное
сообщение, если <b>слово</b> не задано) выдается в стандартный поток ошибок, 
и командный интерпретатор, если он не интерактивный, завершает работу. 
В противном случае, подставляется значение <b>параметра</b>.
</dd>
<dt><b>${параметр:+слово}</b></dt><dd>
Использовать альтернативное значение. Если <b>параметр</b> не установлен или имеет
пустое значение, не подставляется ничего, в противном случае, подставляется 
указанное <b>слово</b>.
</dd>
<dt><b>${параметр:m}<br>
${параметр:m:n}</b></dt><dd>
Подстановка подстрок. Подставляет символы значения параметра, начиная с указанного
смещения <b>m</b> и вплоть до заданной длины <b>n</b>. Если длина не указана, подставляет символы 
с указанного смещения и до конца. В качестве длины и смещения можно
задавать арифметические выражения (см. 
раздел "<a href="#arithmetic"><b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b></a>"
ниже). Длина должна быть неотрицательным числом. Если смещение - отрицательное число,
оно отсчитывается с конца значения параметра. Если <b>параметр</b> - <b>@</b>,
результат - <b>n</b> позиционных параметров, начиная с параметра <b>m</b>. 
Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, 
результат - <b>n</b> элементов массива, начиная с <b>${параметр[m]}</b>.
Индексация подстрок начинается с нуля, за исключением позиционных параметров, 
которые индексируются, начиная с 1.
</dd>
<dt><b>${#параметр}</b></dt><dd>
Подставляется длина значения <b>параметра</b> в символах. Если <b>параметр</b> - <b>*</b> или <b>@</b>,
подставляется количество позиционных параметров. Если <b>параметр</b> - массив с индексом
<b>*</b> или <b>@</b>, подставляется количество элементов массива.
</dd>
<dt><b>${параметр#слово}<br>
${параметр##слово}</b></dt><dd>
<b>Слово</b> рассматривается как шаблон, аналогичный шаблону имен файлов. Если шаблон
сопоставляется с началом значения <b>параметра</b>, то результатом будет значение <b>параметра</b>,
из которого удалена самая короткая (в случае <b>#</b>) или самая длинная (в случае 
<b>##</b>) подстрока. Если <b>параметр</b> - <b>@</b> или <b>*</b>, операция удаления шаблона применяется
поочередно к каждому позиционному параметру и подставляется полученный в результате 
список. Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, операция удаления шаблона
применяется поочередно к каждому элементу массива и подставляется полученный
в результате список.
</dd>
<dt><b>${параметр%слово}<br>
${параметр%%слово}</b></dt><dd>
<b>Слово</b> рассматривается как шаблон, аналогичный шаблону имен файлов. Если шаблон
сопоставляется с конечной частью значения параметра, то результатом будет значение параметра,
из которого удалена самая короткая (в случае <b>%</b>) или самая длинная (в случае 
<b>%%</b>) подстрока. Если <b>параметр</b> - <b>@</b> или <b>*</b>, операция удаления шаблона применяется
поочередно к каждому позиционному параметру и подставляется полученный в результате 
список. Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, операция удаления шаблона
применяется поочередно к каждому элементу массива и подставляется полученный
в результате список.
</dd>
<dt><b>${параметр/шаблон/строка}<br>
${параметр//шаблон/строка}</b></dt><dd>
<b>Шаблон</b> задается аналогично шаблонам имен файлов. Самая длинная подстрока значения
параметра, соответствующая шаблону, заменяется указанной <b>строкой</b>. В первом случае,
заменяется только первое вхождение.  Во втором случае, заменяются все вхождения 
шаблона. Если шаблон начинается с <b>#</b>, он должен сопоставляться начиная с начала
значения <b>параметра</b>. Если же шаблон начинается с <b>%</b>, он должен сопоставляться с 
окончанием значения <b>параметра</b>. Если <b>строка</b> - пустая, соответсвующие шаблону подстроки
удаляются и <b>/</b> после шаблона можно не указывать. Если <b>параметр</b> - <b>@</b> или <b>*</b>,
операция замены шаблона применяется поочередно к каждому позиционному параметру, и подставляется
полученный в результате список. Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, 
операция замены шаблона применяется поочередно к каждому элементу массива и 
подставляется полученный в результате список.
</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="command_subst">Подстановка результатов выполнения команд</a></h3>

<p><i>Подстановка результатов выполнения команд</i> позволяет результат,
выдаваемый командой в стандартный выходной поток, подставить вместо имени 
команды. Имеется две формы такой подстановки:</p>
<dl><dt></dt><dd><tt>
          $(<b>команда</b>)
</tt></dd></dl>
или
<dl><dt></dt><dd><tt>
          `<b>команда</b>`
</tt></dd></dl>

<p>Командный интерпретатор <b>bash</b> делает эту подстановку путем выполнения 
<b>команды</b> и замены конструкции подстановки содержимым стандартного выходного
потока команды, из которого удалены завершающие переводы строк. 
Встроенные переводы строк не удаляются, но они могут быть удалены при разбиении
на слова. Подстановку результатов выполнения команды <b>$(cat  file)</b> можно
заменить эквивалентной, но более быстрой: <b>$(&lt; file)</b>.</p>

<p>При использовании старой формы подстановки в обратных апострофах
обратная косая интерпретируется как литерал, если только после нее не идут
символы <b>$</b>, <b>`</b> или <b>\</b>. Первый же обратный апостроф, не замаскированный обратной
косой, завершает подставляемую команду. При использовании формы <b>$(команда)</b>
все символы между круглыми скобками образуют команду - ни один не имеет
специального значения.</p>

<p>Подстановка результатов выполнения команд может быть <i>вложенной</i>.
Для задания вложенной подстановки в форме с обратными апострофами замаскируйте
внутренние обратные апострофы обратными косыми.</p>

<p>Если подстановка задана в двойных кавычках, разбиение на слова и подстановка
имен файлов в результатах не выполняется.</p>

<h3>&nbsp;&nbsp;&nbsp; <a name="arithmetic">Подстановка значений арифметических выражений</a></h3>

<p>При <i>вычислении арифметических выражений</i> вместо выражения подставляется результат
его вычисления. Для вычисления арифметических выражений используется следующий
формат:</p><p>
</p><dl><dt></dt><dd><tt>
          $((<b>выражение</b>))
</tt></dd></dl>

<p><b>Выражение</b> обрабатывается так, как если бы оно было взято в двойные кавычки, но
двойные кавычки в самом выражении не имеют специального значения. Во всех
лексемах выражения выполняется подстановка значений параметров, подстановка строк,
подстановка результатов выполнения команд и удаление кавычек. Вычисления 
арифметических выражений могут быть вложенными.</p>

<p>Вычисление выполняется по правилам, перечисленным ниже в разделе 
"<a href="#arithmetic_eval"><b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b></a>". 
Если <b>выражение</b> недопустимо, командный интерпретатор
<b>bash</b> выдает сообщение о невозможности вычисления и подстановка не выполняется.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="process_subst">Подстановка процессов</a></h3>

<p><i>Подстановка процессов</i> доступна в системах, поддерживающих
<i>именованные каналы</i> (FIFO) или метод именования открытых файлов через
<b>/dev/fd</b>. Она имеет вид <b>&lt;(список)</b> или <b>&gt;(список)</b>. Процесс <b>список</b> запускается и его
входной или выходной поток связывается с именованным каналом FIFO или
одним из файлов в <b>/dev/fd</b>. Имя этого файла передается в качестве аргумента
текущей команде как результат подстановки. Если использована форма
<b>&gt;(список)</b>, запись в файл будет давать входные данные процессу <b>список</b>. Если же
использована форма <b>&lt;(список)</b>, файл, переданный в качестве аргумента, необходимо 
читать для получения результатов работы процесса <b>список</b>.</p>

<p>Если подстановка процессов поддерживается, она выполняется одновременно с 
подстановкой значений параметров, подстановкой результатов выполнения команд 
и вычислением арифметических выражений.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="word_split">Разбиение на слова</a></h3>

<p>Командный интерпретатор обрабатывает результаты подстановки значений параметров,
результатов выполнения команд и арифметических вычислений, не взятых в 
двойные кавычки, разбивая их на слова.</p>

<p>Командный интерпретатор рассматривает каждый символ значения переменной <b>IFS</b>
как <i>разделитель</i> и разбивает результаты подстановок на слова по этим символам.
Если переменная <b>IFS</b> не установлена или ее значение -     
&lt;пробел&gt;&lt;табуляция&gt;&lt;перевод строки&gt;, т.е. стандартное, то любая 
последовательность подряд идущих символов из <b>IFS</b> считается разделителем слов.
Если же переменная <b>IFS</b> имеет значение, отличающееся от стандартного,
то последовательность <i>пробельных символов</i> (пробелов и символов табуляции)
в начале и в конце слова игнорируется, если пробельные символы входят в значение
<b>IFS</b> (их обобщенно называют <i>пробельным символом <b>IFS</b></i>). Любые символы в значении
<b>IFS</b>, не являющиеся пробельными, вместе с любыми идущими за ними пробельными
символами <b>IFS</b>, ограничивают слово. Последовательность пробельных символов
<b>IFS</b> также считается разделителем. Если переменная <b>IFS</b> имеет пустое значение, 
разбиение на слова не происходит.</p>

<p>Явные пустые строки (<b>""</b> или <b>''</b>) оставляются. Не взятые в кавычки неявные
пустые строки, получающиеся в результате подстановки параметров, не имеющих
значения, удаляются. Если параметр, не имеющий значения, подставляется в двойных 
кавычках, получается пустая строка, и она остается в командной строке.</p>

<p>Учтите, что если не было подстановок, то и разбиение на слова не выполняется.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="pathname_expansion">Подстановка имен файлов</a></h3>

<p>После разбиения на слова, если только не установлена опция <b>-f</b>,
командный интерпретатор <b>bash</b> просматривает каждое слово в поисках символов
<b>*</b>, <b>?</b>, <b>(</b> и <b>[</b>. Если найден любой из этих символов,
слово считается <i>шаблоном</i> и
заменяется упорядоченным по алфавиту списком имен файлов, соответствующих 
шаблону. Если соответствующие имена файлов не найдены и опция командного
интерпретатора <a href="#nullglob"><b>nullglob</b></a> отключена, 
слово остается без изменений. Если опция
<b>nullglob</b> установлена и соответствующие файлы не найдены, слово удаляется.
Если включена опция командного интерпретатора 
<a href="#nocaseglob"><b>nocaseglob</b></a>, сопоставление
выполняется без учета регистра алфавитных символов. Если шаблон используется
для подстановки имен файлов, символ "<b>.</b>" в начале имени или сразу после косой
черты должен сопоставляться явно, если только не установлена опция 
интерпретатора <a href="#dotglob"><b>dotglob</b></a>. При сопоставлении имен файлов косые черты 
всегда должны сопоставляться явно. В других случаях символ "<b>.</b>" обрабатывается 
как любые другие символы. См. описание опций командного интерпретатора 
<a href="#nocaseglob"><b>nocaseglob</b></a>, <a href="#nullglob"><b>nullglob</b></a> 
и <a href="#dotglob"><b>dotglob</b></a> 
ниже в разделе "<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>".</p>

<p>Переменная командного интерпретатора <b>GLOBIGNORE</b> может использоваться
для ограничения множества имен файлов, соответствующих шаблону. Если 
переменная <b>GLOBIGNORE</b> установлена, каждое сопоставившееся имя файла, 
соответствующее также одному из шаблонов, заданных в <b>GLOBIGNORE</b>, удаляется
из списка сопоставившихся. Имена файлов "<b>.</b>" и "<b>..</b>" игнорируются всегда, даже
если установлена переменная <b>GLOBIGNORE</b>. Однако при установке переменной
<b>GLOBIGNORE</b> автоматически устанавливается опция интерпретатора 
<a href="#dotglob"><b>dotglob</b></a>,
так что все остальные имена файлов, начинающиеся с "<b>.</b>", будут подставлены.
Для получения старого поведения - игнорирования имен файлов, начинающихся с "<b>.</b>", -
задайте "<b>.*</b>" как один из шаблонов в переменной <b>GLOBIGNORE</b>. 
Опция <a href="#dotglob"><b>dotglob</b></a> отключается, если переменная <b>GLOBIGNORE</b> не установлена.</p>

<h3>&nbsp;&nbsp;&nbsp;     <a name="pattern_match">Сопоставление с образцом</a></h3>

<p>Любой символ в шаблоне, отличающийся от специальных, описанных ниже, 
сопоставляется буквально. Символ NUL в шаблоне указывать нельзя.
Специальные символы шаблона для буквального сопоставления необходимо
маскировать.</p>

<p>Специальные символы шаблона имеют следующие значения:</p>
<dl>
<dt><b>*</b></dt>
<dd>Соответствует любой строке, в том числе, пустой.</dd>
<dt><b>?</b></dt>
<dd>Соответствует любому одиночному символу.</dd>
<dt><b>[...]</b></dt>
<dd>Соответствует любому из символов в квадратных скобках. Пара символов,
разделенная дефисом, задает <i>диапазон</i>; любой символ, лексически находящийся между
этими двумя символами, включительно, будет соответствовать этой конструкции.
Если сразу после <b>[</b> идет символ <b>!</b> или <b>^</b>, то конструкции соответствует любой
символ, не указанный в квадратных скобках. Для сопоставления с дефисом (<b>-</b>)
его необходимо указать в квадратных скобках первым или последним. Для задания
закрывающей квадратной скобки (<b>]</b>), ее необходимо указать как первый символ набора.

<p>В квадратных скобках можно задавать <i>классы символов</i> с помощью конструкции
<b>[:класс:]</b>, где <b>класс</b> - один из следующих классов, определяемых стандартом
POSIX.2:<br>
<tt>
alnum alpha ascii blank cntrl digit graph  lower  print
punct space upper xdigit
</tt>
<br>
Класс символов сопоставляется с любым символом, принадлежащим к этому классу.</p>

<p>В квадратных скобках можно задавать <i>класс эквивалентности</i> с помощью конструкции
<b>[=c=]</b>, соответствующей всем символам с тем же <i>порядком сортировки</i>
(collation  weight), определяемым текущей локалью, что и символ <b>c</b>.</p>

<p>В квадратных скобках конструкция <b>[.символ.]</b> соответствует <b>символу</b> с
указанным порядком сортировки.</p>
</dd>
</dl>

<p>Если с помощью встроенной команды <a href="#shopt"><b>shopt</b></a> установлена опция
командного интерпретатора <a href="#extglob"><b>extglob</b></a>, распознается ряд дополнительных
операторов сопоставления с образцом. В следующем описании <b>список_шаблонов</b> -
это список из одного или нескольких шаблонов через вертикальную черту (<b>|</b>).
Составные шаблоны можно формировать из одного или нескольких следующих 
подшаблонов:</p>
<dl>
<dt><b>?(список_шаблонов)</b></dt>
<dd>Соответствует нулю или одному вхождению указанных шаблонов</dd>
<dt><b>*(список_шаблонов)</b></dt>
<dd>Соответствует нулю или более вхождений указанных шаблонов</dd>
<dt><b>+(список_шаблонов)</b></dt>
<dd>Соответствует одному или оболее вхождений указанных шаблонов</dd>
<dt><b>@(список_шаблонов)</b></dt>
<dd>Соответствует ровно одному вхождению указанных шаблонов</dd>
<dt><b>!(список_шаблонов)</b></dt>
<dd>Соответствует любой строке, кроме соответствующей одному из указанных шаблонов.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="quote_removal">Удаление кавычек</a></h3>

<p>После выполнения всех перечисленных выше подстановок все незамаскированные
вхождения символов <b>\</b>, <b>'</b> и <b>"</b>, не являющиеся результатом этих подстановок,
удаляются.</p>

<h2><a name="redirection">ПЕРЕНАПРАВЛЕНИЕ</a></h2>

<p>Перед выполнением команды ее входной и выходной потоки могут быть 
<i>перенаправлены</i> с помощью специальных конструкций, обрабатываемых командным
интерпретатором. Перенаправления также можно использовать для открытия и закрытия
файлов в текущей среде работы командного интерпретатора. Следующие операторы
перенаправления могут предшествовать <i>простой команде</i> или указываться в любом 
ее месте, или указываться после <i>команды</i>. Перенаправления обрабатываются в 
порядке их указания, слева направо.</p>

<p>В следующих описаниях если номер дескриптора файла не указан и первый символ
оператора перенаправления - <b>&lt;</b>, выполняется перенаправление стандартного
входного потока (дескриптор файла 0). Если же первым символом оператора
перенаправления является символ <b>&gt;</b>, выполняется перенаправление стандартного
выходного потока (дескриптор файла 1).</p>

<p>В слове, идущем за оператором перенаправления в следующих описаниях, если не
сказано иначе, выполняется подстановка фигурных скобок, замена тильды, 
подстановка значений параметров, подстановка результатов выполнения команд,
вычисление арифметических выражений, удаление кавычек и подстановка имен 
файлов. Если в результате получается более одного слова, командный 
интерпретатор <b>bash</b> выдает сообщение об ошибке.</p>

<p>Учтите, что порядок указания перенаправлений имеет значение. Например, команда</p>
<dl><dt></dt><dd><tt>
          ls &gt; dirlist 2&gt;&amp;1
</tt></dd></dl>

<p>перенаправляет в файл <b>dirlist</b> стандартный выходной поток и стандартный поток 
ошибок, тогда как команда</p>
<dl><dt></dt><dd><tt>
          ls 2&gt;&amp;1 &gt; dirlist
</tt></dd></dl>

<p>перенаправляет в файл <b>dirlist</b> только стандартный выходной поток, поскольку
стандартный поток ошибок был направлен туде же, куда и стандартный выходной поток
до его перенаправления в файл <b>dirlist</b>.</p>

<p>Ошибка при открытии или создании файла приводит к отмене перенаправления.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="stdin_redir">Перенаправление входного потока</a></h3>
  
<p>Перенаправление входного потока приводит к открытию на чтение файла,
имя которого получается в результате подстановок в <b>слове</b>, через дескриптор
файла <b>n</b>, или как стандартного входного потока (дескриптор файла 0), если 
<b>n</b> не указано.</p>

<p>В общем случае перенаправление входного потока имеет вид:</p>
<dl><dt></dt><dd><tt>
          [<b>n</b>]&lt;<b>слово</b>
</tt></dd></dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="stdout_redir">Перенаправление выходного потока</a></h3>

<p>Перенаправление входного потока приводит к открытию на запись файла,
имя которого получается в результате подстановок в <b>слове</b>, через дескриптор
файла <b>n</b>, или как стандартного выходного потока (дескриптор файла 1), если <b>n</b>
не указано. Если файл не существует, он создается; если существует - он 
усекается до нулевого размера.</p>

<p>В общем случае перенаправление выходного потока имеет вид:</p>
<dl><dt></dt><dd><tt>
          [<b>n</b>]&gt;<b>слово</b>
</tt></dd></dl>

<p>Если используется оператор перенаправления <b>&gt;</b> и с помощью встроенной команды 
<b>set</b> установлена опция <a href="#noclobber"><b>noclobber</b></a>, перенаправление не будет выполнено, если
файл с соответствующим именем существует и является обычным файлом.
Если используется оператор перенаправления <b>&gt;|</b>, либо оператор 
перенаправления - <b>&gt;</b> и опция <b>noclobber</b> с помощью встроенной команды 
<a href="#set"><b>set</b></a> не 
установлена, перенаправление выполняется, даже если соответствующий файл существует.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="append_redir_stdout">Добавление перенаправленного вывода</a></h3>

<p>Такое перенаправление вывода приводит к открытию файла, имя которого получается
в результате подстановок в <b>слове</b>, в режиме добавления через дескриптор файла
<b>n</b>, или к добавлению в стандартный выходной поток (дескриптор файла 1) если
<b>n</b> не указано. Если файл не существует, он создается.</p>

<p>Перенаправление вывода на добавление имеет следующий общий вид:</p>
<dl><dt></dt><dd><tt>
          [<b>n</b>]&gt;&gt;<b>слово</b>
</tt></dd></dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="stdout_stderr_redir">Перенаправление стандартного выходного потока и стандартного потока ошибок</a></h3>

<p>Командный интерпретатор <b>bash</b> позволяет перенаправить как стандартный выходной
поток (дескриптор файла 1), так и стандартный поток ошибок (дескриптор файла 2)
в файл, имя которого получается в результате подстановок в <b>слове</b>.</p>

<p>Для этого предлагается два формата конструкции перенаправления:</p>
<dl><dt></dt><dd><tt>
          &amp;&gt;<b>слово</b>
</tt></dd></dl>
и
<dl><dt></dt><dd><tt>
          &gt;&amp;<b>слово</b>
</tt></dd></dl>

<p>Первый формат является предпочтительным. Эта конструкция семантически 
эквивалентна следующей:</p>
<dl><dt></dt><dd><tt>
          &gt;<b>слово</b> 2&gt;&amp;1
</tt></dd></dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="here_doc">Конструкция "документ здесь"</a></h3>

<p>При этом типе перенаправления командный интерпретатор будет читать входные 
данные из текущего файла, пока не встретится строка, содержащая только указанное
<b>слово</b> (без хвостовых пробелов). Все прочитанные до этого строки затем 
используются как стандартный входной поток для команды.</p>

<p>Конструкция "документ здесь" имеет следующий формат:</p>
<dl><dt></dt><dd><tt><pre>&lt;&lt;[-]<b>слово</b>
        <b>документ-здесь</b>
<b>ограничитель</b>
</pre></tt></dd></dl>

<p>В <b>слове</b> не выполняется подстановка значений параметров, результатов выполнения
команд, имен файлов или вычисление арифметических выражений. Если в <b>слове</b> есть 
замаскированный символ, <b>ограничитель</b> является результатом удаления символов 
маскировки из <b>слова</b>. Если в <b>слове</b> нет замаскированных символов, во всех строках 
"документа здесь" выполняется подстановка значений параметров, результатов
выполнения команд и вычисление арифметических выражений. В этом случае
пара <b>\&lt;перевод строки&gt;</b> игнорируется, и необходимо использовать <b>\</b> для маскировки
символов <b>\</b>, <b>$</b> и <b>`</b>.</p>

<p>Если в качестве оператора перенаправления используется &lt;&lt;-, то все
начальные табуляции из входных строк и строки, содержащей <b>ограничитель</b>,
удаляются. Это позволяет естственным образом выравнивать конструкции
"документ здесь" в сценариях командного интерпретатора.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="dupli_file_descr">Дублирование дескрипторов файлов</a></h3>

<p>Оператор перенаправления</p>
<dl><dt></dt><dd><tt>
          [<b>n</b>]&lt;&amp;<b>слово</b>
</tt></dd></dl>
<p>используется для дублирования дескрипторов входных файлов. Если в результате
подстановок <b>слово</b> представляет собой одну или несколько цифр, дескриптор
файла <b>n</b> становится копией соответствующего дескриптора файла. Если
файл с дескриптором, задаваемым цифрами <b>слова</b>, не открыт на чтение, возникает 
ошибка перенаправления. Если после подстановок в <b>слове</b> получается <b>-</b>,
файл с дескриптором <b>n</b> закрывается. Если <b>n</b> не указано, используется
стандартный входной поток (дескриптор файла 0).</p>

<p>Оператор</p>
<dl><dt></dt><dd><tt>
          [<b>n</b>]&gt;&amp;<b>слово</b>
</tt></dd></dl>
<p>используется аналогично для дублирования дескрипторов выходных файлов. Если
<b>n</b> не указано, используется стандартный выходной поток (дескриптор файла 1).
Если цифры в <b>слове</b> не задают дескриптор файла, открытого на запись, возникает
ошибка перенаправления. В качестве специального случая, если <b>n</b> не указано и <b>слово</b>
после подстановок не представляет собой одну или несколько цифр, стандартный
выходной поток и стандартный поток ошибок перенаправляются так, как было
описано выше.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="open_file_desc_rw">Открытие дескрипторов файлов для чтения и записи</a></h3>

<p>Оператор перенаправления</p>
<dl><dt></dt><dd><tt>
          [<b>n</b>]&lt;&gt;<b>слово</b>
</tt></dd></dl>
<p>вызывает открытие файла, имя которого получается в результате подстановок
в <b>слове</b>, для чтения и записи через дескриптор файла <b>n</b> или через дескриптор
файла 0, если <b>n</b> не указано. Если файл не существует, он создается.</p>

<h2><a name="aliases">ПСЕВДОНИМЫ</a></h2>

<p><i>Псеводнимы</i> позволяют подставлять вместо первого слова простой команды строку.
Командный интерпретатор поддерживает список псевдонимов, которые можно 
устанавливать и удалять с помощью встроенных команд <a href="#alias"><b>alias</b></a> и
<a href="#unalias"><b>unalias</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже). Первое слово
каждой команды, если оно не взято в кавычки, ищется в списке псевдонимов.
Если соответствующий псевдоним найден, слово заменяется текстом псевдонима.
Имя псевдонима и подставляемый текст может включать любые допустимые входные данные
для командного интерпретатора, включая перечисленные ранее <i>метасимволы</i>. 
Единственное исключение - имя псевдонима не может содержать знак <b>=</b>.
Первое слово текста псевдонима также ищется в списке псевдонимов, но если оно
совпадает с именем подставляемого псевдонима, повторной подстановки не 
происходит. Это означает, что можно задать псевдоним <b>ls</b> для <b>ls -F</b>,
например, и <b>bash</b> не будет пытаться выполнять рекурсивные подстановки в тексте
псевдонима. Если последний символ текста псевдонима - пробел, следующее за
псевдонимом слово исходной команды также ищется в списке псевдонимов и,
если найдено, заменяется.</p>

<p>Псевдонимы создаются и просматриваются с помощью комадны <a href="#alias"><b>alias</b></a>,
а удаляются с помощью команды <a href="#unalias"><b>unalias</b></a>.</p>

<p>Нет механизма передачи аргументов в подставляемый текст. Если необходимы
аргументы, используйте функцию командного интерпретатора.</p>

<p>Псевдонимы не подставляются, если командный интерпретатор не является 
интерактивным, если только с помощью встроенной команды <a href="#shopt"><b>shopt</b></a> 
не установлена опция <a href="#expand_aliases"><b>expand_aliases</b></a> 
(см. описание команды <a href="#shopt"><b>shopt</b></a> ниже, в разделе
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>").</p>

<p>Правила определения и использования псевдонимов несколько запутаны. 
Командный интерпретатор <b>bash</b> всегда читает по крайней мере одну
полную строку ввода, прежде чем выполнять любые указанные в ней команды.
Псевдонимы подставляются при чтении строки, а не при ее выполнении. Поэтому
определение псевдонима, заданное в одной строке с другой командой, не учитывается,
пока не будет прочитана следующая строка. Команды, идущие после определения
псевдонима в той же строке, этот новый псевдоним не учитывают. Это поведение
также необходимо учитывать при выполнении функций. Псевдонимы подставляются
при чтении определения функции, а не при ее выполнении, поскольку определение
функции само является составной командой. Как следствие, псевдонимы, определенные
в функции, не доступны до тех пор, пока функция не выполнится. Для простоты,
всегда задавайте определения псевдонимов в отдельной строке и не используйте
команду <a href="#alias"><b>alias</b></a> в составных командах.</p>

<p>Практически все варианты использования псевдонимов покрываются функциями
командного интерпретатора.</p>

<h2><a name="functions">ФУНКЦИИ</a></h2>

<p>Функция командного интерпретатора, определенная как было представлено ранее
в разделе "<a href="#shell_syntax"><b>СИНТАКСИС КОМАНД</b></a>", сохраняет под заданным именем 
последовательность команд для выполнения в дальнейшем. 
Функции выполняются в контексте текущего командного интерпретатора; для их
интерпретации не создается новый процесс (сравните с выполнением сценария
командного интерпретатора). При вызове функции ее аргументы становятся 
позиционными параметрами. Специальный параметр <b>#</b> обновляется, отражая
это изменение. Позиционный параметр 0 не изменяется. Все остальные особенности
среды выполнения командного интерпретатора у функции и вызывающей ее команды
идентичны, только обработчик сигнала <b>DEBUG</b> (см. описание встроенной команды
<a href="#trap"><b>trap</b></a> в разделе 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже) не наследуется.</p>

<p>Можно объявлять локальные переменные функции с помощью встроенной команды
<a href="#local"><b>local</b></a>. Обычно переменные и их значения совместно используются функцией и
вызвавшей ее командой.</p>

<p>Если в функции выполняется встроенная команда <a href="#return"><b>return</b></a>, эта функция
завершается, и выполнение продолжается со следующей команды после вызова 
функции. Когда функция завершается, восстанавливаются значения позиционных 
параметров и специального параметра <b>#</b>, которые были до выполнения функции.</p>

<p>Имена и определения функций можно получить с помощью опции <b>-f</b> встроенных
команд <a href="#declare"><b>declare</b></a> или <a href="#typeset"><b>typeset</b></a>. 
С опцией <b>-F</b> встроенные команды <a href="#declare"><b>declare</b></a> и 
<a href="#typeset"><b>typeset</b></a> будут выдавать только имена функций. Функции можно
экспортировать, с помощью опции <b>-f</b> встроенной команды <a href="#export"><b>export</b></a>,
так что они будут автоматически определены в порожденных командных 
интерпретаторах.</p>

<p>Функции могут быть рекурсивными. Глубина рекурсии не ограничена.</p>

<h2><a name="arithmetic_eval">ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</a></h2>

<p>Командный интерпретатор в определенных случаях обеспечивает вычисление 
арифметических выражений (см. встроенную команду <a href="#let"><b>let</b></a> и подраздел
"<a href="#arithmetic"><b>Подстановка арифметических выражений</b></a>" ранее). 
Вычисление выполняется в 
длинных целых числах без проверки переполнения, хотя деление на 0
перехватывается и выдается соответствующее сообщение об ошибке. 
Операторы в следующем списке сгруппированы по уровням с одинаковым
приоритетом. Уровни перечислены в порядке убывания приоритета.</p>
<dl>
<dt><b>- +</b></dt><dd>
унарные минус и плюс</dd>
<dt><b>! ~ </b></dt><dd>
логическое и побитовое отрицание</dd>
<dt><b>**</b></dt><dd>
возведение в степень</dd>
<dt><b>* / %</b></dt><dd>
умножение, деление, получение остатка от деления</dd>
<dt><b>+ -</b></dt><dd>
сложение, вычитание</dd>
<dt><b>&lt;&lt; &gt;&gt;</b></dt><dd>
побитовый сдвиг влево и вправо</dd>
<dt><b>&lt;= &gt;= &lt; &gt;</b></dt><dd>
сравнение</dd>
<dt><b>== !=</b></dt><dd>
равенство и неравенство</dd>
<dt><b>&amp;</b></dt><dd>
побитовое И</dd>
<dt><b>^</b></dt><dd>
побитовое исключающее ИЛИ</dd>
<dt><b>|</b></dt><dd>
побитовое ИЛИ</dd>
<dt><b>&amp;&amp;</b></dt><dd>
логическое И</dd>
<dt><b>||</b></dt><dd>
логическое ИЛИ</dd>
<dt><b>выражение?выражение:выражение</b></dt><dd>
условное вычисление</dd>
<dt><b>= *= /= %= += -=</b></dt><dd>
присваивание</dd>
</dl>

<p>В качестве операндов можно использовать переменные командного интерпретатора;
перед вычислением выполняется подстановка значений параметров. Значение
параметра в арифметическом выражении приводится к длинному целому. 
Чтобы переменную командного интерпретатора можно было использовать в
арифметических выражениях, ее атрибут <b>integer</b> устанавливать
не обязательно.</p>

<p>Константы с начальным 0 интерпретируются как восьмеричные числа.
Начальные <b>0x</b> или <b>0X</b> обозначают шестнадцатеричную константу.
В остальных случаях числа имеют вид <b>[основание#]n</b>, где <b>основание</b> -
десятичное число от 2 до 64, представляющее основание системы счисления,
а <b>n</b> - число в этой системе счисления. Если основание не указано,
используется основание 10. Цифры, большие 9, представляются
строчными буквами, прописными буквами, символами <b>_</b> и <b>@</b>, именно в таком порядке.
Если основание меньше или равно 36, прописные и строчные буквы эквивалентны и
используются для представления чисел от 10 до 35.</p>

<p>Операторы вычисляются в порядке приоритетов. Сначала вычисляются подвыражения в
круглых скобках, которые позволяют переопределить представленные выше
стандартные приоритеты операторов.</p>

<h2><a name="conditional_expr">УСЛОВНЫЕ ВЫРАЖЕНИЯ</a></h2>

<p>Условные выражения используются составной командой <b>[[</b> и встроенными командами
<a href="#test"><b>test</b></a> и <b>[</b> для проверки атрибутов файла и выполнения 
строковых и арифметических
сравнений. Выражения формируются из следующих унарных и бинарных элементарных
условий. Если любой из аргументов <b>файл</b> в одном из условий имеет вид <b>/dev/fd/n</b>, 
проверяется файл с дескриптором <b>n</b>.</p>
<dl>
<dt><b>-a файл</b></dt><dd>
Истинно, если <b>файл</b> существует.</dd>
<dt><b>-b файл</b></dt><dd>
Истинно, если <b>файл</b> существует и являтся специальным блочным устройством.</dd>
<dt><b>-c файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является специальным символьным устройством.</dd>
<dt><b>-d файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является каталогом.</dd>
<dt><b>-e файл</b></dt><dd>
Истинно, если <b>файл</b> существует</dd>
<dt><b>-f файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является обычным файлом.</dd>
<dt><b>-g файл</b></dt><dd>
Истинно, если <b>файл</b> существует и имеет установленный бит <b>SGID</b>.</dd>
<dt><b>-h файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является символической связью.</dd>
<dt><b>-k файл</b></dt><dd>
Истинно, если <b>файл</b> существует и имеет установленный "клейкий" бит.</dd>
<dt><b>-p файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является именованным каналом (FIFO).</dd>
<dt><b>-r файл</b></dt><dd>
Истинно, если <b>файл</b> существует и доступен для чтения.</dd>
<dt><b>-s файл</b></dt><dd>
Истинно, если <b>файл</b> существует и имеет ненулевой размер.</dd>
<dt><b>-t fd</b></dt><dd>
Истинно, если дескриптор файла <b>fd</b> открыт и связан с терминалом.</dd>
<dt><b>-u файл</b></dt><dd>
Истинно, если <b>файл</b> существует и имеет установленный бит <b>SUID</b>.</dd>
<dt><b>-w файл</b></dt><dd>
Истинно, если <b>файл</b> существует и доступен для записи.</dd>
<dt><b>-x файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является выполняемым.</dd>
<dt><b>-O файл</b></dt><dd>
Истинно, если <b>файл</b> существует и принадлежит пользователю, задаваемому текущим
эффективным идентификатором пользователя.</dd>
<dt><b>-G файл</b></dt><dd>
Истинно, если <b>файл</b> существует и принадлежит группе, задаваемой текущим
эффективным идентификатором группы.</dd>
<dt><b>-L файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является символической связью.</dd>
<dt><b>-S файл</b></dt><dd>
Истинно, если <b>файл</b> существует и является сокетом.</dd>
<dt><b>-N файл</b></dt><dd>
Истинно, если <b>файл</b> существует и был изменен с момента последнего чтения.</dd>
<dt><b>файл1 -nt файл2</b></dt><dd>
Истинно, если <b>файл1</b> новее (в соответствии с датой изменения), чем <b>файл2</b>.</dd>
<dt><b>файл1 -ot файл2</b></dt><dd>
Истинно, если <b>файл1</b> старее, чем <b>файл2</b>.</dd>
<dt><b>файл1 -ef файл2</b></dt><dd>
Истинно, если <b>файл1</b> и <b>файл2</b> находятся на одном устройстве и имеют одинаковые
номера индексных дескрипторов.</dd>
<dt><b>-o опция</b></dt><dd>
Истинно, если установлена указанная <b>опция</b> командного интерпретатора. Список
опций см. далее в описании опции <a href="#set-o"><b>-o</b></a> встроенной 
команды <a href="#set"><b>set</b></a>.</dd>
<dt><b>-z строка</b></dt><dd>
Истинно, если длина <b>строки</b> - ноль (т.е. строка - пустая).</dd>
<dt><b>-n строка<br>
строка</b></dt><dd>
Истинно, если длина <b>строки</b> - не ноль.</dd>
<dt><b>строка1 == строка2</b></dt><dd>
Истинно, если строки совпадают. Вместо <b>==</b> можно использовать просто <b>=</b>.</dd>
<dt><b>строка1 != строка2</b></dt><dd>
Истинно, если строки не совпадают.</dd>
<dt><b>строка1 &lt; строка2</b></dt><dd>
Истинно, если <b>строка1</b> в текущей локали при лексикографическом
упорядочении предшествует <b>строке2</b>.</dd>
<dt><b>строка1 &gt; строка2</b></dt><dd>
Истинно, если <b>строка1</b> в текущей локали при лексикографическом
упорядочении идет после <b>строки2</b>.</dd>
<dt><b>arg1 OP arg2</b></dt><dd>
Оператор <b>OP</b> - один из следующих: <b>-eq</b>, <b>-ne</b>, <b>-lt</b>,
<b>-le</b>, <b>-gt</b> или <b>-ge</b>. Эти бинарные арифметические операторы возвращают 
истину, если <b>arg1</b> равен, не равен, меньше, меньше или равен,больше, больше или равен
<b>arg2</b>, соответственно. Аргументы <b>arg1</b> и <b>arg2</b> могут быть любыми целыми числами.</dd>
</dl>

<h2><a name="simple_command">ОБРАБОТКА ПРОСТОЙ КОМАНДЫ</a></h2>

<p>При обработке простой команды командный интерпретатор делает, слева направо,
следующие подстановки, присваивания и перенаправления.</p>

<ol>
<li>Слова, помеченные синтаксическим анализатором как присваивания переменным 
(те, что идут перед именем команды) и перенаправления, сохраняются для
дальнейшей обработки.</li>
<li>В остальных словах выполняются подстановки и замены. Если после этого
остались какие-то слова, первое из них считается именем команды, а остальные -
ее аргументами.</li>
<li>Перенаправления выполняются так, как описано ранее 
в разделе "<a href="#redirection"><b>ПЕРЕНАПРАВЛЕНИЕ</b></a>".</li>
<li>В тексте после <b>=</b> в каждом присваивании переменной перед присваиванием 
выполняется замена тильды, подстановка значений параметров, подстановка 
результатов выполнения команд и вычисление арифметических выражений, а также
удаление кавычек.</li>
</ol>

<p>Если в результате имени команды нет, присваивания переменным влияют на среду
текущего командного интерпретатора. В противном случае, переменные добавляются в 
среду выполняемой команды и не влияют на среду текущего командного 
интерпретатора. Если происходит попытка присвоить значение переменной с атрибутом
только для чтения, выдается сообщение об ошибке и команда завершается с
ненулевым статусом выхода.</p>

<p>Если в результате имени команды нет, перенаправления выполняются,
но не влияют на среду текущего командного интерпретатора. При ошибке
перенаправления команда завершается с ненулевым статусом выхода.</p>

<p>Если после подстановок имя команды осталось, выполнение продолжается так,
как описано ниже. В противном случае, выполнение команды завершается.
При этом если выполнялись подстановки результатов выполнения команд,
статус выхода будет равен статусу последней команды, результаты которой были
подставлены. Если подстановок результатов выполнения команд не было, команда
завершается со статусом выхода ноль.</p>

<h2><a name="command_exec">ВЫПОЛНЕНИЕ КОМАНДЫ</a></h2>

<p>После разбиения команды на слова, если в результате получилась простая команда
с необязательным списком аргументов, выполняются следующие действия.</p><p>

</p><p>Если имя команды не содержит сиволов косой черты, командный интерпретатор
пытается ее найти. Если существует функция командного интерпретатора с
таким именем, она вызывается как было описано выше 
в разделе "<a href="#functions"><b>ФУНКЦИИ</b></a>".
Если же функции с таким именем нет, командный интерпретатор ищет ее в списке
встроенных команд. Если такая встроенная команда есть, она выполняется.</p>

<p>Если имя не является именем функции или именем встроенной команды и не содержит
пробелы, командный интерпретатор <b>bash</b> просматривает каждый
каталог в значении переменной <b>PATH</b> в поисках выполняемого файла с 
соответствующим именем. Для запоминания полных имен выполняемых файлов
<b>bash</b> использует хэш-таблицу (см. описание команды <a href="#hash"><b>hash</b></a> 
в разделе "<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" далее). 
Полный поиск по каталогам в <b>PATH</b>
выполняется только если команда не найдена в этой хэш-таблице.
Если команда при таком поиске не найдена, командный интерпретатор выдает 
соответствующее сообщение и завершает выполнение команды со статусом выхода 127.</p>

<p>Если команда найдена или имя команды содержит косые черты, командный 
интерпретатор выполняет соответствующую команду в отдельной среде выполнения.
Аргумент 0 устанавливается равным имени команды, и ей передаются параметры,
соответствующие аргументам в командной строке, если они заданы.</p>

<p>Если выполнить команду не удалось, потому что файл не соответствует поддерживаемым 
выполняемым форматам, и этот файл не является каталогом, предполагается,
что файл является <i>сценарием командного интерпретатора</i>, содержащим его команды.
Для его выполнения запускается порожденный командный интерпретатор. Этот
порожденный командный интерпретатор переинициализируется, как если бы для
обработки сценария был вызван новый командный интерпретатор, но только 
местонахождения команд, запомненные родительским интерпретатором (см. описание
команды <a href="#hash"><b>hash</b></a> ниже в разделе 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>"),
передаются порожденному.</p>

<p>Если текст в файле начинается с <b>#!</b>, остаток первой строки задает интерпретатор
для программы. Командный интерпретатор запускает указанный интерпретатор
в операционных системах, которые не поддерживают соответствующий формат 
выполняемого файла непосредственно. Этому интерпретатору в качестве аргументов
передается один необязательный аргумент, затем имя интерпретатора из первой
строки программы, затем имя самой программы и ее аргументы, если они заданы.</p>

<h2><a name="shell_exec_env">СРЕДА ВЫПОЛНЕНИЯ КОМАНД</a></h2>

<p>У командного интерпретатора есть <i>среда выполнения</i>, содержащая следующие
компоненты:</p>
<ul>
<li>открытые файлы, унаследованные командным интерпретатором при вызове, с учетом
изменений, вызванных перенаправлениями, переданными встроенной 
команде <a href="#exec"><b>exec</b></a></li>

<li>текущий рабочий каталог, установленный командами <a href="#cd"><b>cd</b></a>, 
<a href="#pushd"><b>pushd</b></a> или <a href="#popd"><b>popd</b></a>, 
или унаследованный командным интерпретатором при вызове</li>

<li>маска режима создания файла, установленная с помощью команды <a href="#umask"><b>umask</b></a>
или унаследованная от родительского процесса</li>

<li>текущие обработчики сигналов, установленные с помощью <a href="#trap"><b>trap</b></a></li>

<li>параметры командного интерпретатора, установленные путем присваивания 
переменным или унаследованные из среды родительского процесса</li>

<li>функции командного интерпретатора, заданные в ходе выполнения или унаследованные
из среды родительского процесса</li>

<li>опции, установленные при вызове (как стандартные, так и заданные явно в 
командной строке) или установленные с помощью комнады <a href="#set"><b>set</b></a></li>

<li>опции, установленные с помощью команды <a href="#shopt"><b>shopt</b></a></li>

<li>псевдонимы, заданные с помощью команды <a href="#alias"><b>alias</b></a></li>

<li>идентификаторы различных процессов, в том числе, для фоновых заданий, значение
параметра <b>$$</b> и значение параметра <b>$PPID</b></li>
</ul>

<p>Когда необходимо выполнить команду, не являющуюся встроенной или функцией
командного интерпретатора, она вызывается в отдельной среде выполнения, 
состоящей из указанных ниже компонентов. Если не указано иначе, все значения
наследуются от командного интерпретатора.</p>
<ul>
<li>открытые файлы командного интерпретатора плюс любые изменения и дополнения,
заданные для команды перенаправлениями</li>

<li>текущий рабочий каталог</li>

<li>маска режима создания файлов</li>

<li>переменные командного интерпретатора, помеченные как экспортированные, а также 
переменные, экспортированные для команды и переданные в среде</li>

<li>наследуются установленные в родительском командном интерпретаторе обработчики
сигналов, а сигналы, в нем игнорировавшиеся, также игнорируются.</li>
</ul>
<p>Команда, вызванная в этой отдельной среде, не может повлиять на среду
выполнения родительского командного интерпретатора.</p>

<p>Команды, результаты которых необходимо подставить, и асинхронные команды 
вызываются в средах порожденных командных интерпретаторов, которые совпадают
со средой родительского, но обработчки сигналов устанавливаются такие, как были 
унаследованы родительским командным интерпретатором при вызове.
Встроенные команды, вызываемые как часть конвейера, также выполняются в среде 
порожденного командного интерпретатора. Изменения в среде порожденного
командного интерпретатора не затрагивают среду выполнения родительского.</p>

<h2><a name="environment">СРЕДА</a></h2>

<p>При вызове программы ей передается массив строк, который называют <i>средой</i>.
Это список пар имя-значение вида <b>name=value</b>.</p>

<p>Командный интерпретатор позволяет манипулировать средой несколькими способами.
При вызове командный интерпретатор просматривает свою среду и создает 
одноименный параметр для каждого имени, автоматически <i>экспортируя</i> его для
порожденных процессов. Выполняемые команды наследуют среду. Команды
<a href="#export"><b>export</b></a> и <a href="#declare"><b>declare  -x</b></a>  
позволяют добавлять и удалять параметры и функции из 
среды. Если значение параметра, входящего в среду, изменено, новое значение
становится частью среды, заменяя старое. Среда, наследуемая выполняемой командой,
состоит из начальной среды командного интерпретатора, значения которой могли
быть изменены в ходе его работы, за исключением пар, удаленных с помощью
команды <a href="#unset"><b>unset</b></a>, и новых параметров, добавленных с 
помощью команд <a href="#export"><b>export</b></a> и <a href="#declare"><b>declare -x</b></a>.</p>

<p>Среда для любой <i>простой команды</i> или функции может быть временно дополнена путем
задания перед именем присваиваний параметрам, как описано ранее в разделе
"<a href="#parameters"><b>ПАРАМЕТРЫ</b></a>". Эти операторы присваивания влияют 
только на среду вызываемой команды.</p>

<p>Если установлена опция <a href="#set-k"><b>-k</b></a>, (см. описание встроенной команды 
<a href="#set"><b>set</b></a> ниже), то все параметры с присвоенными при вызове значениями, 
а не только предшествующие имени команды, помещаются в ее среду.</p>

<p>Когда командный интерпретатор <b>bash</b> вызывает внешнюю команду, переменная <b>_</b>
устанавливается равной полному имени файла команды и передается этой команде
в среде.</p>

<h2><a name="exit_status">СТАТУС ВЫХОДА</a></h2>

<p>С точки зрения командного интерпретатора, команда, завершившаяся со статусом
выхода 0, сработала успешно. Статус выхода 0 означает успешное завершение.
Ненулевой статус выхода означает неудачу. Если работа команды прервана сигналом,
командный интерпретатор <b>bash</b> использует в качестве статуса выхода
значение 128+сигнал.</p>

<p>Если команда не найдена, порожденный для ее выполнения процесс возвращает
статус выхода 127. Если команда найдена, но не является выполняемой, 
возвращается статус выхода 126.</p>

<p>Если команда не сработала, поскольку ошибка произошла при подстановках или 
перенаправлениях, возвращается положительный статус выхода.</p>

<p>Встроенные команды интерпретатора возвращают статус 0 (<b>истина</b>) при успешном
выполнении, и ненулевой статус (<b>ложь</b>), если при выполнении произошла ошибка.
При некорректном использовании все встроенные команды возвращают статус 2.</p>

<p>Сам командный интерпретатор <b>bash</b> возвращает статус выхода последней выполненной
команды, если только не обнаруживает синтаксическую ошибку. В этом случае
он завершает работу с ненулевым статусом. См. также описание встроенной
команды <a href="#exit"><b>exit</b></a> ниже.</p>

<h2><a name="signals">СИГНАЛЫ</a></h2>

<p>Когда командный интерпретатор <b>bash</b> работает в интерактивном режиме,
при отсутствии обработчиков сигналов, он игнорирует сигнал <b>SIGTERM</b> (так что
команда <a href="#kill"><b>kill 0</b></a> не прекращает работу интерактивного 
командного интерпретатора),
а сигнал <b>SIGINT</b> перехватывается и обрабатывается (так, что встроенная команда
<a href="#wait"><b>wait</b></a> им не прерывается). Во всех случаях, 
<b>bash</b> игнорирует сигнал <b>SIGQUIT</b>.
Если действует управление заданиями, <b>bash</b> игнорирует сигналы <b>SIGTTIN</b>,
<b>SIGTTOU</b> и <b>SIGTSTP</b>.</p>

<p>У синхронных заданий, запущенных командным интерпретатором <b>bash</b>,
устанавливаются обработчики сигналов, унаследованные командным интерпретатором
от родительского процесса. Если управление заданиями не действует, асинхронные
команды также игнорируют сигналы <b>SIGINT</b> и <b>SIGQUIT</b>. Команды, выполняемые для
подстановки результатов выполнения, игнорируют сигналы управления заданиями
<b>SIGTTIN</b>, <b>SIGTTOU</b> и <b>SIGTSTP</b>, посланные с клавиатуры.</p>

<p>По умолчанию командный интерпретатор завершает работу при получении сигнала
<b>SIGHUP</b>. Перед завершением он посылает сигналы <b>SIGHUP</b> всем заданиям, как
выполняющимся, так и остановленным. Остановленным заданиям предварительно 
посылается сигнал <b>SIGCONT</b>, гарантирующий получение ими сигнала <b>SIGHUP</b>. Для
предотвращения послыки интерпретатором сигнала конкретному заданию, его
необходимо удалить из таблицы заданий с помощью встроенной 
команды <a href="#disown"><b>disown</b></a>
(см. раздел "<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" далее) 
или пометить как не получающие сигнал <b>SIGHUP</b> 
с помощью <a href="#disown"><b>disown -h</b></a>.</p>

<p>Если с помощью команды <a href="#shopt"><b>shopt</b></a> установлена опция 
командного интерпретатора <a href="#huponexit"><b>huponexit</b></a>, 
<b>bash</b> посылает сигнал <b>SIGHUP</b> всем заданиям при завершении
работы интерактивного начального командного интерпретатора.</p>

<p>При получении командным интерпретатором <b>bash</b> сигнала, для которого установлен
обработчик, в то время, когда ожидается завершение команды, обработчик
не выполняется, пока команда не завершится. Когда <b>bash</b> ожидает завершения
асинхронной команды с помощью встроенной команды <a href="#wait"><b>wait</b></a>, 
получение сигнала, для которого установлен обработчик, приводит к немедленному 
завершению встроенной команды <a href="#wait"><b>wait</b></a> со статусом выхода 
более 128 сразу же после выполнения кода обработчика.</p>

<h2><a name="job_control">УПРАВЛЕНИЕ ЗАДАНИЯМИ</a></h2>

<p><i>Управление заданиями</i> - это возможность избирательно останавливать 
(<i>приостанавливать</i>) выполнение процессов и продолжать (<i>возобновлять</i>)
их выполнение в дальнейшем. Пользователи обычно делают это через 
интерактивный интерфейс, совместно реализуемый драйвером терминала и
командным интерпретатором <b>bash</b>.</p>

<p>Командный интерпретатор связывает <i>задание</i> с каждым конвейером. Он поддерживает
таблицу выполняющихся заданий, которую можно просматривать с помощью
команды <a href="#jobs"><b>jobs</b></a>. 
При запуске задания асинхронно (<i>в фоновом режиме</i>) <b>bash</b> 
выдает строку следующего вида:</p>
<dl><dt></dt><dd><tt>
          [1] 25647
</tt></dd></dl>
<p>показывающую, что это задание с номером 1, а идентификатор последнего
процесса в конвейере, связанном с данным заданием - 25647. Все процессы в одном
конвейере являются частями одного задания. Командный интерпретатор <b>bash</b>
использует понятие <i>задания</i> как основу для управления заданиями.</p>

<p>Для упрощения реализации пользовательского интерфейса для управления заданиями
система поддерживает понятие <i>идентификатора группы процессов текущего терминала</i>.
Члены этой группы процессов (процессы, идентификатор группы процессов которых
равен идентификатору группы процессов терминала) получают сигналы с клавиатуры,
например, сигнал <b>SIGINT</b>. Эти процессы называют <i>приритетными</i> (процессами переднего
плана). <i>Фоновые</i> процессы - это те, идентификатор группы процессов которых не
совпадает с терминальным; таким процессам сигналы с клавиатуры не посылаются.
Только приоритетные процессы могут читать данные с терминала и выдавать
данные в него. Фоновые процессы, пытающиеся читать с терминала (или выдавать 
в него данные) получают от драйвера терминала сигнал <b>SIGTTIN</b> (<b>SIGTTOU</b>),
который, если не перехвачен, приостанавливает работу процесса.</p>

<p>Если операционная система, в которой работает <b>bash</b>, поддерживает управление
заданиями, <b>bash</b> позволяет его использовать. При нажатии клавиши <i>приостановки</i>
(обычно <b>^Z</b>, <b>Control-Z</b>) по ходу работы процесса, этот процесс останавливается и
управление возвращается командному интерпретатору <b>bash</b>. При нажатии клавиши
<i>отложенной приостановки</i> (обычно <b>^Y</b>, <b>Control-Y</b>) процесс останавливается при 
попытке чтения данных с терминала, и управление возвращается командному
интерпретатору <b>bash</b>. Затем пользователь может управлять состоянием этого задания,
используя команду <a href="#bg"><b>bg</b></a> для его продолжения в фоновом режиме, 
команду <a href="#fg"><b>fg</b></a> - для
продолжения в приоритетном режиме или команду <a href="#kill"><b>kill</b></a> для его прекращения.
Нажатие <b>^Z</b> срабатывает немедленно и имеет дополнительный побочный
эффект в виде сброса данных, ожидающих вывода и ввода.</p>

<p>Командный интерпретатор поддерживает несколько способов сослаться на задание.
Символ <b>%</b> означает начало имени задания. На задание с номером <b>n</b> можно
сослаться как <b>%n</b>. На задание можно сослаться также с помощью префикса имени
команды, использованной для его начала, или подстроки, входящей в 
соответствующую командную строку. Например, <b>%ce</b> ссылается на остановленное 
задание <b>ce</b>. Если префикс соответствует нескольким заданиям, <b>bash</b> выдает
сообщение об ошибке. Обращение вида <b>%?ce</b>, с другой стороны, ссылается на любое
задание, в командной строке которого содержится подстрока <b>ce</b>. Если эта 
подстрока содержится в нескольких заданиях, <b>bash</b> выдает сообщение об ошибке.
Строки <b>%%</b> и <b>%+</b> обозначают <i>текущее задание</i> командного интерпретатора -
последнее задание, остановленное при работе в приоритетном режиме или запущенное в
фоновом режиме. На <i>предыдущее задание</i> можно сослаться с помощью строки <b>%-</b>.
В результатах работы команд, связанных с управлением заданиями, (в частности,
в результатах выполнения команды <a href="#jobs"><b>jobs</b></a>), текущее задание всегда 
помечается знаком <b>+</b>, а предыдущее - знаком <b>-</b>.</p>

<p>Для перевода задания в приоритетный режим достаточно ввести только его имя:
<b>%1</b> - это синоним для команды "<b>fg %1</b>", переводящей задание 1 из фонового
в приоритетный режим. Аналогично, команда "<b>%1  &amp;</b>" продолжает работу задания
1 в фоновом режиме и эквивалентна команде "<b>bg %1</b>".</p>

<p>Об изменении состояния задания командный интерпретатор узнает сразу.
Обычно <b>bash</b> информирует об изменениях в состоянии заданий при выдаче очередного
приглашения, чтобы не прерывать этой информацией выдачу любых других результатов.
Если с помощью встроенной команды <a href="#set"><b>set</b></a> установлена 
опция <a href="#set-b"><b>-b</b></a>, <b>bash</b> информирует о таких изменениях немедленно.</p>

<p>Если при наличии остановленных заданий происходит попытка выхода из <b>bash</b>,
командный интерпретатор выдает соответствующее предупреждение. Затем
с помощью команды <a href="#jobs"><b>jobs</b></a> можно проверить состояние этих заданий. Если
сразу же выполняется повторная попытка завершить работу, командный интерпретатор не выдает
предупреждения и остановленные задания прекращаются.</p>

<h2><a name="prompting">ПРИГЛАШЕНИЯ</a></h2>

<p>При интерактивной работе командный интерпретатор <b>bash</b> выдает первичное 
приглашение, <b>PS1</b>, когда он готов к вводу команды, и вторичное приглашение,
<b>PS2</b>, когда для завершения команды необходимы дополнительные данные. 
Командный интерпретатор <b>bash</b> позволяет настраивать эти строки приглашения 
с помощью ряда маскируемых обратной косой специальных символов со следующими
значениями:</p>
<dl><dt></dt><dd>
<table cellspacing="4" width="90%" border="0">
<tbody><tr width="10%" valign="top"><td><b>\a</b></td><td>
символ сигнала ASCII (звонок - 07)</td></tr>
<tr valign="top"><td><b>\d</b></td><td>
дата в формате "День_недели Месяц Число" (т.е., "Tue May 26")</td></tr>
<tr valign="top"><td><b>\e</b></td><td>
управляющий символ ASCII (033)</td></tr>
<tr valign="top"><td><b>\h</b></td><td>
имя хоста вплоть до первого символа '<b>.</b>'</td></tr>
<tr valign="top"><td><b>\H</b></td><td>
имя хоста</td></tr>
<tr valign="top"><td><b>\n</b></td><td>
перевод строки</td></tr>
<tr valign="top"><td><b>\r</b></td><td>
возврат каретки</td></tr>
<tr valign="top"><td><b>\s</b></td><td>
имя командного интерпретатора - базовое имя из параметра <b>$0</b> (часть полного
имени после последней косой черты)</td></tr>
<tr valign="top"><td><b>\t</b></td><td>
текущее время в 24-часовом формате <b>ЧЧ:ММ:СС</b></td></tr>
<tr valign="top"><td><b>\T</b></td><td>
текущее время в 12-часовом формате <b>ЧЧ:ММ:СС</b></td></tr>
<tr valign="top"><td><b>\@</b></td><td>
текущее время в 12-часовом формате am/pm (утра/вечера)</td></tr>
<tr valign="top"><td><b>\u</b></td><td>
имя текущего пользователя</td></tr>
<tr valign="top"><td><b>\v</b></td><td>
версия командного интерпретатора <b>bash</b> (например, 2.00)</td></tr>
<tr valign="top"><td><b>\V</b></td><td>
релиз командного интерпретатора <b>bash</b>, версия + уровень исправлений 
(например, 2.00.0)</td></tr>
<tr valign="top"><td><b>\w</b></td><td>
текущий рабочий каталог</td></tr>
<tr valign="top"><td><b>\W</b></td><td>
базовое имя текущего рабочего каталога</td></tr>
<tr valign="top"><td><b>\!</b></td><td>
порядковый номер данной команды в списке истории</td></tr>
<tr valign="top"><td><b>\#</b></td><td>
порядковый номер данной команды</td></tr>
<tr valign="top"><td><b>\$</b></td><td>
если эффективный идентификатор пользователя - 0, то <b>#</b>, иначе - <b>$</b></td></tr>
<tr valign="top"><td><b>\nnn</b></td><td>
символ, соответствующий восьмеричному числу <b>nnn</b></td></tr>
<tr valign="top"><td><b>\\</b></td><td>
обратная косая</td></tr>
<tr valign="top"><td><b>\[</b></td><td>
начало последовательности непечатных символов, которая может использоваться 
для включения в приглашение управляющих символов терминала</td></tr>
<tr valign="top"><td><b>\]</b></td><td>
завeршение последовательности непечатных символов</td></tr>
</tbody></table>
</dd></dl>

<p>Порядковый номер команды и порядковый номер команды в списке истории обычно
различаются: порядковый номер в списке истории задает ее позицию в списке,
который может содержать команды, прочитанные из файла истории
(см. раздел "<a href="#history"><b>ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</b></a>" далее), тогда как порядковый
номер команды задает ее позицию в списке команд, выполненных в текущем сеансе
командного интерпретатора. После декодирования строки приглашения в ней
выполняется подстановка значений параметров, подстановка результатов выполнения
команд, результатов вычисления арифметических выражений, подстановка строк и
удаление кавычек, в зависимости от значения опции командного интерпретатора
<a href="#promptvars"><b>promptvars</b></a> 
(см. описание команды <a href="#shopt"><b>shopt</b></a> в разделе 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" далее).</p>

<h2><a name="readline">БИБЛИОТЕКА READLINE</a></h2>

<p>Это библиотека, обрабатывающая входные данные при работе командного
интерпретатора в интерактивном режиме, если при его вызове не была указана
опция <a href="#noediting"><b>--noediting</b></a>. По умолчанию, команды редактирования 
строки подобны используемым в редакторе <b>emacs</b>. Также предоставляется интерфейс для 
редактирования командной строки в стиле редактора <b>vi</b>. Для отключения 
возможности редактирования после запуска командного интерпретатора используются
опции <b>+o emacs</b> или <b>+o vi</b> встроенной команды <a href="#set"><b>set</b></a> 
(см. раздел "<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже).</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_notation">Соглашения по записи команд readline</a></h3>

<p>В этом разделе для записи нажимаемых клавиш используются соглашения в стиле
редактора <b>emacs</b>. <i>Управляющие клавиши</i> обозначаются <b>C-клавиша</b>, так что <b>C-n</b>
сокращенно обозначает <b>Control-N</b>. Аналогично, <i>метаклавиши</i> обозначаются
<b>M-клавиша</b>, так что <b>M-x</b> обозначает <b>Meta-X</b>. (На клавиатурах, где нет клавиши 
<b>meta</b>, <b>M-x</b> обозначает <b>ESC x</b>, т.е. нажать клавишу <b>Escape</b> и затем 
нажать клавишу <b>x</b>. Тем самым, клавиша <b>ESC</b> реализует префикс <b>meta</b>. 
Комбинация <b>M-C-x</b> обозначает <b>ESC-Control-x</b>, или нажать клавишу <b>Escape</b>,
затем, удерживая клавишу <b>Control</b>, нажать клавишу <b>x</b>.)</p>

<p>Команды библиотеки <b>readline</b> могут иметь числовые <i>аргументы</i>, обычно обозначающие 
количество повторений. Иногда, однако, они являются признаком значимости аргумента.
Передача отрицательного аргумента команде, работающей с дальнейшим текстом
(например, <b>kill-line</b>) приводит к ее применению к предшествующему тексту.
Команды, работа которых отличается от описанной здесь, специально отмечены ниже.</p>

<p>Если команда <i>удаляет</i> текст, этот текст сохраняется для дальнейшего извлечения 
(вставки). Удаленый текст помещается в кольцевой буфер. Последовательные удаления
пополняют буфер, формируя единицу вставки. Команды, не удаляющие текст,
разделяют фрагменты в кольцевом буфере удаления.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_init">Инициализация библиотеки readline</a></h3>

<p>Библиотека <b>readline</b> настраивается с помощью команд в <i>файле инициализации</i>
(файл <b>inputrc</b>). В качестве имени этого файла берется значение переменной
<b>INPUTRC</b>. Если эта переменная не установлена, используется стандартный файл,
<b>~/.inputrc</b>. При запуске программы, использующей библиотеку <b>readline</b>, 
файл инициализации читается и устанавливаются соответствующие переменные
и горячие клавиши. В файле инициализации <b>readline</b> допускаются лишь несколько
простых конструкций. Пустые строки игнорируются. Строки, начинающиеся символом
<b>#</b>, являются <i>комментариями</i>. Строки, начинающиеся символом <b>$</b>, обозначают <i>условные
конструкции</i>. Остальные строки обозначают установки горячих клавиш и присваивания
значений переменным.</p>

<p>Стандартные горячие клавиши можно изменить в файле <b>inputrc</b>. Другие программы, 
использующие эту библиотеку, могут добавлять собственные команды и горячие 
клавиши.</p>

<p>Например, поместив в файл инициализации</p>
<dl><dt></dt><dd><tt>
M-Control-u: universal-argument
</tt></dd></dl>
или
<dl><dt></dt><dd><tt>
C-Meta-u: universal-argument
</tt></dd></dl>
<p>мы привязываем к комбинации клавиш <b>M-C-u</b> команду <b>universal-argument</b> библиотеки
<b>readline</b>.</p>

<p>Распознаются следующие имена символов: <b>RUBOUT</b>, <b>DEL</b>, <b>ESC</b>, 
<b>LFD</b>, <b>NEWLINE</b>, <b>RET</b>, <b>RETURN</b>, <b>SPC</b>, <b>SPACE</b> и <b>TAB</b>. Кроме
имен команд, библиотека <b>readline</b> позволяет привязывать к клавишам строки,
которые будут вставляться при их нажатии (т.е. задвать макроподстановки).</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_bindings">Горячие клавиши readline</a></h3>

<p>Привязки клавиш в файле <b>inputrc</b> задаются с помощью простого синтаксиса.
Необходимо указать только имя команды или текст макроподстановки, и горячие
клавиши, с которыми его надо связать. Горячие клавиши можно задавать двумя 
способами: как символическое имя клавиши, возможно, с префиксом <b>Meta-</b> или 
<b>Control-</b>, или как комбинацию клавиш. При использовании формы 
<b>имя_клавиши:имя_функции или макроподстановка</b>, <b>имя_клавиши</b> просто задается на
английском. Например:</p>
<dl><dt></dt><dd><tt>
Control-u: universal-argument<br>
Meta-Rubout: backward-kill-word<br>
Control-o: "&gt; output"
</tt></dd></dl>
<p>В этом примере комбинация клавиш <b>C-u</b> связывается с функцией <b>universal-argument</b>,
<b>M-DEL</b> - с функцией <b>backward-kill-word</b>, а <b>C-o</b> - с макроподстановкой, указанной 
в правой части (т.е. приведет к вставке текста <b>&gt; output</b> в строку).</p>

<p>Во второй форме, <b>"комбинация_клавиш":имя_функции или макроподстановка</b>, комбинация
клавиш отличается от использованного выше имени клавиши тем, что может
задаваться в двойных кавычках. При этом можно использовать некоторые
управляющие символы в стиле GNU Emacs, как в следующем примере.</p>
<dl><dt></dt><dd><tt>
"\C-u": universal-argument<br>
"\C-x\C-r": re-read-init-file<br>
"\e[11~": "Function Key 1"
</tt></dd></dl>
<p>В этом примере, комбинация клавиш <b>C-u</b> опять связывается с функцией
<b>universal-argument</b>. Комбинация <b>C-x C-r</b> связывается с функцией <b>re-read-init-file</b>,
а комбинация <b>ESC [ 1 1 ~</b> будет приводить к вставке текста <b>Function Key 1</b>.
Полный набор управляющих последовательностей в стиле GNU Emacs представлен ниже.</p>
<dl><dt></dt><dd>
<table cellspacing="4" width="90%" border="0">
<tbody><tr><td width="10%"><b>\C-</b></td><td>
префикс клавиши <b>Control</b></td></tr>
<tr><td><b>\M-</b></td><td>
префикс клавиши <b>Meta</b></td></tr>
<tr><td><b>\e</b></td><td>
управляющий символ</td></tr>
<tr><td><b>\\</b></td><td>
обратная косая</td></tr>
<tr><td><b>\"</b></td><td>
символ "</td></tr>
<tr><td><b>\'</b></td><td>
символ '</td></tr>
</tbody></table>
</dd></dl>

<p>Помимо управляющих последовательностей в стиле GNU  Emacs, имеется еще один
набор управляющих последовательностей, начинающихся с обратной косой:</p>

<dl><dt></dt><dd>
<table cellspacing="4" width="90%" border="0">
<tbody><tr><td width="10%"><b>\a</b></td><td>
предупреждение (звонок)</td></tr>
<tr><td><b>\b</b></td><td>
забой (backspace)</td></tr>
<tr><td><b>\d</b></td><td>
удаление символа (delete)</td></tr>
<tr><td><b>\f</b></td><td>
перевод страницы (form feed)</td></tr>
<tr><td><b>\n</b></td><td>
новая строка</td></tr>
<tr><td><b>\r</b></td><td>
возврат каретки</td></tr>
<tr><td><b>\t</b></td><td>
горизонтальная табуляция</td></tr>
<tr><td><b>\v</b></td><td>
вертикальная табуляция</td></tr>
<tr><td valign="top"><b>\nnn</b></td><td>
символ, ASCII-код которого имеет восьмеричное значение <b>nnn</b> (от одной до трех цифр)</td></tr>
<tr><td><b>\xnnn</b></td><td>
символ, ASCII-код которого имеет щестнадцатеричное значение <b>nnn</b>
(от одной до трех цифр)</td></tr>
</tbody></table>
</dd></dl>

<p>При вводе текста макроподстановки необходимо для ее обозначения указывать 
одиночные или двойные кавычки. Текст без кавычек считается именем функции. В теле
макроподстановки интерпретируются перечисленные выше управляющие 
последовательности, начинающиеся с обратной косой. Обратная косая маскирует
любой другой символ в тексте макроподстановки, в том числе, символы <b>"</b> и <b>'</b>.</p>

<p>Командный интерпретатор <b>bash</b> позволяет просмотреть или изменить текущие горячие
клавиши библиотеки <b>readline</b> с помощью встроенной команды <a href="#bind"><b>bind</b></a>.
Режим редактирования можно переключать в ходе интерактивной работы с помощью опции
<a href="#set-o"><b>-o</b></a> встроенной команды <a href="#set"><b>set</b></a> 
(см. раздел "<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже).</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_variables">Переменные readline</a></h3>

<p>Библиотека <b>readline</b> поддерживает переменные, которые можно использовать для
дополнительной настройки ее работы. Значение переменной можно установить в файле
<b>inputrc</b> или с помощью оператора вида</p>
<dl><dt></dt><dd><tt>
set имя_переменной значение
</tt></dd></dl>
<p>За исключением явно указанных случаев, переменные <b>readline</b> могут иметь значения
<b>On</b> или <b>Off</b>. Ниже представлены эти переменные и их стандартные значения:</p>
<dl>
<dt><b>bell-style (audible)</b></dt><dd>
Управляет тем, что происходит, когда библиотека <b>readline</b> должна выдать звонок 
(звуковой сигнал) терминала. Если задано значение <b>none</b>, <b>readline</b> никогда не 
выдает звуковой сигнал. Если задано значение <b>visible</b>, <b>readline</b> использует 
визуальный сигнал, если он поддерживается терминалом. Если задано значение
<b>audible</b>, <b>readline</b> пытается выдать звуковой сигнал терминала.</dd>
<dt><b>comment-begin ("#")</b></dt><dd>
Строка, вставляемая при выполнении команды <b>insert-comment</b> библиотеки <b>readline</b>.
Эта команда привязана к клавишам <b>M-#</b> в режиме <b>emacs</b> и к клавише <b>#</b> в режиме <b>vi</b>.</dd>
<dt><b>completion-ignore-case (Off)</b></dt><dd>
Если установлено значение <b>On</b>, библиотека <b>readline</b> выполняет подстановку имен файлов
и дополнение командной строки с учетом регистра.</dd>
<dt><b>completion-query-items (100)</b></dt><dd>
Определяет, когда у пользователя запрашивают подтверждение выдачи всех завершений 
команды, генерируемых командой <b>possible-completions</b>. Можно задавать любое
неотрицательное целочисленное значение. Если количество возможных завершений
больше или равно значению этой переменной, у пользователя запрашивают, желает
ли он все их увидеть; иначе они просто выдаются на терминал.</dd>
<dt><b>convert-meta (On)</b></dt><dd>
Если установлено значение <b>On</b>, <b>readline</b> будет преобразовывать символы с установленным
восьмым битом в последовательность символов ASCII путем сброса восьмого бита и
добавления управляющего символа (фактически, используя управляющий символ как 
мета-префикс).</dd>
<dt><b>disable-completion (Off)</b></dt><dd>
Если установлено значение <b>On</b>, <b>readline</b> не будет выполнять завершение слов. Символы 
завершения будут вставляться в строку буквально.</dd>
<dt><b>editing-mode (emacs)</b></dt><dd>
Управляет тем, с каким набором горячих клавиш начинает работать библиотека <b>readline</b> -
анаголичным <b>emacs</b> или <b>vi</b>. Переменная <b>editing-mode</b> может иметь значения <b>emacs</b> или <b>vi</b>.</dd>
<dt><b>enable-keypad (Off)</b></dt><dd>
Если установлено значение <b>On</b>, <b>readline</b> будет пытаться включить поддержку цифрового
блока клавиатуры справа при вызове. Некоторым системам это необходимо для поддержки
клавиш со стрелками.</dd>
<dt><b>expand-tilde (Off)</b></dt><dd>
Если установлено значение <b>On</b>, при попытке завершеная слов выполняется замена тильды.</dd>
<dt><b>horizontal-scroll-mode (Off)</b></dt><dd>
Если установлено значение <b>On</b>, <b>readline</b> будет использовать одну строку для показа, 
прокручивая ее при необходимости в одной строке, когда ее длина превышает ширину 
экрана, а не перенося визуально на новую строку.</dd>
<dt><b>input-meta (Off)</b></dt><dd>
Если установлено значение <b>On</b>, <b>readline</b> будет поддерживать ввод восьмибитовых
символов (т.е. не будет сбрасывать старший бит символов при чтении), независимо
от того, поддерживает ли восьмибитовые символы терминал. Имя <b>meta-flag</b> - синоним
для данной переменной.</dd>
<dt><b>isearch-terminators ("C-[C-J")</b></dt><dd>
Строка символов, которые должны прекращать инкрементный поиск без последующего
выполнения символа как команды. Если значение этой переменной не задано, инкрементный
поиск будут прекращать клавиши <b>ESC</b> и <b>C-J</b>.</dd>
<dt><b>keymap (emacs)</b></dt><dd>
Устанавливает текущую раскладку горячих клавиш для <b>readline</b>. Допускаются имена раскладок
<b>emacs</b>, <b>emacs-standard</b>, <b>emacs-meta</b>, <b>emacs-ctlx</b>, <b>vi</b>, <b>vi-command</b> и <b>vi-insert</b>. 
<b>vi</b> эквивалентно <b>vi-command</b>; <b>emacs</b> эквивалентно <b>emacs-standard</b>. Стандартное значение -
<b>emacs</b>; значение переменной <b>editing-mode</b> также влияет на горячие клавиши.</dd>
<dt><b>mark-directories (On)</b></dt><dd>
Если установлено значение <b>On</b>, к завершенным именам каталогов добавляется косая черта.</dd>
<dt><b>mark-modified-lines (Off)</b></dt><dd>
Если установлено значение <b>On</b>, перед строками списка истории команд, которые были изменены,
выдается звездочка (<b>*</b>).</dd>
<dt><b>output-meta (Off)</b></dt><dd>
Если установлено значение <b>On</b>, <b>readline</b> будет выдавать символы с установленным
восьмым битом непосредственно, а не как управляющую последовательность,
начинающуюся метасимволом.</dd>
<dt><b>print-completions-horizontally (Off)</b></dt><dd>
Если установлено значение <b>On</b>, <b>readline</b> будет выдавать возможные завершения
отсортированные в алфавитном порядке по горизонтали, в строках, а не по вертикали,
в столбцах.</dd>
<dt><b>show-all-if-ambiguous (Off)</b></dt><dd>
Изменяет стандартное поведение функций завершения. Если установлено значение <b>On</b>,
для слов, имеющих более одного возможного завершения, список возможных
выдается сразу, а не после звукового сигнала.</dd>
<dt><b>visible-stats (Off)</b></dt><dd>
Если установлено значение <b>On</b>, к именам файлов при выдаче возможных завершений
добавляется символ, задающий их тип в соответствии с функцией <b>stat(2)</b>.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_conditional">Управляющие конструкции readline</a></h3>

<p>Библиотека <b>readline</b> реализует средства, аналогичные по духу возможностям
условной компиляции препроцессора языка C и позволяющие назначать горячие клавиши или
присваивать значения переменным в зависимости от условий. Поддерживается
четыре директивы анализатора.</p>
<dl>
<dt><b>$if</b></dt><dd>
Конструкция <b>$if</b> позволяет назначать те или иные клавиши в зависимости от используемого 
режима редактирования, тип терминала или приложения, использующего библиотеку
<b>readline</b>. Текст условия продолжается до конца строки - никакие завершающие символы
не нужны.
<dl>
<dt><b>mode</b></dt><dd>
Форма <b>mode=</b> директивы <b>$if</b> используется для проверки того, работает ли библиотека
<b>readline</b> в режиме <b>emacs</b> или <b>vi</b>. Ее можно использовать совместно с командой
<b>set keymap</b>, например, для установки горячих клавиш стандарта <b>emacs</b> и
раскладки <b>emacs-ctlx</b> только если <b>readline</b> запускается в режиме <b>emacs</b>.
</dd>
<dt><b>term</b></dt><dd>
Форма <b>term=</b> может использоваться для включения специфических горячих клавиш
для данного терминала, в частности, для привязки последовательностей символов к
функциональным клавишам терминала. Слово справа от символа <b>=</b> сравнивается с
полным именем терминала и частью имени терминала до первого вхождения <b>-</b>.
Это позволяет задавать, например, <b>sun</b> для сопоставления как с <b>sun</b>, так и 
с <b>sun-cmd</b>.
</dd>
<dt><b>приложение</b></dt><dd>
Конструкция <b>приложение</b> используется для включения специфических настроек
приложения. Каждая программа, использующая библиотеку <b>readline</b>, устанавливает
имя приложения, а в инициализационном файле можно проверять установку определенного
значения. Это можно использовать для привязки клавиш к функциям, существенным для 
конкретной программы. Например, следующая команда задает последовательность клавиш,
берущую в кавычки текущее или предыдущее слово в <b>bash</b>:
<dl><dt></dt><dd><tt>
$if Bash<br>
# Взять в кавычки текущее или предыдущее слово<br>
"\C-xq": "\eb\"\ef\""<br>
$endif
</tt></dd></dl>
</dd></dl>
</dd>

<dt><b>$endif</b></dt><dd>
Эта команда, как видно по предыдущему примеру, завершает команду <b>$if</b>.
</dd>
<dt><b>$else</b></dt><dd>
Команды в этой ветке директивы <b>$if</b> выполняются, если не выполнено условие проверки.
</dd>
<dt><b>$include</b></dt><dd>
Эта директива принимает в качестве аргумента имя файла и читает команды и привязки
клавиш из этого файла. Например, следующая директива требует прочитать файл
<b>/etc/inputrc</b>:
<dl><dt></dt><dd><tt>
$include  /etc/inputrc
</tt></dd></dl>
</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="searching">Поиск</a></h3>

<p>Библиотека <b>readline</b> предлагает команды для поиска в списке истории команд 
(см. раздел "<a href="#history"><b>ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</b></a>" ниже) строк, содержащих определенную подстроку. Имеется два режима поиска: инкрементный и не инкрементный.</p>

<p>Инкрементные поиски начинаются прежде, чем пользователь закончит ввод искомой строки.
Привводе каждого символа искомой строки, <b>readline</b> выдает следующую
запись из списка истории, соответствующую уже набранной подстроке. При
инкрементном поиске достаточно ввести ровно столько символов, сколько надо
для нахождения интересующей команды. Символы значения переменной
<b>isearch-terminators</b> используются для завершения инкрементного поиска. Если
значение этой переменной не задано, инкрементный поиск прерывается клавишами
<b>Escape</b> и <b>Control-J</b>. Нажатие <b>Control-G</b> прерывает инкрементный поиск и восстанавливает
исходную строку. При завершении поиска, запись из списка истории, содержащая строку 
поиска, становится текущей строкой. Для поиска других соответствующих записей в 
списке истории, нажмите <b>Control-S</b> или <b>Control-R</b>, в зависимости от направления
поиска. В результате, будет выполнен поиск в обратном или прямом направлении
следующей записи, соответствующей уже набранному фрагменту строки. Ввод любой другой
последовательности символов, привязанной к команде библиотеки <b>readline</b>,
приводит к завершению поиска и выполнению команды. Например, нажатие клавиши <b>Enter</b>
завершит поиск и выполнит выбранную команду из списка истории.</p>

<p>При неинкрементом поиске перед началом поиска читается вся искомая строка. Искомая строка
может быть набрана пользователем или быть частью содержимого текущей строки.</p>

<h3>&nbsp;&nbsp;&nbsp;   <a name="readline_command_names">Имена команд readline</a></h3>

<p>Ниже представлен список имен команд и стандартные комбинации клавиш, к
которым они привязаны. Имена команд, для которых не указана комбинация
клавиш, по умолчанию ни к какой комбинации не привязаны.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_command_moving">Команды для перемещения</a></h3>
<dl>
<dt><b>beginning-of-line (C-a)</b></dt><dd>
Перемещает курсор в начало текущей строки.</dd>
<dt><b>end-of-line (C-e)</b></dt><dd>
Перемещает курсор в конец строки.</dd>
<dt><b>forward-char (C-f)</b></dt><dd>
Перемещает курсор на один символ вперед.</dd>
<dt><b>backward-char (C-b)</b></dt><dd>
Перемещает курсор на один символ назад.</dd>
<dt><b>forward-word (M-f)</b></dt><dd>
Перемещает курсор на одно слово вперед. Слова состоят из алфавитно-цифровых 
символов (букв и цифр).</dd>
<dt><b>backward-word (M-b)</b></dt><dd>
Переходит к началу текущего или предыдущего слова. Слова состоят из 
алфавитноцифровых символов (букв и цифр).</dd>
<dt><b>clear-screen (C-l)</b></dt><dd>
Очищает экран, оставляя текущую строку вверху экрана. При указании аргумента
обновляет текущую строку, не очищая экрана.</dd>
<dt><b>redraw-current-line</b></dt><dd>
Обновляет текущую строку.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_command_history">Команды для работы со списком истории</a></h3>
<dl>
<dt><b>accept-line (Newline, Return)</b></dt><dd>
Принимает строку, независимо от позиции курсора. Если эта строка - не пустая,
добавляет ее в список истории в соответствии с состоянием переменной
<b>HISTCONTROL</b>. Если строка представляет собой измененную строку из списка 
истории, то строка истории восстанавливается в исходное состояние.</dd>
<dt><b>previous-history (C-p)</b></dt><dd>
Извлекает предыдущую команду из списка истории, возвращаясь к началу списка.</dd>
<dt><b>next-history (C-n)</b></dt><dd>
Извлекает следующую команду из списка истории, направляясь к концу списка.</dd>
<dt><b>beginning-of-history (M-&lt;)</b></dt><dd>
Переходит к первой строке в списке истории.</dd>
<dt><b>end-of-history (M-&gt;)</b></dt><dd>
Переходит к концу истории введенных команд, т.е. к текущей вводимой строке.</dd>
<dt><b>reverse-search-history (C-r)</b></dt><dd>
Ищет команду среди предыдущих, начиная с текущей строки и продвигаясь, при 
необходимости, к началу списка истории. Этот поиск - инкрементный.</dd>
<dt><b>forward-search-history (C-s)</b></dt><dd>
Поиск далее, начиная с текущей строки и продвигаясь, при необходимости,
к концу списка истории. Этот поиск - инкрементный.</dd>
<dt><b>non-incremental-reverse-search-history (M-p)</b></dt><dd>
Неинкрементный поиск введенной пользователем строки в обратном направлении, 
начиная с текущей строки.</dd>
<dt><b>non-incremental-forward-search-history (M-n)</b></dt><dd>
Неинкрементный поиск введенной пользователем строки далее, 
начиная с текущей строки.</dd>
<dt><b>history-search-forward</b></dt><dd>
Поиск далее в списке истории строки символов от начала текущей строки до
<i>позиции курсора</i> (текущей позиции). Этот поиск - не инкрементный.</dd>
<dt><b>history-search-backward</b></dt><dd>
Поиск в обратном направлении в списке истории строки символов от начала 
текущей строки до позиции курсора (текущей позиции). Этот поиск - не инкрементный.</dd>
<dt><b>yank-nth-arg (M-C-y)</b></dt><dd>
Вставляет первый аргумент предыдущей команды (обычно это второе слово
предыдущей строки) в текущую позицию курсора. Если указан аргумент <b>n</b>,
вставляет <b>n</b>-ное слово предыдущей команды (слова в предыдущей команде нумеруются
с 0). Если аргумент - отрицательный, вставляется <b>n</b>-ное слово от конца
предыдущей команды.</dd>
<dt><b>yank-last-arg (M-., M-_)</b></dt><dd>
Вставляет последний аргумент предыдущей команды (последнее слово в предыдущей
записи списка истории). Если указан аргумент, работает так же, как и
команда <b>yank-nth-arg</b>. При последовательном вызове команды
<b>yank-last-arg</b> выполняется проход в обратном направлении по списку истории,
со вставкой последнего аргумента очередной строки.</dd>
<dt><b>shell-expand-line (M-C-e)</b></dt><dd>
Выполняет подстановки в строке по аналогии с командным интерпретатором.
Выполняются подстановки псевдонимов и команд из списка истории,
а также подстановка слов. Описание подстановки команд из списка истории
см. далее в разделе "<a href="#history_expansion"><b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</b></a>".</dd>
<dt><b>history-expand-line (M-^)</b></dt><dd>
Выполняет подстановку команд из списка истории в текущей строке.
Описание подстановки команд из списка истории
см. далее в разделе "<a href="#history_expansion"><b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</b></a>".</dd>
<dt><b>magic-space</b></dt><dd>
Выполняет подстановку команд из списка истории в текущей строке 
и добавляет пробел. Описание подстановки команд из списка истории
см. далее в разделе "<a href="#history_expansion"><b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</b></a>".</dd>
<dt><b>alias-expand-line</b></dt><dd>
Выполняет подстановку псевдонимов в текущей строке. Описание подстановки
псевдонимов см. ранее в разделе ""<a href="#aliases"><b>ПСЕВДОНИМЫ</b></a>".</dd>
<dt><b>history-and-alias-expand-line</b></dt><dd>
Выполняет подстановки псевдонимов и команд из списка истории в текущей строке.</dd>
<dt><b>insert-last-argument (M-., M-_)</b></dt><dd>
Синоним для команды <b>yank-last-arg</b>.</dd>
<dt><b>operate-and-get-next (C-o)</b></dt><dd>
Принимает текущую строку для выполнения и извлекает следующую строку
после текущей из списка истории для редактирования. Аргументы игнорируются.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;   <a name="changing_text">Команды для изменения текста</a></h3>
<dl>
<dt><b>delete-char (C-d)</b></dt><dd>
Удаляет символ в позиции курсора. Если текущая позиция - начало строки,
в строке нет символов и последняя нажатая клавиша не привязана к команде
<b>delete-char</b>, возвращает <b>EOF</b>.</dd>
<dt><b>backward-delete-char (Backspace)</b></dt><dd>
Удаляет символ перед курсором. При указании числового аргумента
сохраняет удаленный текст в <i>кольцевом буфере</i> (kill ring).</dd>
<dt><b>forward-backward-delete-char</b></dt><dd>
Удаляет символ в позиции курсора, если куросор не в конце строки, - в
этом случае удаляется символ перед курсором. По умолчанию эта команда ни к
какой комбинации клавиш не привязана.</dd>
<dt><b>quoted-insert (C-q, C-v)</b></dt><dd>
Добавляет следующий набранный символ буквально. Так можно вставлять, например,
символы типа <b>C-q</b>.</dd>
<dt><b>tab-insert (C-v TAB)</b></dt><dd>
Вставляет символ табуляции.</dd>
<dt><b>self-insert (a, b, A, 1, !, ...)</b></dt><dd>
Вставляет набранный символ.</dd>
<dt><b>transpose-chars (C-t)</b></dt><dd>
Переносит символ перед текущей позицией за текущую позицию. Текущая позиция 
также перемещается вперед на один символ. Если текущая позиция - конец строки,
меняет местами два символа перед текущей позицией. Отрицательные аргументы не
поддерживаются.</dd>
<dt><b>transpose-words (M-t)</b></dt><dd>
Переносит предыдущее слово за слово, на котором (или после которого) стоит 
курсор. Курсор перемещается в конец перенесенного слова.</dd>
<dt><b>upcase-word (M-u)</b></dt><dd>
Переводит в верхний регистр текущее (или следующее слово). Если указан 
отрицательный аргумент, переводит в верхний регистр предыдущее слово, но не
меняет текущей позиции.</dd>
<dt><b>downcase-word (M-l)</b></dt><dd>
Переводит в нижний регистр текущее (или следующее слово). Если указан 
отрицательный аргумент, переводит в верхний регистр предыдущее слово, но не
меняет текущей позиции.</dd>
<dt><b>capitalize-word (M-c)</b></dt><dd>
Начинает с прописной буквы текущее или следующее слово. Если указан
отрицательный аргумент, начинает с прописной буквы предыдущее слово, но
не меняет текущей позиции.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="kill_yank">Удаление и вставка</a></h3>
<dl>
<dt><b>kill-line (C-k)</b></dt><dd>
Удаляет текст от текущей позиции курсора до конца строки.</dd>
<dt><b>backward-kill-line (C-x Backspace)</b></dt><dd>
Удаляет текст до начала строки.</dd>
<dt><b>unix-line-discard (C-u)</b></dt><dd>
Удаляет текст от текущей позиции до начала строки. Удаленный текст помещается в
<i>кольцевой буфер</i>.</dd>
<dt><b>kill-whole-line</b></dt><dd>
Удаляет все символы текущей строки, независимо от позиции курсора.</dd>
<dt><b>kill-word (M-d)</b></dt><dd>
Удаляет символы от курсора до конца слова или, если курсор стоит между словами, до 
конца следующего слова. Границы слов определяются так же, как и для
команды <b>forward-word</b>.</dd>
<dt><b>backward-kill-word (M-Backspace)</b></dt><dd>
Удаляет слово перед курсором. Границы слова определяются так же,
как и в команде <b>backward-word</b>.</dd>
<dt><b>unix-word-rubout (C-w)</b></dt><dd>
Удаляет слово перед курсором, используя в качестве ограничителя слов <i>пробельные 
символы</i>. Границы слова, таким образом, отличаются от принятых в команде
<b>backward-kill-word</b>.</dd>
<dt><b>delete-horizontal-space (M-\)</b></dt><dd>
Удаляет все пробелы и символы табуляции вокруг текущей позиции.</dd>
<dt><b>kill-region</b></dt><dd>
Удаляет весь текст от текущей позиции до отметки (запомненной позиции
курсора). Этот текст называют <i>областью</i> (region).</dd>
<dt><b>copy-region-as-kill</b></dt><dd>
Копирует текст области в буфер.</dd>
<dt><b>copy-backward-word</b></dt><dd>
Копирует слово перед текущей позицией в буфер. Границы слов определяются так же,
как в команде <b>backward-word</b>.</dd>
<dt><b>copy-forward-word</b></dt><dd>
Копирует слово после текущей позиции в буфер. Границы слов определяются так же,
как в команде <b>forward-word</b>.</dd>
<dt><b>yank (C-y)</b></dt><dd>
Вставляет верхний элемент кольцевого буфера в позиции курсора.</dd>
<dt><b>yank-pop (M-y)</b></dt><dd>
Прокручивает кольцевой буфер и вставляет новый верхний элемент. Работает
только после команды <b>yank</b> или <b>yank-pop</b>.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="numberic_args">Числовые аргументы</a></h3>
<dl>
<dt><b>digit-argument (M-0, M-1, ..., M--)</b></dt><dd>
Добавляет соответствующую цифру к уже накопленному аргументу или начинает
новый аргумент. <b>M--</b> начинает отрицательный аргумент.</dd>
<dt><b>universal-argument</b></dt><dd>
Это еще один способ задания аргумента. Если после этой команды идет одна
или несколько цифр, возможно, начинающихся со знака минус, эти цифры образуют
аргумент. Если после команды идут цифры, повторное выполнение 
<b>universal-argument</b> завершает числовой аргумент, в противном случае -
игнорируется. В качестве специального случая, если сразу после команды идет
символ, отличный от цифры или знака минус, аргумент <b>count</b> для следующей
команды умножается на четыре. Аргумент <b>count</b> первоначально имеет занчение 1, 
так что при первом выполнении получается четыре, затем - шестнадцать и так далее.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="completing">Завершение</a></h3>
<dl>
<dt><b>complete (TAB)</b></dt><dd>
Пытается завершить текст, введенный до текущей позиции.
Командный интерпретатор <b>bash</b> пытается выполнить завершение,
рассматривая текст последовательно как обращение к переменной 
(если текст начинается с <b>$</b>), как имя пользователя (если текст начинается 
с <b>~</b>), как имя хоста (если текст начинается с <b>@</b>), или как команду 
(включая псевдонимы и функции). Если ни одним из этих способов завершить
строку не удалось, выполняется попытка завершения имени файла.</dd>
<dt><b>possible-completions (M-?)</b></dt><dd>
Список возможных завершений текста до текущей позиции.</dd>
<dt><b>insert-completions (M-*)</b></dt><dd>
Вставляет все завершения введенного текста, генерируемые командой
<b>possible-completions</b>.</dd>
<dt><b>menu-complete</b></dt><dd>
Аналогична команде <b>complete</b>, но заменяет завершаемое слово
первым из возможных завершений. Повторное выполнение команды
<b>menu-complete</b> вставляет следующий элемент из списка возможных завершений.
В конце списка завершений выдается сигнал и восстанавливается исходный 
текст. Аргумент <b>n</b> вызывает преход на <b>n</b> позиций вперед в списке завершений;
отрицательный аргумент вызывает переход по списку в обратном направлении. 
Предполагается привязка этой команды к клавише <b>TAB</b>, но стандартно она ни к
какой комбинации клавиш не привязана.</dd>
<dt><b>delete-char-or-list</b></dt><dd>
Удаляет символ в позиции курсора, если курсор не находится в начале
или в конце строки (аналогично команде <b>delete-char</b>). Если курсор - в конце
строки, ведет себя аналогично команде <b>possible-completions</b>. Эта
команда стандартно ни к какой комбинации клавиш не привязана.</dd>
<dt><b>complete-filename (M-/)</b></dt><dd>
Пытается завершить введенный текст до текущей позиции как имя файла.</dd>
<dt><b>possible-filename-completions (C-x /)</b></dt><dd>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
имя файла.</dd>
<dt><b>complete-username (M-~)</b></dt><dd>
Пытается завершить введенный текст до текущей позиции как имя пользователя.</dd>
<dt><b>possible-username-completions (C-x ~)</b></dt><dd>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
имя пользователя.</dd>
<dt><b>complete-variable (M-$)</b></dt><dd>
Пытается завершить введенный текст до текущей позиции как обращение к
переменной командного интерпретатора.</dd>
<dt><b>possible-variable-completions (C-x $)</b></dt><dd>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
обращение к переменной командного интерпретатора.</dd>
<dt><b>complete-hostname (M-@)</b></dt><dd>
Пытается завершить введенный текст до текущей позиции как имя хоста.</dd>
<dt><b>possible-hostname-completions (C-x @)</b></dt><dd>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
имя хоста.</dd>
<dt><b>complete-command (M-!)</b></dt><dd>
Пытается завершить введенный текст до текущей позиции как имя команды.
При завершении команд текст сопоставляется последовательно с псевдонимами, 
зарезервированными словами, функциями командного интерпретатора, 
встроенными функциями командного интерпретатора и, наконец, 
с именами выполняемых файлов.</dd>
<dt><b>possible-command-completions (C-x !)</b></dt><dd>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
имя команды.</dd>
<dt><b>dynamic-complete-history (M-TAB)</b></dt><dd>
Пытается завершить введенный текст до текущей позиции, сравнивая его
со строками из списка истории выполненных команд в поисках возможных
соответствий.</dd>
<dt><b>complete-into-braces (M-{)</b></dt><dd>
Выполняет завершение имени файла и возвращает список возможных завершений
в фигурных скобках, чтобы он мог быть обработан командным интерпретатором
(см. раздел "<b>Подстановка значений в фигурных скобках</b>" ранее).</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="keyboard_macros">Клавиатурные макросы</a></h3>
<dl>
<dt><b>start-kbd-macro (C-x ()</b></dt><dd>
Начинает запоминание набранных символов в текущий <i>клавиатурный макрос</i>.</dd>
<dt><b>end-kbd-macro (C-x ))</b></dt><dd>
Завершает запоминание набранных символов в текущий клавиатурный макрос и
сохраняет его определение.</dd>
<dt><b>call-last-kbd-macro (C-x e)</b></dt><dd>
Выполняет последний определенный клавиатурный макрос, выводя символы
макроса так, как если бы они были введены с клавиатуры.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="readline_misc_commands">Прочие команды</a></h3>
<dl>
<dt><b>re-read-init-file (C-x C-r)</b></dt><dd>
Перечитывает содержимое файла <b>inputrc</b> и учитывает все указанные в нем
привязки клавиш и значения переменных.</dd>
<dt><b>abort (C-g)</b></dt><dd>
Прерывает текущую команду редактирования и выдает сигнал терминала
(вид сигнала задается командой <b>bell-style</b>).</dd>
<dt><b>do-uppercase-version (M-a, M-b, M-x, ...)</b></dt><dd>
Если символ <b>x</b>, введенный вместе с клавишей <b>Meta</b>, является символом нижнего
регистра, выполнить команду, привязанную к соответствующему символу
в верхнем регистре.</dd>
<dt><b>prefix-meta (ESC)</b></dt><dd>
Рассматривать следующий введенный символ как предваренный клавишей <b>Meta</b>.
<b>ESC f</b> эквивалентно <b>Meta-f</b>.</dd>
<dt><b>undo (C-_, C-x C-u)</b></dt><dd>
Инкрементная отмена, запоминаемая отдельно для каждой строки.</dd>
<dt><b>revert-line (M-r)</b></dt><dd>
Отмена всех изменений текущей строки. Аналогично выполнению команды
<b>undo</b> несколько раз до возвращения строки в исходное состояние.</dd>
<dt><b>tilde-expand (M-&amp;)</b></dt><dd>
Выполняет замену тильды в текущем слове.</dd>
<dt><b>set-mark (C-@, M-&lt;space&gt;)</b></dt><dd>
Устанавливает метку в текущей позиции. Если задан числовой аргумент, метка
устанавливается в соответствующей позиции.</dd>
<dt><b>exchange-point-and-mark (C-x C-x)</b></dt><dd>
Меняет местами метку и текущую позицию. Текущей позицией курсора становится
запомненная в метке, а прежняя позиция курсора запоминается в метке.</dd>
<dt><b>character-search (C-])</b></dt><dd>
Читается символ, и курсор переводится на следующее вхождение этого
символа. Отрицательный аргумент означает поиск предыдущего вхождения.</dd>
<dt><b>character-search-backward (M-C-])</b></dt><dd>
Читается символ, и курсор переводится на предыдущее вхождение этого
символа. Отрицательный аргумент означает поиск следующего вхождения.</dd>
<dt><b>insert-comment (M-#)</b></dt><dd>
Значение переменной <b>comment-begin</b> библиотеки <b>readline</b> вставляется в
начало текущей строки, и строка принимается, как если бы была нажата
клавиша <b>Enter</b>. В результате, текущая строка становится <i>комментарием</i>
командного интерпретатора.</dd>
<dt><b>glob-expand-word (C-x *)</b></dt><dd>
Слово перед текущей позицией рассматривается как шаблон имен файлов и
вместо него вставляется список соответствующих имен файлов.</dd>
<dt><b>glob-list-expansions (C-x g)</b></dt><dd>
Выдается список имен файлов, генерируемых командой 
<b>glob-expand-word</b>, а затем снова исходная строка.</dd>
<dt><b>dump-functions</b></dt><dd>
Выдает все функции и комбинации клавиш, к которым они привязаны, в
выходной поток <b>readline</b>. Если задан числовой аргумент,
результат форматируется так, что его можно непосредственно включить в файл <b>inputrc</b>.</dd>
<dt><b>dump-variables</b></dt><dd>
Выдает все <i>изменяемые</i> переменные <b>readline</b> вместе с их значениями в
выходной поток <b>readline</b>. Если задан числовой аргумент,
результат форматируется так, что его можно непосредственно включить в файл <b>inputrc</b>.</dd>
<dt><b>dump-macros</b></dt><dd>
Выдает все комбинации клавиш <b>readline</b>, привязанные к макросам, и
строки, которые выдаются при их нажатии. Если задан числовой аргумент,
результат форматируется так, что его можно непосредственно включить в файл <b>inputrc</b>.</dd>
<dt><b>display-shell-version (C-x C-v)</b></dt><dd>
Выдает информацию о версии текущего экземпляра командного интерпретатора <b>bash</b>.</dd>
</dl>

<h2><a name="history">ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</a></h2>

<p>При включении опции <b>-o history</b> с помощью встроенной команды <a href="#set"><b>set</b></a>,
командный интерпретатор обеспечивает доступ к истории выполнения
команд - списку ранее введенных команд. Текст последних
<b>HISTSIZE</b> команд (по умолчанию - 500) сохраняется в <i>списке истории</i>.
Командный интерпретатор сохраняет в списке истории команды до подстановки
значений параметров и переменных (см. раздел "<a href="#expansion"><b>ЗАМЕНА</b></a>" ранее), 
но после подстановки команд из списка истории, с учетом значений переменных
командного интерпретатора <b>HISTIGNORE</b> и <b>HISTCONTROL</b>. При запуске история 
выполнения команд считывается из файла, имя которого задается переменной
<b>HISTFILE</b> (стандартно - <b>~/.bash_history</b>). Файл <b>HISTFILE</b> при необходимости
усекается, чтобы в нем было не более <b>HISTFILESIZE</b> строк. При завершении работы
интерактивного командного интерпретатора последние
<b>HISTSIZE</b> строк копируются из списка истории выполнения команд
в файл <b>HISTFILE</b>. Если установлена опция командного интерпретатора 
<a href="#histappend"><b>histappend</b></a> (см. описание 
команды <a href="#shopt"><b>shopt</b></a> в разделе 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже), 
строки добавляются к файлу истории, 
иначе файл истории перезаписывается. Если переменная <b>HISTFILE</b> не установлена
или файл истории не доступен на запись, история выполнения команд не
сохраняется. После сохранения истории файл усекается до не более чем
<b>HISTFILESIZE</b> строк. Если переменная <b>HISTFILESIZE</b> не установлена
усечение файла не выполняется.</p>

<p>Встроенная команда <a href="#fc"><b>fc</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" ниже)
может использоваться для выдачи или редактирования и повторного выполнения
части списка истории. Встроенная команда <a href="#history"><b>history</b></a> позволяет 
выдавать и изменять список истории выполнения команд, а также
управлять файлом истории. При редактировании командной строки во всех режимах
редактирования доступны команды поиска по списку истории выполнения команд.</p>

<p>Командный интерпретатор позволяет управлять тем, какие команды сохраняются в
списке истории. Переменные <b>HISTCONTROL</b> и <b>HISTIGNORE</b> позволяют ограничить
множество сохраняемых команд. Опция командного интерпретатора 
<a href="#cmdhist"><b>cmdhist</b></a>, при 
включении, заставляет командный интерпретатор пытаться сохранять все строки 
многострочной команды в одной записи списка истории, вставляя при необходимости
точки с запятой для обеспечения синтаксической корректности. Опция
командного интерпретатора <a href="#lithist"><b>lithist</b></a> заставляет сохранять команды со
встроенными переводами встрок вместо вставки точек с запятой. Установка и сброс 
опций командного интерпретатора рассмотрены ниже в описании встроенной
команды <a href="#shopt"><b>shopt</b></a> в разделе 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>".</p>

<h2><a name="history_expansion">ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</a></h2>

<p>Командный интерпретатор <b>bash</b> поддерживает возможность <i>подстановки
команд из списка истории</i>, аналогично командному интерпретатору <b>csh</b>.
В этом разделе описан соответствующий синтаксис. Эта возможность
включается по умолчанию для интерактивных командных интерпретаторов
и может быть отключена с помощью опции <b>+H</b> встроенной команды
<a href="#set"><b>set</b></a> (см. раздел 
"<a href="#shell_builtin"><b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b></a>" далее). 
Не интерактивные командные интерпретаторы по умолчанию не выполняют
подстановку команд из списка истории.</p>

<p>С помощью этой подстановки слова из списка истории можно вставлять
во входной поток, что упрощает повторение команд, вставку аргументов
предыдущей команды в текущую строку и исправление ошибок в предыдущих 
командах.</p>

<p>Подстановка из списка истории выполняется сразу же после считывания
всей строки, прежде чем командный интерпретатор разобъет ее на слова.
Это выполняется в два приема. Сначала определяется, какую строку
из списка истории использовать при подстановке. Затем из этой строки 
выбираются части для вставки в текущую строку. Строка, выбираемая из
списка истории, - это <i>событие</i>, а ее части, с которыми происходит 
работа, - <i>слова</i>. Для манипулирования выбранными словами поддерживаются
различные <i>модификаторы</i>. Строка разбивается на слова точно так же, как
и при чтении команды, так что несколько слов, разделенных 
метасимволами и взятые в кавычки, считаются одним словом. 
Подстановка из списка истории инициируется <i>метасимволом подстановки из
списка истории</i>. По умолчанию - это символ <b>!</b>. Замаскировать
этот метасимвол можно только обратной косой (<b>\</b>) и одиночными
кавычками.</p>

<p>Особенностями подстановки из списка истории можно управлять путем 
установки ряда опций командного интерпретатора с помощью встроенной
команды <a href="#shopt"><b>shopt</b></a>. Если установлена опция командного интерпретатора 
<a href="#histverify"><b>histverify</b></a> 
(см. описание встроенной команды <a href="#shopt"><b>shopt</b></a>) и используется
библиотека <b>readline</b>, результаты подстановки из списка истории не
передаются сразу анализатору командного интерпретатора. Вместо этого,
полученная в результате подстановки строка снова загружается в буфер
редактирования <b>readline</b> для дальнейшего изменения. Если используется
библиотека <b>readline</b> и установлена опция командного интерпретатора
<a href="#histreedit"><b>histreedit</b></a>, неудавшаяся подстановка из списка истории команд
будет повторно загружена в буфер редактирования <b>readline</b> для
исправления. Опция <b>-p</b> встроенной команды <a href="#history_builtin"><b>history</b></a> 
может использоваться для предварительного просмотра результатов подстановки 
из списка истории перед ее использованием. Опция <b>-s</b> встроенной команды
<a href="#history_builtin"><b>history</b></a> позволяет добавлять команды в 
конец списка истории без их фактического добавления, так что их можно будет повторно 
использовать в дальнейшем.</p>

<p>Командный интерпретатор позволяет управлять назначением различных
метасимволов, используемых механизмом подстановки команд из списка 
истории (см. описание переменной <a href="#histchars"><b>histchars</b></a> ранее в разделе
"<a href="#shell_vars"><b>Переменные командного интерпретатора</b></a>").</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="event_designator">Пометки событий</a></h3>

<p><i>Пометка события</i> - это ссылка на элемент командной строки в списке 
истории.</p>
<dl>
<dt><b>!</b></dt><dd>
Начинает подстановку из списка выполненных команд, если только
далее не идет пробел, перевод строки, <b>=</b> или <b>(</b>.</dd>
<dt><b>!n</b></dt><dd>
Ссылка на командную строку <b>n</b>.</dd>
<dt><b>!-n</b></dt><dd>
Ссылка на текущую строку минус <b>n</b>.</dd>
<dt><b>!!</b></dt><dd>
Ссылка на предыдущую команду. Это синоним для команды <b>!-1</b>.</dd>
<dt><b>!строка</b></dt><dd>
Ссылка на самую недавнюю команду, начинающуюся со <b>строки</b>.</dd>
<dt><b>!?строка[?]</b></dt><dd>
Ссылка на самую недавнюю команду, содержащую <b>строку</b>. Завершающий символ
<b>?</b> можно не указывать, если сразу после <b>строки</b> идет новая строка.</dd>
<dt><b>^строка1^строка2^</b></dt><dd>
Быстрая подстановка. Повторить последнюю команду, заменяя 
<b>строку1</b> <b>строкой2</b>. Аналогично <b>!!:s/строка1/строка2/</b> 
(см. подраздел "<a href="#modofiers"><b>Модификаторы</b></a>" ниже).</dd>
<dt><b>!#</b></dt><dd>
Вся набранная до этого момента командная строка.</dd>
</dl>

<h3>&nbsp;&nbsp;&nbsp;  <a name="word_designator">Пометки слов</a></h3>

<p><i>Пометки слов</i> (word  designators) используются для выбора необходимых слов из события. 
Двоеточие (<b>:</b>) отделяет пометку слова от спецификации события. Двоеточие можно
не указывать, если пометка слова начинается символом 
<b>^</b>, <b>$</b>, <b>*</b>, <b>-</b> или <b>%</b>. Слова нумеруются с начала строки, 
причем первое слово имеет номер 0. Слова вставляются в текущую строку через один пробел.</p>
<dl>
<dt><b>0</b></dt><dd>
Нулевое слово. Для командного интерпретатора это - имя команды.</dd>
<dt><b>n</b></dt><dd>
<b>n</b>-ное слово.</dd>
<dt><b>^</b></dt><dd>
Первый аргумент. Т.е. слово 1.</dd>
<dt><b>$</b></dt><dd>
Последний аргумент.</dd>
<dt><b>%</b></dt><dd>
Слово, сопоставившееся при последнем поиске '<b>?строка?</b>'.</dd>
<dt><b>x-y</b></dt><dd>
Диапазон слов; '<b>-y</b>' - это сокращение для '<b>0-y</b>'.</dd>
<dt><b>*</b></dt><dd>
Все слова, кроме нулевого. Это синоним '<b>1-$</b>'.
Вполне допустимо использовать <b>*</b> если в событии есть всего одно слово -
в этом случае возвращается пустая строка.</dd>
<dt><b>x*</b></dt><dd>
Сокращение для <b>x-$</b>.</dd>
<dt><b>x-</b></dt><dd>
Сокращенная форма для <b>x-$</b>, аналогично <b>x*</b>, но не включая последнее слово.</dd>
</dl>

<p>Если пометка слова указана без спецификации события, в качестве
события используется предыдущая команда.</p>

<h3>&nbsp;&nbsp;&nbsp;  <a name="modifier">Модификаторы</a></h3>

<p>После необязательной пометки слова может идти последовательность одного или
нескольких следующих <i>модификаторов</i>, предваряемых двоеточием - '<b>:</b>'.</p>
<dl>
<dt><b>h</b></dt><dd>
Удаляет последний компонент имени файла, оставляя только начало.</dd>
<dt><b>t</b></dt><dd>
Удаляет все начальные компоненты имени файла, оставляя только последний.</dd>
<dt><b>r</b></dt><dd>
Удаляет хвостовой суффикс вида <b>.xxx</b>, оставляя базовое имя файла.</dd>
<dt><b>e</b></dt><dd>
Удаляет все, кроме хвостового суффикса.</dd>
<dt><b>p</b></dt><dd>
Выдает новую команду на экран, но не выполняет ее.</dd>
<dt><b>q</b></dt><dd>
Берет подставляемые слова в кавычки для предотвращения дальнейших подстановок.</dd>
<dt><b>x</b></dt><dd>
Берет подставляемые слова в кавычки, как и модификатор <b>q</b>, но разбивает на
слова по пробелам и символам новой строки.</dd>
<dt><b>s/old/new/</b></dt><dd>
Подставляет <b>new</b> вместо первого вхождения <b>old</b> в строке события. Вместо
<b>/</b> можно использовать любой <i>ограничитель</i>. Завершающий ограничитель не 
обязателен, если он является последним символом в строке события. 
Ограничитель в строках <b>old</b> и <b>new</b> можно маскировать обратной косой.
Если в строке <b>new</b> есть метасимвол <b>&amp;</b>, он заменяется строкой <b>old</b>.
Обратная косая маскирует метасимвол <b>&amp;</b>. Если строка <b>old</b> - пустая, 
вместо нее используется строка из последней по времени подстановки или,
если подстановок из списка истории ранее не было, последняя строка,
искавшаяся с помощью конструкции <b>!?строка</b>[<b>?</b>].</dd>
<dt><b>&amp;</b></dt><dd>
Повторяет предыдущую подстановку.</dd>
<dt><b>g</b></dt><dd>
Применяет изменения ко всей строке события. Этот модификатор используется
совместно с '<b>:s</b>'  (например, '<b>:gs/old/new/</b>') или '<b>:&amp;</b>'. При использовании
с '<b>:s</b>', вместо косой (<b>/</b>) можно указывать любой ограничитель, а завершающий
ограничитель указывать не обязательно, если он является последним символом 
в строке события.</dd>
</dl>

<h2><a name="shell_builtin">ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</a></h2>

<p>Если явно не указано иначе, каждая из описанных в этом разделе
встроенных команд, принимающих опции, начинающиеся с дефиса (<b>-</b>),
распознает два дефиса (<b>--</b>) как признак завершения опций.</p>

<dl>
<dt><b>: [аргументы]</b></dt><dd>
Никакого эффекта; команда не делает ничего, 
кроме подстановки <b>аргументов</b> и выполнения указанных перенаправлений. 
Возвращает нулевой код возврата.
<br><br></dd>
<dt><b><a name="source">. имя_файла [аргументы]</a><br>
source имя_файла [аргументы]</b></dt><dd>
Читает и выполняет команды из указанного <b>файла</b> в среде текущего командного 
интерпретатора и возвращает статус выхода последней выполненной команды из 
файла. Если <b>имя_файла</b> не содержит косой черты, файл ищется в каталогах, 
перечисленных в переменной <b>PATH</b>. Искомый файл не обязательно должен быть 
выполняемым. Если ни в одном из каталогов, перечисленных в <b>PATH</b>, файл с 
указанным именем не найден, он ищется в текущем каталоге.  Если отключена 
опция <a href="#sourcepath"><b>sourcepath</b></a> встроенной 
команды <a href="#shopt"><b>shopt</b></a>, перечисленные в <b>PATH</b> каталоги не 
просматриваются. Если переданы <b>аргументы</b>, они становятся позиционными 
параметрами при выполнении <b>файла</b>. Иначе значения позиционных параметров не 
изменяются. Статусом выхода становится статус последней выполненной в 
сценарии команды (статус выхода равен 0, если ни одна команда не выполнялась), 
или 1, если файл не найден или не может быть прочитан.
<br><br></dd>
<dt><b><a name="alias">alias [-p] [имя[=значение] ...]</a></b></dt><dd>
Команда <b>alias</b> без аргументов или с опцией <b>-p</b> выдает список псевдонимов команд в 
виде <b>alias имя=значение</b> в стандартный выходной поток. Если переданы 
аргументы, каждое <b>имя</b>, для которого задано <b>значение</b>, становится <b>псевдонимом</b>. 
Если значение завершается <b>пробелом</b>, в следующем слове при подстановке будет 
выполняться замена псевдонима. Для каждого <b>имени</b> в списке аргументов без 
соответствующего <b>значения</b> выдается имя и значение соответствующего 
псевдонима. Команда <b>alias</b> возвращает истину, если только не задано <b>имя</b>, не 
являющееся именем псевдонима.
<br><br></dd>
<dt><b><a name="bg">bg [задание]</a></b></dt><dd>
Возобновляет выполнение указанного <b>задания</b> в фоновом режиме, как если бы оно 
было запущено с конструкцией <b>&amp;</b>. Если <b>задание</b> не указано, в фоновый режим 
переводится <i>текущее задание</i> командного интерпретатора. Команда <b>bg задание</b> 
возвращает 0, если только управление заданиями не отключено или, при 
включенном управлении заданиями, соответствующее <b>задание</b> не найдено или 
запускалось при отключенном управлении заданиями.
<br><br></dd>
<dt><b><a name="bind">bind [-m keymap] [-lpsvPSV]</a><br>
bind [-m keymap] [-q функция] [-u функция] [-r keyseq]<br>
bind [-m keymap] -f имя_файла<br>
bind [-m keymap] keyseq:имя_функции</b></dt><dd>
Выдает текущие привязки клавиш и функций библиотеки <b>readline</b> или привязывает 
комбинацию клавиш к функции или макросу <b>readline</b>. При этом поддерживается 
такой же синтаксис привязки, как и в файле <b>.inputrc</b>, но каждая привязка должна 
передаваться как отдельный аргумент;  т.е. <b>'"\C-x\C-r":    re-read-init-file'</b>.

<p>Опции, если они переданы, имеют следующие значения:</p>
<dl>
<dt><b>-m keymap</b></dt><dd>
Использовать набор привязок  для последующих привязок. Допускаются имена 
привязок <b>emacs</b>, <b>emacs-standard</b>, <b>emacs-meta</b>, <b>emacs-ctlx</b>, 
<b>vi</b>, <b>vi-command</b> и <b>vi-insert</b>. <b>vi</b> 
эквивалентно <b>vi-command</b>; <b>emacs</b> эквивалентно <b>emacs-standard</b>.</dd>
<dt><b>-l</b></dt><dd>
Список имен всех функций <b>readline</b>.</dd>
<dt><b>-p</b></dt><dd>
Выдает имена функций и привязки <b>readline</b> так, чтобы их можно было прочитать 
повторно.</dd>
<dt><b>-P</b></dt><dd>
Выдает текущие имена функций и привязки <b>readline</b>.</dd>
<dt><b>-v</b></dt><dd>
Выдает имена и значения переменных <b>readline</b> так, чтобы их можно было 
прочитать повторно.</dd>
<dt><b>-V</b></dt><dd>
Выдает имена и значения текущих переменных <b>readline</b>.</dd>
<dt><b>-s</b></dt><dd>
Выдает комбинации клавиш <b>readline</b>, привязанные к макросам, и выдаваемые при 
их нажатии строки так, чтобы их можно было прочитать повторно.</dd>
<dt><b>-S</b></dt><dd>
Выдает комбинации клавиш <b>readline</b>, привязанные к макросам, и выдаваемые при 
их нажатии строки</dd>
<dt><b>-f имя_файла</b></dt><dd>
Читать привязки клавиш из указанного <b>файла</b>.</dd>
<dt><b>-q функция</b></dt><dd>
Выдает комбинации клавиш, привязанные к указанной <b>функции</b>.</dd>
<dt><b>-u функция</b></dt><dd>
Снять все привязки комбинаций клавиш к указанной <b>функции</b>.</dd>
<dt><b>-r keyseq</b></dt><dd>
Удалить привязку к указанной комбинации клавиш <b>keyseq</b>.</dd>
</dl>
<p>Команда возвращает значение 0, кроме случаев, когда передана нераспознанная опция или 
произошла ошибка.</p>
</dd>
<dt><b><a name="break">break [n]</a></b></dt><dd>
Выход из цикла <a href="#for"><b>for</b></a>, <a href="#while"><b>while</b></a>, 
<a href="#until"><b>until</b></a> или <a href="#select"><b>select</b></a>. 
Если значение <b>n</b> указано, выход из <b>n</b> 
уровней циклов. <b>n</b> должно быть больше 1. Если значение <b>n</b> превышает количество 
вложенных циклов, происходит выход из всех циклов. Команда возвращает 
значение 0, если только не выполнена вне цикла.
<br><br></dd>
<dt><b><a name="builtin">builtin встроенная_команда [аргументы]</a></b></dt><dd>
Выполняет указанную <b>встроенную_команду</b> интерпретатора, передает ей 
<b>аргументы</b> и возвращает ее статус выхода. Это полезно при определении функции, 
имя которой совпадает с именем встроенной команды интерпретатора так, чтобы 
можно использовать вызов встроенной команды в функции. Обычно так 
переопределяется встроенная команда <a href="#cd"><b>cd</b></a>. Если указанная команда не является 
встроенной командой интерпретатора, возвращается статус 1.
<br><br></dd>
<dt><b><a name="cd">cd [-LP] [каталог]</a></b></dt><dd>
Делает указанный <b>каталог</b> текущим. <i>Стандартный каталог</i> хранится в переменной 
<b>HOME</b>. Пременная <b>CDPATH</b> определяет пути поиска каталогов, содержащих 
указанный <b>каталог</b>.

<p>Альтернативные имена каталогов в значении <b>CDPATH</b> разделяются двоеточием 
(<b>:</b>). Пустое имя каталога в <b>CDPATH</b> соответствует текущему каталогу, т.е. "<b>.</b>".
Если <b>каталог</b> начинается с косой черты (<b>/</b>), то значение переменной <b>CDPATH</b> не 
используется. Опция <b>-P</b> требует использовать физическую структуру каталогов 
вместо следования по символьным связям (см. также опцию <b>-P</b> встроенной 
команды <a href="#set"><b>set</b></a>); 
опция <b>-L</b> требует следовать по символьным связям. Аргумент <b>-</b> 
эквивалентен <b>$OLDPWD</b>. При успешной смене текущего каталога возвращается 
значение 0, в противном случае - 1.</p>
</dd>
<dt><b><a name="command">command [-pVv] команда [аргумент ...]</a></b></dt><dd>
Выполняет <b>команду</b> с <b>аргументами</b>, не выполняя обычный поиск функций 
командного интерпретатора. Выполняются только встроенные команды или 
команды, которые находятся в указанных в переменной <b>PATH</b> каталогах. Если 
задана опция <b>-p</b>, поиск <b>команды</b> выполняется по стандартному значению 
переменной <b>PATH</b>, гарантирующему, что будут найдены все стандартные утилиты. 
Если указана опция <b>-V</b> или <b>-v</b>, выдается описание команды. Опция <b>-v</b> выдает одно 
слово - имя команды или имя файла, представляющего команду;  опция <b>-V</b> дает 
немного более детальное описание. Если указана опция <b>-V</b> или <b>-v</b>, статус выхода 
будет 0, если команда найдена, и 1 в противном случае. Если ни одна из этих 
опций не задана и возникла ошибка или команду не удалось найти, будет получен 
статус выхода 127. В противном случае статусом выхода встроенной команды 
<b>command</b> является статус выхода выполненной <b>команды</b>.
<br><br></dd>
<dt><b><a name="continue">continue [n]</a></b></dt><dd>
Перейти к следующей итерации цикла <a href="#for"><b>for</b></a>, 
<a href="#while"><b>while</b></a>, <a href="#until"><b>until</b></a> или 
<a href="#select"><b>select</b></a>. Если указано 
значение <b>n</b>, перейти к следующей итерации <b>n</b>-го внешнего цикла. Значение <b>n</b> 
должно быть больше 1. Если <b>n</b> превышает количество имеющихся внешних циклов, 
выполняется следующая итерация самого внешнего цикла (цикла "верхнего 
уровня"). Возвращается значение 0, если только команда не вызвана вне цикла
<br><br></dd>
<dt><b><a name="declare">declare [-afFirx] [-p] [имя[=значение]]</a><br>
<a name="typeset">typeset [-afFirx] [-p] [имя[=значение]]</a></b></dt><dd>
Объявляет переменные и/или задает их атрибуты. Если <b>имена</b> не заданы, выдаются 
значения переменных. Опция <b>-p</b> будет выдавать атрибуты и значения переменных с 
указанными <b>именами</b>. Когда используется опция <b>-p</b>, остальные опции 
игнорируются. Опция <b>-F</b> запрещает выдачу определений функций; выдаются 
только имена и атрибуты функций. Опция <b>-F</b> автоматически устанавливает <b>-f</b>. 
Следующие опции можно использовать для выдачи переменных только с 
указанными атрибутами или для задания атрибутов переменных:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="10%"><b>-a</b></td><td>
Каждое <b>имя</b> - переменная типа массив (см. раздел "<a href="#arrays"><b>Массивы</b></a>" ранее).</td></tr>
<tr><td valign="top"><b>-f</b></td><td>
Использовать только имена функций.</td></tr>
<tr><td valign="top"><b>-i</b></td><td>
Переменная считается целочисленной; при присваивании переменной значения 
вычисляются арифметические выражения (см. раздел 
"<a href="#arithmetic_eval"><b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b></a>").</td></tr>
<tr><td valign="top"><b>-r</b></td><td>
Делает соответствующие переменные доступными только для чтения. Этим 
переменным нельзя присваивать значения в следующих операторах и их нельзя 
сбрасывать.</td></tr>
<tr><td valign="top"><b>-x</b></td><td>
Помечает имена для экспортирования в среду для последующих команд.</td></tr>
</tbody></table>

<p>При задании '<b>+</b>' вместо '<b>-</b>' атрибут сбрасывается, за исключением того, что опцию 
<b>+a</b> нельзя использовать для уничтожения массива. При использовании в функции, 
команда делает каждую опцию локальной, как и команда <b>local</b>. Возвращается 
значение 0, если только не указана недействительная опция, не делается попытка 
определить функцию с помощью конструкции "<b>-f foo=bar</b>", не делается попытка 
присвоить значение переменной, доступной только для чтения, не делается 
попытка присвоить значение массиву без использования конструкции 
присваивания для массива (см. раздел "<a href="#arrays"><b>Массивы</b></a>" ранее), 
не используется <b>имя</b> 
несуществующей переменной командного интерпретатора, не выполняется 
попытка отменить статус только для чтения переменной, созданной как доступная 
только для чтения, не делается попытка отменить статус массива для переменной 
типа массив, и не предлагается выдать определение несуществующей функции с 
помощью опции <b>-f</b>.</p>
</dd>
<dt><b><a name="dirs">dirs [-clpv] [+n] [-n]</a></b></dt><dd>
Без опций эта команда выдает список текущих запомненных каталогов. По 
умолчанию каталоги выдаются в одну строку через пробел. Каталоги добавляются 
в список с помощью команды <a href="#pushd"><b>pushd</b></a>; 
команда <a href="#popd"><b>popd</b></a> удаляет записи из списка.

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="10%"><b>+n</b></td><td> 
Выдает <b>n</b>-ную запись слева списка, выдаваемого командой <b>dirs</b> при вызове без 
опций. Нумерация начинается с нуля.</td></tr>
<tr><td valign="top"><b>-n</b></td><td>
Выдает <b>n</b>-ную запись справа списка, выдаваемого командой <b>dirs</b> при вызове без 
опций. Нумерация начинается с нуля.</td></tr>
<tr><td valign="top"><b>-c</b></td><td>
Очищает стек каталогов, удаляя все записи.</td></tr>
<tr><td valign="top"><b>-l</b></td><td>
Выдает более длинный листинг; в стандартном формате листинга для обозначения 
начального каталога используется тильда.</td></tr>
<tr><td valign="top"><b>-p</b></td><td>
Выдает стек каталогов по одной записи в строку.</td></tr>
<tr><td valign="top"><b>-v</b></td><td>
Выдает стек каталогов по одной записи в строку, выдавая индекс записи перед 
каждой записью.</td></tr>
</tbody></table>

<p>Если не указана недопустимая опция, и индекс <b>n</b> не выходит за пределы стека, 
возвращается значение 0.</p>
</dd>

<dt><b><a name="disown">disown [-ar] [-h] [задание ...]</a></b></dt><dd>
При вызове без опций каждое указанное <b>задание</b> удаляется из таблицы активных 
заданий. Если задана опция <b>-h</b>, <b>задания</b> не удаляются из таблицы, а помечаются так, 
что сигнал <b>SIGHUP</b> не посылается заданию при получении сигнала <b>SIGHUP</b> командным 
интерпретатором. Если <b>задание</b> не указано и не заданы опции <b>-a</b> и <b>-r</b>, 
используется <i>текущее задание</i>. Если <b>задание</b> не указано, опция <b>-a</b> 
означает удалить или пометить все 
задания; опция <b>-r</b> без аргумента задание ограничивает действие выполняющимися 
заданиями. Команда возвращает значение 0, если только не указано несуществующее 
задание.<br><br>
</dd>
<dt><b><a name="echo">echo [-neE] [аргумент ...]</a></b></dt><dd>
Выдает <b>аргументы</b> через пробел, дополняя в конце символом новой строки. Статус 
возврата - всегда 0. Если указана опция <b>-n</b>, символ новой строки не выдается. Если 
указана опция <b>-e</b>, включается интерпретация следующих управляющих комбинаций 
символов с обратной косой. Опция <b>-E</b> отключает интерпретацию этих управляющих 
последовательностей даже в системах, где они интерпретируются по умолчанию. 
Команда <b>echo</b> не интерпретирует <b>--</b> как признак завершения опций. Команда <b>echo</b> 
интерпретирует следующие управляющие последовательности:
<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="10%"><b>\a</b></td>	<td>сигнал (звонок)</td></tr>
<tr><td valign="top"><b>\b</b></td>	<td>забой</td></tr>
<tr><td valign="top"><b>\c</b></td>	<td>не выводить завершающие символы новой строки</td></tr>
<tr><td valign="top"><b>\e</b></td>	<td>управляющий символ</td></tr>
<tr><td valign="top"><b>\f</b></td>	<td>прогон страницы</td></tr>
<tr><td valign="top"><b>\n</b></td>	<td>новая строка</td></tr>
<tr><td valign="top"><b>\r</b></td>	<td>возврат каретки</td></tr>
<tr><td valign="top"><b>\t</b></td>	<td>горизонтальная табуляция</td></tr>
<tr><td valign="top"><b>\v</b></td>	<td>вертикальная табуляция</td></tr>
<tr><td valign="top"><b>\\</b></td>	<td>обратная косая</td></tr>
<tr><td valign="top"><b>\nnn</b></td>	<td>
символ, ASCII-код которого - восьмеричное значение <b>nnn</b> (от одной до трех цифр)</td></tr>
<tr><td valign="top"><b>\xnnn</b></td>	<td>
символ, ASCII-код которого - шестнадцатеричное значение <b>nnn</b> (от одной до трех 
цифр)</td></tr>
</tbody></table>
</dd>
<dt><b><a name="enable">enable [-adnps] [-f имя_файла] [имя ...]</a></b></dt><dd>
Включает и отключает встроенные команды интерпретатора. Отключение встроенной 
команды позволяет выполнять без указания полного имени файл на диске, имя 
которого совпадает со встроенной командой, хотя обычно встроенные команды 
просматриваются первыми. Если используется опция <b>-n</b>, указанные по <b>именам</b> 
команды отключаются, в противном случае они влючаются. Например, чтобы 
использовать двоичную программу <b>test</b>, которая находится в одном из указанных в 
переменной <b>PATH</b> каталогов, вместо встроенной версии интерпретатора, выполните 
<b>enable -n test</b>. Опция <b>-f</b> требует загрузить новую встроенную команду с указанным 
именем из заданного <i>разделяемого объектного файла</i> в системах, поддерживающих 
динамическую загрузку. Опция <b>-d</b> удаляет встроенную команду, ранее загруженную с 
помощью опции <b>-f</b>. Если <b>имена</b> не заданы или если указана опция <b>-p</b>, 
выдается список встроенных команд интерпретатора. При отсутствии других опций и аргументов этот 
список содержит все включенные встроенные команды интерпретатора. Если опция <b>-n</b> 
не указана, выдаются только отключенные встроенные команды. Если указана опция
<b>-a</b>, выдаваемый список включает все встроенные команды с признаком включена или 
отключена. Если указана опция <b>-s</b>, выдаются только встроенные команды, 
предполагаемые <i>стандартом POSIX</i>. Возвращается значение 0, если только <b>имя</b> 
являеся именем встроенной команды интерпретатора и не возникла проблема при 
загрузке новой встроенной команды из разделямого объектного файла.
<br><br>
</dd>
<dt><b><a name="eval">eval [аргумент ...]</a></b></dt><dd>
<b>Аргументы</b> читаются и соединяются в единую команду. Эта команда затем читается и 
выполняется командным интерпретатором, а ее статус выхода возвращается в 
качестве значения команды <b>eval</b>. Если аргументов нет или все аргументы пустые, 
команда <b>eval</b> возвращает 0.<br><br>
</dd>
<dt><b><a name="exec">exec [-cl] [-a имя] [команда [аргументы]]</a></b></dt><dd>
Если указана <b>команда</b>, она заменяет командный интерпретатор. При этом новый 
процесс не создается. <b>Аргументы</b> становятся аргументами команды. Если указана 
опция <b>-l</b>, командный интерпретатор помещает дефис в качестве нулевого аргумента, 
передаваемого <b>команде</b>. Именно так делает команда 
<a href="http://ln.com.ua/~openxs/projects/man/uw2/login.html"><b>login(1)</b></a>. 
Опция <b>-c</b> вызывает 
выполнение команды с пустой средой. Если указана опция <b>-a</b>, командный 
интерпретатор передает <b>имя</b> как нулевой аргумент выполняемой <b>команде</b>. Если 
<b>команда</b> не может быть выполнена по той или иной причине, неинтерактивный 
командный интерпретатор завершает работу, если только не включена опция 
интерпретатора <a href="#execfail"><b>execfail</b></a>, - в этом случае команда возвращает 
код ошибки. Интерактивный командный интерпретатор возвращает код ошибки если файл не 
может быть выполнен. Если команда не указана, любые перенаправления срабатывают 
в текущем командном интерпретаторе и статус выхода будет 0. Если при 
перенаправлении произошла ошибка, статус выхода будет 1.<br><br>
</dd>
<dt><b><a name="exit">exit [n]</a></b></dt><dd>
Вызывает завершение работы командного интерпретатора со статусом <b>n</b>. Если 
значение <b>n</b> не указано, статусом выхода будет статус выхода последней выполненной 
команды. Перед заврешением работы интерпретатора срабатыват обработчик сигнала 
<b>EXIT</b>.<br><br>
</dd>
<dt><b><a name="export">export [-fn] [имя[=слово]] ...</a><br>
export -p</b></dt><dd>
Указанные <b>имена</b> помечаются для автоматического <i>экспортирования в среду</i> 
следующих выполняемых команд. Если указана опция <b>-f</b>, экспортируются имена 
функций. Если имена не указаны или задана опция <b>-p</b>, выдается список всех имен, 
экспортированных данным командным интерпретатором. Опция <b>-n</b> вызывает удаление 
признака экспортирования с указанных переменных. Команда <b>export</b> возвращает 
сатутус выхода 0, если только не указана недопустимая опция, имя несуществующей 
переменной или в опции <b>-f</b> не указано <b>имя</b>, не являющееся именем функции.<br><br>
</dd>
<dt><b><a name="fc">fc [-e редактор] [-nlr] [первая] [последняя]</a><br>
fc -s [pat=rep] [команда]</b></dt><dd>
Исправить команду. Первая форма выбирает диапазон команд, от <b>первой</b> до 
<b>последней</b>, из списка истории выполнения. <b>Первую</b> и <b>последнюю</b> команду можно 
задавать строкой (найти последнюю команду, начинающуюся с соответствующей 
строки) или числом (индекс в списке истории, причем отрицательные значения 
используются как смещение от номера текущей команды). Если <b>последняя</b> не указана, 
при выдаче последней считается текущая команда (так что <b>fc -l -10</b> выдает последних 
10 команд), а для остальных опций предполагается, что <b>последняя</b> совпадает с <b>первой</b>. 
Если <b>первая</b> не указана, ею становится предыдущая команда при редактировании и -16 
(шестнадцатая с конца списка истории) при выдаче.

<p>Опция <b>-n</b> подавляет выдачу номеров команд. Опция <b>-r</b> изменяет порядок выдачи 
команд на противоположный. Если указана опция <b>-l</b>, команды выдаются в стандартный 
выходной поток. В противном случае вызывается указанный <b>редактор</b>, которому 
передается файл с соответствующими командами. Если <b>редактор</b> не задан, 
используется значение переменной <b>FCEDIT</b> или значение переменной <b>EDITOR</b>, если 
<b>FCEDIT</b> не установлена. Если не установлены обе переменные, используется редактор 
<b>vi</b>. По завершении редактирования, отредактированные команды выдаются и 
выполняются.</p>

<p>Вторая форма требует повторного выполнения команды после замены каждого 
вхождения <b>pat</b> на <b>rep</b>. Полезно задать псевдоним "<b>r=fc -s</b>",
так что при наборе "<b>r cc</b>" будет выполнена последняя команда, начинавшаяся 
со строки "<b>cc</b>", а при вводе "<b>r</b>" будет повторно выполняться последняя команда.</p>

<p>Если используется первая форма, команда возвращает значение 0, если только не 
указана недопустимая опция или <b>первая</b> или <b>последняя</b> команда выходит за пределы 
номеров команд в списке истоии. Если указана опция <b>-e</b>, возвращается статус выхода 
последней выполненной команды или ошибка, произошедшая при работе с временным 
файлом команд. Если используется вторая форма, возвращается статус выхода 
повторно выполненной команды, если только команда не задает несуществующую 
строку в списке истории, - в этом случае команда <b>fc</b> возвращает 1.</p>
</dd>
<dt><b><a name="fg">fg [задание]</a></b></dt><dd>
Возобновляет работу <i>задания</i> в <i>приоритетном режиме</i> и делает это <b>задание</b> 
<i>текущим</i>. Если <b>задание</b> не указано, используется текущее задание командного интерпретатора. Возвращается значение статуса выхода команды, переведенной в приоритетный
режим, или 1 если управление заданиями отключено или, при включенном управлении 
заданиями, если указано несуществующее <b>задание</b> или <b>задание</b>, запущенное при 
отключенном управлении заданиями.<br><br>
</dd>
<dt><b><a name="getopts">getopts строка_опций имя [аргументы]</a></b></dt><dd>
Команда <b>getopts</b> используется процедурами командного интерпретатора для разбора 
позиционных параметров. <b>Строка_опций</b> содержит буквы опций, которые необходимо 
распознать; если после буквы указано двоеточие, предполагается, что у опции должен 
быть аргумент, отделяемый от нее пробельным символом. При каждом вызове команда 
<b>getopts</b> помещает в переменную интерпретатора с указанным именем очередную 
опцию, создавая переменную, если она еще не существует, а индекс следующего 
аргмента - в переменную <b>OPTIND</b>. <b>OPTIND</b> получает значение 1 при каждом вызове 
командного интерпретатора или сценария. Если опция должна иметь аргумент, 
команда <b>getopts</b> помещает этот аргумент в переменную <b>OPTARG</b>. Командный 
интерпретатор не сбрасывает значение <b>OPTIND</b> автоматически. Между вызовами 
команды <b>getopts</b> в том же командном интерпретаторе, если необходимо использовать 
новый набор параметров, надо сбрасывать это значение явно.

<p>Когда все опции обработаны, команда <b>getopts</b> завершает работу со значением, 
большим нуля. <b>OPTIND</b> при этом содержит индекс первого аргумента, не являющегося 
опцией, а переменная <b>имя</b> получает значение <b>?</b>.</p>

<p>Команда <b>getopts</b> обычно обрабатывает позиционные параметры, но если заданы 
<b>аргументы</b>, <b>getopts</b> разбирает их.</p>

<p>Команда <b>getopts</b> может сообщать об ошибках двумя способами. Если первый символ 
<b>строки_опций</b> - двоеточие, используется немногословное информирование об 
ошибках. При обычной работе выдаются диагностические сообщения, если 
обнаруживаются недопустимые опции или недостающие аргументы. Если переменная 
<b>OPTERR</b> имеет значение 0, сообщения об ошибках не выдаются, даже если первым 
символом <b>строки_опций</b> не является двоеточие.</p>

<p>Если обнаружена недопустимая опция, <b>getopts</b> помещает <b>?</b> в переменную 
<b>имя</b> и, если не задано немногословное информирование, выдает сообщение об ошибке и 
сбрасывает переменную <b>OPTARG</b>. Если <b>getopts</b> работает в режиме немногословного 
информирования, символ опции помещается в переменную <b>OPTARG</b> и никакие 
диагностические сообщения не выдаются.</p>

<p>Если обязательный <b>аргумент</b> не обнаружен, и для <b>getopts</b> не задано немногословное 
информирование, переменная <b>имя</b> получает значение <b>?</b>, переменная <b>OPTARG</b> 
сбрасывается, и выдается диагностическое сообщение. Если <b>getopts</b> работает в режиме 
немногословного информирования, переменная <b>имя</b> получает значение <b>:</b>, а в 
переменную <b>OPTARG</b> помещается символ опции.</p>

<p>Команда <b>getopts</b> возвращает 0, если опция, указанная или не указанная, обнаружена. 
Она возвращает ложь, если достигнут конец опций или произошла ошибка.</p>
</dd>
</dl>

<dl>
<dt><b><a name="hash">hash [-r] [-p имя_файла] [имя]</a></b></dt><dd>
Для каждого <b>имени</b> определяется и запоминается полное имя команды 
путем поиска в каталогах, перечисленных в переменной <b>$PATH</b>.
Если указана опция <b>-p</b>, поиск по каталогам не выполняется, и указанное
<b>имя файла</b> используется как полное имя команды. Опция <b>-r</b> вызывает 
сброс всех запомненных имен. Если аргументы не заданы, выдается 
информация о запомненных командах. Статус выхода - истина, если  
только имя удалось найти и не указана недопустимая опция.
<br><br></dd>
<dt><b><a name="help">help [шаблон]</a></b></dt><dd>
Выдает полезную информацию о встроенных командах. Если <b>шаблон</b> указан,
команда <b>help</b> выдает детальную справочную информацию о всех командах, 
соответствующих <b>шаблону</b>; в противном случае, выдается справка по всем
встроенным командам и управляющим структурам интерпретатора. Статус 
выхода - 0, если удалось найти команду, соответствующую <b>шаблону</b>.
<br><br></dd>
<dt><b><a name="history_builtin">history [-c] [n]<br>
history -anrw [имя_файла]<br>
history -p аргумент [аргумент ...]<br>
history -s аргумент [аргумент ...]</a></b></dt><dd>
Если опции не указаны, выдает список истории команд с номерами строк.
Строки, для которых указана звездочка (<b>*</b>), были изменены.
При указании аргумента <b>n</b> выдаются только последние <b>n</b> строк.
Если указано <b>имя_файла</b>, список истории берется из этого файла; если файл
не указан, используется значение переменной <b>HISTFILE</b>.
Опции имеют следующие значения:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="5%"><b>-a</b></td><td>
Добавлять "новые" строки истории (строки истории, введенные с начала
текущего сеанса <b>bash</b>) в файл истории.</td></tr>
<tr><td valign="top"><b>-n</b></td><td>
Читать строки истории, еще не прочитанные из файла истории, в текущий список 
истории команд. Речь идет о строках, добавленных в файл истории с начала
текущего сеанса <b>bash</b>.</td></tr>
<tr><td valign="top"><b>-r</b></td><td>
Читать содержимое файла истории и использовать его в качестве текущего списка
истории выполнения команд.</td></tr>
<tr><td valign="top"><b>-w</b></td><td>
Записывать текущий список истории команд в файл истории, переписывая его 
текущее содержимое.</td></tr>
<tr><td valign="top"><b>-c</b></td><td>
Очистить список истории выполнения команд, удаляя все записи.</td></tr>
<tr><td valign="top"><b>-p</b></td><td>
Выполнить подстановку из списка истории для последующих аргументов и выдать
результат в стандартный выходной поток. Результат не запоминается в 
списке истории. Для отключения обычной подстановки из списка истории,
необходимо маскировать (брать в кавычки) каждый аргумент.</td></tr>
<tr><td valign="top"><b>-s</b></td><td>
Сохранить аргументы в списке истории как одну запись. Последняя команда
в списке истории удаляется перед добавлением аргументов.</td></tr>
</tbody></table>

<p>Возвращается значение 0, если не передана недопустимая опция
или при попытке чтения или записи файла истории не произошла ошибка.</p>
</dd>
<dt><b><a name="jobs">jobs [-lnprs] [ задание ... ]<br>
jobs -x команда [ аргументы ... ]</a></b></dt><dd>
Первое из списка активных заданий. Опции имеют следующие значения:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="5%"><b>-l</b></td><td>
Помимо обычной информации выдает идентификаторы процессов.</td></tr>
<tr><td valign="top"><b>-p</b></td><td>
Выдает только идентификаторы процессов-лидеров групп процессов, образующих
<b>задание</b>.</td></tr>
<tr><td valign="top"><b>-n</b></td><td>
Выдает информацию только о заданиях, состояние которых изменилось с момента 
последнего уведомления пользователя о состоянии заданий.</td></tr>
<tr><td valign="top"><b>-r</b></td><td>
Выдает только выполняющиеся задания.</td></tr>
<tr><td valign="top"><b>-s</b></td><td>
Выдает только остановленные задания.</td></tr>
</tbody></table>

<p>Если указано <b>задание</b>, выдается информация только об этом задании. 
Статус выхода - 0, кроме случаев, когда указана недопустимая опция или идентификатор
несуществующего задания.</p>

<p>Если указана опция <b>-x</b>, команда <b>jobs</b> заменяет любой идентификатор
задания в <b>команде</b> или <b>аргументах</b> соответствующим идентификатором группы
процессов, и выполняет команду, передавая ей аргументы и возвращая ее статус выхода.</p>
</dd>
<dt><b><a name="kill">kill [-s сигнал | -n номер_сигнала | -сигнал] [идентификатор_процесса | задание] ...<br>
kill -l [сигнал | статус_выхода]</a></b></dt><dd>
Посылает указанный по имени или номеру <b>сигнал</b> процессам с указанными
<b>идентификаторами</b> или входящим в <b>задание</b> с указанным идентификатором.
<b>Сигнал</b> задается либо по имени, например, <b>SIGKILL</b>, либо по номеру. 
Если <b>сигнал</b> задается по имени, имя может включать префикс <b>SIG</b>, а может 
и не включать. Если сигнал не задан явно, предполагается сигнал 
<b>SIGTERM</b>. При указании опции <b>-l</b> выдаются имена сигналов.
Если при указании опции <b>-l</b> заданы аргументы, выдаются только имена 
сигналов, соответствующих аргументам, и возвращается статус 0. 
Аргумент <b>статус_выхода</b> опции <b>-l</b> - число, задающее либо номер сигнала, 
либо статус выхода процесса, прерванного этим сигналом. Команда <b>kill</b>
возвращает истину, если, по крайней мере, один сигнал был послан 
успешно, или ложь, если возникла ошибка или была указана недопустимая опция.
<br><br></dd>
<dt><b><a name="let">let аргумент [аргумент ...]</a></b></dt><dd>
Каждый аргумент - арифметическое выражение, которое необходимо 
вычислить (см. раздел "<a href="#arithmetic_eval"><b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b></a>").  
Если последний аргумент имеет значение 0, команда <b>let</b> возвращает 1,
в противном случае, она возвращает зачение 0.
<br><br></dd>
<dt><b><a name="local">local [имя[=значение] ...]</a></b></dt><dd>
Для каждого аргумента создается локальная переменная с указанным 
<b>именем</b>, получающая соответствующее <b>значение</b>. Когда команда <b>local</b> 
используется в функции, она ограничивает область действия этой 
переменной соответствующей функцией и вызванными из нее функциями.
При вызове без операндов команда <b>local</b> выдает список локальных
переменных в стандартный выходной поток. Использование команды
<b>local</b> вне функции - ошибка. Статус возврата - 0, если только 
команда <b>local</b> не использована вне функции или не передано 
недопустимое имя.
<br><br></dd>
<dt><b><a name="logout">logout</a></b></dt><dd>
Выход из начального командного интерпретатора.
<br><br></dd>
<dt><b><a name="popd">popd [-n] [+n] [-n]</a></b></dt><dd>
Удаляет записи из стека каталогов. При вызове без аргументов
удаляет верхний каталог из стека и выполняет переход в новый
верхний каталог. Аргументы имеют следующие значения:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="5%"><b>+n</b></td><td>
Удаляет <b>n</b>-ную запись слева списка каталогов, начиная с нуля.
Например: "<b>popd +0</b>" удаляет первый каталог, а "<b>popd +1</b>" - второй.</td></tr>
<tr><td valign="top"><b>-n</b></td><td>
Удаляет <b>n</b>-ную запись справа списка каталогов, начиная с нуля.
Например: "<b>popd -0</b>" удаляет последний каталог, а 
"<b>popd -1</b>" - предпоследний.</td></tr>
<tr><td valign="top"><b>-n</b></td><td>
Подавляет обычное измнение текущего каталога при удалении каталогов 
из стека, так что изменяется только содержимое стека.</td></tr>
</tbody></table>

<p>Если команда <b>popd</b> завершается успешно, выполняется также команда
<a href="#dirs"><b>dirs</b></a> и возвращается статус 0. Команда <b>popd</b> возвращает ложь,
если выявлена недопустимая опция, стек каталогов - пустой, указана
несуществующая запись в стеке каталогов или не удалось перейти в
соответствующий каталог.</p>
</dd>
<dt><b><a name="printf">printf формат [аргументы]</a></b></dt><dd>
Выдает <b>аргументы</b> в соответствии с <b>форматом</b> в стандартный
выходной поток. <b>Формат</b> - строка символов, содержащая три
типа объектов: обычные символы, которые просто копируются
в стандартный выходной поток, управляющие последовательности 
символов, преобразуемые и копируемые в стандартный выходной поток, и
спецификации формата, каждая из которых вызывает выдачу последующего
аргумента. Помимо стандартных форматов <b>printf(1)</b>, спецификатор <b>%b</b>
вызывает замену управляющих последовательностей, начинающихся с 
обратной косой, а спецификатор <b>%q</b> требует выдать соответствующий 
аргумент в формате, который можно повторно использовать в качестве
входных данных командного интерпретатора.

<p><b>Формат</b> при необходимости используется повторно, чтобы покрыть все 
<b>аргументы</b>. Если <b>формат</b> требует больше <b>аргументов</b>, чем передано,
дополнительные спецификации формата раскрываются как если бы были 
переданы нулевые значения или пустые строки, соответственно.</p>
</dd>
<dt><b><a name="pushd">pushd [-n] [каталог]<br>
pushd [-n] [+n] [-n]</a></b></dt><dd>
Добавляет каталог на вершину стека каталогов или прокручивает стек, делая новый 
верхний элемент стека текущим рабочим каталогом. При вызове без аргументов,
меняет местами два верхних каталога и возвращает 0, если
стек каталогов не пустой. Аргументы имеют следующие значения:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="5%"><b>+n</b></td><td>
Прокручивает стек так, что <b>n</b>-ный каталог (при подсчете слева
по списку каталогов, начиная с 0) становится вершиной.</td></tr>
<tr><td valign="top"><b>-n</b></td><td>
Прокручивает стек так, что <b>n</b>-ный каталог (при подсчете справа
по списку каталогов, начиная с 0) становится вершиной.</td></tr>
<tr><td valign="top"><b>-n</b></td><td>
Эта опция подавляет обычный переход в каталог при добавлении каталогов в
стек, так что действия выполняются только со стеком.</td></tr>
<tr><td valign="top"><b>каталог</b></td><td>
Добавляет каталог на вершину стека каталогов, делая его текущим
рабочим каталогом.</td></tr>
</tbody></table>

<p>Если команда <b>pushd</b> выполнена успешно, выполняется также команда 
<a href="#dirs"><b>dirs</b></a>. Если
используется первая форма, <b>pushd</b> возвращает 0 за исключением случая, 
когда не удалось перейти в каталог. При использовании второй формы
<b>pushd</b>  возвращает 0, если только стек каталогов не пустой, не указан несуществующий
элемент стека и удалось перейти в новый текущий каталог.</p>
</dd>
<dt><b><a name="pwd">pwd [-LP]</a></b></dt><dd>
Выдает полное имя текущего каталога. Выдаваемое имя файла не содержит символьных
связей, если указана опция <b>-P</b> или включена опция <b>-o  physical</b>
встроенной команды <a href="#set"><b>set</b></a>. Если использована опция 
<b>-L</b>, выполняется проход по символьным связям. Статус выхода - 0, если не 
возникла ошибка при чтении имени текущего каталога или не передана недопустимая опция.
<br><br></dd>
<dt><b><a name="read">read [-er] [-a имя_массива] [-p приглашение] [имя ...]</a></b></dt><dd>
Читает одну строку из стандартного входного потока и присваивает первое слово
первому <b>имени</b>, второе слово - второму <b>имени</b>, и так далее, так что оставшиеся слова
вместе с разделителями между ними присваиваются в качестве значения последнему 
<b>имени</b>. Если из входного потока прочитано меньше слов, чем указано <b>имен</b>, остальные
<b>имена</b> получают пустые значения. Для разбиения строки на слова используются символы,
указанные в значении переменной <b>IFS</b>. Символ обратной косой (\) можно использовать
для литеральной интерпретации следующего прочитанного символа и для продолжения ввода
на следующей строке. Опции имеют следующие значения:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="5%"><b>-r</b></td><td>
Обратная косая не обрабатывается как символ маскировки. Она считается частью строки.  
В частности, для продолжения на следующей строке нельзя использовать пару
обратная косая/новая строка.</td></tr>
<tr><td valign="top"><b>-p</b></td><td>
Выдает <b>приглашение</b>, без завершающего перевода строки, перед чтением входного
потока. <b>Приглашение</b> выдается только если входные данные идут с терминала.</td></tr>
<tr><td valign="top"><b>-a</b></td><td>
Слова присваиваются последовательным элементам массива <b>имя_массива</b>, начиная с 0.
<b>Имя_массива</b> сбрасывается перед присваиванием новых значений. Другие имена в аргументах игнорируются.</td></tr>
<tr><td valign="top"><b>-e</b></td><td>
Если стандартный входной поток идет с терминала, для получения строки используется
библиотека <b>readline</b> (см. раздел "<a href="#readline"><b>БИБЛИОТЕКА READLINE</b></a>" ранее).</td></tr>
</tbody></table>

<p>Если имена не указаны, прочитанная строка присваивается переменной <b>REPLY</b>.
Статус выхода - 0, если только не встретился символ конца файла.</p>
</dd>
</dl>

<dl>
<dt><b><a name="readonly">readonly [-apf] [имя ...]</a></b></dt><dd>
Указанные <b>имена</b> помечаются как доступные только для чтения; значения соответствующих
переменных нельзя изменять в дальнейшем с помощью присваивания. Если указана опция
<b>-f</b>, функции, соответствующие <b>именам</b>, тоже помечаются. Опция <b>-a</b> ограничивает
действие только массивами. Если ни одно <b>имя</b> не указано или задана опция <b>-p</b>,
выдается список имен, доступных только для чтения. Опция <b>-p</b> вызывает выдачу 
результатов в формате, который можно использовать как входной. Статус выхода - 0, 
если только не передана недопустимая опция, одно из <b>имен</b> не является именем 
переменной или опция <b>-f</b> не указана перед именем, не являющимся именем функции.
<br><br></dd>
<dt><b><a name="return">return [n]</a></b></dt><dd>
Вызывает завершение работы функции с указанным статусом выхода <b>n</b>. Если <b>n</b> не указано,
возвращается статус выхода последней команды, выполненной в теле функции. При использовании вне функции, но в ходе выполнения сценария командой <b>.</b> (<a href="#source"><b>source</b></a>),
вызывает прекращение выполнения сценария и возврат либо значения <b>n</b>, либо
статуса выхода последней команды сценария. При использовании вне функции и не при
выполнении сценария командой <b>.</b>, возвращает 1.
<br><br></dd>
<dt><b><a name="set">set [--abefhkmnptuvxBCHP] [-o опция] [аргумент ...]</a></b></dt><dd>
При вызове без опций выдает имя и значение всех переменных командного интерпретатора в виде, пригодном для повторного выполнения присваиваний. Результат отсортирован по
именам в соответствии с текущей локалью. Если опции указаны, они устанавливают или сбрасывают атрибуты командного интерпретатора. Все оставшиеся после обработки опций
аргументы присваиваются последовательно в качестве значений позиционным параметрам
<b>$1</b>, <b>$2</b>,... <b>$n</b>. Опции имеют следующие значения:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="15%"><b><a name="set-a">-a</a></b></td><td>
Автоматически помечать изменяемые или создаваемые переменные как экспортируемые 
в среду для последующих команд.</td></tr>
<tr><td valign="top"><b><a name="set-b">-b</a></b></td><td>
Сообщать о состоянии прерванных фоновых заданий немедленно, а не перед выдачей
следующего первичного приглашения. Эта опция действует только если включено управление
заданиями.</td></tr>
<tr><td valign="top"><b><a name="set-e">-e</a></b></td><td>
Немедленно завершать работу, если <i>простая команда</i> 
(см. раздел "<a href="#shell_syntax"><b>СИНТАКСИС КОМАНД</b></a>" ранее)  
завершает работу с ненулевым статусом выхода. Работа командного интерпретатора не
завершается, если закончившаяся неудачно команда является частью 
цикла <a href="#until"><b>until</b></a> или <a href="#while"><b>while</b></a>,
частью оператора <a href="#if"><b>if</b></a>, частью списка <b>&amp;&amp;</b> или <b>||</b>, или 
если к статусу выхода команды применяется отрицание с помощью оператора <b>!</b>.</td></tr>
<tr><td valign="top"><b><a name="set-f">-f</a></b></td><td>
Отключить подстановку имен файлов.</td></tr>
<tr><td valign="top"><b><a name="set-h">-h</a></b></td><td>
Запоминать местонахождение команд, найденное при выполнении. Эта опция включена по
умолчанию.</td></tr>
<tr><td valign="top"><b><a name="set-k">-k</a></b></td><td>
Помещать в среду все аргументы в виде операторов присваивания, а не только
предшествующие имени команды.</td></tr>
<tr><td valign="top"><b><a name="set-m">-m</a></b></td><td>
Режим мониторинга. Управление заданиями включено. Эта опция стандартно устанавливается
для интерактивных командных интерпретаторов в системах, где управление заданиями
поддерживается (см. раздел 
"<a href="#job_control"><b>УПРАВЛЕНИЕ ЗАДАНИЯМИ</b></a>" ранее). Фоновые процессы
работают в отдельной группе процессов, и строка, содержащая их статус выхода, выдается
при завершении их работы.</td></tr>
<tr><td valign="top"><b><a name="set-s">-n</a></b></td><td>
Читать команды, но не выполнять их. Эту опцию можно использовать для проверки
наличия синтаксических ошибок в сценариях командного интерпретатора. Интерактивные 
командные интерпретаторы ее игнорируют.</td></tr>
<tr><td valign="top"><b><a name="set-o">-o имя_опции</a></b></td><td>
<b>Имя_опции</b> может иметь одно из следующих значений:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="15%"><b><a name="allexport">allexport</a></b></td><td>
То же, что и опция <a href="#set-a"><b>-a</b></a></td></tr>
<tr><td valign="top"><b><a name="braceexpand">braceexpand</a></b></td><td>
То же, что и опция <a href="#set-B"><b>-B</b></a></td></tr>
<tr><td valign="top"><b><a name="emacs">emacs</a></b></td><td>
Использовать интерфейс редактирования командной строки в стиле редактора <b>emacs</b>.
Эта опция установлена по умолчанию в интерактивных командных интерпретаторах, если
только они не запущены с опцией <b>--noediting</b></td></tr>
<tr><td valign="top"><b><a name="errexit">errexit</a></b></td><td>
То же, что и опция <a href="#set-e"><b>-e</b></a></td></tr>
<tr><td valign="top"><b><a name="hashall">hashall</a></b></td><td> 
То же, что и опция <a href="#set-h"><b>-h</b></a></td></tr>
<tr><td valign="top"><b><a name="histexpand">histexpand</a></b></td><td>
То же, что и опция <a href="#set-H"><b>-H</b></a></td></tr>
<tr><td valign="top"><b><a name="history">history</a></b></td><td>
Включить поддержку истории выполнения команд, как описано ранее 
в разделе "<a href="#history"><b>ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</b></a>". 
Эта опция установлена по умолчанию для интерактивных командных интерпретаторов.</td></tr>
<tr><td valign="top"><b><a name="ignoreeof">ignoreeof</a></b></td><td>
Результат такой же, как и после выполнения команды <b>IGNOREEOF=10</b> (см. раздел
"<a href="#shell_vars"><b>Переменные командного интерпретатора</b></a>" ранее)</td></tr>
<tr><td valign="top"><b><a name="keyword">keyword</a></b></td><td>
То же, что и опция <a href="#set-k"><b>-k</b></a></td></tr>
<tr><td valign="top"><b><a name="monitor">monitor</a></b></td><td>
То же, что и опция <a href="#set-m"><b>-m</b></a></td></tr>
<tr><td valign="top"><b><a name="noclobber">noclobber</a></b></td><td>
То же, что и опция <a href="#set-C"><b>-C</b></a></td></tr>
<tr><td valign="top"><b><a name="noexec">noexec</a></b></td><td>
То же, что и опция <a href="#set-n"><b>-n</b></a></td></tr>
<tr><td valign="top"><b><a name="noglob">noglob</a></b></td><td>
То же, что и опция <a href="#set-f"><b>-f</b></a></td></tr>
<tr><td valign="top"><b><a name="notify">notify</a></b></td><td>
То же, что и опция <a href="#set-b"><b>-b</b></a></td></tr>
<tr><td valign="top"><b><a name="nounset">nounset</a></b></td><td>
То же, что и опция <a href="#set-u"><b>-u</b></a></td></tr>
<tr><td valign="top"><b><a name="onecmd">onecmd</a></b></td><td>
То же, что и опция <a href="#set-t"><b>-t</b></a></td></tr>
<tr><td valign="top"><b><a name="physical">physical</a></b></td><td>
То же, что и опция <a href="#set-P"><b>-P</b></a></td></tr>
<tr><td valign="top"><b><a name="posix">posix</a></b></td><td>
Изменяет поведение <b>bash</b> на соответствующее стандарту
POSIX  1003.2, там, где оно отличается</td></tr>
<tr><td valign="top"><b><a name="privileged">privileged</a></b></td><td>
То же, что и опция <a href="#set-p"><b>-p</b></a></td></tr>
<tr><td valign="top"><b><a name="verbose">verbose</a></b></td><td>
То же, что и опция <a href="#set-v"><b>-v</b></a></td></tr>
<tr><td valign="top"><b><a name="vi">vi</a></b></td><td>
Использовать интерфейс редактирования командной строки в стиле редактора <b>vi</b>.</td></tr>
<tr><td valign="top"><b><a name="xtrace">xtrace</a></b></td><td>
То же, что и опция <a href="#set-x"><b>-x</b></a>.</td></tr>
</tbody></table>

Если указана опция <b>-o</b> без <b>имени_опции</b>, выдаются значения текущих установленных опций.
Если указана опция <b>+o</b> без <b>имени_опции</b>, в стандартный выходной поток выдается набор
команд <b>set</b>, необходимый для воссоздания текущего набора опций.
</td></tr>
<tr><td valign="top"><b><a name="set-p">-p</a></b></td><td>
Включить привилегированный режим. В этом режиме файлы <b>$ENV</b> и <b>$BASH_ENV</b> не
обрабатываются, функции командного интерпертатора не наследуются из среды, а переменная
среды <b>SHELLOPTS</b> игнорируется. Если командный интерпретатор запущен с эффективным
идентификатором пользователя (группы), не совпадающим с реальным, а опция <b>-p</b> не
задана, выполняются перечилсенные действия и эффективный идентификатор
устанавливается равным реальному. Если опция <b>-p</b> задана при запуске, эффективный
идентификатор не сбрасывается. Отключение данной опции приводит к установке эффективных идентификаторов пользователя и группы равными реальным.</td></tr>
<tr><td valign="top"><b><a name="set-t">-t</a></b></td><td>
Завершить после чтения и выполнения одной команды.</td></tr>
<tr><td valign="top"><b><a name="set-u">-u</a></b></td><td>
При подстановке значений параметров рассматривать не установленную переменную как
ошибку. При попытке подстановки значения не существующей переменной командный
интерпретатор выдает сообщение об ошибке и, если он - не интерактивный, завершает
работу с ненулевым статусом выхода.</td></tr>
<tr><td valign="top"><b><a name="set-v">-v</a></b></td><td>
Выдавать строки команд по мере чтения.</td></tr>
<tr><td valign="top"><b><a name="set-x">-x</a></b></td><td>
После подстановок в каждой простой команде выдавать значение переменной <b>PS4</b>, а затем -
команду с результатами подстановок в аргументах.</td></tr>
<tr><td valign="top"><b><a name="set-B">-B</a></b></td><td>
Выполнять подстановку квадратных скобок в командном интерпретаторе (см. раздел
"<a href="#brace_expansion"><b>Подстановка выражений в скобках</b></a>" ранее).
Эта опция установлена по умолчанию.</td></tr>
<tr><td valign="top"><b><a name="set-C">-C</a></b></td><td>
Если эта опция установлена, <b>bash</b> не переписывает существующий файл при перенаправлениях
с помощью операторов <b>&gt;</b>, <b>&gt;&amp;</b> и <b>&lt;&gt;</b>. Это поведение можно 
переопределить при создании выходных файлов, применяя оператор перенаправления 
<b>|&gt;</b> вместо <b>&gt;</b>.</td></tr>
<tr><td valign="top"><b><a name="set-H">-H</a></b></td><td> 
Включить подстановку из списка истории с помощью метасимвола <b>!</b>. Эта опция
по умолчанию установлена в интерактивных командных интерпретаторах.</td></tr>
<tr><td valign="top"><b><a name="set-P">-P</a></b></td><td>
Если эта опция установлена, командный интерпретатор не следует по символьным
связям при выполнении команд типа <b>cd</b>, изменяющих текущий рабочий каталог. Вместо этого,
он использует физическую структуру каталогов. По умолчанию, <b>bash</b> следует по
логической цепочке каталогов при выполнении команд, изменяющих текущий каталог.</td></tr>
<tr><td valign="top"><b><a name="set--">--</a></b></td><td>
Если после этой опции нет аргументов, сбрасываются значения позиционных параметров.
В противном случае, позиционные параметры устанавливаются в соответствии с 
аргументами, даже если некоторые из них начинаются с дефиса (<b>-</b>).</td></tr>
<tr><td valign="top"><b><a name="set-">-</a></b></td><td>
Сигнализирует об окончании опций, так что все оставшиеся аргументы присваиваются
позиционным параметрам. Опции <b>-x</b> и <b>-v</b> при этом отключаются. Если больше 
аргументов нет, позиционные параметры остаются без изменений.</td></tr>
</tbody></table>

<p>Опции по умолчанию отключены, если явно не сказано иначе. При указании <b>+</b> вместо <b>-</b> 
перед буквой опции, опция отключается. Опции также можно задавать как аргументы при
вызове командного интерпретатора. Текущий набор опций представлен в виде значения
параметра <b>$-</b>. Статус выхода - 0, если только не указана недопустимая опция.</p>

</dd><dt><b><a name="shift">shift [n]</a></b></dt><dd>
Позиционные параметры <b>n+1</b> ... переименовываются в <b>$1</b> .... Параметры от <b>$#-n+1</b> до
<b>$#</b> сбрасываются. <b>n</b> должно быть неотрицательным целым числом, не превышающим <b>$#</b>.
Если <b>n</b> равно 0, параметры не изменяются. Если <b>n</b> не указано, предполагается 
значение 1. Если <b>n</b> больше <b>$#</b>, поизиционные параметры не изменяются. Статус выхода -
больше нуля, если <b>n</b> больше <b>$#</b> или отрицательное и 0 в противном случае.
<br><br></dd>
<dt><b><a name="shopt">shopt [-pqsu] [-o] [имя_опции ...]</a></b></dt><dd>
Переключает значения переменных, управляющих не обязательным поведением командного
интерпретатора. Если опции не указаны или задана опция <b>-p</b>, выдается список всех
возможных опций, с указанием, установлена опция или нет. Опция <b>-p</b> вызывает 
выдачу результатов в формате, позволяющем использовать их в качестве входных команд.  
Остальные опции имеют следующие значения:

<table cellspacing="4&quot;" border="0">
<tbody><tr><td valign="top" width="5%"><b>-s</b></td><td>
Включает (устанавливает) все указанные опции.</td></tr>
<tr><td valign="top"><b>-u</b></td><td>
Отключает (сбрасывает) все указанные опции.</td></tr>
<tr><td valign="top"><b>-q</b></td><td>
Подавляет выдачу стандартной информации (немногословный режим); статус выхода
показывает, установлена опция или нет. Если после <b>-q</b> указано несколько <b>имен_опций</b>,
статус выхода - 0, если все указанные опции включены и не 0 в противном случае.</td></tr>
<tr><td valign="top"><b>-o</b></td><td>
Ограничивает значения <b>имен_опций</b> только поддерживаемыми в 
опции <a href="#set-o"><b>-o</b></a> встроенной команды <a href="#set"><b>set</b></a>.</td></tr>
</tbody></table>

<p>Если опция <b>-s</b> или <b>-u</b> использована без аргументов, выдается информация только об
установленных или неустановленных опциях, соответственно. Если не указано иначе, опции
команды <b>shopt</b> по умолчанию отключены (сброшены).</p>

<p>Статус выхода при выдаче опций - 0, если все указанные опции включены и не 0 в 
противном случае. При установке или сбросе опций статус выхода - 0, если только не
указана недопустимая опция командного интерпретатора.</p>

<p>Вот список допустимых опций команды <b>shopt</b>:</p>
<dl>
<dt><b><a name="cdable_vars">cdable_vars</a></b></dt><dd>
Если эта опция установлена и переданный встроенной команде <a href="#cd"><b>cd</b></a> 
аргумент не является именем каталога, то предполагается, что это - имя переменной, 
значение которой - каталог для перехода.<br><br></dd>
<dt><b><a name="cdspell">cdspell</a></b></dt><dd> 
Если эта опция установлена, небольшие ошибки в написании имен каталогов для
команды <b>cd</b> будут исправляться. Речь идет о переставленных местами символах,
пропущенном символе и одном лишнем символе. Если при исправлении найден подходящий
вариант, выдается исправленное имя каталога и команда выполняется. Эта опция
используется только интерактивными командными интерпретаторами.<br><br></dd>
<dt><b><a name="checkhash">checkhash</a></b></dt><dd>
Если эта опция установлена, <b>bash</b> проверяет, что найденная в хэше команда
существует, прежде чем пытаться ее выполнить. Если находящаяся в хэше команда больше не
существует, выполняется обычный поиск по каталогам.<br><br></dd>
<dt><b><a name="cdeckwinsize">checkwinsize</a></b></dt><dd>
Если эта опция установлена, <b>bash</b> проверяет размер окна после выполнения каждой
команды и, при необходимости, обновляет значения переменных <b>LINES</b> и <b>COLUMNS</b>.<br><br></dd>
<dt><b><a name="cmdhist">cmdhist</a></b></dt><dd>
Если эта опция установлена, <b>bash</b> пытается сохранить все строки многострочной
команды в одной записи списка истории. Это позволяет легко редактировать многострочные
команды.<br><br></dd>
<dt><b><a name="dotglob">dotglob</a></b></dt><dd>
Если эта опция установлена, <b>bash</b> включает в результаты подстановки имен файлов
имена, начинающиеся с точки (<b>.</b>).<br><br></dd>
<dt><b><a name="execfail">execfail</a></b></dt><dd>
Если эта опция установлена, не интерактивный командный интерпретатор не будет 
завершать работу, если не сможет выполнить файл, указанный в качестве аргумента для
встроенной команды <a href="#exec"><b>exec</b></a>. 
Интерактивный командный интерпретатор не завершает работу, 
если команда <b>exec</b> не срабатывает.<br><br></dd>
<dt><b><a name="expand_aliases">expand_aliases</a></b></dt><dd>
Если эта опция установлена, псевдонимы заменяются так, как было описано ранее в
разделе "<a href="#aliases"><b>ПСЕВДОНИМЫ</b></a>". Эта опция включена по умолчанию 
в интерактивных командных интерпретаторах.<br><br></dd>
<dt><b><a name="extglob">extglob</a></b></dt><dd>
Если эта опция установлена, поддерживаются расширенные возможности сопоставления с образцом, описанные ранее в разделе 
"<a href="#pathname_expansion"><b>Подстановка имен файлов</b></a>".<br><br></dd>
<dt><b><a name="histappend">histappend</a></b></dt><dd>
Если эта опция установлена, список истории добавляется в файл, имя которого является
значением пременной <b>HISTFILE</b>, при завершении работы командного интерпретатора, а не 
переписывает файл.<br><br></dd>
<dt><b><a name="histreedit">histreedit</a></b></dt><dd>
Если эта опция установлена и используется библиотека <b>readline</b>, пользователь получает
возможность повторно редактировать команду при невозможности подстановки из списка 
истории.<br><br></dd>
<dt><b><a name="histverify">histverify</a></b></dt><dd>
Если эта опция установлена и используется библиотека <b>readline</b>, результаты подстановки
из списка истории не передаются анализатору командного интерпретатора немедленно.
Вместо этого, полученная в результате строка загружается в буфер редактирования
<b>readline</b> для дальнейших изменений.<br><br></dd>
<dt><b><a name="hostcomplete">hostcomplete</a></b></dt><dd>
Если эта опция установлена и используется библиотека <b>readline</b>, <b>bash</b> будет пытаться
выполнить подстановку имен хостов после завершения слова, содержащего символ <b>@</b>, (см.
подраздел "<a href="#completing"><b>Завершение</b></a>" в разделе 
"<a href="#readline"><b>БИБЛИОТЕКА READLINE</b></a>" ранее). 
Эта опция включена по умолчанию.<br><br></dd>
<dt><b><a name="huponexit">huponexit</a></b></dt><dd>
Если эта опция установлена, <b>bash</b> будет посылать сигнал <b>SIGHUP</b> всем заданиям
при завершении работы интерактивного начального командного интерпретатора.<br><br></dd>
<dt><b><a name="interactive_comments">interactive_comments</a></b></dt><dd>
Если эта опция установлена, слово, начинающееся символом <b>#</b>, и все остальные символы в
этой строке игнорируются интерактивным команжным интерпретатором (см. раздел
"<a href="#comments"><b>КОММЕНТАРИИ</b></a>" ранее). Эта опция включена по умолчанию.<br><br></dd>
<dt><b><a name="lithist">lithist</a></b></dt><dd>
Если эта опция установлена, и установлена опция <a href="#cmdhist"><b>cmdhist</b></a>, 
многострочные команды, по возможности, сохраняются в списке истории со встроенными 
символами новой строки вместо точек с запятыми.<br><br></dd>
<dt><b><a name="mailwarn">mailwarn</a></b></dt><dd>
Если эта опция установлена и файл, проверяемый командным интерпретатором <b>bash</b> как
почтовый ящик, читался с момента последней проверки, выдается сообщение
"<b>The mail in имя_файла has been read</b>".<br><br></dd>
<dt><b><a name="nocaseglob">nocaseglob</a></b></dt><dd>
Если эта опция установлена, <b>bash</b> при подстановке имен файлов выполняет сопоставление
с образцом без учета регистра символов (см. раздел 
"<a href="#pathname_expansion"><b>Подстановка имен файлов</b></a>" ранее).<br><br></dd>
<dt><b><a name="nullglob">nullglob</a></b></dt><dd>
Если эта опция установлена, <b>bash</b> подставляет пустую строку вместо шаблонов, которым
не соответствует ни один файл (см. раздел 
"<a href="#pathname_expansion"><b>Подстановка имен файлов</b></a>" ранее), а не 
сам шаблон.<br><br></dd>
<dt><b><a name="promptvars">promptvars</a></b></dt><dd>
Если эта опция установлена, в строках приглашения выполняется подстановка значений
переменных и параметров после стандартных подстановок, описанных в разделе
"<a href="#prompting"><b>ПРИГЛАШЕНИЯ</b></a>" ранее. Эта опция установлена по умолчанию.<br><br></dd>
<dt><b><a name="restricted_shell_option">restricted_shell</a></b></dt><dd>
Командный интерпретатор устанавливает эту опцию, если он запущен в ограниченном
режиме (см. раздел "
<a href="#restricted_shell"><b>ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</b></a>" ниже). Значение этой
опции изменять нельзя. Она не сбрасывается при выполнении файлов начального запуска,
что позволяет в этих файлах учесть, является ли командный интерпретатор ограниченным.<br><br></dd>
<dt><b><a name="shift_verbose">shift_verbose</a></b></dt><dd>
Если эта опция установлена, встроенная команда <a href="#shift"><b>shift</b></a> выдает сообщение об
ошибке, когда параметр сдвига превышает количество позиционных параметров.<br><br></dd>
<dt><b><a name="sourcepath">sourcepath</a></b></dt><dd>
Если эта опция установлена, встроенная команда <a href="#source"><b>source</b></a> 
(<b>.</b>) использует значение переменной <b>PATH</b> для поиска каталога, содержащего файл, 
переданный в качестве аргумента. Эта опция по умолчанию включена.</dd>
</dl>
</dd>
</dl>

<dl>
<dt><b><a name="suspend">suspend [-f]</a></b></dt><dd>
Приостанавливает работу текущего командного интерпретатора, пока он не получит
сигнал <b>SIGCONT</b>. Опция <b>-f</b> отключает предупреждения, если эта команда выполняется в
начальном командном интерпретаторе - безусловно приостановить работу. Статус выхода -
0, если только командный интерпретатор не является начальным, а опция <b>-f</b> - не указана,
или если управление заданиями отключено.
<br><br></dd>
<dt><b><a name="test">test выражение</a><br>
[ выражение ]</b></dt><dd>
Возвращает статус 0 или 1, в зависимости от результатов проверки условного выражения.
Каждый оператор или операнд должен быть отдельным аргументом. Выражения состоят из
элементов, описанных ранее в разделе "<a href="#conditional_expr"><b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b></a>".

<p>Выражения можно комбинировать с помощью следующих операторов, перечисленных по
убыванию приоритета.</p>

<dl>
<dt><b>! выражение</b></dt><dd>
Истинно, если <b>выражение</b> ложно.<br><br></dd>
<dt><b>( выражение )</b></dt><dd>
Возвращает значение <b>выражения</b>. Можно использовать для переопределения обычного
приоритета выполнения операторов.<br><br></dd>
<dt><b>выражение1 -a выражение2</b></dt><dd>
Истинно, если истинны оба <b>выражения</b>.<br><br></dd>
<dt><b>выражение1 -o выражение2</b></dt><dd>
Истинно, если истинно <b>выражение1</b> или <b>выражение2</b>.</dd>
</dl>

<p>Команды <b>test</b> и <b>[</b> проверяют условные выражения с помощью набора правил, основанного
на количестве аргументов.</p>

<dl>
<dt><b>0 аргументов</b></dt><dd>
Выражение ложно.<br><br></dd>
<dt><b>1 аргумент</b></dt><dd>
Выражение истинно только если <b>аргумент</b> - не пустой.<br><br></dd>
<dt><b>2 аргумента</b></dt><dd>
Если первый <b>аргумент</b> - <b>!</b>, выражение истинно только если второй <b>аргумент</b> -
пустой. Если первый аргумент - один из <i>унарных условных операторов</i>, перечисленных ранее 
в разделе "<a href="#conditional_expr"><b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b></a>", выражение истинно, 
если унарный оператор возвращает истину. Если первый <b>аргумент</b> не является 
допустимым унарным условным оператором, выражение ложно.<br><br></dd>
<dt><b>3 аргумента</b></dt><dd>
Если второй <b>аргумент</b> - один из бинарных условных операторов, перечисленных 
ранее в разделе "<a href="#conditional_expr"><b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b></a>", 
результатом проверки будет значение бинарного
условного выражения, использующего первый и третий <b>аргументы</b> в качестве операндов. Если
первый <b>аргумент</b> - <b>!</b>, результат - отрицание двухаргументной проверки второго и третьего
<b>аргументов</b>. Если первый <b>аргумент</b> - только <b>(</b>, а третий - только <b>)</b>,
результатом будет результат одноаргументной проверки второго <b>аргумента</b>. В противном случае,
выражение ложно. В этом контексте операторы <b>-a</b> и <b>-o</b> считаются бинарными.<br><br></dd>
<dt><b>4 аргумента</b></dt><dd>
Если первый <b>аргумент</b> - <b>!</b>, результат - отрицание трехаргументной проверки оставшихся
<b>аргументов</b>. В противном случае, выражение разбирается и проверяется в соответствии
с приоритетами по перечисленным выше правилам.<br><br></dd>
<dt><b>5 и более аргументов</b></dt><dd>
Выражение разбирается и проверяется в соответствии с приоритетами по перечисленным выше правилам.</dd>
</dl>
</dd>
<dt><b><a name="times">times</a></b></dt><dd>
Выдает накопленные пользовательское и системное время работы для командного
интерпретатора и запущенных из него процессов. Статус выхода - 0.
<br><br></dd>
<dt><b><a name="trap">trap [-lp] [аргумент] [сигнал ...]</a></b></dt><dd>
Команда <b>аргумент</b> читается и выполняется при получении командным интерпретатором
указанных <b>сигналов</b>. Если <b>аргумент</b> не указан или задан как <b>-</b>, для всех указанных
<b>сигналов</b> устанавливаются исходные обработчики (те, что были при запуске
командного интерпретатора). Если <b>аргумент</b> - пустая строка, все указанные сигналы
игнорируются командным интерпретатором и вызываемыми им командами. Если указана
опция <b>-p</b>, выдаются команды <b>trap</b>, связанные с каждым из перечисленных <b>сигналов</b>.
Если аргументов нет или указана только опция <b>-p</b>, команда <b>trap</b> выдает список 
команд (<i>обработчиков</i>), связанных с каждым из <b>сигналов</b>. 
<b>Сигнал</b> можно задавать как по имени,
определенному в файле <b>&lt;signal.h&gt;</b>, так и по номеру. Если в качестве <b>сигнала</b>
указана конструкция <b>EXIT (0)</b>, команда-<b>аргумент</b> выполняется при завершении работы
командного интерпретатора. Если в качестве <b>сигнала</b> указано <b>DEBUG</b>, 
команда-<b>аргумент</b> выполняется после каждой <i>простой команды</i> 
(см. раздел "<a href="#shell_syntax"><b>СИНТАКСИС КОМАНД</b></a>" ранее).
Опция <b>-l</b> приводит к выдаче списка имен сигналов и соответствующих им номеров.
Сигналы, игнорировавшиеся при входе в командный интерпретатор, нельзя перехватить или
переустановить. Перехваченные сигналы сбрасываются в исходные значения в порожденных
процессах при создании. Статус возврата - 1, если указан недопустимый <b>сигнал</b>; в
противном случае, <b>trap</b> возвращает 0.
<br><br></dd>
<dt><b><a name="type">type [-atp] имя [имя ...]</a></b></dt><dd>
При вызове без опций показывает, как имена будут интерпретироваться
при использовании в качестве имени команды. Если указана опция <b>-t</b>, <b>type</b> выдает
одну из строк <b>alias</b>,  <b>keyword</b>,  <b>function</b>,  <b>builtin</b> или <b>file</b>,
если <b>имя</b>, соответственно,
представляет собой псевдоним, зарезервированное слово командного интерпретатора,
функцию, встроенную команду или файл на диске. Если <b>имя</b> не найдено, ничего не
выдается и возвращается статус выхода 1. Если указана опция <b>-p</b>, <b>type</b> вернет
либо имя файла на диске, который будет выполняться при указании имени в качестве
имени команды, либо ничего, если обращения к файлу не будет. Если команда хранится в
хэше, опция <b>-p</b> приводит к выдаче значения из хэша, а не обязательно первого файла,
выбираемого по перечисленным в <b>PATH</b> каталогам. Если использована опция <b>-a</b>, команда 
<b>type</b> выдает список всех каталогов, где есть выполняемый файл с соответствующим именем.  В список включаются также псевдонимы и функции, если только не указана опция <b>-p</b>. К 
хэшу команд не обращаются, если указана опция <b>-a</b>. Команда <b>type</b> возвращает 0,
если хоть один из аргументов найден, и 1 в противном случае.
<br><br></dd>
<dt><b><a name="ulimit">ulimit [-SHacdflmnpstuv [ограничение]]</a></b></dt><dd>
Обеспечивает управление ресурсами, доступными для командного интерпретатора и
запущенных им процессов в системах, поддерживающих такое управление. Значение
ограничения может быть числом единиц измерения ресурса или строкой <b>unlimited</b>.
Опции <b>-H</b> и <b>-S</b> указывают, что для данного ресурса устанавливается жесткое или мягкое
ограничение. <i>Жесткое ограничение</i> после установки превосходить нельзя; <i>мягкое
ограничение</i> можно превосходить вплоть до значения соответствующего жесткого
ограничения. Если опции <b>-H</b> и <b>-S</b> не указаны, устанавливаются и мягкое, и жесткое
ограничение. Если ограничение не указано, выдается текущее значение мягкого ограничения
на ресурс, если только не указана опция <b>-H</b>. Если указано несколько ресурсов, 
перед значением выдается название и единица измерения ресурса. Другие опции
интерпретируются следующим образом:

<table cellspacing="4" border="0">
<tbody><tr><td valign="top" width="5%"><b>-a</b></td><td>
Выдается информация о всех текущих ограничениях</td></tr>
<tr><td valign="top"><b>-c</b></td><td>
Максимальный размер создаваемых файлов <b>core</b></td></tr>
<tr><td valign="top" width="5%"><b>-d</b></td><td>
Максимальный размер сегмента данных процесса</td></tr>
<tr><td valign="top" width="5%"><b>-f</b></td><td>
Максимальный размер файлов, создаваемых командным интерпретатором</td></tr>
<tr><td valign="top" width="5%"><b>-l</b></td><td>
Максимальный размер сегмента, который может быть привязан к памяти</td></tr>
<tr><td valign="top" width="5%"><b>-m</b></td><td>
Максимальный размер резидентного набора</td></tr>
<tr><td valign="top" width="5%"><b>-n</b></td><td>
Максимальное количество открытых <i>файловых дескрипторов</i> (большинство систем не
позволяет устанавливать это значение)</td></tr>
<tr><td valign="top" width="5%"><b>-p</b></td><td>
Размер программного канала в 512-байтовых блоках (его устанавливать нельзя)</td></tr>
<tr><td valign="top" width="5%"><b>-s</b></td><td>
Максимальный размер стека</td></tr>
<tr><td valign="top" width="5%"><b>-t</b></td><td>
Максимальное количество процессорного времени в секундах</td></tr>
<tr><td valign="top" width="5%"><b>-u</b></td><td>
Максимальное количество процессов для одного пользователя</td></tr>
<tr><td valign="top" width="5%"><b>-v</b></td><td>
Максимальный объем виртуальной памяти, доступный командному интерпретатору</td></tr>
</tbody></table>

<p>Если ограничение указано, оно становится новым предельным значением для 
соответствующего ресурса (опция <b>-a</b> только выдает информацию). Если опции не
заданы, предполагается опция <b>-f</b>. Значения представляются в единицах 1024 байта, за
исключением опции <b>-t</b>, где значения - в секундах, <b>-p</b>, где значения - в 512-байтовых
блоках, и опций <b>-n</b> и <b>-u</b>, для которых значения не масштабируются. Статус выхода - 0,
если не указана недопустимая опция, в качестве ограничения не задано не числовое значение, отличное от <b>unlimited</b>, и при установке нового ограничения не произошла ошибка.</p>
</dd>
<dt><b><a name="umask">umask [-p] [-S] [маска]</a></b></dt><dd>
Пользовательская маска создания файла устанавливается равной аргументу <b>маска</b>. Если
<b>маска</b> начинается с цифры, она интерпретируется как восьмеричное число; иначе - как
маска в символьном формате, аналогичном используемому в команде <b>chmod(1)</b>. Если
<b>маска</b> не указана или задана опция <b>-S</b>, выдается текущее значение маски. Опция <b>-S</b>
вызывает выдачу маски в символьном формате; по умолчанию выдается восьмеричное
число. Если указана опция <b>-p</b>, а маска не задана, результат выдается в виде,
который можно использовать во входной команде. Статус выхода - 0, если маска была
успешно изменена или не указана, и 1 в противном случае.
<br><br></dd>
<dt><b><a name="unalias">unalias [-a] [имя ...]</a></b></dt><dd>
Удаляет <b>имена</b> из списка определенных псевдонимов. Если указана опция <b>-a</b>, удаляются
все определения. Возвращается значение 0, за исключением случаев, когда переданное
имя не является псевдонимом.
<br><br></dd>
<dt><b><a name="unset">unset [-fv] [имя ...]</a></b></dt><dd>
Для каждого <b>имени</b> удаляет (сбрасывает) соответствующую переменную или функцию. 
Если опции не указаны или задана опция <b>-v</b>, удаляются только переменные. 
Переменные только для чтения удалять нельзя. Если указана опция <b>-f</b>,
удаляются только определения соответствующих функций. Удаляемая переменная
или функция удаляется из среды, передаваемой последующим командам. Если 
сбрасывается одна из переменных <b>RANDOM</b>, <b>SECONDS</b>, <b>LINENO</b>, 
<b>HISTCMD</b> или <b>DIRSTACK</b>,
эти переменные теряют специальные свойства, даже если они в дальнейшем
снова устанавливаются. Статус выхода - 0, за исключеним случаев, когда <b>имя</b> не
существует или доступно только для чтения.
<br><br></dd>
<dt><b><a name="wait">wait [n]</a></b></dt><dd>
Ждет завершения указанного процесса и возвращает статус его завершения. <b>n</b> может
быть идентификатором процесса или спецификацией задания; если указана спецификация
задания, ждет завершения всех процессов в конвейере соответствующего задания. Если
<b>n</b> не указано, ожидается завершение всех текущих активных порожденных процессов, и
возвращается статус ноль. Если <b>n</b> задает идентификатор несуществующего процесса или
задания, статус выхода - 127. В противном случае, статусом выхода является
статус завершения последнего процесса или задания, завершение которого ждали.
</dd>
</dl>

<h2><a name="restricted_shell">ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</a></h2>

<p>Если <b>bash</b> запущен по имени <b>rbash</b> или с опцией <b>-r</b> при вызове, 
командный интерпретатор становится ограниченным. <i>Ограниченный командный 
интерпретатор</i> используется для создания более управляемой стреды по сравнению с 
обычным интерпретатором. Он ведет себя аналогично <b>bash</b>, но следующие действия 
не разрешены или не выполняются:</p>

<ul>
<li>изменение текущего каталога с помощью <b>cd</b></li>
<li>установка или сброс значений переменных <b>SHELL</b>, <b>PATH</b>, <b>ENV</b> или 
<b>BASH_ENV</b></li>
<li>указание <b>/</b> в именах команд</li>
<li>указание имени файла, содержащего <b>/</b>, в качестве аргумента для встроенной команды <b>.</b></li>
<li>импортирование определений функций из среды командного интерпретатора при запуске</li>
<li>разбор значения переменной <b>SHELLOPTS</b> из среды командного интерпретатора при
запуске</li>
<li>перенаправление вывода с помощью операторов <b>&gt;</b>, <b>&gt;|</b>, <b>&lt;&gt;</b>, <b>&gt;&amp;</b>, <b>&amp;&gt;</b>
и <b>&gt;&gt;</b></li>
<li>использование встроенной команды <a href="#exec"><b>exec</b></a> 
для замены командного интерпретатора другой командой</li>
<li>добавление или удаление встроенных команд с помощью опций <b>-f</b> и <b>-d</b>
встроенной команды <a href="#enable"><b>enable</b></a></li>
<li>указание опции <b>-p</b> для встроенной команды <a href="#command"><b>command</b></a></li>
<li>отключение режима ограниченного командного интерпретатора с помощью опций 
<b>set +r</b> или <b>set +o  restricted</b>.</li>
</ul>

<p>Эти ограничения применяются после чтения файлов начального запуска.</p>

<p>При выполнении команды, которая оказалась сценарием командного интерпретатора
(см. раздел "<a href="#command_exec"><b>ВЫПОЛНЕНИЕ КОМАНД</b></a>" ранее), 
<b>rbash</b> отключает любые ограничения в 
командном интерпретаторе, порожденном для выполнения сценария.</p>

<h2><a name="see_also">ССЫЛКИ</a></h2>
<dl><dt></dt><dd>
Bash Features, Brian Fox and Chet Ramey<br>
The Gnu Readline Library, Brian Fox and Chet Ramey<br>
The Gnu History Library, Brian Fox and Chet Ramey<br>
Utilities, IEEE Portable Operating System Interface (POSIX) Part  2:  Shell<br>
и
<b>sh(1)</b>, 
<b>ksh(1)</b>, 
<b>csh(1)</b>,
<a href="http://ln.com.ua/~openxs/projects/man/uw2/vi.html"><b>vi(1)</b></a>
</dd></dl>

<h2><a name="files">ФАЙЛЫ</a></h2>

<dl>
<dt><b>/bin/bash</b></dt><dd>
Выполняемый файл <b>bash</b><br><br></dd>
<dt><b>/etc/profile</b></dt><dd>
Общесистемный файл инициализации, выполняется начальными командными интерпретаторами<br><br>
</dd><dt><b>~/.bash_profile</b></dt><dd>
Личный файл инициализации, выполняется начальными командными интерпретаторами<br><br>
</dd><dt><b>~/.bashrc</b></dt><dd>
Отдельный файл начального запуска для интерактивных командных интерпретаторов<br><br>
</dd><dt><b>~/.bash_logout</b></dt><dd>
Отдельный файл очистки для начального командного интерпретатора, выполняемый при
завершении его работы<br><br>
</dd><dt><b>~/.inputrc</b></dt><dd>
Отдельный файл инициализации библиотеки <b>readline</b></dd>
</dl>

<h2><a name="authors">АВТОРЫ</a></h2>
<p>Брайан Фокс (Brian Fox), Free Software Foundation<br>
<a href="mailto:bfox@gnu.ai.mit.edu"><b>bfox@gnu.ai.MIT.Edu</b></a></p>

<p>Чет Реми (Chet Ramey), Case Western Reserve University<br>
<a href="mailto:chet@ins.CWRU.Edu"><b>chet@ins.CWRU.Edu</b></a></p>

<h2><a name="bug_reports">ИНФОРМАЦИЯ ОБ ОШИБКАХ</a></h2>

<p>Если вы обнаружили ошибку в <b>bash</b>, сообщите о ней. Но сначала убедитесь, что
это действительно ошибка, и что она проявляется в последней имеющейся у вас версии
<b>bash</b>.</p>

<p>После того, как определено, что ошибка действительно существует, используйте команду
<b>bashbug</b> для посылки сообщения об ошибке. Если вы знаете, как ошибку исправить,
пришлите и исправление! Предложения и "философские" сообщения об ошибках
можете отправлять по электронной почте по адресу 
<a href="mailto:bug-bash@gnu.org"><b>bug-bash@gnu.org</b></a> или в дискуссионную
группу Usenet <b>gnu.bash.bug</b>.</p>

<p>ВСЕ сообщения об ошибках должны включать:</p>
<ul>
<li>номер версии <b>bash</b></li>
<li>информацию об аппаратной платформе и операционной системе</li>
<li>компилятор, использовавшийся для компиляции</li>
<li>описание ошибочного поведения</li>
<li>короткий сценарий или "рецепт", позволяющий воспроизвести проблему</li>
</ul>

<p>Команда <b>bashbug</b> вставляет первые три компонента в предлагаемый шаблон сообщения 
об ошибке автоматически.</p>

<p>Комментарии и сообщения об ошибках на этой странице справочного руководства
отправляйте по адресу <a href="mailto:chet@ins.CWRU.Edu"><b>chet@ins.CWRU.Edu</b></a>.</p>

<p>Комментарии и сообщения об ошибках в переводе этой страницы справочного руководства
на русский язык отправляйте по адресу <a href="mailto:valera@openxs.kiev.ua"><b>valera@openxs.kiev.ua</b></a>.</p>

<h2><a name="bugs">ОШИБКИ</a></h2>

<p>Слишком большой и слишком медленный.</p>

<p>Есть ряд небольших отличий между <b>bash</b> и традационными версиями <b>sh</b>, в основном,
связанные с поддержкой спецификации POSIX.</p>

<p>Псевдонимы иногда могут сбивать с толку.</p>

<p>Встроенные команды и функции интерпретатора нельзя остановить/перезапустить.</p>

<p>Составные команды и последовательности команд вида <b>'a ; b ; c'</b> обрабатываются
некорректно при попытке приостановки процесса. Когда процесс останавливается,
командный интерпретатор немедленно выполняет следующую команду в последовательности.
Для выполнения последовательности команд в порожденном командном интерпретаторе, что
позволяет останавливать их, как единое целое, достаточно взять ее в скобки.</p>

<p>Команды в операторе подстановки результатов выполнения команды <b>$(...)</b> не
разбираются, пока не будет выполнена попытка подстановки. Это откладывает
выдачу сообщения об ошибке на определенное время при вводе команды.</p>

<p>Нельзя (пока) экспортировать массивы.</p>

<h2><a name="notes">ПРИМЕЧАНИЯ</a></h2>
<p>Исходный код <b>bash</b> доступен в пакете <b>SUNWbashS</b>.</p>

<p align="center">Последнее изменение: 20 января 1999 года</p>

<p align="center"><font size="-2">
Copyright 2002 <a href="mailto:valera@openxs.kiev.ua">В. Кравчук</a>,
<a href="http://ln.com.ua/~openxs">OpenXS Initiative</a>, перевод на русский язык
</font></p> 

<br>
<form method="get" action="/search.shtml">
<font size="-1">
<font color="#555555">Поиск по тексту MAN-ов:&nbsp;</font><input size="30" name="words" value="bash" type="text">
<input name="restrict" value="/man" type="hidden">
<input value="Найти" type="submit">
</font>
<input name="method" value="and" type="hidden">
<input name="format" value="builtin-long" type="hidden">
<input name="sort" value="score" type="hidden">
</form>
<br>
<!--htdig_noindex-->
<noindex>
<br>


</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br><br>
<div style="background-color: #E9EAD6; width:100%; height: 61px;">
<div style="margin-right: 20px; float:left; line-height: 61px; vertical-align: middle; margin-left: 10px; font-size: 120%;">
Спонсоры:
</div>
<div style="float:left; height: 60px;  line-height: 60px; margin-left: 20px;">
<a style="align: middle;" target="_blank" href="https://inferno.name/"><img src="/img/inferno2.png" alt="Inferno Solutions" height="57" width="200"></a>
</div>
<div style="float:right; height: 60px;  line-height: 60px;  margin-left: 15px;">
<a style="align: middle;" target="_blank" href="http://hoster.ru/?utm_source=site&amp;utm_medium=banner&amp;utm_campaign=opennet"><img src="/img/dh143x60t.png" alt="Hosting by Hoster.ru" height="60" width="143"></a>
</div>
<div style="float:right;  height: 60px;  line-height: 60px; vertical-align: middle;font-size: 120%;">
Хостинг:
</div>

</div>

<div style="clear: both;"></div>


<br>
<table class="ttxt" style="border-top: 3px solid #C9CaB6;">
<tbody><tr><td width="35%">
<a href="/cgi-bin/opennet/bookmark.cgi">Закладки на сайте</a><br>
<a href="/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить за страницей</a>
</td>
<td align="RIGHT" width="65%">
Created&nbsp;1996-2021&nbsp;by <b><a href="/contact.shtml" title="email maxim.chirkov@gmail.com">Maxim&nbsp;Chirkov</a></b><br>
<a href="https://www.opennet.ru/add.shtml">Добавить</a>, <a href="https://www.opennet.ru/donate.shtml" style="color: #C00000;">Поддержать</a>, <a href="https://www.opennet.ru/banners2.shtml">Вебмастеру</a>
</td>
</tr>
</tbody></table>
<br><br>


<!--/htdig_noindex-->
<!-- end of footer -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>




</body>
<!---------------------------------------------  0  ---------------------------------------------->
