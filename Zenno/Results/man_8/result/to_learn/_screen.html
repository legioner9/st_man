
<!--+++++++++++++++++++++++++++++++++++++++++++  0  +++++++++++++++++++++++++++++++++++++++++++--->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Проект OpenNet: MAN screen (8) Команды системного администрирования (FreeBSD и Linux)</title><meta name="KeyWords" content="man, manual, MAN, системное руководство, linux, FreeBSD, OpenBSD, Solaris, ядро, программы, системный вызов, screen"><meta name="viewport" content="width=device-width, initial-scale=1"></head>


<body link="#0000FF" vlink="#000080" text="#000000" bgcolor="#E3E4D0" alink="#FF00FF">
<link rel="stylesheet" href="/opennet4.css" type="text/css">
<!--htdig_noindex-->
<form method="get" action="https://www.opennet.ru/search.shtml">
<aside>
<div style="width: 100%; text-align: right; font-size: 70%; background: #E9EAD6; margin-bottom:-10px;">
Профиль: <b><a href="/~" rel="nofollow" title="/~ - сводная страница участника"><u>Аноним</u></a></b> (<a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=login">вход</a> | <a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=user_register">регистрация</a>)</div>

<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody><tr>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" valign="BOTTOM" bgcolor="#E9EAD6" width="300">
<a href="https://www.opennet.ru/"><img src="/opennet2.gif" alt="The OpenNET Project" height="60" width="249" border="0"></a><br>
</td>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" bgcolor="#E9EAD6" align="CENTER" width="100">

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:10px;" bgcolor="#E9EAD6" align="CENTER" width="50%">
<table width="100%" border="0">
<tbody><tr>
<td width="22%">
 <a href="https://www.opennet.ru/opennews/" class="h"><b>НОВОСТИ</b></a> (<a href="https://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="18%%">
  <a href="https://www.opennet.ru/mp/" class="h"><b>КОНТЕНТ</b></a>
</td><td width="14%">
  <a href="http://wiki.opennet.ru" class="h"><b>WIKI</b></a>
</td><td width="14%">
   <a href="https://www.opennet.ru/man.shtml" class="h"><b>MAN'ы</b></a>
</td><td width="16%">
   <a href="https://www.opennet.ru/forum/" class="h"><b>ФОРУМ</b></a>
</td><td width="16%">
<a href="https://www.opennet.ru/search.shtml" class="h" onmouseover="document.getElementById('form12').style.display='block';">Поиск</a>&nbsp;(<a href="https://www.opennet.ru/keywords/" class="h">теги</a>)
<input id="form12" style="display: none;" size="10" name="words" value="" title="для поиска в google наберите &quot;g фраза&quot;" type="text">
</td></tr>
</tbody></table>

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:5px;" bgcolor="#E9EAD6" align="right" width="20%">

<a href="https://www.opennet.ru/opennews/opennews_all_utf.rss"><img src="/img/rss.png" alt="RSS" title="RSS" height="16" width="16" border="0"></a>&nbsp;<a href="https://twitter.com/opennetru"><img src="/twitter.png" alt="twitter" title="Twitter" height="16" width="16" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="/img/vkontakte.gif" title="ВКонтакте" height="16" width="16" border="0"></a>&nbsp;<a href="https://zen.yandex.ru/opennet"><img src="/img/zen.gif" title="Yandex Zen" height="16" width="16" border="0"></a>&nbsp;<a href="https://www.facebook.com/OpenNet.News/"><img src="/img/facebook.gif" title="Facebook" height="16" width="16" border="0"></a>&nbsp;<a href="https://telegram.space/opennet_ru"><img src="/img/telegram2.png" title="Telegram" height="16" width="16" border="0"></a>
</td></tr></tbody></table>
</aside>

<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class="hdr_mobile">
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url('/back.gif') repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<a href="https://www.opennet.ru"><img src="/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" alt="The OpenNET Project / Index page"></a>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="/opennews/">новости</a>&nbsp;/<a href="/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">+++</a> | <a href="/forum/">форум</a> | <a href="http://wiki.opennet.ru">wiki</a> | <a href="/keywords/">теги</a>
| <a href="tg://resolve?domain=opennet_ru"><img src="/img/telegram2.png" title="Telegram" style="margin-bottom: -4px;" height="16" width="16" border="0"></a>
]</small>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id="adv">
</div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id="adv2">
</div>
<div style="width: 279;float: right;" id="adv3">
</div>
<div style="clear: both;"></div>
<br>
</form>
<!--/htdig_noindex-->

<center><h3><font color="#000088">Интерактивная система просмотра системных руководств (man-ов)</font></h3></center>
<form method="GET" action="/man.shtml"> 
<table cellspacing="0" cellpadding="1" bgcolor="#B0B190" align="center" width="600" border="0">
<tbody><tr>
<td valign="TOP">

<table cellspacing="0" cellpadding="0" bgcolor="#E9EAD6" align="center" width="100%" border="0">
<tbody><tr><td>&nbsp;<font color="#555555">Тема</font></td><td><font color="#555555">Набор</font></td><td><font color="#555555">Категория</font></td><td>&nbsp;</td></tr>
<tr><td>

&nbsp;<input size="20" name="topic" value="screen" type="text"></td><td><select name="russian">
<option value="4">Solaris man
</option><option value="1">FreeBSD man
</option><option value="3">Разные man
</option><option value="0" selected="">Русские man
</option><option value="2">Linux man
</option><option value="5">POSIX man
</option></select></td>
<td><select size="1" name="category">
	  <option value="" selected="">All
	  </option><option value="1">1
	  </option><option value="2">2
	  </option><option value="3">3
	  </option><option value="4">4
	  </option><option value="5">5
	  </option><option value="6">6
	  </option><option value="7">7
	  </option><option value="8">8
	  </option><option value="9">9
</option></select></td>

<td><input name="submit" value="Показать man" type="submit"></td></tr>
<script async="" src="https://www.google-analytics.com/analytics.js"></script><script language="JavaScript" src="/print.js"></script>
<tr><td colspan="4" align="left">&nbsp;[<a href="/man.shtml">Cписок руководств</a> | <a href="#" onclick="pr('none');">Печать</a>]</td></tr>
</tbody></table>
</td></tr></tbody></table>
</form>
<h3></h3><font size="+2">screen (8)</font><hr><li> <a href="/man.shtml?topic=screen&amp;category=1&amp;russian=4"><u>screen</u></a> (1) <font color="#555555"> ( Solaris man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=screen&amp;category=1&amp;russian=2"><u>screen</u></a> (1) <font color="#555555"> ( Linux man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=screen&amp;category=4&amp;russian=1"><u>screen</u></a> (4) <font color="#555555"> ( FreeBSD man: Специальные файлы /dev/* )</font></li><li>&gt;&gt; <a href="/man.shtml?topic=screen&amp;category=8&amp;russian=0"><u>screen</u></a> (8) <font color="#555555"> ( Русские man: Команды системного администрирования )</font></li><li><font color="#555555">Ключ <a href="/keywords/screen.html"><u>screen</u></a> обнаружен в базе ключевых слов.</font></li>
{{header}}
{{translator-igorchubin}}
<a href="http://linux.die.net/man/1/screen">http://linux.die.net/man/1/screen</a>
<p>
Эта страница является переводом официальной man-страницы программы GNU Screen,
текстового оконного менеджера, эмулирующего терминал VT100/ANSI.
</p><p>
<a name="lbAB">&nbsp;</a>
</p><h2> Имя </h2>

<p>

screen  оконный менеджер с эмуляцией терминала VT100/ANSI
</p><p>
<a name="lbAC">&nbsp;</a>
</p><h2> Синтаксис </h2>

<p>

</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>       screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]

</pre>

</dd></dl>

<p>
<a name="lbAD">&nbsp;</a>
</p><h2> Описание </h2>

<p>

</p><p>
Screen это полноэкранный оконный менеджер, который мультиплексирует физический терминал 
между несколькими процессами (обычно, интерактивными оболочками).
Каждый терминал обладает функциональностью терминала DEC VT100
и некоторыми управляющими функциями из стандартов ISO 6429 (ECMA 49, ANSI X3.64) 
и ISO 2022 (вставка/удаление строки и поддержка множеств символов).
Для каждого виртуального терминала есть буфер истории и механизм обмена, позволяющий
копировать текст между окнами.
</p><p>
При вызове screen создаёт отдельное окно, в котором запускает оболочку командного интерпретатора
(или заданную программу), и вы можете работать с ней как и обычно.
Потом, в любое время, можно создавать новые (полноэкранные) окна,
в которых будут исполняться другие программы (в том числе различные оболочки),
закрывать существующие окна, просматривать список окон, включать/выключать запись,
просматривать буфер прокрутки, переключаться между окнами самыми разнообразными способами
и выполнять множество других действий.
Все окна работают полностью независимо друг от друга.
Программы продолжают работать, даже если они невидимы в настоящий момент,
или вообще весь сеанс screen полностью отключён от терминала пользователя.
Когда программа завершается, screen (по умолчанию) закрывает то окно, 
в котором она исполнялась. Если это окно было активным, screen активирует предыдущее;
если окон не осталось, screen завершается.
</p><p>
Всё, что вы набираете внутри screen, отправляется программе, работающей
в текущем окне.  Единственное исключение --- комбинация клавиш,   которая
показывает, что сейчас вы  хотите работать с самим оконным  менеджером.
По умолчанию, команды работы с оконным менеджером  начинаются  нажатием
Control-a (далее C-a), за которым следует  нажатие одной  клавиши.  Эта
и другие управляющие комбинации могут быть настроены иначе, но они
обязательно должны состоять из двух символов.
</p><p>
Программа screen не понимает префикс "C-" как обозначение нажатия Ctrl.
Вместо этого нужно использовать запись с символом ^ (например, ^A вместо C-a).
Это может пригодиться,  например,  как аргумент опции -e.  Кроме этого,
управляющие символы screen выводит в этом же формате.
</p><p>
Стандартный способ создать новое окно --- нажать "C-a c".
Окно создаётся мгновенно, и screen сразу же делает его активным, независимо
от того, в каком состоянии находится процесс, выполняющийся в текущем окне.
Аналогично можно создавать новые окна, в которых будет выполняться какая-то своя команда.
Для этого сначала нужно привязать команду к комбинации клавиш (это делается через
конфигурационный файл 
</p><dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<br>&nbsp;или&nbsp;через&nbsp;режим&nbsp;командной&nbsp;строки&nbsp;<i>C-a&nbsp;:</i>,
а потом, когда будет нужно, просто использовать эту комбинацию клавиш.
Кроме всего прочего, новые окна можно создавать при помощи команды:
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    screen emacs prog.c

</pre>

</dd></dl>

которая вызывается в командном интерпретаторе, работающем внутри screen.
Новая копия screen создаваться не будет, а вместо этого команда будет передана
текущему менеджеру (информация о том кто именно является текущим менеджером
находится в переменной окружения 
<dl compact=""><dt></dt><dd>
<pre>$STY
</pre>

</dd></dl>

), который и создаст 
новое окно.
В приведённом выше примере запускается редактор <i>emacs</i> (в котором открывается prog.c)
и окно с этим редактором становится активным.
<p>
Если файл 
</p><dl compact=""><dt></dt><dd>
<pre>/var/run/utmp
</pre>

</dd></dl>

<br>&nbsp;доступен&nbsp;screen&nbsp;для&nbsp;изменения,&nbsp;
он сделает соответствующие записи для каждого окна при их создании, 
и удалит при их закрытии. Это очень полезно при использовании
таких программ как <i>talk</i>, <i>script</i>, <i>shutdown</i>, <i>rsend</i>, <i>sccs</i>
и многими другими, которые используют файл 
<dl compact=""><dt></dt><dd>
<pre>utmp
</pre>

</dd></dl>

,
для того чтобы определить кто вы (то есть, какой пользователь работает с каким терминалом).
До тех пор пока screen активен на терминале, запись про собственно этот 
терминал удаляется. Также смотрите <i>C-a L</i>.
<p>
<a name="lbAE">&nbsp;</a>
</p><h2> С чего начать? </h2>

<p>

</p><p>
Перед тем как приступить к работе  со  screen'ом,  нужно убедиться, что
установлен правильный тип терминала (как и для других программ, которые
используют tercap/terminfo). Это можно сделать,   например,   с помощью
программы <b>tset</b>.
</p><p>
Если вы хотите побыстрее  начать  работу со screen  и  не углубляться в
долгое чтение,  вам нужно запомнить только одну команду: "C-a ?".  Если
нажать эту комбинацию  клавиш,  будет показан список  доступных  команд
screen и привязок комбинаций  клавиш  к  ним.  Каждая комбинация клавиш
обсуждается   в  разделе  "Привязки  клавиш".  Раздел   "Индивидуальная
настройка" рассказывает о том, что может быть в  конфигурационном файле
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<p>
Если ваш терминал - это настоящий терминал с авто-отступом (auto-marign)
(не позволяет обновить последнюю позицию экрана без прокрутки), возможно
вам стоит использовать такую версию termcap  для  вашего  терминала,  в
которой автоматические отступы выключены.  В этом случае  screen  будет
правильно обновлять экран при любых обстоятельствах. Сегодня у большинства
терминалов есть  волшебные  отступы  (magic margins)  -  автоматические
отступы и используемая последняя колонка, что соответствует стилю VT100
и отлично подходит для screen. Если у вас терминал с авто-отступами, 
screen может его использовать, но обновление последнего символа в строке
может быть невозможным без прокрутки или перемещения символа в другую
позицию  каким-то  иным  способом.  Задержку, связанную  с  этим, можно
сократить, если использовать терминал, у которого есть возможность 
вставки символов.
</p><p>
<a name="lbAF">&nbsp;</a>
</p><h2> Опции командной строки </h2>

<p>

У программы <i>screen</i> такие ключи командной строки:
</p><p>
</p><dl compact="">
<dt><b>-a</b>

</dt><dd>
<br>

<br>&nbsp;включать&nbsp;все&nbsp;возможности&nbsp;(за&nbsp;некоторыми&nbsp;небольшими&nbsp;исключениями)&nbsp;в&nbsp;termcap&nbsp;каждого&nbsp;окна,&nbsp;даже&nbsp;если&nbsp;screen&nbsp;должен&nbsp;перерисовывать&nbsp;
часть экрана для реализации функции. 
</dd><dt><b>-A</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Адаптирует&nbsp;&nbsp;размеры&nbsp;&nbsp;всех&nbsp;&nbsp;окон&nbsp;&nbsp;под&nbsp;&nbsp;размер&nbsp;&nbsp;текущего&nbsp;&nbsp;терминала.&nbsp;&nbsp;По&nbsp;умолчанию&nbsp;screen&nbsp;пытается&nbsp;восстановить&nbsp;старый&nbsp;размер&nbsp;
окна (при подключении к терминалам с изменяемыми размерами (те у кого  есть "WS" в описании, например, suncmd или xterm). 
<p>
</p></dd><dt><b>-c</b> <i>file</i>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;использовать&nbsp;<i>file</i>&nbsp;вместо&nbsp;стандартного&nbsp;"$HOME/.screenrc"&nbsp;в&nbsp;качестве&nbsp;конфигурационного
<p>
</p></dd><dt><b>-d</b>|<b>-D</b> [<i>pid.tty.host</i>]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;не&nbsp;запускает&nbsp;новый&nbsp;сеанс,&nbsp;&nbsp;а&nbsp;отключает&nbsp;вместо&nbsp;этого&nbsp;уже&nbsp;запущенный&nbsp;ранее.&nbsp;&nbsp;Достигается&nbsp;тот&nbsp;же&nbsp;эффект,&nbsp;что&nbsp;и&nbsp;в&nbsp;с&nbsp;случае&nbsp;нажатия&nbsp;
клавиш "C-a d" на управляющем терминале screen. Ключ -D эквивалентен ключу power detach. Если ни к одному сеансу  нельзя 
<br>&nbsp;обратиться,&nbsp;&nbsp;&nbsp;опция&nbsp;игнорируется.&nbsp;&nbsp;В&nbsp;связке&nbsp;с&nbsp;-r/-R&nbsp;могут&nbsp;быть&nbsp;достигнуты&nbsp;другие&nbsp;более&nbsp;интересные&nbsp;эффекты:&nbsp;
</dd><dt><b>-d -r</b>

</dt><dd>
<br>

<br>&nbsp;Подключить&nbsp;к&nbsp;сеансу,&nbsp;и&nbsp;если&nbsp;необходимо,&nbsp;сначала&nbsp;отключить&nbsp;его.
<p>
</p></dd><dt><b>-d -R</b>

</dt><dd>
<br>

<br>&nbsp;Переподключиться&nbsp;к&nbsp;сеансу.&nbsp;Если&nbsp;необходимо&nbsp;&nbsp;сначала&nbsp;&nbsp;отключить&nbsp;или&nbsp;создать&nbsp;сеанс.
<p>
</p></dd><dt><b>-d -RR</b>

</dt><dd>
<br>

<br>&nbsp;Переподключиться&nbsp;к&nbsp;сеансу.&nbsp;Если&nbsp;необходимо&nbsp;&nbsp;сначала&nbsp;&nbsp;отключить&nbsp;или&nbsp;создать&nbsp;сеанс.&nbsp;&nbsp;Воспользоваться&nbsp;первой&nbsp;сессией,&nbsp;если&nbsp;
больше одной сессии создать нельзя. 
</dd><dt><b>-D -r</b>

</dt><dd>
<br>

<br>&nbsp;Подключиться&nbsp;к&nbsp;сеансу.&nbsp;Если&nbsp;необходимо,&nbsp;сначала&nbsp;отключить&nbsp;его&nbsp;удалённо&nbsp;и&nbsp;разрегистрироваться.
<p>
</p></dd><dt><b>-D -R</b>   

</dt><dd>
<br>

<br>&nbsp;Подключиться&nbsp;здесь&nbsp;и&nbsp;сейчас.&nbsp;Это&nbsp;значит:&nbsp;если&nbsp;сессия&nbsp;&nbsp;работает,&nbsp;переподключиться.&nbsp;Если&nbsp;необходимо,&nbsp;сначала&nbsp;отключиться&nbsp;
удалённо.  Если не работала  создать  и  сообщить  об  этом пользователю.  Любимый ключ авторов. 
</dd><dt><b>-D -RR</b>

</dt><dd>
<br>

<br>&nbsp;Подключиться&nbsp;прямо&nbsp;сейчас.&nbsp;&nbsp;Не&nbsp;важно,&nbsp;что&nbsp;будет,&nbsp;просто&nbsp;сделать&nbsp;это.&nbsp;
<br>

<br>&nbsp;Замечание:&nbsp;хорошая&nbsp;идея&nbsp;всегда&nbsp;проверять&nbsp;состояние&nbsp;сеансов&nbsp;screen&nbsp;с&nbsp;помощью&nbsp;"screen&nbsp;-list"
<p>
</p></dd><dt><b>-e</b> <i>xy</i>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Устанавливает&nbsp;&nbsp;управляющий&nbsp;&nbsp;символ&nbsp;равным&nbsp;<i>x</i>&nbsp;и&nbsp;&nbsp;символ,&nbsp;который&nbsp;генерирует&nbsp;сам&nbsp;этот&nbsp;символ&nbsp;в&nbsp;<i>y</i>&nbsp;(после&nbsp;ввода&nbsp;командного&nbsp;
символа).  По умолчанию это "C-a" и "a",  что можно явным образом указать как "-e^Aa".  При  создании  сеанса  screen  эта  опция 
<br>&nbsp;устанавливает&nbsp;управляющий&nbsp;символ.&nbsp;В&nbsp;многопользовательских&nbsp;сеансах&nbsp;все&nbsp;добавляемые&nbsp;пользователи&nbsp;будут&nbsp;использовать&nbsp;
указанный символ.  При подключении к существующей сессии,  опция меняет управляющий символ только для пользователя, выполняющего 
подключение. Опция эквивалентна командам "defescape" и "escape" соответственно. 
</dd><dt><b>-f</b>, <b>-fn</b> и <b>-fa</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;включить,&nbsp;&nbsp;&nbsp;выключить&nbsp;&nbsp;&nbsp;или&nbsp;&nbsp;&nbsp;перевести&nbsp;&nbsp;&nbsp;в&nbsp;&nbsp;автоматический&nbsp;&nbsp;режим&nbsp;flow-control.&nbsp;&nbsp;Аналогичный&nbsp;результат&nbsp;достигается&nbsp;с&nbsp;помощью&nbsp;
команды "defflow" конфигурационного файла. 
</dd><dt><b>-h</b> <i>num</i>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Установить&nbsp;размер&nbsp;истории&nbsp;буфера&nbsp;прокрути&nbsp;равным&nbsp;<i>num</i>&nbsp;строк.
<p>
</p></dd><dt><b>-i</b>

</dt><dd>
<br>

<br>&nbsp;приводит&nbsp;к&nbsp;тому&nbsp;что&nbsp;клавиша&nbsp;прерывания&nbsp;(C-c)&nbsp;срабатывает&nbsp;мгновенно&nbsp;если&nbsp;включено&nbsp;аппаратное&nbsp;управление&nbsp;потоком.&nbsp;См.&nbsp;
команду <b>defflow</b>.  Использование этой опции не рекомендуется. 
</dd><dt><b>-l</b> и <b>-ln</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Включает&nbsp;или&nbsp;выключает&nbsp;login-режим&nbsp;(для&nbsp;обновления&nbsp;/var/run/utmp).&nbsp;&nbsp;Это&nbsp;же&nbsp;можно&nbsp;задать&nbsp;с&nbsp;помощью&nbsp;команды&nbsp;<b>deflogin</b>&nbsp;
в файле .RS
<pre>~/.screenrc
</pre>


<p>
</p></dd><dt><b>-ls</b> и <b>-list</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;не&nbsp;запускает&nbsp;screen,&nbsp;а&nbsp;показывает&nbsp;вместо&nbsp;этого&nbsp;список&nbsp;идентифицирующих&nbsp;сеансы&nbsp;screen&nbsp;строк&nbsp;pid.tty.host.&nbsp;&nbsp;Сеансы,&nbsp;которые&nbsp;
отмечены словом "detached" могут быть продолжены  с помощью  команды  "screen -r".  Сеансы, которые отмечены словом "attached", 
работают, и у них есть управляющий терминал. Если сеанс  работает в многопользовательском режиме, он отмечен словом "multi". 
Сеансы, которые отмечены словом "unreachable" или работают на другом хосте, или умерли (dead).  Недоступный  (unreachable) 
<br>&nbsp;сеанс&nbsp;&nbsp;считается&nbsp;мёртвым,&nbsp;если&nbsp;его&nbsp;имя&nbsp;соответствует&nbsp;или&nbsp;имени&nbsp;локального&nbsp;хоста,&nbsp;или&nbsp;указанному&nbsp;параметру&nbsp;(если&nbsp;такой&nbsp;
есть).  Как описывать строки для выбора рассказывается в описании ключа -r. Сеансы, отмеченные как "dead", нужно проверить 
и удалить. Если вы не уверены, нужно ли удалять какой-то сеанс, вы можете обратиться к системному администратору (если 
это не вы сами, иначе может возникнуть бесконечная рекурсия).  Удалить сеансы можно с помощью опции -wipe. 
</dd><dt><b>-L</b>

</dt><dd>
<br>

<br>&nbsp;Включить&nbsp;автоматическую&nbsp;запись&nbsp;(logging)&nbsp;для&nbsp;окон.
<p>
</p></dd><dt><b>-m</b>

</dt><dd>
<br>

<br>&nbsp;Заставляет&nbsp;&nbsp;&nbsp;screen&nbsp;&nbsp;&nbsp;игнорировать&nbsp;&nbsp;переменную&nbsp;окружения&nbsp;$TTY.&nbsp;&nbsp;При&nbsp;использовании&nbsp;"screen&nbsp;-m"&nbsp;создаётся&nbsp;новый&nbsp;сеанс,&nbsp;независимо&nbsp;
от того вызывается ли screen изнутри другого сеанса screen  или  нет.  Этот флаг имеет особое значение, если вызывается с опцией: 
<p>
</p></dd><dt><b>-d -m</b>

</dt><dd>
<br>

<br>&nbsp;Запустить&nbsp;сеанс&nbsp;в&nbsp;"отключенном"&nbsp;режиме.&nbsp;Сессия&nbsp;создаётся,&nbsp;но&nbsp;&nbsp;к&nbsp;ней&nbsp;&nbsp;не&nbsp;&nbsp;выполняется&nbsp;&nbsp;подключение.&nbsp;&nbsp;Это&nbsp;полезно&nbsp;для&nbsp;загрузочных&nbsp;
системных скриптов. 
</dd><dt><b>-D -m</b>

</dt><dd>
<br>

<br>&nbsp;Тоже&nbsp;запускает&nbsp;<i>screen</i>&nbsp;в&nbsp;"отключенном"&nbsp;режиме,&nbsp;но&nbsp;не&nbsp;создаёт&nbsp;новый&nbsp;процесс.&nbsp;Команда&nbsp;завершается,&nbsp;если&nbsp;сессия&nbsp;прерывается.&nbsp;
<p>
</p></dd><dt><b>-O</b>

</dt><dd>
<br>

<br>&nbsp;использует&nbsp;более&nbsp;оптимальный&nbsp;режим&nbsp;вывода&nbsp;вашим&nbsp;терминалом,&nbsp;&nbsp;чем&nbsp;в&nbsp;случае&nbsp;&nbsp;с&nbsp;&nbsp;обычной&nbsp;&nbsp;эмуляцией&nbsp;VT100&nbsp;&nbsp;(касается&nbsp;&nbsp;только&nbsp;auto-margin&nbsp;
терминалов без поддержки LP). Такого же результата можно  достичь, если установить OP в команде termcap. 
</dd><dt><b>-p</b> <i>number_or_name</i>

</dt><dd>
<br>

<br>&nbsp;Заранее&nbsp;выбирает&nbsp;окно.&nbsp;Полезно,&nbsp;когда&nbsp;вы&nbsp;&nbsp;хотите&nbsp;&nbsp;переподключиться&nbsp;к&nbsp;конкретному&nbsp;окну&nbsp;или&nbsp;если&nbsp;вы&nbsp;хотите&nbsp;с&nbsp;помощью&nbsp;опции&nbsp;
-X отправить команду в конкретное окно.  Как и в случае с командой select, знак "-" означает пустое окно.  Если вместо номера 
указать символ =, то при подключении появится меню windowlist с списком окон. 
</dd><dt><b>-q</b>

</dt><dd>
<br>

<br>&nbsp;Подавляет&nbsp;вывод&nbsp;сообщений&nbsp;об&nbsp;ошибках.&nbsp;В&nbsp;сочетании&nbsp;с&nbsp;"-ls"&nbsp;возвращает&nbsp;код&nbsp;завершения:&nbsp;9&nbsp;-&nbsp;нет&nbsp;каталога&nbsp;с&nbsp;сеансами;&nbsp;10&nbsp;-&nbsp;
каталог есть, но нет сеансов, к которым можно подключиться. 11 (или больше) говорит что есть 1 (или больше) рабочий сеанс. 
В сочетании с "-r" возвращает код завершения: 10 - нет сеансов, которые можно возобновить; 12 (или больше) что есть 2 (или 
больше) сеанса, работу которых можно возобновить, и  нужно  выбрать  какой-то  один.  Во всех остальных случаях ключ " .RS
<pre>-q
</pre>


" эффекта не имеет.  
<p>
</p></dd><dt><b>-r</b> [<i>pid.tty.host</i>]

</dt><dd>
</dd><dt><b>-r</b> <i>sessionowner</i>/[<i>pid.tty.host</i>]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;возобновляет&nbsp;работу&nbsp;отключённого&nbsp;сеанса.&nbsp;Никакие&nbsp;другие&nbsp;опции&nbsp;&nbsp;(за&nbsp;исключением&nbsp;комбинаций&nbsp;&nbsp;с&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-d
</pre>

</dd></dl>

/
<dl compact=""><dt></dt><dd>
<pre>-D
</pre>

</dd></dl>

<br>&nbsp;&nbsp;не&nbsp;&nbsp;допускаются).&nbsp;&nbsp;Необязательный&nbsp;параметр&nbsp;[<i>pid</i>.]<i>tty.host</i>&nbsp;может&nbsp;указываться&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;определить&nbsp;
какой именно сеанс из множества отключённых имеется в виду. Вторая форма используется для подключения к работающему в 
многопользовательском режиме сеансу другого пользователя.  Эта опция говорит о том,  что файл нужно искать в каталоге другого 
пользователя. Требует наличия бита setuid-root у программы screen. 
</dd><dt><b>-R</b>

</dt><dd>
<br>

<br>&nbsp;пытается&nbsp;&nbsp;возобновить&nbsp;&nbsp;работу&nbsp;&nbsp;&nbsp;первого&nbsp;&nbsp;попавшегося&nbsp;&nbsp;отключённого&nbsp;сеанса.&nbsp;&nbsp;&nbsp;Если&nbsp;попытка&nbsp;успешная,&nbsp;все&nbsp;остальные&nbsp;аргументы&nbsp;
командной строки  игнорируются.  Если  отключённых  сеансов  нет,  запускает новый сеанс с учётом заданных опций, так как будто 
<dl compact=""><dt></dt><dd>
<pre>-R
</pre>

</dd></dl>

<br>&nbsp;&nbsp;вообще&nbsp;и&nbsp;не&nbsp;указано.&nbsp;&nbsp;Эта&nbsp;&nbsp;опция&nbsp;&nbsp;подразумевается&nbsp;&nbsp;по&nbsp;&nbsp;умолчанию,&nbsp;когда&nbsp;screen&nbsp;вызывается&nbsp;как&nbsp;login-оболочка&nbsp;(если&nbsp;быть&nbsp;точным,&nbsp;
<br>&nbsp;то&nbsp;в&nbsp;этом&nbsp;случае&nbsp;подразумеваются&nbsp;опции&nbsp;"&nbsp;.RS
<pre>-xRR
</pre>


"). О том, что происходит, если вызвать screen в сочетании с опциями 
<dl compact=""><dt></dt><dd>
<pre>-d
</pre>

</dd></dl>

/
<dl compact=""><dt></dt><dd>
<pre>-D
</pre>

</dd></dl>

, написано в описании этих опций.
<p>
</p></dd><dt><b>-s</b>

</dt><dd>
<br>

<br>&nbsp;устанавливает&nbsp;оболочку&nbsp;по&nbsp;умолчанию&nbsp;равной&nbsp;заданной&nbsp;программе&nbsp;(без&nbsp;опции&nbsp;в&nbsp;качестве&nbsp;оболочки&nbsp;по&nbsp;умолчанию&nbsp;используется&nbsp;
программа, что указана в $SHELL или "/bin/sh", если никакая не указана). Такой же эффект  может  быть  получен  с  помощью  команды 
<b>shell</b> в файле ".screenrc". 
</dd><dt><b>-S</b> <i>sessionname</i>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Эта&nbsp;опция&nbsp;может&nbsp;&nbsp;использоваться&nbsp;&nbsp;для&nbsp;задания&nbsp;&nbsp;имени&nbsp;сеансу&nbsp;при&nbsp;его&nbsp;создании.&nbsp;&nbsp;Имя&nbsp;&nbsp;используется&nbsp;&nbsp;для&nbsp;&nbsp;идентификации&nbsp;при&nbsp;вызове&nbsp;
"screen -list"  и  "screen -r".  Оно  заменяет префикс "tty.host", использующийся по умолчанию. 
</dd><dt><b>-t</b> <i>name</i>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;установить&nbsp;заголовок&nbsp;для&nbsp;командного&nbsp;интерпретатора&nbsp;или&nbsp;указанной&nbsp;программы.&nbsp;См.&nbsp;также&nbsp;команду&nbsp;<i>shelltitle</i>&nbsp;для&nbsp;

</dd><dt><b>-U</b>

</dt><dd>
<br>

<br>&nbsp;Запустить&nbsp;<i>screen</i>&nbsp;в&nbsp;режиме&nbsp;UTF-8.&nbsp;Эта&nbsp;опция&nbsp;говорит&nbsp;<i>screen</i>,&nbsp;что&nbsp;терминал&nbsp;посылает&nbsp;и&nbsp;понимает&nbsp;символы&nbsp;в&nbsp;кодировке&nbsp;
UTF-8. Этот ключ также устанавливает кодировку по умолчанию для окон .RS
<pre>utf8
</pre>


<p>
</p></dd><dt><b>-v</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;Показать&nbsp;номер&nbsp;версии.
<p>
</p></dd><dt><b>-wipe</b> [<i>match</i>]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;работает&nbsp;также&nbsp;как&nbsp;"screen&nbsp;-ls",&nbsp;только&nbsp;удаляет&nbsp;файлы&nbsp;уничтоженных&nbsp;сеансов&nbsp;вместо&nbsp;того&nbsp;чтобы&nbsp;помечать&nbsp;их&nbsp;как&nbsp;"dead"&nbsp;(мёртвые).&nbsp;
Сеанс, который   не   отвечает,   считается   мёртвым,  или  если его имя соответствует имени локального хоста, или указанному 
явно параметру <i>match</i>. См. описание ключа -r, где рассказаны правила составления <i>match</i>. 
</dd><dt><b>-x</b>

</dt><dd>
<br>

<br>&nbsp;Подключиться&nbsp;к&nbsp;активной&nbsp;(not&nbsp;detached)&nbsp;сессии&nbsp;screen.&nbsp;(Многодисплейный&nbsp;режим).
<p>
</p></dd><dt><b>-X</b>

</dt><dd>
<br>

<br>&nbsp;Отправить&nbsp;&nbsp;указанную&nbsp;&nbsp;команду&nbsp;&nbsp;в&nbsp;&nbsp;работающий&nbsp;&nbsp;сеанс&nbsp;&nbsp;screen.&nbsp;&nbsp;Можно&nbsp;указать&nbsp;ключ&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-d
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-r
</pre>

</dd></dl>

, чтобы screen смотрел только на подключённые (attached) или отключённые (detached) сеансы.  Обратите внимание на то, 
что команда не сработает, если сеанс защищён с помощью пароля. 
</dd></dl>
<a name="lbAG">&nbsp;</a>
<h2> Привязки клавиш </h2>

<p>

</p><p>
Каждая управляющая последовательность screen состоит из комбинации "C-a",
за которой идёт один символ.  Для удобства все команды, которые привязаны
к символу в нижнем регистре также привязаны к комбинации этого символа с
Ctrl (за исключением "C-a a"; см. ниже). Так, например, "C-a c" работает
также как "C-a C-c"  создаёт новое  окно.  См.  раздел  "<b>Индивидуальная настройка</b>" для описания команд. 
В таблице показаны привязки клавиш по умолчанию:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>       C-a '       (select)      Спросить название или имя окна, в которое нужно
                                 переключиться.

       C-a "       (windowlist -b)
                                 Представить список всех окон для выбора.

       C-a 0       (select 0)
        ...           ...
       C-a 9       (select 9)
       C-a -       (select -)    Переключиться в окно с номером 0  -  9 или в пустое окно.

       C-a tab     (focus)       Переключить фокус ввода на следующий регион.

       C-a C-a     (other)       Переключиться в ранее активное окно.
                                 (по умолчанию команда привязана к управляющему символу, 
                                 нажатому дважды  например, если вы вызовите screen
                                 с опцией "-e]x", команда будет вызываться символами "]]").

       C-a a       (meta)        Отправить C-a в окно. См. также команду <b>escape</b>

       C-a A       (title)       Ввести заголовок текущего окна.

       C-a b
       C-a C-b     (break)       Отправить break в окно.

       C-a B       (pow_break)   Повторно открыть терминальную линию и отправить break.

       C-a c
       C-a C-c     (screen)      Создать новое окно с запущенным интерпретатором
                                 и переключиться в это окно.

       C-a C       (clear)       Очистить экран.

       C-a d
       C-a C-d     (detach)      Отключить screen от этого терминала.

       C-a D D     (pow_detach)  Отключиться и разрегистрироваться.

       C-a f
       C-a C-f     (flow)        Включить/выключить/перевести в автоматический режим 
                                 управление потоком (flow control).

       C-a F       (fit)         Изменить размер окна под размер текущего региона.

       C-a C-g     (vbell)       Переключить режим visual-bell 

       C-a h       (hardcopy)    Записать копию текущего окна в файл "hardcopy.n".

       C-a H       (log)         Начать/закончить запись сессии работы в текущем окне в файл
                                 "screenlog.n".

       C-a i
       C-a C-i     (info)        Показать информацию о текущем окне.

       C-a k
       C-a C-k     (kill)        Уничтожить текущее окно.

       C-a l
       C-a C-l     (redisplay)   Полностью обновить текущее окно.

       C-a L       (login)       Переключить login-запись этого окна. Доступно только в случае, 
                                 когда screen настроен на обновление базы utmp.

       C-a m
       C-a C-m     (lastmsg)     Повторить последнее сообщение, показанное в строке сообщений.

       C-a M       (monitor)     Включить/выключить мониторинг в текущем окне.

       C-a space
       C-a n
       C-a C-n     (next)        Переключиться на следующее окно.

       C-a N       (number)      Показать номер (и заголовок) текущего окна.

       C-a backspace
       C-a h
       C-a p
       C-a C-p     (prev)        Переключиться на предыдущее окно (противоположно C-a n).

       C-a q
       C-a C-q     (xon)         Отправить CTRL-q в текущее окно.

       C-a Q       (only)        Удалить все регионы за исключением текущего.

       C-a r
       C-a C-r     (wrap)        Включить/выключить настройку line-wrap текущего окна
                                 (включает и выключает автоматические отступы (automatic margins))

       C-a s
       C-a C-s     (xoff)        Отправить control-s в текущее окно.

       C-a S       (split)       Разделить текущий регион на два новых.

       C-a t
       C-a C-t     (time)        Показать информацию о системе.

       C-a v       (version)     Показать версию и дату сборки.

       C-a C-v     (digraph)     Ввести диграф.

       C-a w
       C-a C-w     (windows)     Показать список окон.

       C-a W       (width)       Переключить количество колонок: 80/132

       C-a x
       C-a C-x     (lockscreen)  Заблокировать текущий терминал.

       C-a X       (remove)      Закрыть текущий регион.

       C-a z
       C-a C-z     (suspend)     Приостановить (suspend) screen. Система должна поддерживать 
                                 управление работами (job-control) в стиле BSD.

       C-a Z       (reset)       Сбросить виртуальные терминалы в их исходные значения.

       C-a .       (dumptermcap) Записать файл ".termcap"

       C-a ?       (help)        Показать привязки клавиш.

       C-a C-\     (quit)        Закрыть все окна и завершить screen.

       C-a :       (colon)       Перейти в режим ввода командной строки screen.

       C-a [
       C-a C-[
       C-a esc     (copy)        Перейти в режим копирования/прокрутки.

       C-a ]       (paste .)     Записать содержимое буфера обмена в стандартный поток 
                                 ввода текущего окна.

       C-a {
       C-a }       (history)     Скопировать и вставить предыдущую командную строку.

       C-a &gt;       (writebuf)    Записать буфер обмена в файл.

       C-a &lt;       (readbuf)     Прочитать файл обмена (screen-exchange) в буфер обмена. 

       C-a =       (removebuf)   Удалить файл, использующийся вместе с C-a &lt; и C-a &gt;.

       C-a ,       (license)     Показать информацию о программе GNU Screen.

       C-a _       (silence)     Включить/выключить режим слежения за неактивностью текущего окна.

       C-a *       (displays)    Показать список всех подключенных сейчас дисплеев.

</pre>

</dd></dl>

----------------
<p>
<a name="lbAH">&nbsp;</a>
</p><h2> Индивидуальная настройка </h2>

<p>

</p><p>
По умолчанию каталог для сокетов (socket directory) это или $HOME/.screen, 
или /tmp/screens, или, скорее всего, /var/run/screen; задаётся при компиляции.
Если screen имеет бит setuid-root, каталог для сокетов
обязательно должен находиться не на NFS-разделе. Если screen не имеет бита setuid, 
пользователь может указывать каталог через переменную 
</p><dl compact=""><dt></dt><dd>
<pre>$SCREENDIR
</pre>

</dd></dl>

<p>
У этого каталога должен быть режим доступа 700.
</p><p>
При вызове screen исполняет настроечные команды из файла 
</p><dl compact=""><dt></dt><dd>
<pre>/etc/screenrc
</pre>

</dd></dl>

<p>
и файла 
</p><dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

, что расположен в домашнем каталоге.
Имена этих файлов -- настройки по умолчанию, которые можно перекрыть 
одним из следующих способов:
глобальный настроечный файл указывается 
при помощи переменной окружения 
<dl compact=""><dt></dt><dd>
<pre>$SYSSCREENRC
</pre>

</dd></dl>

<br>&nbsp;(эта&nbsp;возможность&nbsp;может&nbsp;
быть отключена при компиляции),
пользовательский настроечный файл ищется по пути, указанном в 
<dl compact=""><dt></dt><dd>
<pre>$SCREENRC
</pre>

</dd></dl>

,
и в файле 
<dl compact=""><dt></dt><dd>
<pre>$HOME/.screenrc
</pre>

</dd></dl>

<br>&nbsp;Есть&nbsp;ещё&nbsp;опция&nbsp;командной&nbsp;строки&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-c
</pre>

</dd></dl>

,
которая имеет приоритет над перечисленными выше настройками имён конфигурационных файла.
<p>
Команды в этих файлах используются для того чтобы задавать опции, привязывать
действия к функциональным клавишам, открывать несколько окон при старте сеанса screen.
Команды записываются по одной в строке. Пустые строки игнорируются.
Аргументы команд разделяются табуляцией или пробелами и могут объединяться с помощью
двойных кавычек. Строки, которые нельзя распознать, игнорируются. При этом для каждой такой строки
выдаётся предупреждение.
В командах могут использоваться ссылки на переменные окружения. Синтаксис такой же 
как в командном интерпретаторе: 
</p><dl compact=""><dt></dt><dd>
<pre>$VAR
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>${VAR}
</pre>

</dd></dl>

<br>&nbsp;Обратите&nbsp;внимание,&nbsp;
что этот способ записи несовместим с предыдущими версиями screen, потому что сейчас 
символ $, если мы хотим передать именно его, нужно экранировать с помощью символа 
<dl compact=""><dt></dt><dd>
<pre>\
</pre>

</dd></dl>

<p>
От подстановки переменных также защищают одинарные кавычки.
</p><p>
В дистрибутив входит два конфигурационных файла-примера: 
</p><dl compact=""><dt></dt><dd>
<pre>etc/etcscreenrc
</pre>

</dd></dl>

<p>
и 
</p><dl compact=""><dt></dt><dd>
<pre>etc/screenrc
</pre>

</dd></dl>

<br>&nbsp;В&nbsp;этих&nbsp;файлах&nbsp;есть&nbsp;много&nbsp;хороших&nbsp;примеров&nbsp;различных&nbsp;конфигурационных
команд GNU Screen.
<p>
Настраивать GNU Screen можно и в on-line режиме. Для того чтобы перейти в режим командной строки,
нажмите 
</p><dl compact=""><dt></dt><dd>
<pre>C-a :
</pre>

</dd></dl>

<br>&nbsp;Команды,&nbsp;начинающиеся&nbsp;с&nbsp;"def"&nbsp;меняют&nbsp;настройки&nbsp;по&nbsp;умолчанию,
а остальные меняют текущие настройки.
<p>
Доступны следующие команды:
</p><p>
</p><dl compact="">
<dt><b>acladd</b> <i>usernames</i> [<i>crypted-pw</i>]

</dt><dd>
</dd><dt><b>addacl</b> <i>usernames</i>

</dt><dd>
<br>

<br>&nbsp;Даёт&nbsp;пользователю&nbsp;возможность&nbsp;получения&nbsp;доступа&nbsp;к&nbsp;сеансу&nbsp;screen.&nbsp;В&nbsp;качестве&nbsp;параметра&nbsp;<i>usernames</i>&nbsp;может&nbsp;задаваться&nbsp;
имя пользователя или имена нескольких пользователей, разделённых запятыми. Команда разрешает подключаться к screen 
и в том числе выполняет действия аналогичные действию команды <i>aclchg usernames +rwx "#?"</i>. Для того чтобы добавить 
пользователя с ограниченным доступом, нужно использовать команду <i>aclchg</i> указанную ниже.  В качестве опционального 
параметра <i>crypted-pw</i> может указываться зашифрованный пароль для заданного пользователя.  Команда <i>addacl</i> 
--- синоним команды <i>acladd</i>.  Только для многопользовательского режима. 
</dd><dt><b>aclchg</b> <i>usernames</i> <i>permbits</i> <i>list</i>

</dt><dd>
</dd><dt><b>chacl</b> <i>usernames</i> <i>permbits</i> <i>list</i>

</dt><dd>
<br>

<br>&nbsp;Изменить&nbsp;права&nbsp;для&nbsp;пользователей.&nbsp;Список&nbsp;пользователей&nbsp;<i>usernames</i>&nbsp;состоит&nbsp;из&nbsp;имён&nbsp;пользователей,&nbsp;разделённых&nbsp;
запятыми. Права представлены символами .RS
<pre>r
</pre>


, 
<dl compact=""><dt></dt><dd>
<pre>w
</pre>

</dd></dl>

<br>&nbsp;и&nbsp;
<dl compact=""><dt></dt><dd>
<pre>x
</pre>

</dd></dl>

<br>&nbsp;Префикс&nbsp;
<dl compact=""><dt></dt><dd>
<pre>+
</pre>

</dd></dl>

<br>&nbsp;обозначает&nbsp;добавление&nbsp;права,&nbsp;а&nbsp;префикс&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-
</pre>

</dd></dl>

<br>&nbsp;снятие&nbsp;его.&nbsp;Третий&nbsp;параметр,&nbsp;<i>list</i>&nbsp;это&nbsp;список&nbsp;команд&nbsp;и/или&nbsp;окон,&nbsp;заданных&nbsp;с&nbsp;помощью&nbsp;номеров&nbsp;или&nbsp;названий.&nbsp;Специальный&nbsp;
список .RS
<pre>#
</pre>


<br>&nbsp;обозначает&nbsp;все&nbsp;окна,&nbsp;а&nbsp;
<dl compact=""><dt></dt><dd>
<pre>?
</pre>

</dd></dl>

<br>&nbsp;--&nbsp;все&nbsp;команды.&nbsp;&nbsp;Если&nbsp;параметр&nbsp;
<dl compact=""><dt></dt><dd>
<pre>*
</pre>

</dd></dl>

<br>&nbsp;состоит&nbsp;из&nbsp;одного&nbsp;единственного&nbsp;символа&nbsp;
<dl compact=""><dt></dt><dd>
<pre>*
</pre>

</dd></dl>

, команда применяется ко всем пользователям.  Пользователь может выполнить команду, если у него есть бит "x" для этой команды. 
Пользователь может вводить данные в окно, если у него есть бит "w" для этого окна, и оно никем не заблокировано. Другие биты 
пока что игнорируются.  Для того чтобы отозвать блокировку записи в окно 2 выполненную другим пользователем, нужно выполнить 
команду: " .RS
<pre>aclchg username -w+w 2
</pre>


". Для того чтобы предоставить доступ только для чтения: 
<dl compact=""><dt></dt><dd>
<pre>aclchg username -w "#"
</pre>

</dd></dl>

<br>&nbsp;&nbsp;Как&nbsp;только&nbsp;имя&nbsp;пользователя&nbsp;становится&nbsp;известно&nbsp;screen,&nbsp;этот&nbsp;пользователь&nbsp;может&nbsp;подключаться&nbsp;к&nbsp;сеансу&nbsp;и&nbsp;по&nbsp;умолчанию&nbsp;
у него есть права на исполнение всех команд со всеми окнами.  Право на исполнение acl-команд, <i>at</i> и прочих нужно тоже 
удалить, иначе пользователь сможет восстановить себе права на запись сам.  Права специального пользователя nobody изменить 
нельзя (подробности в описании команды <i>su</i>).  Команда <i>chacl</i> это синоним для <i>aclchg</i>. Только для многопользовательского 
режима. 
</dd><dt><b>acldel</b> <i>username</i>

</dt><dd>
<br>

<br>&nbsp;Удалить&nbsp;пользователя&nbsp;из&nbsp;списка&nbsp;контроля&nbsp;доступа&nbsp;screen.&nbsp;Если&nbsp;у&nbsp;пользователя&nbsp;есть&nbsp;подключенные&nbsp;экраны,&nbsp;все&nbsp;они&nbsp;отключаются.&nbsp;
И больше подключится он не может. Это только в многопользовательском режиме. 
</dd><dt><b>aclgrp</b> <i>username</i> [<i>groupname</i>]

</dt><dd>
<br>

<br>&nbsp;Создаёт&nbsp;группу&nbsp;пользователей&nbsp;с&nbsp;одинаковыми&nbsp;правами&nbsp;доступа.&nbsp;Название&nbsp;группы&nbsp;совпадает&nbsp;с&nbsp;названием&nbsp;лидера&nbsp;группы.&nbsp;Все&nbsp;
члены группы наследуют права лидера группы. Это означает, что если пользователю доступ не дали, делается выполняется 
проверка для лидера. Пользователь удаляется изо всех групп, если в качестве имени группы используется специальное слово 
<i>none</i>. Если второй параметр не указан, на экран выводятся все группы, в которых состоит пользователь. 
</dd><dt><b>aclumask [[</b><i>users</i>]+<i>bits</i> |[<i>users</i>]-<i>bits</i> .... ]

</dt><dd>
</dd><dt><b>umask [[</b><i>users</i>]+<i>bits</i> |[<i>users</i>]-<i>bits</i> .... ]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Команда&nbsp;определяет,&nbsp;какие&nbsp;права&nbsp;будут&nbsp;у&nbsp;пользователей&nbsp;при&nbsp;доступе&nbsp;к&nbsp;окнам,&nbsp;которые&nbsp;создаст&nbsp;тот,&nbsp;кто&nbsp;вызывает&nbsp;эту&nbsp;команду.&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Аргумент&nbsp;<i>users</i>&nbsp;может&nbsp;отсутствовать&nbsp;или,&nbsp;если&nbsp;он&nbsp;есть,&nbsp;это&nbsp;список&nbsp;пользователей,&nbsp;разделённых&nbsp;запятыми.&nbsp;&nbsp;Если&nbsp;список&nbsp;
пользователей <i>users</i> не указан, подразумевается что перечислены все известные пользователи.  Аргумент <i>bits</i> 
это любая комбинация битов контроля доступа, которые могут использоваться в команде <i>aclchg</i>.  Специальное имя пользователя 
<dl compact=""><dt></dt><dd>
<pre>?
</pre>

</dd></dl>

<br>&nbsp;определяет&nbsp;какие&nbsp;права&nbsp;доступа&nbsp;к&nbsp;окнам&nbsp;будут&nbsp;выдаваться&nbsp;пока&nbsp;неизвестным&nbsp;пользователям.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Специальное&nbsp;имя&nbsp;пользователя&nbsp;
<dl compact=""><dt></dt><dd>
<pre>??
</pre>

</dd></dl>

<br>&nbsp;определяет&nbsp;какие&nbsp;права&nbsp;вызова&nbsp;команд&nbsp;будут&nbsp;выдаваться&nbsp;пока&nbsp;неизвестным&nbsp;пользователям.&nbsp;&nbsp;Права&nbsp;для&nbsp;специального&nbsp;пользователя&nbsp;
nobody менять нельзя (см. команду "su").  Команда <i>umask</i> это синоним команды <i>aclumask</i>. .RE
<p>
</p><dl compact="">
<dt><b>activity</b> <i>message</i>

</dt><dd>
<br>

<br>&nbsp;Если&nbsp;в&nbsp;окне,&nbsp;которое&nbsp;находится&nbsp;под&nbsp;наблюдением,&nbsp;возникает&nbsp;какая-то&nbsp;активность,&nbsp;screen&nbsp;показывает&nbsp;строку&nbsp;предупреждения.&nbsp;
Текст предупреждения можно переопределить с помощью строки <i>message</i>. Символ .RS
<pre>%
</pre>

</dd></dl>
</dd></dl>

<br>&nbsp;в&nbsp;сообщении&nbsp;заменяется&nbsp;номером&nbsp;окна,&nbsp;в&nbsp;котором&nbsp;возникла&nbsp;активность,&nbsp;а&nbsp;символ&nbsp;
<dl compact=""><dt></dt><dd>
<pre>^G
</pre>

</dd></dl>

<br>&nbsp;заменяется&nbsp;на&nbsp;определение&nbsp;звонка&nbsp;(bell)&nbsp;из&nbsp;termcap-файла&nbsp;(обычно&nbsp;ему&nbsp;соответствует&nbsp;звуковой&nbsp;звонок).&nbsp;Сообщение&nbsp;по&nbsp;
умолчанию выглядит так: 
<dl compact=""><dt></dt><dd>
<pre>    "Activity in window %n"

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Обратите&nbsp;внимание&nbsp;на&nbsp;то,&nbsp;что&nbsp;мониторинг&nbsp;по&nbsp;умолчанию&nbsp;выключен.&nbsp;Его&nbsp;можно&nbsp;включить&nbsp;командой&nbsp;(C-a&nbsp;M).&nbsp;.RE
<p>
</p><dl compact="">
<dt><b>allpartial</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Если&nbsp;установлен,&nbsp;обновляется&nbsp;только&nbsp;строка,&nbsp;содержащая&nbsp;курсор.&nbsp;Действует&nbsp;на&nbsp;все&nbsp;окна.&nbsp;Полезно&nbsp;для&nbsp;медленных&nbsp;линий.&nbsp;Предыдущие&nbsp;
настройки обновления восстанавливаются при вызове <i>allpartial off</i>. Команда влияет на глобальный флаг, перекрывающий 
их собственные настройки. Команда не влияет на новые окна и их отрисовку. 
</dd><dt><b>altscreen</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Если&nbsp;установлен,&nbsp;включается&nbsp;поддержка&nbsp;альтернативного&nbsp;экрана&nbsp;(alternate&nbsp;screen),&nbsp;как&nbsp;в&nbsp;xterm&nbsp;(например,&nbsp;когда&nbsp;вы&nbsp;выходите&nbsp;
из man и то что бы на консоли восстанавливается). Начальная настройка "off". 
<b>at</b> [<i>identifier</i>][#|*|%] <i>command</i> [<i>args</i> ... ]
<dl compact=""><dt></dt><dd>
<br>&nbsp;Выполнить&nbsp;команду&nbsp;на&nbsp;другом&nbsp;окне&nbsp;или&nbsp;дисплее,&nbsp;так&nbsp;будто&nbsp;бы&nbsp;она&nbsp;была&nbsp;вызвана&nbsp;там.&nbsp;&nbsp;Команда&nbsp;<i>at</i>&nbsp;меняет&nbsp;контекст&nbsp;(текущее&nbsp;
окно или дисплей).  Если первый аргумент описывает не уникальный контекст, команда будет выполнена многократно. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Если&nbsp;первый&nbsp;параметр&nbsp;задан&nbsp;в&nbsp;форме&nbsp;
<dl compact=""><dt></dt><dd>
<pre>id*
</pre>

</dd></dl>

, тогда <i>id</i> проверяется на соответствие именам пользователей.  Команда выполняется по разу для каждого дисплея заданного 
пользователя.  Если идентификатор <i>identifier</i> задан в форме <i>id%</i>, он проверяется на соответствие дисплеям. 
<br>&nbsp;Дисплеи&nbsp;именуются&nbsp;в&nbsp;соответствии&nbsp;с&nbsp;названиями&nbsp;терминалов,&nbsp;к&nbsp;которым&nbsp;они&nbsp;подключаются.&nbsp;&nbsp;Префиксы&nbsp;.RS
<pre>/dev/
</pre>

</dd></dl>

<br>&nbsp;и&nbsp;
<dl compact=""><dt></dt><dd>
<pre>/dev/tty
</pre>

</dd></dl>

<br>&nbsp;указывать&nbsp;в&nbsp;идентификаторе&nbsp;не&nbsp;обязательно.&nbsp;&nbsp;Если&nbsp;идентификатор&nbsp;заканчивается&nbsp;
<dl compact=""><dt></dt><dd>
<pre>#
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;никаких&nbsp;специальных&nbsp;символов&nbsp;в&nbsp;конце&nbsp;нет,&nbsp;он&nbsp;проверяется&nbsp;на&nbsp;соответствие&nbsp;номера&nbsp;и&nbsp;названиям&nbsp;окон.&nbsp;.RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Если&nbsp;не&nbsp;указать&nbsp;идентификатор&nbsp;перед&nbsp;
<dl compact=""><dt></dt><dd>
<pre>#
</pre>

</dd></dl>

<br>&nbsp;
<dl compact=""><dt></dt><dd>
<pre>*
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>%
</pre>

</dd></dl>

<br>&nbsp;будут&nbsp;выбраны&nbsp;все&nbsp;пользователи,&nbsp;все&nbsp;дисплеи&nbsp;или&nbsp;все&nbsp;окна&nbsp;соответственно.&nbsp;&nbsp;На&nbsp;экране&nbsp;появится&nbsp;короткое&nbsp;сообщение,&nbsp;описывающее,&nbsp;
что происходит.  Обратите внимание, что символ "#" работает как комментарий, если перед ним поставить #.  Экранировать 
символ можно с помощью .RS
<pre>\
</pre>

</dd></dl>

<br>&nbsp;&nbsp;Разрешения&nbsp;проверяются&nbsp;для&nbsp;того,&nbsp;кто&nbsp;вызвал&nbsp;команду&nbsp;<i>at</i>,&nbsp;а&nbsp;не&nbsp;для&nbsp;владельца&nbsp;дисплея,&nbsp;на&nbsp;котором&nbsp;будет&nbsp;выполняться&nbsp;
команда. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Замечание:&nbsp;При&nbsp;поиске&nbsp;соответствия&nbsp;именам&nbsp;окон,&nbsp;команда&nbsp;выполняется&nbsp;как&nbsp;минимум&nbsp;по&nbsp;разу&nbsp;для&nbsp;каждого&nbsp;окна.&nbsp;Команды,&nbsp;которые&nbsp;
меняют порядок окон (как <i>other</i>) могут вызываться более одного раза.  В окнах, подключенных к нескольким дисплеям, 
команда будет выполняться для каждого дисплея.  Осторожно с переключающими (toggle) программами типа <b>login</b>!  Некоторые 
программы (например, "process") требуют чтобы экран был подключен к целевому окну. Такие команды могут не очень корректно 
работать, когда <i>at</i> обходит окна. .RE
<p>
</p><dl compact="">
<dt><b>attrcolor</b> <i>attrib</i> [<i>attribute</i>/<i>color-modifier</i>]

</dt><dd>
<br>

<br>&nbsp;Команда&nbsp;предназначена&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;подсвечивать&nbsp;атрибуты&nbsp;путём&nbsp;смены&nbsp;цвета&nbsp;текста.&nbsp;&nbsp;Если&nbsp;используется&nbsp;атрибут&nbsp;<i>attrib</i>,&nbsp;
применяется модификатор attribute/color.  Если модификатор не задан, удаляются текущие.       Подробнее о синтаксисе читайте 
в разделе "Escape-последовательности". .br
<br>&nbsp;Программа&nbsp;screen&nbsp;понимает&nbsp;два&nbsp;псевдо-атрибута:&nbsp;"i"&nbsp;обозначает&nbsp;яркий&nbsp;цвет&nbsp;буквы&nbsp;и&nbsp;"I"&nbsp;обозначает&nbsp;яркий&nbsp;цвет&nbsp;фона.&nbsp;
<dl compact=""><dt></dt><dd>
<pre>  Примеры:

  attrcolor b "R"
       Выводить ярко-красным цветом текст, который должен быть полужирным.

  attrcolor u "-u b"
       Выводить текст синим цветом вместо подчёркнутого.

  attrcolor b ".I"
       Использовать яркие цвета для вывода полужирного текста. Большинство терминалов и так это делает. 
  attrcolor i "+b"
       Сделать чтобы яркий текст был ещё и полужирным.

</pre>

</dd></dl>

</dd><dt><b>autodetach</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Будет&nbsp;ли&nbsp;экран&nbsp;отключаться&nbsp;(detach)&nbsp;при&nbsp;разрыве&nbsp;связи&nbsp;с&nbsp;терминалом&nbsp;(hangup).&nbsp;В&nbsp;результате&nbsp;отключения&nbsp;команды,&nbsp;работающие&nbsp;
в screen, должны продолжать работать и не завершаться. Восстановить подключение можно с помощью команды <i>screen -r</i>. 
Если опция выключена (<i>off</i>), при разрыве связи с терминалом все процессы получат сигнал потери связи с терминалом 
(hangup, HUP) и (скорее всего) завершатся. По умолчанию: <i>on</i> 
</dd><dt><b>autonuke</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Указывает,&nbsp;должна&nbsp;ли&nbsp;команда&nbsp;очистки&nbsp;экрана&nbsp;удалять&nbsp;вывод,&nbsp;который&nbsp;ещё&nbsp;не&nbsp;был&nbsp;отправлен&nbsp;на&nbsp;терминал.&nbsp;&nbsp;См&nbsp;также.&nbsp;<b>obuflimit</b>.&nbsp;
<p>
</p></dd><dt><b>backtick </b><i>id</i> <i>lifespan</i> <i>autorefresh</i> <i>cmd</i> <i>args</i>...

</dt><dd>
</dd><dt><b>backtick </b><i>id</i>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Программирует&nbsp;backtick-команду&nbsp;(командную&nbsp;подстановку)&nbsp;с&nbsp;заданным&nbsp;идентификатором&nbsp;<i>id</i>.&nbsp;&nbsp;Вывод&nbsp;этой&nbsp;команды&nbsp;
используется для замены строковой последовательности .RS
<pre>%`
</pre>

</dd></dl>

<br>&nbsp;(
<dl compact=""><dt></dt><dd>
<pre>%<i>номер</i>`
</pre>

</dd></dl>

).  Заданный промежуток времени <i>lifespan</i> определяет количество секунду в течение которых вывод может считаться 
действительным. Когда время заканчивается, если встретится соответствующая escape-последовательность, программа 
должна запускаться заново.  Параметр <i>autorefresh</i> включает автоматическое обновление заголовков после заданного 
количества секунд. 
<br>

<br>&nbsp;Если&nbsp;и&nbsp;<i>lifespan</i>,&nbsp;и&nbsp;<i>autorefresh</i>&nbsp;равны&nbsp;0,&nbsp;предполагается,&nbsp;что&nbsp;программа&nbsp;должна&nbsp;уйти&nbsp;в&nbsp;фон&nbsp;и&nbsp;изредка&nbsp;генерировать&nbsp;
вывод. В этом случае команда запускается сразу же, и screen сохраняет последнюю строчку вывода. Если печатается новая 
строка, screen автоматически обновляет заголовки или hardstatus.  Вторая форма команды удаляет bactick с идентификатором 
<i>id</i>. .RE
<p>
</p></dd><dt><b>bce</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<br>

<br>&nbsp;Настройка&nbsp;background-color-erase&nbsp;(цвет&nbsp;фона&nbsp;при&nbsp;очистке).&nbsp;Если&nbsp;bce&nbsp;установлено,&nbsp;все&nbsp;символы,&nbsp;которые&nbsp;в&nbsp;настоящий&nbsp;
момент очищаются,вставляются, выводятся из буфера-прокрутки или очищаются, будут выводиться с текущим цветом фона. 
В противном случае используется цвет фона, заданный по умолчанию. 
</dd><dt><b>bell_msg</b> [<i>message</i>]

</dt><dd>
<br>

<br>&nbsp;Когда&nbsp;символ&nbsp;звонка&nbsp;(bell&nbsp;character)&nbsp;выводится&nbsp;в&nbsp;фоновом&nbsp;окне,&nbsp;screen&nbsp;показывает&nbsp;сообщение-предупреждение.&nbsp;&nbsp;Это&nbsp;сообщение&nbsp;
предупреждение можно переопределить командой <i>bell_msg</i>.  Каждый символ " .RS
<pre>%
</pre>

</dd></dl>
</dd></dl>

" в сообщение заменяется номером окна в котором прозвучал звонок; а каждая последовательность "
<dl compact=""><dt></dt><dd>
<pre>^G
</pre>

</dd></dl>

" заменяется на обозначения звонка из termcap (обычно, звуковым звонком).  По умолчанию сообщение такое: 
<dl compact=""><dt></dt><dd>
<pre>        "Bell in window %n"

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Можно&nbsp;подавить&nbsp;вывод&nbsp;сообщения,&nbsp;если&nbsp;задать&nbsp;пустое&nbsp;сообщение&nbsp;в&nbsp;качестве&nbsp;аргумента&nbsp;(
<dl compact=""><dt></dt><dd>
<pre>bell_msg ""
</pre>

</dd></dl>

). При вызове <i>bell_msg</i> безе параметров показывается текущее сообщение.
</dd></dl>

<p>
</p><dl compact="">
<dt><b>bind</b> [-c <i>class</i>] <i>key</i> [<i>command</i> [<i>args</i>]]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Привязать&nbsp;команду&nbsp;к&nbsp;комбинации&nbsp;клавиш.&nbsp;По&nbsp;умолчанию,&nbsp;большинство&nbsp;команд,&nbsp;которые&nbsp;есть&nbsp;в&nbsp;screen&nbsp;уже&nbsp;привязаны&nbsp;к&nbsp;каким-то&nbsp;
клавишам или их комбинациям (см.  "Привязки клавиш").  Так, например, команда создания окна привязана к клавише "c" или 
"C-c".  С помощью команды <i>bind</i> можно переопределять существующие привязки или создавать новые.  Аргумент <i>key</i> 
это или один символ, или последовательность из двух символов в виде "^x" (означающая Ctrl-x), обратный слеш за которым 
идет восьмеричное число (обозначающее код ASCII-символа) или обратный слеш, за котором идёт другой, экранированный, 
символ (например, \^ или \\).  Этот аргумент можно брать в кавычки. Если больше аргументов нет, удаляется сделанная 
ранее привязка к этому ключу.  В качестве аргумента <i>command</i> может использоваться любая команда, описанная в этом 
разделе. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Если&nbsp;при&nbsp;помощи&nbsp;опции&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-c
</pre>

</dd></dl>

<br>&nbsp;указан&nbsp;класс&nbsp;команды,&nbsp;ключ&nbsp;привязывается&nbsp;к&nbsp;команде&nbsp;указанного&nbsp;класса.&nbsp;Класс&nbsp;активируется&nbsp;с&nbsp;помощью&nbsp;команды&nbsp;<i>command</i>.&nbsp;
Классы команд можно использовать для создания множественных комбинаций или многосимвольных привязок. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Некоторые&nbsp;примеры:
</dd></dl>

<dl compact=""><dt></dt><dd>
<pre>    bind   windows
    bind ^k
    bind k
    bind K kill
    bind ^f screen telnet foobar
    bind \033 screen -ln -t root -h 1000 9 su

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;последовательность&nbsp;привязывает&nbsp;пробел&nbsp;к&nbsp;команде,&nbsp;которая&nbsp;показывает&nbsp;список&nbsp;окон&nbsp;(и&nbsp;команда,&nbsp;которая&nbsp;обычно&nbsp;доступна&nbsp;
через C-a C-w теперь доступа и по нажатию C-a пробел).  Следующие три строки удаляют привязку kill с комбинаций "C-a 
C-k" и "C-a k".  После чего kill привязывается к "C-a K". Потом комбинация клавиш "C-f" привязывается к команде "создать 
окно с TELNET-подключением к foobar", а клавишу "escape"  к команде, которая создаёт с именем root в слоте 0, с командным 
интерпретатором, запущенным от имени суперпользователя и буфером прокрутки на 1000 строк. .RE
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bind -c demo1 0 select 10
    bind -c demo1 1 select 11
    bind -c demo1 2 select 12
    bindkey "^B" command -c demo1

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Сделать&nbsp;так&nbsp;что&nbsp;бы&nbsp;"C-b&nbsp;0"&nbsp;выбирало&nbsp;окно&nbsp;0,&nbsp;"C-b&nbsp;1"&nbsp;окно&nbsp;11&nbsp;и&nbsp;т.&nbsp;д.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bind -c demo2 0 select 10
    bind -c demo2 1 select 11
    bind -c demo2 2 select 12
    bind - command -c demo2

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Сделать&nbsp;так&nbsp;что&nbsp;бы&nbsp;"C-a&nbsp;-&nbsp;0"&nbsp;выбирало&nbsp;окно&nbsp;10,&nbsp;"C-a&nbsp;-&nbsp;1"&nbsp;окно&nbsp;11&nbsp;и&nbsp;так&nbsp;далее.
</dd></dl>

<p>
</p><dl compact="">
<dt><b>bindkey</b> [-d] [-m] [-a] [ [-k|-t] <i>string</i> [<i>cmd</i> <i>args</i>] ]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;Команда&nbsp;предназначена&nbsp;для&nbsp;управления&nbsp;таблицами&nbsp;трансляции&nbsp;screen.&nbsp;Каждая&nbsp;запись&nbsp;в&nbsp;таблице&nbsp;говорит&nbsp;screen&nbsp;как&nbsp;реагировать&nbsp;
на нажатие определённых последовательностей клавиш при работе в разных режимах. Есть три таблицы: в одной хранятся действия, 
запрограммированные пользователем; во второй действия по умолчанию при эмуляции терминала; и одну для управления курсором 
в режиме копирования.  В разделе "Трансляция при вводе" приводится список привязок по умолчанию.  Если задана опция .RS
<pre>-d
</pre>

</dd></dl>
</dd></dl>

,  bindkey изменяет таблицу по умолчанию,  
<dl compact=""><dt></dt><dd>
<pre>-m
</pre>

</dd></dl>

<br>&nbsp;изменяет&nbsp;таблицу&nbsp;для&nbsp;режима&nbsp;копирования,&nbsp;и&nbsp;если&nbsp;ключей&nbsp;не&nbsp;задавать&nbsp;вообще&nbsp;&nbsp;выбирается&nbsp;пользовательская&nbsp;таблица.&nbsp;Аргумент&nbsp;
<i>string</i> это последовательность из двух символов, к которой привязывается действие.  Это может быть или строка или 
имя клавиатурной termcap возможность (выбор при помощи .RS
<pre>-k
</pre>

</dd></dl>

).  На терминале VT100 некоторые клавиши могут отправлять другие последовательности, если включен режим приложения (например, 
клавиши управления курсором).  У таких клавиш в таблице трансляции две записи. Выбор режима приложения выполняется с помощью 
ключа .RS
<pre>-a
</pre>

</dd></dl>

<br>&nbsp;&nbsp;Опция&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-t
</pre>

</dd></dl>

<br>&nbsp;говорит&nbsp;screen,&nbsp;что&nbsp;ненужно&nbsp;делать&nbsp;межсимвольный&nbsp;тайминг.&nbsp;&nbsp;Нельзя&nbsp;отключить&nbsp;тайминг,&nbsp;если&nbsp;используюся&nbsp;termcap&nbsp;capability.&nbsp;
<br>&nbsp;Аргумент&nbsp;<i>cmd</i>&nbsp;может&nbsp;быть&nbsp;любой&nbsp;командой&nbsp;screen&nbsp;с&nbsp;произвольным&nbsp;количеством&nbsp;аргументов.&nbsp;&nbsp;Если&nbsp;<i>cmd</i>&nbsp;не&nbsp;указано,&nbsp;
привязка удаляется из таблицы. 
<dl compact=""><dt></dt><dd>
<br>&nbsp;Вот&nbsp;некоторые&nbsp;примеры&nbsp;привязок:
</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bindkey -d

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Показать&nbsp;все&nbsp;привязки&nbsp;клавиш.&nbsp;Записи&nbsp;приложений&nbsp;(application&nbsp;mode&nbsp;entries)&nbsp;отмечаются&nbsp;символом&nbsp;
<dl compact=""><dt></dt><dd>
<pre>[A]
</pre>

</dd></dl>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bindkey -k k1 select 1

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;F1&nbsp;переключает&nbsp;на&nbsp;окно&nbsp;1.
</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bindkey -t foo stuff barfoo

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Сделать&nbsp;слово&nbsp;<i>foo</i>&nbsp;сокращением&nbsp;для&nbsp;слова&nbsp;<i>barfoo</i>.&nbsp;Таймаут&nbsp;отключён,&nbsp;поэтому&nbsp;можно&nbsp;набирать&nbsp;медленно.&nbsp;.RE
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bindkey "\024" mapdefault

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Сделать&nbsp;"^T"&nbsp;escape-последовательностью&nbsp;для&nbsp;привязок&nbsp;клавиш.&nbsp;Если&nbsp;вы&nbsp;выполнили&nbsp;предыдущую&nbsp;команду,&nbsp;теперь&nbsp;слово&nbsp;"foo"&nbsp;
нужно будеть вводить через "^T": "^Tfoo". Если вы хотите вставить "^T", надо нажать её дважды.  (т.е. экранировать второе 
нажатие с помощью первого). .RE
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bindkey -k F1 command

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Сделать&nbsp;F11&nbsp;(не&nbsp;F1!)&nbsp;альтернативой&nbsp;escape-символу&nbsp;(^A).
</dd></dl>

<p>
</p><dl compact="">
<dt><b>break</b> [<i>duration</i>]

</dt><dd>
<br>

<br>&nbsp;Отправляет&nbsp;сигнал&nbsp;разрыва&nbsp;(break)&nbsp;длительностью&nbsp;duration*0.25&nbsp;секунд.&nbsp;Для&nbsp;не-POSIX&nbsp;систем&nbsp;число&nbsp;секунд&nbsp;может&nbsp;округляться&nbsp;
до целого. Наиболее полезно в том случае, когда символьное устройство подключено к окну, а не процессу командного интерпретатора 
(см. Типы окон). Максимальная длительность сигнала ограничена величиной 15 секунд. 
</dd><dt><b>blanker</b>

</dt><dd>
<br>

<br>&nbsp;Активирует&nbsp;хранитель&nbsp;экрана.&nbsp;Сначала&nbsp;очищается&nbsp;экран.&nbsp;Потом,&nbsp;если&nbsp;хранитель&nbsp;экрана&nbsp;не&nbsp;задан,&nbsp;выключается&nbsp;курсор;&nbsp;если&nbsp;
же курсор задан, он запускается и его вывод направляется на экран. По первому нажатию клавиши хранитель завершается, а 
его вывод стирается. Нажатая клавиша не запоминается. Обычно, эта команда используется совместно с командой <b>idle</b>. 
<p>
</p></dd><dt><b>blankerprg</b> [<i>program args</i>]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Указывает&nbsp;какая&nbsp;программа&nbsp;должна&nbsp;использоваться&nbsp;в&nbsp;качестве&nbsp;хранителя&nbsp;экрана.&nbsp;Или&nbsp;отключает&nbsp;хранитель&nbsp;экрана&nbsp;вообще,&nbsp;
если этот параметр не задан. 
</dd><dt><b>breaktype</b> [tcsendbreak|TIOCSBRK |TCSBRK]

</dt><dd>
<br>

<br>&nbsp;Выбрать&nbsp;один&nbsp;из&nbsp;доступных&nbsp;способов&nbsp;генерирования&nbsp;сигнала&nbsp;разрыва&nbsp;(break)&nbsp;для&nbsp;терминальных&nbsp;устройств.&nbsp;Команда&nbsp;должна&nbsp;
действовать только на текущее окно, но до сих пор она работает как <b>defbreaktype</b>. В будущем это изменится. Если вызвать 
<b>breaktype</b> без параметров, будет выведена текущая настройка. 
</dd><dt><b>bufferfile</b> [<i>exchange-file</i>]

</dt><dd>
<br>

<br>&nbsp;Изменить&nbsp;имя&nbsp;файла,&nbsp;использующегося&nbsp;для&nbsp;чтения&nbsp;и&nbsp;записи&nbsp;буфера&nbsp;обмена.&nbsp;Если&nbsp;имя&nbsp;файла&nbsp;не&nbsp;указано,&nbsp;реактивируется&nbsp;настройка&nbsp;
по умолчанию ( .RS
<pre>/tmp/screen-exchange
</pre>

</dd></dl>
</dd></dl>

). В этом примере системный файл 
<dl compact=""><dt></dt><dd>
<pre>passwd
</pre>

</dd></dl>

<br>&nbsp;копируется&nbsp;в&nbsp;окно&nbsp;(при&nbsp;помощи&nbsp;буфера&nbsp;обмена,&nbsp;в&nbsp;котором&nbsp;остаётся&nbsp;копия):
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    C-a : bufferfile /etc/passwd
    C-a &lt; C-a ]
    C-a : bufferfile

</pre>

</dd></dl>

<dl compact="">
<dt><b>c1</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Изменяет&nbsp;обработку&nbsp;кода&nbsp;c1.&nbsp;Если&nbsp;включить&nbsp;(C1&nbsp;on),&nbsp;screen&nbsp;будет&nbsp;обрабатывать&nbsp;символы&nbsp;с&nbsp;кодом&nbsp;в&nbsp;диапазоне&nbsp;от&nbsp;128&nbsp;до&nbsp;159&nbsp;как&nbsp;
специальные управляющие последовательности. Он будет воспринимать 8-битный код как комбинацию ESC и аналогичного 
7-битного. По умолчанию обработка кодов C1 включена (настройку по умолчанию можно изменить при помощи команды <i>defc1</i>). 
Пользователь, которому нужны символы с кодами на позициях относящихся к C1, может выключить эту функцию. .RE
<p>
</p><dl compact="">
<dt><b>caption</b> <b>always</b>|<b>splitonly</b> [<i>string</i>]

</dt><dd>
</dd><dt><b>caption</b> <b>string</b> [<i>string</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Команда&nbsp;управляет&nbsp;отображением&nbsp;заголовков&nbsp;окон.&nbsp;По&nbsp;умолчанию,&nbsp;заголовки&nbsp;показываются&nbsp;только&nbsp;если&nbsp;на&nbsp;экране&nbsp;больше&nbsp;одного&nbsp;
окна (режим split screen). Если же включен режим <i>caption always</i>, заголовок будет показываться всегда. По умолчанию 
включён режим <i>splitonly</i>. 
<br>

<br>&nbsp;Вторая&nbsp;форма&nbsp;вызова&nbsp;изменяет&nbsp;текст&nbsp;заголовка.&nbsp;Можно&nbsp;использовать&nbsp;escape-последовательности&nbsp;(см.&nbsp;раздел&nbsp;Escape-последовательности).&nbsp;
По умолчанию заголовок: "%3n %t". Можно смешивать обе формы и задавать строку как дополнительный аргумент. .RE
<p>
</p><dl compact="">
<dt><b>charset</b> <i>set</i>

</dt><dd>
<br>

<br>&nbsp;Изменяет&nbsp;текущее&nbsp;назначение&nbsp;слотов&nbsp;и&nbsp;привязку&nbsp;кодировок.&nbsp;&nbsp;Первые&nbsp;четыре&nbsp;символа&nbsp;рассматриваются&nbsp;как&nbsp;описание&nbsp;кодировки,&nbsp;
а пятый и шестой должны находиться в диапазоне и задавать настройку отображения GL/GR. В каждой позиции символ "." может 
указывать на то, что соответствующая кодировка не должна меняться (множество добивается внутри screen символами . до 
6).  У новых окон будет кодировка по умолчанию "BBBB02", кроме тех случаев, когда активна команда "encoding".
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Текущие&nbsp;настройки&nbsp;можно&nbsp;посмотреть&nbsp;при&nbsp;помощи&nbsp;команды&nbsp;<i>info</i>.
</dd></dl>

<p>
</p></dd><dt><b>chdir</b> [<i>directory</i>]

</dt><dd>
<br>

<br>&nbsp;Изменяет&nbsp;текущий&nbsp;каталог&nbsp;screen&nbsp;на&nbsp;заданный&nbsp;или,&nbsp;если&nbsp;команда&nbsp;вызвана&nbsp;без&nbsp;аргументов,&nbsp;на&nbsp;домашний&nbsp;каталог&nbsp;пользователя&nbsp;
(значение переменной .RS
<pre>$HOME
</pre>

</dd></dl>
</dd></dl>

). У всех программ, которые запускаются в окнах, создающихся при помощи команды <i>screen</i> из 
<dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

, или при помощи C-a c, или при помощи <i>C-a : screen ...</i> будет этот текущий каталог. Без вызова команды <i>chdir</i> 
текущим каталогом будет тот, из которого вызывался <i>screen</i>. Hardcopy-файл и файл-журнал пишутся в текущий каталог 
окна (а не процесса, который работает в этом окне). Можно многократно использовать эту команду в файле .RS
<pre></pre>

</dd></dl>
</dd></dl>

: например, для того чтобы создавать различные окна с различными рабочими каталогами. Последний вызов <i>chdir</i> будет 
влиять на окна, которые создаются интерактивно. 
</dd><dt><b>clear</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Очищает&nbsp;текущее&nbsp;окно&nbsp;и&nbsp;сохраняет&nbsp;его&nbsp;образ&nbsp;в&nbsp;буфер&nbsp;прокрутки.
<p>
</p></dd><dt><b>colon</b> [<i>prefix</i>]

</dt><dd>
<br>

<br>&nbsp;Позволяет&nbsp;вводить&nbsp;командные&nbsp;строки&nbsp;
<dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<br>&nbsp;Полезно&nbsp;для&nbsp;выполнения&nbsp;изменений&nbsp;привязки&nbsp;клавиш&nbsp;на&nbsp;лету,&nbsp;хитрого&nbsp;управления&nbsp;окнами.&nbsp;Обратите&nbsp;внимание&nbsp;на&nbsp;то,&nbsp;что&nbsp;ключевое&nbsp;
слово <b>set</b> больше не существует. Как правило, команды воздействуют на текущее окно, а не на настройки для будущих 
окон. Если нужно поменять настройки для будущих окон, используются команды, начинающиеся словом <b>def...</b>. .br
<br>&nbsp;Вы&nbsp;можете&nbsp;воспринимать&nbsp;этот&nbsp;режим&nbsp;как&nbsp;режим&nbsp;Ex&nbsp;в&nbsp;screen,&nbsp;а&nbsp;режим&nbsp;вызываемый&nbsp;по&nbsp;комбинации&nbsp;<b>C-a&nbsp;esc</b>&nbsp;&nbsp;как&nbsp;командный&nbsp;режим&nbsp;
по аналогии с редактором Vi. 
</dd><dt><b>command</b> [-c <i>class</i>]

</dt><dd>
<br>

<br>&nbsp;Это&nbsp;команда&nbsp;делает&nbsp;то&nbsp;же&nbsp;самое,&nbsp;что&nbsp;и&nbsp;комбинация&nbsp;клавиш&nbsp;^A.&nbsp;По&nbsp;всей&nbsp;видимости,&nbsp;толк&nbsp;от&nbsp;неё&nbsp;есть&nbsp;только&nbsp;при&nbsp;описании&nbsp;привязок&nbsp;
комбинаций клавиш. Если задан ключ .RS
<pre>-c
</pre>

</dd></dl>
</dd></dl>

, определяется класс команды. См. также <b>bind</b> и <b>bindkey</b>.
<p>
</p></dd><dt><b>compacthist</b> [on|off]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Говорит&nbsp;<i>screen</i>,&nbsp;нужно&nbsp;ли&nbsp;подавлять&nbsp;последние&nbsp;пустые&nbsp;строки&nbsp;при&nbsp;прокрутке&nbsp;текста&nbsp;в&nbsp;буфере&nbsp;истории.&nbsp;
</dd><dt><b>console</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Захватывает&nbsp;(или&nbsp;отпускает&nbsp;захват)&nbsp;системной&nbsp;консоли&nbsp;текущим&nbsp;окном.&nbsp;Захватить&nbsp;консоль&nbsp;может&nbsp;только&nbsp;владелец&nbsp;файла&nbsp;/dev/console.&nbsp;
Кроме того, система должна поддерживать ioctl TIOCCONS. 
</dd><dt><b>copy</b>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Переходит&nbsp;в&nbsp;режим&nbsp;копирования/прокрутки.&nbsp;В&nbsp;этом&nbsp;режиме&nbsp;можно&nbsp;скопировать&nbsp;текст&nbsp;из&nbsp;текущего&nbsp;окна&nbsp;и&nbsp;его&nbsp;истории&nbsp;в&nbsp;буфер&nbsp;обмена.&nbsp;
<br>&nbsp;В&nbsp;этом&nbsp;режиме&nbsp;активируется&nbsp;vi-подобный&nbsp;интерфейс:&nbsp;.RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Клавиши&nbsp;для&nbsp;передвижения:
<p>
<br>

* h, j, k, l перемещают курсор на одну строку или одну колонку.
</p><p>
<br>

* 0,  ^  и  $  перемещают курсов в самую левую колонку, в первую или последнюю позицию, где стоит непробельный символ. 
<br>

* H, M и L перемещают курсор в самую левую колнонку верхней, средней или нижней строки экрана.
</p><p>
<br>

* + и - перемещают на одну строку вверих или вниз.
</p><p>
<br>

* G переходит на строку с заданным номеромt (по умолчанию: до конца буфера).
</p><p>
<br>

* | переходят на колонку с заданным номером.
</p><p>
<br>

* w, b, e передвижение по словам.
</p><p>
<br>

* B, E передвижение по СЛОВАМ (как в vi).
</p><p>
<br>

* C-u  и  C-d  прокручивает экран вверх/вниз на заданное количество строк, сохраняя при этом позицию курсора 
<br>

* (По умолчанию: пол-экрана).
</p><p>
<br>

* C-b и C-f прокручивают на один экран ввер/вниз.
</p><p>
<br>

* g переходит в начало буфера.
</p><p>
<br>

* % переходит на указанный процент буфера.
</p></dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Замечание:
<p>
<br>

<br>&nbsp;Команды&nbsp;перемещения&nbsp;в&nbsp;стиле&nbsp;Emacs&nbsp;можно&nbsp;настроит&nbsp;с&nbsp;помощью&nbsp;
</p><dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<br>&nbsp;(Например,&nbsp;markkeys&nbsp;"h=^B:l=^F:$=^E").&nbsp;Нет&nbsp;простого&nbsp;способа&nbsp;для&nbsp;полной&nbsp;раскладки&nbsp;в&nbsp;стиле&nbsp;Emacs,&nbsp;поскольку&nbsp;нужно&nbsp;задействовать&nbsp;
многосимвольные коды. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;<i>Маркировка</i>:
<p>
<br>

<br>&nbsp;Область&nbsp;копирования&nbsp;определяется&nbsp;двумя&nbsp;отметками.&nbsp;Текст&nbsp;между&nbsp;отметками&nbsp;подсвечивается.&nbsp;Отметки&nbsp;ставятся&nbsp;при&nbsp;помощи&nbsp;
пробела. 
<br>

* Y и y маркируют всю строку или с начала строки.
</p><p>
<br>

* W маркирует ровно одно слово.
</p></dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;<i>Повтор</i>:
<p>
<br>

<br>&nbsp;Любую&nbsp;команду&nbsp;можно&nbsp;вводить&nbsp;после&nbsp;числа,&nbsp;которое&nbsp;обозначает&nbsp;количество&nbsp;повторов&nbsp;при&nbsp;вызове&nbsp;этой&nbsp;команды.&nbsp;
<br>

* 0..9 обозначает количество повторов.
</p><p>
<br>

<br>&nbsp;Пример:&nbsp;&nbsp;"C-a&nbsp;&nbsp;C-[&nbsp;&nbsp;H&nbsp;&nbsp;10&nbsp;j&nbsp;5&nbsp;Y"&nbsp;копирует&nbsp;строки&nbsp;с&nbsp;11&nbsp;по&nbsp;15&nbsp;в&nbsp;буфер&nbsp;обмена.
</p></dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;<i>Поиск</i>:
<p>
<br>

* / Поиск вперёд в стиле Vi
</p><p>
<br>

* ? Поиск назад в стиле Vi
</p><p>
<br>

* C-a s Инкрементальный поиск вперёд в стиле Emacs
</p><p>
<br>

* C-r Обратный интерактивный поиск в стиле Emacs
</p></dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;<i>Отличия&nbsp;от&nbsp;vi</i>:
<p>
<br>

<br>&nbsp;Есть&nbsp;несколько&nbsp;клавиш,&nbsp;которые&nbsp;работают&nbsp;не&nbsp;как&nbsp;в&nbsp;vi.&nbsp;&nbsp;Vi&nbsp;(не&nbsp;vim)&nbsp;не&nbsp;позволяет&nbsp;работать&nbsp;с&nbsp;прямоугольными&nbsp;блоками&nbsp;текста,&nbsp;
а screen позволяет. 
<br>

* c или C to задаёт левый или правый отступ соответственно.
</p><p>
<br>

<br>&nbsp;&nbsp;Если&nbsp;не&nbsp;задан&nbsp;повтор,&nbsp;отступ&nbsp;будет&nbsp;соответствовать&nbsp;текущей&nbsp;позиции&nbsp;курсора.
</p><p>
<br>

<br>&nbsp;&nbsp;Пример:&nbsp;Попробуйте&nbsp;такую&nbsp;последовательность:&nbsp;"C-a&nbsp;[&nbsp;M&nbsp;20&nbsp;l&nbsp;SPACE&nbsp;c&nbsp;10&nbsp;l&nbsp;5&nbsp;j&nbsp;C&nbsp;SPACE".&nbsp;&nbsp;перейти&nbsp;на&nbsp;среднюю&nbsp;линию,&nbsp;сдвинуться&nbsp;
на 20 колонку, ометить начало буфера, установить левую колонку, перейти на 5 строк вниз, установить правую колонку, отметить 
конец буфера обмена. 
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Теперь&nbsp;попробуйте:&nbsp;"C-a&nbsp;[&nbsp;M&nbsp;20&nbsp;l&nbsp;SPACE&nbsp;10&nbsp;l&nbsp;5&nbsp;j&nbsp;SPACE"&nbsp;и&nbsp;обратите&nbsp;внимание&nbsp;на&nbsp;то,&nbsp;сколько&nbsp;текста&nbsp;скопировалось&nbsp;на&nbsp;этот&nbsp;раз.&nbsp;
</p></dd></dl>

<dl compact=""><dt></dt><dd>
* J  объединить строки. Он переключается между 4 режимами: строки разделяются символом новой строки (new line, 012), объединяются 
бесшовно, разделяются одним пробелом или разделяются запятой.  Можно сдедать так, что бы перед символом новой строки (new 
line) выводился символ перевода каретки (carriage return), для этого нужно дать команду <i>crlf on</i>. 
<br>

* v нужна пользователям vi, которые включают ":set numbers" - переключает величину отступа между 9 и 1. 
<br>

* a переключает в режим добавления (append mode). Содержимое буфера обмена не будет стёрто, а дописано. 
<br>

* A переключает режим ввода (append mode) и ставит вторую отметку.
<p>
<br>

* &gt; ставит вторую отметку и записывает выделенный текст в файл screen-exchnage (по умолчанию 
</p><dl compact=""><dt></dt><dd>
<pre>/tmp/screen-exchange
</pre>

</dd></dl>

) и выходит из режима копирования.
</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Пример&nbsp;как&nbsp;записать&nbsp;весь&nbsp;буфер&nbsp;прокрутки&nbsp;в&nbsp;тот&nbsp;файл:&nbsp;"C-A&nbsp;[&nbsp;g&nbsp;SPACE&nbsp;G&nbsp;$&nbsp;&gt;".
<p>
<br>

* C-g показывает информацию о текущей строке и колонке.
</p><p>
<br>

* x  меняет местами первую отметку и текущую позицию курсора. Можно использовать для того чтобы передвинуть уже установленную 
отметку. 
<br>

* @ ничего не делает. Даже не выходит из режима копирования.
</p></dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Все&nbsp;клавиши,&nbsp;которые&nbsp;не&nbsp;были&nbsp;описаны&nbsp;здесь,&nbsp;завершают&nbsp;режим&nbsp;копирования.
</dd></dl>

<p>
</p><dl compact="">
<dt><b>copy_reg</b> [<i>key</i>]

</dt><dd>
<br>

<br>&nbsp;Больше&nbsp;не&nbsp;существует,&nbsp;используйте&nbsp;<i>readreg</i>.
<p>
</p></dd><dt><b>crlf</b> [<i>on</i>|<i>off</i>] 

</dt><dd>
<br>

<br>&nbsp;Команда&nbsp;влияет&nbsp;на&nbsp;копирование&nbsp;блоков&nbsp;текста&nbsp;с&nbsp;помощью&nbsp;комбинации&nbsp;клавиш&nbsp;<b>C-a&nbsp;[</b>.&nbsp;Если&nbsp;установить&nbsp;её&nbsp;в&nbsp;<i>on</i>,&nbsp;строки&nbsp;
будут разделяться символами CR  LF. В противном случае (по умолчанию) они будут разделяться только LF. При вызове без параметров, 
состояние переключается. 
</dd><dt><b>debug</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<br>

<br>&nbsp;Включает&nbsp;или&nbsp;выключает&nbsp;отладку.&nbsp;Если&nbsp;программа&nbsp;screen&nbsp;откомпилирована&nbsp;с&nbsp;опцией&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-DDEBUG
</pre>

</dd></dl>

, отладка включена по умолчанию. Обратите внимание на то, что команда действует на отладочный вывод только главного процесса 
screen. Отладочный вывод attacher-процессов можно только выключить, да и то только один раз. 
</dd><dt><b>defc1</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>c1</b>,&nbsp;но&nbsp;настройка&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;По&nbsp;умочанию,&nbsp;равна&nbsp;<i>on</i>.&nbsp;
</dd><dt><b>defautonuke</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>autonuke</b>,&nbsp;но&nbsp;настройка&nbsp;изменяется&nbsp;по&nbsp;умолчанию&nbsp;и&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальная&nbsp;настройка&nbsp;равна&nbsp;<b>off</b>.&nbsp;
Обратите внимание, что вы можете использовать специальную возможность (capability) AN терминала, если вы хотите чтобы 
действие зависело от типа терминала. 
</dd><dt><b>defbce</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>bce</b>,&nbsp;но&nbsp;настройка&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;По&nbsp;умочанию,&nbsp;равна&nbsp;<i>off</i>.&nbsp;
</dd><dt><b>defbreaktype</b> [<i>tcsendbreak</i>|<i>TIOCSBRK</i> |<i>TCSBRK</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Выбрать&nbsp;один&nbsp;из&nbsp;трёх&nbsp;доступных&nbsp;методов&nbsp;генерирования&nbsp;сигнала&nbsp;разрыва&nbsp;(break&nbsp;signal)&nbsp;для&nbsp;терминальных&nbsp;устройств.&nbsp;&nbsp;Предпочитально&nbsp;
использовать методы <i>tcsendbreak</i> и <i>TIOCSBRK</i>. Третий метод, <i>TCSBRK</i>, полностью блокирует сеанс screen 
на протяжении разрыва, но в некоторых случаях это может быть единственным рабочим способом сделать длинный разрыв. <i>Tcsendbreak</i> 
и <i>TIOCSBRK</i> могут делать, а могут не делать длинные разрывы с шипами (long breaks with spikes) (например, 4 в секунду). 
Это зависит не только от системы, но и от драйверов последовательных адаптеров. Если вызвать "defbreaktype" без параметров, 
будут показаны текущие настройки. .RE
<p>
</p><dl compact="">
<dt><b>defcharset</b> [<i>set</i>]

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>charset</b>,&nbsp;но&nbsp;настройка&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Если&nbsp;вызвать&nbsp;без&nbsp;аргументов,&nbsp;показывает&nbsp;
текущую настройку. 
</dd><dt><b>defescape</b> <i>xy</i>

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;командный&nbsp;символ.&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;escape,&nbsp;за&nbsp;исключением&nbsp;того,&nbsp;что&nbsp;может&nbsp;быть&nbsp;полезно&nbsp;только&nbsp;в&nbsp;многпользовательских&nbsp;
сеансах. В многопользовательских сеансах <i>escape</i> меняет настройку только для вызвавшего эту команду пользователя, 
а <i>defescape</i> меняет настройку для пользователей, которые будут добавлены позже. 
</dd><dt><b>defflow</b> <i>on</i>|<i>off</i>|<i>auto</i> [<i>interrupt</i>]

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>flow</b>,&nbsp;но&nbsp;настройка&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальная&nbsp;настройка&nbsp;<i>auto</i>.&nbsp;Вызов&nbsp;
<i>defflow auto interrupt</i> равносилен использованию при вызове ключей командной строки .RS
<pre>-fa
</pre>

</dd></dl>
</dd></dl>

<br>&nbsp;и&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-i
</pre>

</dd></dl>

<p>
</p></dd><dt><b>defgr</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>gr</b>,&nbsp;но&nbsp;изменяет&nbsp;настройку&nbsp;в&nbsp;том&nbsp;числе&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;По&nbsp;умочанию,&nbsp;равна&nbsp;<i>off</i>.&nbsp;
</dd><dt><b>defhstatus</b> [<i>status</i>]

</dt><dd>
<br>

<br>&nbsp;Статусная&nbsp;строка&nbsp;(hardstatus)&nbsp;во&nbsp;всех&nbsp;новых&nbsp;окнах&nbsp;инициализируется&nbsp;строкой&nbsp;<i>status</i>.&nbsp;Команда&nbsp;нужна&nbsp;дла&nbsp;того&nbsp;чтобы&nbsp;
в окнах screen в строке состояний выводить номера окон, их заголовки и тому подобное. В строке статуса могут использоваться 
те же директивы, что и в сообщениях для окон, только в качестве escape-символа используется " .RS
<pre>^E
</pre>

</dd></dl>
</dd></dl>

" (восьмиричное 005) вместо "
<dl compact=""><dt></dt><dd>
<pre>%
</pre>

</dd></dl>

". Это сделано специально: чтобы уменьшить вероятность ошибочного распознавания сгенерированных программно статусных 
строк. Если параметр <i>status</i> не задан, показывается текущая строка статуса по умолчанию. По умолчанию hardstatus 
строка окон пустая. 
<dl compact="">
<dt><b>defencoding</b> <i>enc</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>encoding</b>,&nbsp;но&nbsp;изменяет&nbsp;настройку&nbsp;в&nbsp;том&nbsp;числе&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальная&nbsp;настройка&nbsp;берётся&nbsp;из&nbsp;свойств&nbsp;
терминала. 
</dd><dt><b>deflog</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>log</b>,&nbsp;но&nbsp;изменяет&nbsp;настройку&nbsp;в&nbsp;том&nbsp;числе&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;По&nbsp;умочанию,&nbsp;равна&nbsp;<i>off</i>.&nbsp;
</dd><dt><b>deflogin</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>login</b>,&nbsp;но&nbsp;изменяет&nbsp;настройку&nbsp;в&nbsp;том&nbsp;числе&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;По&nbsp;умочанию,&nbsp;равна&nbsp;<i>on</i>&nbsp;(см.&nbsp;config.h.in&nbsp;
в исходниках). 
</dd><dt><b>defmode</b> <i>mode</i>

</dt><dd>
<br>

<br>&nbsp;Режим&nbsp;доступа&nbsp;(права),&nbsp;которые&nbsp;устанавливаются&nbsp;для&nbsp;каждого&nbsp;нового&nbsp;псевдотерминала.&nbsp;Режим&nbsp;задаётся&nbsp;в&nbsp;виде&nbsp;восьмиричного&nbsp;
числа. По умолчанию 0622. 
</dd><dt><b>defmonitor</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>monitor</b>,&nbsp;но&nbsp;настройка&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Настройка&nbsp;по&nbsp;умолчанию:&nbsp;<i>off</i>.&nbsp;
<p>
</p></dd><dt><b>defnonblock</b> <i>on</i>|<i>off</i>|<i>numsecs</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>nonblock</b>,&nbsp;но&nbsp;настройка&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Настройка&nbsp;по&nbsp;умолчанию:&nbsp;<i>off</i>.&nbsp;
<p>
</p></dd><dt><b>defobuflimit</b> <i>limit</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>obuflimit</b>,&nbsp;но&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;настройка&nbsp;по&nbsp;умолчанию&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальное&nbsp;значение:&nbsp;
<i>256 байтов</i>. Если вы хотите, чтобы параметр зависел от типа терминала, вы можете использовать специальную возможность 
(capability) терминала, которая называется <i>OL</i>. 
</dd><dt><b>defscrollback</b> <i>num</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>scrollblock</b>,&nbsp;но&nbsp;изменяется&nbsp;в&nbsp;том&nbsp;числе&nbsp;и&nbsp;настройка&nbsp;по&nbsp;умолчанию&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальное&nbsp;значение:&nbsp;
<i>100</i>. 
</dd><dt><b>defshell</b> <i>command</i>

</dt><dd>
<br>

<br>&nbsp;Синоним&nbsp;команды&nbsp;<b>shell</b>.&nbsp;Смотрите&nbsp;эту&nbsp;команду.
<p>
</p></dd><dt><b>defsilence</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;<b>silence</b>,&nbsp;но&nbsp;изменяется&nbsp;настройка&nbsp;по&nbsp;умолчанию&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальное&nbsp;значение:&nbsp;<i>off</i>.&nbsp;
<p>
</p></dd><dt><b>defslowpaste</b> <i>msec</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;'''slowpaste'',&nbsp;только&nbsp;меняет&nbsp;настройку&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальная&nbsp;настройка:&nbsp;0&nbsp;мс,&nbsp;означающая&nbsp;''off''.&nbsp;
<p>
</p></dd><dt><b>defutf8</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;'''utf8'',&nbsp;только&nbsp;меняет&nbsp;настройку&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальная&nbsp;настройка:&nbsp;''off''&nbsp;или&nbsp;''on'',&nbsp;если&nbsp;screen&nbsp;
был запущен с ключом .RS
<pre>-U
</pre>

</dd></dl>
</dd></dl>

<p>
</p></dd><dt><b>defwrap</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;'''wrap'',&nbsp;только&nbsp;меняет&nbsp;настройку&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальная&nbsp;настройка&nbsp;''on'',&nbsp;может&nbsp;быть&nbsp;изменена&nbsp;
командой ''wrap'' ''on''|''off'' (или с помощью "C-a r"). 
</dd><dt><b>defwritelock</b> <i>on</i>|<i>off</i>|<i>auto</i>

</dt><dd>
<br>

<br>&nbsp;То&nbsp;же,&nbsp;что&nbsp;и&nbsp;команда&nbsp;'''writelock'',&nbsp;только&nbsp;меняет&nbsp;настройку&nbsp;для&nbsp;новых&nbsp;окон.&nbsp;Начальная&nbsp;настройка&nbsp;''off''.&nbsp;
</dd><dt><b>defzombie</b> [<i>keys</i>]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Синоним&nbsp;команды&nbsp;<b>zombie</b>.&nbsp;В&nbsp;настоящий&nbsp;момент&nbsp;обе&nbsp;они&nbsp;меняют&nbsp;настройки&nbsp;по&nbsp;умолчанию.&nbsp;Смотрите&nbsp;эту&nbsp;команду.&nbsp;
</dd><dt><b>detach</b> [<i>-h</i>]

</dt><dd>
<br>

<br>&nbsp;Отключить&nbsp;сеанс&nbsp;screen&nbsp;(отключить&nbsp;от&nbsp;терминала&nbsp;и&nbsp;отправить&nbsp;в&nbsp;фон).&nbsp;Происходит&nbsp;возврат&nbsp;в&nbsp;интерпретатор,&nbsp;из&nbsp;которого&nbsp;вызывался&nbsp;
screen. Отключенный screen можно восстановить при помощи опции .RS
<pre>-r
</pre>

</dd></dl>
</dd></dl>

<br>&nbsp;(см.&nbsp;"Опции&nbsp;командной&nbsp;строки").&nbsp;Опция&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-h
</pre>

</dd></dl>

<br>&nbsp;говорит,&nbsp;что&nbsp;нужно&nbsp;разорвать&nbsp;соединение&nbsp;с&nbsp;терминалом&nbsp;(hangup).
<p>
</p></dd><dt><b>dinfo</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Показывает,&nbsp;что&nbsp;screen&nbsp;думает&nbsp;о&nbsp;вашем&nbsp;терминале.&nbsp;Может&nbsp;пригодится,&nbsp;если&nbsp;нужно&nbsp;узнать&nbsp;почему&nbsp;не&nbsp;работают&nbsp;цвет&nbsp;или&nbsp;альтернативная&nbsp;
кодировка. 
</dd><dt><b>displays</b>

</dt><dd>
<br>

<br>&nbsp;Показывает&nbsp;таблицу&nbsp;с&nbsp;списком&nbsp;подключенных&nbsp;в&nbsp;настоящиё&nbsp;момент&nbsp;пользователей.&nbsp;Очень&nbsp;полезная&nbsp;команда&nbsp;для&nbsp;многопользовательского&nbsp;
режима работы GNU Screen. 
</dd><dt><b>digraph</b> [<i>preset</i>]

</dt><dd>
<br>

<br>&nbsp;Ввести&nbsp;диграф.&nbsp;Выдаётся&nbsp;приглашение&nbsp;пользователю&nbsp;для&nbsp;ввода&nbsp;двухсимвольной&nbsp;последовательности.&nbsp;По&nbsp;введённым&nbsp;двум&nbsp;символам&nbsp;
в встроенной таблице ищется диграф, найденный символ вставляется в окно. Например, если ввести .RS
<pre>a:
</pre>

</dd></dl>
</dd></dl>

, будет вставлен a-умляут. Если первый символ это 0 (ноль), screen будет рассматривать следующие символы как восьмеричное 
число. Опциональный аргумент <i>preset</i> рассматривается как обозначение нажатого символа, т.е. с его помощью можно 
сделать, например, умляут-клавишу.  Если сделать привяку " .RS
<pre>bindkey ^K digraph :
</pre>


", пользователь сможет вводить а-умляют при помощи комбинации Ctrl-K a.
<p>
</p></dd><dt><b>dumptermcap</b>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Сохранить&nbsp;записи&nbsp;termcap&nbsp;для&nbsp;текущего&nbsp;окна&nbsp;в&nbsp;.termcap-файл&nbsp;в&nbsp;каталог&nbsp;
<dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<br>&nbsp;в&nbsp;домашнем&nbsp;каталоге&nbsp;пользователя&nbsp;&nbsp;"
<dl compact=""><dt></dt><dd>
<pre>$HOME/.screen
</pre>

</dd></dl>

" (или в другой каталог, где screen хранит свои сокеты. См. раздел "Файлы").  Эта запись termcap идентична значению переменной 
<dl compact=""><dt></dt><dd>
<pre>$TERMCAP
</pre>

</dd></dl>

, которую screen устанавливает для каждого окна. Для систем с terminfo нужно будет запускать конвертер наподобие <b>captoinfo</b>, 
а потом компилировать запись при помощи <b>tic</b>. .RE
<p>
</p><dl compact="">
<dt><b>echo</b> [-n] <i>message</i>

</dt><dd>
<br>

<br>&nbsp;Команда&nbsp;может&nbsp;использоваться&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;распространять&nbsp;"сообщение&nbsp;дня".&nbsp;Обычно&nbsp;её&nbsp;добавляют&nbsp;в&nbsp;
<dl compact=""><dt></dt><dd>
<pre>/etc/screenrc
</pre>

</dd></dl>

<br>&nbsp;При&nbsp;вызове&nbsp;с&nbsp;ключом&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-n
</pre>

</dd></dl>

<br>&nbsp;конечный&nbsp;перевод&nbsp;строки&nbsp;не&nbsp;выводится.&nbsp;См.&nbsp;также&nbsp;<i>sleep</i>.&nbsp;Ещё&nbsp;может&nbsp;пригодиться&nbsp;для&nbsp;online-проверки&nbsp;переменных&nbsp;
окружения. 
</dd><dt><b>encoding</b> <b>enc</b> [<i>enc</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Говорит&nbsp;screen&nbsp;как&nbsp;интерпретировать&nbsp;ввод/вывод.&nbsp;Первый&nbsp;аргумент&nbsp;устанавливает&nbsp;кодироку&nbsp;текущего&nbsp;окна.&nbsp;Каждое&nbsp;окно&nbsp;
может эмулировать отдельную кодировку. Второй опциональный параметр перебивает кодировку присоединённого терминала. 
Обычно этот параметр не нужен, потому что screen может определить кодировку из настроек локали. Можно ещё выбирать кодировку 
терминала в зависимости от типа терминала, с помощью записи " .RS
<pre>KJ
</pre>

</dd></dl>

" в termcap.
</dd></dl>
</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Поддерживаются&nbsp;кодировки&nbsp;eucJP,&nbsp;SJIS,&nbsp;eucKR,&nbsp;eucCN,&nbsp;Big5,&nbsp;&nbsp;GBK,&nbsp;&nbsp;KOI8-R,&nbsp;CP1251,&nbsp;&nbsp;UTF-8,&nbsp;&nbsp;ISO8859-2,&nbsp;ISO8859-3,&nbsp;ISO8859-4,&nbsp;
ISO8859-5, ISO8859-6, ISO8859-7, ISO8859-8, ISO8859-9, ISO8859-10, ISO8859-15, jis. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;См.&nbsp;также&nbsp;"defencoding",&nbsp;который&nbsp;меняет&nbsp;настройки&nbsp;по&nbsp;умолчанию&nbsp;для&nbsp;новых&nbsp;окон.
</dd></dl>

<p>
</p><dl compact="">
<dt><b>escape</b> <i>xy</i>

</dt><dd>
<br>

<br>&nbsp;Устанавливает&nbsp;управляющий&nbsp;символ&nbsp;равным&nbsp;x&nbsp;(похоже&nbsp;на&nbsp;опцию&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-e
</pre>

</dd></dl>

), а символ генерирующий литерал управляющего символа равным y. Каждый параметр (x и y) это или отдельный символ, или два 
символа в форме "^x" (обозначает "C-x"), или обратный слэш, за которым идёт восьмеричное число (ASCII-код символа), 
или обратный слэш за которым идёт ещё один символ (например, .RS
<pre>\^
</pre>

</dd></dl>
</dd></dl>

<br>&nbsp;или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>\\
</pre>

</dd></dl>

). По умолчанию "
<dl compact=""><dt></dt><dd>
<pre>^Aa
</pre>

</dd></dl>

".
<p>
</p></dd><dt><b>eval</b> <i>command1</i> [<i>command2</i> ...]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разбирает&nbsp;и&nbsp;выполняет&nbsp;каждый&nbsp;аргумент&nbsp;как&nbsp;отдельную&nbsp;команду.
<p>
</p></dd><dt><b>exec</b> <i>fdpat</i>] <i>newcommand</i> [<i>args</i> ...

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Запускает&nbsp;подпроцесс&nbsp;UNIX&nbsp;(соответствующий&nbsp;<i>newcommand</i>&nbsp;и&nbsp;её&nbsp;аргументам)&nbsp;в&nbsp;текущем&nbsp;окне.&nbsp;&nbsp;Соединение&nbsp;потоков&nbsp;(atdin/stdout/stderr)&nbsp;
команды <i>newcommand</i>,  процесса, работающего в окне, и собственно screen определяется шаблоном <i>fdpat</i>.  Шаблон 
<i>fdpat</i> это фактически трёхсимвольная последовательность, представляющая стандартный поток ввода, стандартный 
поток вывода и стандартный поток ошибок команды <i>newcommand</i>.  Символ <i>точка</i> (.) подсоединяет файловый дескриптор 
к screen.  Символ <i>восклицательный знак</i> (!) говорит о том, что файловый дескриптор должен быть присоединён к приложению. 
<br>&nbsp;Символ&nbsp;<i>двоеточие</i>&nbsp;(:)&nbsp;сочетает&nbsp;в&nbsp;себе&nbsp;действие&nbsp;двух&nbsp;предыдущих.&nbsp;&nbsp;Данные,&nbsp;которые&nbsp;вводятся&nbsp;пользователем,&nbsp;передаются&nbsp;
новой команде за исключением тех случаев, когда она подключена к потоку вывода приложения, работающего в окне (первый 
символ <i>fdpats</i> это .RS
<pre>!
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>:
</pre>

</dd></dl>

), и когда в конце <i>fdpat</i> стоит символ канала (|).  Если вызывать <i>exec</i> без аргументов, будут показаны именя и 
аргументы процессов, работающих в текущем окне.  В каждом окне за раз может исполняться только один подпроцесс.  Если подпроцесс 
работает, команда <i>kill</i> подействует на него, а не на процесс, работающий в окне.  В файле .RS
<pre>doc/fdpat.ps
</pre>


<br>&nbsp;проиллюстрированы&nbsp;все&nbsp;21&nbsp;комбинация&nbsp;соединений.&nbsp;На&nbsp;каждом&nbsp;рисунке&nbsp;есть&nbsp;цифры&nbsp;2,1,0&nbsp;соответствующие&nbsp;трём&nbsp;файловым&nbsp;дескрипторам&nbsp;
команды <i>newcomand</i>. Прямоугольник <i>W</i> это псевдотерминал, к которому с подчинённой стороны (slave side) подключено 
приложение.  Прямоугольник <i>P</i> это вторичный псевдотерминал, к которому с главной стороны (master side) подключен 
screen. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Сокращения:
<p>
<br>

<br>&nbsp;Пробелы&nbsp;между&nbsp;словом&nbsp;<i>exec</i>&nbsp;и&nbsp;<i>fdpat</i>&nbsp;можно&nbsp;пропустить.&nbsp;&nbsp;Точки&nbsp;в&nbsp;конце&nbsp;<i>fdpat</i>&nbsp;писать&nbsp;не&nbsp;обязательно;&nbsp;<i>fdpat</i>,&nbsp;
состоящий из одних только точек, писать не обязательно.  Символ " .RS
</p><pre>|
</pre>

</dd></dl>

" это синоним для шаблона "!..|"; cлово <i>exec</i> в данном случае писать не обязательно, вместо него можно указать символ 
<dl compact=""><dt></dt><dd>
<pre>!
</pre>

</dd></dl>

<p>

</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Примеры:
</dd></dl>

<dl compact=""><dt></dt><dd>
<pre>    exec ... /bin/sh
    exec /bin/sh
    !/bin/sh

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Создаёт&nbsp;новый&nbsp;интерпретатор,&nbsp;в&nbsp;то&nbsp;время&nbsp;как&nbsp;первый&nbsp;продолжает&nbsp;работать.&nbsp;&nbsp;Вывод&nbsp;обоих&nbsp;интерпретаторов&nbsp;попадает&nbsp;в&nbsp;окно,&nbsp;
а ввод отправляется новому интерпретатору. .RE
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    exec !.. stty 19200
    exec ! stty 19200
    !!stty 19200

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Устанавливается&nbsp;скорость&nbsp;терминала&nbsp;окна.&nbsp;Если&nbsp;программа&nbsp;<b>stty</b>&nbsp;работает&nbsp;со&nbsp;стандартным&nbsp;потоком&nbsp;ввода,&nbsp;добавьте&nbsp;
ещё один знак " .RS
<pre>!
</pre>

</dd></dl>

".
</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    exec !..| less
    |less

</pre>

</dd></dl>

К выводу подключается pager. Специальный символ "|" нужен для того чтобы дать пользователю возможность управлять этим 
пейджером, несмотря на то, что данные он получает от процесса, работающего в окне.  Это работает, потому что less слушает 
стандартный поток ошибок (поведение, которое screen не ожидал бы без символа " .RS
<pre>|
</pre>


") когда стандартный поток ввода не терминал.  <b>Less</b> новее чем версия 177 будет сбоить; а старый добрый <b>pg</b> работает. 
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    !:sed -n s/.*Error.*/\007/p

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Отправляет&nbsp;вывод&nbsp;на&nbsp;экран&nbsp;пользователю&nbsp;и&nbsp;на&nbsp;вход&nbsp;команде&nbsp;<b>sed</b>.&nbsp;Команда&nbsp;вставляет&nbsp;дополнительный&nbsp;символ&nbsp;звонка&nbsp;(восьмиричное&nbsp;
007) в вывод screen. Поэтому при каждом появлении на экране слова "Error" в строку статуса выводится сообщение " .RS
<pre>Bell in window x
</pre>

</dd></dl>

". 

<p>
</p></dd><dt><b>fit</b>

</dt><dd>
<br>

<br>&nbsp;Изменить&nbsp;размер&nbsp;текущего&nbsp;размера&nbsp;под&nbsp;текущую&nbsp;область.&nbsp;Команда&nbsp;может&nbsp;пригодиться,&nbsp;когда&nbsp;screen&nbsp;не&nbsp;перестраивает&nbsp;размер&nbsp;
окна, когда оно показывается больше чем один раз. 
</dd><dt><b>flow</b> [<i>on</i>|<i>off</i>|<i>auto</i>]

</dt><dd>
<br>

<br>&nbsp;Настроить&nbsp;режим&nbsp;управления&nbsp;потоком&nbsp;окна.&nbsp;При&nbsp;вызове&nbsp;без&nbsp;параметров&nbsp;команда&nbsp;циклически&nbsp;переключает&nbsp;настройки&nbsp;<i>auto</i>,&nbsp;
<i>on</i>, <i>off</i>. Подробнее в разделе "Flow-control". Имейте в виду, что это настройка может поменяться в будущих 
выпусках screen. Настройка по умолчанию задаётся при помощи <i>defflow</i>. 
</dd><dt><b>focus</b> [<i>up</i>|<i>down</i>|<i>top</i>|<i>bottom</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Переместить&nbsp;фокус&nbsp;ввода&nbsp;на&nbsp;следующих&nbsp;регион.&nbsp;Выполняется&nbsp;циклически,&nbsp;поэтому&nbsp;верхний&nbsp;регион&nbsp;выбирается&nbsp;после&nbsp;самого&nbsp;
нижнего. Если подкоманда не задана, подразумевается <i>down</i>. Подкоманда <i>up</i> перемещает фокус в противоположном 
порядке, а <i>top</i> и <i>bottom</i> переводят фокус на самый верхний или самый нижний регион. Полезные привязки .RE
(
<dl compact=""><dt></dt><dd>
<pre>j
</pre>

</dd></dl>

<br>&nbsp;и&nbsp;
<dl compact=""><dt></dt><dd>
<pre>k
</pre>

</dd></dl>

<br>&nbsp;как&nbsp;в&nbsp;vi)
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bind j focus down
    bind k focus up
    bind t focus top
    bind b focus bottom

</pre>

</dd></dl>

<dl compact="">
<dt><b>gr</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Включает/выключает&nbsp;GR-переключение&nbsp;(GR&nbsp;charset&nbsp;switching).&nbsp;Когда&nbsp;screen&nbsp;встречает&nbsp;8-битный&nbsp;символ,&nbsp;он&nbsp;использует&nbsp;
charset записанный в GR-слоте и выводит символ с удалённым восьмым битом. По умолчанию (см. также <i>defgr</i>)  GR не обрабатываются, 
потому что иначе символы ISO88591 перестанут работать. .RE
<p>
</p><dl compact="">
<dt><b>hardcopy</b> [<i>-h</i>] [<i>file</i>]

</dt><dd>
<br>

<br>&nbsp;Записывает&nbsp;изображение&nbsp;текущего&nbsp;терминала&nbsp;в&nbsp;файл&nbsp;<i>file</i>&nbsp;или,&nbsp;если&nbsp;имя&nbsp;файла&nbsp;не&nbsp;задано,&nbsp;в&nbsp;файл&nbsp;
<dl compact=""><dt></dt><dd>
<pre>hardcopy.n
</pre>

</dd></dl>

<br>&nbsp;в&nbsp;текущем&nbsp;каталоге,&nbsp;где&nbsp;<i>n</i>&nbsp;---&nbsp;это&nbsp;номер&nbsp;текущего&nbsp;окна.&nbsp;Файл&nbsp;или&nbsp;дописывается&nbsp;или&nbsp;переписывается&nbsp;сверху&nbsp;(см.&nbsp;ниже).&nbsp;
Если указан ключ -h, скидывается и содержимое буфера прокрутки. 
</dd><dt><b>hardcopy_append</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Если&nbsp;включено&nbsp;(<i>on</i>),&nbsp;screen&nbsp;будет&nbsp;дописывать&nbsp;файлы&nbsp;созданные&nbsp;по&nbsp;нажатию&nbsp;"C-a&nbsp;h"&nbsp;в&nbsp;конец&nbsp;файла&nbsp;.RS
<pre>hardcopy.n
</pre>

</dd></dl>
</dd></dl>

, в противном случае он будет переписываться сверху. По умолчанию: <i>off</i>.
<p>
</p></dd><dt><b>hardcopydir</b> <i>directory</i>

</dt><dd>
<br>

<br>&nbsp;Определяет&nbsp;каталог,&nbsp;в&nbsp;котором&nbsp;будет&nbsp;размешён&nbsp;hardcopy-файл.&nbsp;Если&nbsp;не&nbsp;задан,&nbsp;файлы&nbsp;будут&nbsp;размещаться&nbsp;в&nbsp;текущем&nbsp;каталоге&nbsp;
программы screen. 
</dd><dt><b>hardstatus</b> [<i>on</i>|<i>off</i>]

</dt><dd>
</dd><dt><b>hardstatus</b> [<i>always</i>]<i>lastline</i>|<i>message</i>|<i>ignore</i> [<i>string</i>]

</dt><dd>
</dd><dt><b>hardstatus</b> <i>string</i> [<i>string</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Команда&nbsp;настраивает&nbsp;использование&nbsp;или&nbsp;эмуляцию&nbsp;hardstatus-строки&nbsp;терминала.&nbsp;Первая&nbsp;форма&nbsp;переключает&nbsp;использование&nbsp;
аппаратной  статусной строки (hardware status line) для отображения сообщений. Если флаг установлен в <i>off</i>, сообщения 
выводятся в реверсивном видео на экране. Настройка по умолчанию: <i>on</i>. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Вторая&nbsp;форма&nbsp;говорит&nbsp;screen&nbsp;что&nbsp;делать&nbsp;в&nbsp;том&nbsp;случае,&nbsp;когда&nbsp;у&nbsp;терминала&nbsp;нет&nbsp;строки&nbsp;<i>hardstatus</i>&nbsp;(то&nbsp;есть,&nbsp;в&nbsp;termcap/terminfo&nbsp;
не установлены "hs", "ts","fs" и "ds"). Если используется тип <i>lastline</i>, screen резервирует последнюю строку экрана 
для строки статуса; тип <i>message</i> говорит screen о том, что надо использовать механизм сообщений screen и <i>ignore</i> 
-- что нужно не показывать hardstatus вообще. Если добавить слово <i>always</i> перед типом строки, screen будет использовать 
его даже в том случае, если терминал поддерживает hardstatus. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Последняя&nbsp;форма&nbsp;описывает&nbsp;содержимое&nbsp;строки&nbsp;hardstatus.&nbsp;По&nbsp;умолчанию&nbsp;используется&nbsp;строка&nbsp;"%h",&nbsp;т.е.&nbsp;показывается&nbsp;статус&nbsp;
текущего окна (устанавливается строками " .RS
<pre>ESC]0;&lt;string&gt;^G
</pre>

</dd></dl>

" или "
<dl compact=""><dt></dt><dd>
<pre>ESC_&lt;string&gt;ESC\
</pre>

</dd></dl>

"). Можно настроить строку как угодно, для этого нужно использовать Escape-последовательности (см. раздел "Escape-последовательности"). 
Если вызвать команду без аргументов, будет показана текущая настройка. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Можно&nbsp;смешивать&nbsp;вторую&nbsp;и&nbsp;третью&nbsp;формы&nbsp;---&nbsp;задавать&nbsp;строку&nbsp;как&nbsp;дополнительный&nbsp;аргумент&nbsp;или&nbsp;нет.
</dd></dl>

<p>
</p><dl compact="">
<dt><b>height</b> [-w|-d] [<i>lines</i> [<i>cols</i>]]

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;высоту&nbsp;отображения&nbsp;равной&nbsp;количеству&nbsp;строк&nbsp;<i>lines</i>.&nbsp;Когда&nbsp;аргумент&nbsp;не&nbsp;задан,&nbsp;выполняется&nbsp;переключение&nbsp;между&nbsp;
24 и 42 строками. Можно определить и ширину, если нужно изменить оба значения. Опция .RS
<pre>-w
</pre>

</dd></dl>
</dd></dl>

<br>&nbsp;говорит,&nbsp;что&nbsp;нужно&nbsp;оставить&nbsp;размер&nbsp;экрана&nbsp;неизменным&nbsp;и&nbsp;менять&nbsp;только&nbsp;размер&nbsp;окна,&nbsp;а&nbsp;опция&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-d
</pre>

</dd></dl>

<br>&nbsp;наоборот.
<p>
</p><dl compact="">
<dt><b>help</b> [-c <i>class</i>]

</dt><dd>
<br>

<br>&nbsp;Не&nbsp;совсем&nbsp;помощь,&nbsp;а&nbsp;просто&nbsp;картинка&nbsp;со&nbsp;списком&nbsp;комбинаций&nbsp;клавиш.&nbsp;На&nbsp;первой&nbsp;странице&nbsp;показаны&nbsp;все&nbsp;внутренние&nbsp;команды&nbsp;и&nbsp;
их текущие привязки. На последующих страницах показаны пользовательские привязки, по одной команде на одну комбинацию. 
Пробел переходит к следующей странице; enter -- завершает просмотр. Все остальные символы игнорируются. Если задана 
опция .RS
<pre>-c
</pre>

</dd></dl>
</dd></dl>

, выводится список всех команд указанного класса <i>class</i>. См. также раздел "Привязка клавиш".
<p>
</p></dd><dt><b>history</b>

</dt><dd>
<br>

<br>&nbsp;В&nbsp;командных&nbsp;интерпретаторах&nbsp;легко&nbsp;посмотреть&nbsp;или&nbsp;использовать&nbsp;вызванные&nbsp;ранее&nbsp;команды.&nbsp;Например,&nbsp;в&nbsp;csh&nbsp;есть&nbsp;.RS
<pre>!!
</pre>

</dd></dl>
</dd></dl>

, которая повторяет последнюю вызванную команду. В screen есть простой механизм вызова команд, начинающихся с определённой 
последовательности: нужно набрать интересующую последовательность, почле чего нажать "C-a {" и screen попытается 
найти строку, начинающуюся с текста слева от курсора (с символом приглашения, приглашение character).  Найденная строка 
вставляется в окно. Этот механизм может использоваться как грубая замена механизма истории в командном интерпретаторе 
(в историю подставляются варианты как из видимой части окна, так и из буфера прокрутки). 
</dd><dt><b>hstatus</b> <i>status</i>

</dt><dd>
<br>

<br>&nbsp;Изменить&nbsp;строку&nbsp;статуса&nbsp;окна&nbsp;на&nbsp;status
<p>
</p></dd><dt><b>idle</b> [<i>timeout</i> [<i>cmd</i> <i>args</i>]]

</dt><dd>
<br>

<br>&nbsp;Указывает&nbsp;команды,&nbsp;которая&nbsp;запускается&nbsp;после&nbsp;того&nbsp;как&nbsp;проходит&nbsp;заданное&nbsp;количество&nbsp;секунд&nbsp;без&nbsp;активности.&nbsp;Обычно&nbsp;в&nbsp;качестве&nbsp;
команды указывается команда <i>blanker</i>, которая вызывает хранитель экрана screen. Если команда не задана, определяется 
только величина таймаута. Таймаут равный нулю (или специальное слово <i>off</i>) отключает таймер вообще. Если аргументы 
не заданы, показывается текущая настройка. 
</dd><dt><b>ignorecase</b> [on|off]

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Говорит&nbsp;screen,&nbsp;что&nbsp;нужно&nbsp;игнорировать&nbsp;регистр&nbsp;символа&nbsp;при&nbsp;поиске.&nbsp;По&nbsp;умолчанию&nbsp;выключено.
<p>
</p></dd><dt><b>info</b>

</dt><dd>
<br>

<br>&nbsp;Выводит&nbsp;информацию&nbsp;о&nbsp;текущем&nbsp;окне:&nbsp;позиция&nbsp;курсора&nbsp;в&nbsp;форме&nbsp;&nbsp;"(column,row)",&nbsp;начиная&nbsp;с&nbsp;"(1,1)",&nbsp;&nbsp;ширина&nbsp;и&nbsp;высота&nbsp;терминала&nbsp;
плюс размер буфера прокрутки в строках, например "(80,24)+50",  текущее состояние управления потоком (flow control) 
окна XON/XOFF, показанное в виде (см. также раздел "Flow Control"): 
<dl compact=""><dt></dt><dd>
<pre>    +flow     автоматический контроль потока (automatic flow control), включен
    -flow     автоматический контроль потока (automatic flow control), выключен
    +(+)flow  контроль потока включен. Совпадает с автоматическим контролем потока
    -(+)flow  контроль потока выключен. Не совпадает с автоматическим контролем потока
    +(-)flow  контроль потока включен. Не совпадает с автоматическим контролем потока
    -(-)flow  контроль потока выключен. Совпадает с автоматическим контролем потока

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Показываются&nbsp;настройки&nbsp;переноса&nbsp;("
<dl compact=""><dt></dt><dd>
<pre>+wrap
</pre>

</dd></dl>

" говорит, что перенос включён; "
<dl compact=""><dt></dt><dd>
<pre>-wrap
</pre>

</dd></dl>

" говорит, что перенос выключен).
</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Флаги&nbsp;"ins",&nbsp;"org",&nbsp;"app",&nbsp;"log",&nbsp;"mon"&nbsp;или&nbsp;"nored"&nbsp;показываются&nbsp;в&nbsp;том&nbsp;случае,&nbsp;если&nbsp;окно&nbsp;находится&nbsp;в&nbsp;режиме&nbsp;вставки&nbsp;(insert),&nbsp;
исходном (origin),  приложения (application-keypad), если в нём включена журнализация вывода (output logging), мониторинг 
активности (activity monitoring) или частичная отрисовка (partial redraw). .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Показываются&nbsp;активный&nbsp;набор&nbsp;символов&nbsp;(character&nbsp;set;&nbsp;G0,&nbsp;G1,&nbsp;G2&nbsp;или&nbsp;G3)&nbsp;и&nbsp;в&nbsp;квадратных&nbsp;скобках&nbsp;символы&nbsp;терминала,&nbsp;которые&nbsp;
выделены для G0-G3. Если окно в режиме UTF-8, вместо всего этого показывается строка .RS
<pre>UTF-8
</pre>

</dd></dl>

<p>
</p></dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;В&nbsp;конце&nbsp;строки&nbsp;статуса&nbsp;выводятся&nbsp;дополнительные&nbsp;режимы&nbsp;(см.&nbsp;также&nbsp;"Типы&nbsp;окон").&nbsp;Если&nbsp;машина&nbsp;состояний&nbsp;эмулятора&nbsp;терминала&nbsp;
находится не в нормальном состоянии, строка info начинается со строки, идентифицирующей текущее состояние. Для получения 
системной информации используется команда <i>time</i>. .RE
<p>
</p><dl compact="">
<dt><b>ins_reg</b> [<i>key</i>]

</dt><dd>
<br>

<br>&nbsp;Больше&nbsp;не&nbsp;существует.&nbsp;Используйте&nbsp;<i>paste</i>
<p>
</p></dd><dt><b>kill</b>

</dt><dd>
<br>

<br>&nbsp;Завершает&nbsp;текущее&nbsp;окно.&nbsp;Если&nbsp;выполняется&nbsp;команда&nbsp;
<dl compact=""><dt></dt><dd>
<pre>exec
</pre>

</dd></dl>

, она завершается. Если нет, процесс (командный интерпретатор), работающий в окне, получает сигнал HANGUP, структура 
окна удаляется и screen переключается на другое окно. Когда последнее окно закрывается, screen завершает свою работу. 
После закрытия окна screen переключается на окно, которое отображалось до того. .br
<br>&nbsp;Замечание:&nbsp;Пользователи&nbsp;Emacs&nbsp;(да&nbsp;и&nbsp;не&nbsp;только&nbsp;Emacs,&nbsp;но&nbsp;и&nbsp;других&nbsp;программ&nbsp;имитирующих&nbsp;интерфейс&nbsp;Emacs,&nbsp;в&nbsp;частности&nbsp;bash)&nbsp;
должны помнить об этой команде, когда удаляются текст до конца строки. Или лучше не использовать "C-a" как escape-последовательность 
или привязать kill на "C-a K". 
</dd><dt><b>lastmsg</b>

</dt><dd>
<br>

<br>&nbsp;Повторно&nbsp;показать&nbsp;содержимое&nbsp;статусной&nbsp;строки.&nbsp;Полезно,&nbsp;когда&nbsp;вы&nbsp;случайно&nbsp;сбили&nbsp;сообщение&nbsp;при&nbsp;наборе&nbsp;(сообщение&nbsp;пропадает,&nbsp;
если нажать любую клавишу), а потом хотите его посмотреть. См. также <i>msgwait</i> и <i>msgminwait</i> (тонкая настройка 
режима показа сообщения). 
</dd><dt><b>license</b>

</dt><dd>
<br>

<br>&nbsp;Показать&nbsp;страницу-disclaimer.&nbsp;Она&nbsp;показывается&nbsp;при&nbsp;запуске&nbsp;screen&nbsp;без&nbsp;опций,&nbsp;что&nbsp;происходит&nbsp;достаточно&nbsp;часто.&nbsp;См.&nbsp;
также команду <i>startup_message</i>. 
</dd><dt><b>lockscreen</b>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Блокирует&nbsp;дисплей.&nbsp;Вызывается&nbsp;специальную&nbsp;программу&nbsp;блокировки&nbsp;(
<dl compact=""><dt></dt><dd>
<pre>/local/bin/lck
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>/usr/bin/lock
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;встроенную,&nbsp;если&nbsp;других&nbsp;нет).&nbsp;Screen&nbsp;не&nbsp;обрабатывает&nbsp;никакие&nbsp;клавиши&nbsp;и&nbsp;комбинации&nbsp;клавиш&nbsp;до&nbsp;тех&nbsp;пор&nbsp;пока&nbsp;эта&nbsp;программа&nbsp;
не завершится. Тем временем исполнение процессов в окнах может продолжаться, а сами окна находятся в отключённом (detached) 
состоянии. Программу screenlock можно укзать при помощи переменной .RS
<pre>$LOCKPRG
</pre>

</dd></dl>

, которая устанавливается в интерпретаторе, из которого вызывается screen. Программа выполняется от имени и с правами 
пользователя, который выполняет screen. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Предупреждение:&nbsp;если&nbsp;вы&nbsp;оставляете&nbsp;другие&nbsp;оболочки&nbsp;разблокированными&nbsp;и&nbsp;на&nbsp;screen&nbsp;не&nbsp;стоит&nbsp;пароль,&nbsp;толку&nbsp;от&nbsp;блокировки&nbsp;
никакого. Можно легко подключиться к screen из другой оболочки. Правильонее было бы назвать эту фукнцию "lockterminal". 
</dd></dl>

<p>
</p></dd><dt><b>log</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<br>

<br>&nbsp;Начинает/останавливает&nbsp;запись&nbsp;журнала&nbsp;действий&nbsp;в&nbsp;текущем&nbsp;окне&nbsp;в&nbsp;файл&nbsp;
<dl compact=""><dt></dt><dd>
<pre>screenlog.n
</pre>

</dd></dl>

<br>&nbsp;в&nbsp;текущем&nbsp;каталоге&nbsp;окна&nbsp;(где&nbsp;<i>n</i>&nbsp;--&nbsp;номер&nbsp;текущего&nbsp;окна).&nbsp;Имя&nbsp;файла&nbsp;можно&nbsp;изменить&nbsp;при&nbsp;помощи&nbsp;команды&nbsp;<i>logfile</i>.&nbsp;
Если команда вызывается без парамеров, состояние переключается на противоположное. Журнал дописывается в конец файла 
(если файл уже есть). Текущее состояние экрана и буфер прокрутки не включаются в журнал. По умолчанию: <i>off</i>. 
</dd><dt><b>logfile</b> <i>filename</i>

</dt><dd>
</dd><dt><b>logfile</b> <i>flush</i> <i>secs</i>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Определяет&nbsp;имя&nbsp;файла&nbsp;журнала.&nbsp;По&nbsp;умолчанию&nbsp;"screenlog.%n".&nbsp;Вторая&nbsp;форма&nbsp;определяет&nbsp;количество&nbsp;секунд,&nbsp;которые&nbsp;screen&nbsp;
будет ждать прежде чем сбросить буфер файла журнала на диск. По умолчанию 10 секунд. .RE
<p>
</p><dl compact="">
<dt><b>login</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Добавляет&nbsp;или&nbsp;удаляет&nbsp;запись&nbsp;в&nbsp;базе&nbsp;данных&nbsp;utmp&nbsp;для&nbsp;текущего&nbsp;окна.&nbsp;Фактически,&nbsp;регистрирует&nbsp;(log&nbsp;in)&nbsp;окно.&nbsp;При&nbsp;вызове&nbsp;без&nbsp;
параметров переключается состояние (регистрирует/разрегистрирует). Помимо этого, удобно когда есть комбинации клавиш 
для регистрации и разрегистрации. Например, " .RS
<pre>bind I login on
</pre>

</dd></dl>

" и "
<dl compact=""><dt></dt><dd>
<pre>bind O login off
</pre>

</dd></dl>

" привязывают эти действия
</dd></dl>
</dd></dl>

к "C-a I" и "C-a O". Настройка по умолчанию (в 
<dl compact=""><dt></dt><dd>
<pre>config.h.in
</pre>

</dd></dl>

) должна быть <i>on</i> для окон, наботающих с установленным битом suid-root. Состояние "по умолчанию" для новых окон 
задаётся при помощи команды <i>deflogin</i>. Обе команды есть только в том случае, если screen откомпилирован с поддержкой 
utmp. 
</dd><dt><b>logtstamp</b> [<i>on</i>|<i>off</i>]

</dt><dd>
</dd><dt><b>logtstamp</b> <b>after</b> [<i>secs</i>]

</dt><dd>
</dd><dt><b>logtstamp</b> <b>string</b> [<i>string</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Команда&nbsp;управляет&nbsp;временными&nbsp;метками&nbsp;в&nbsp;файле-журнале&nbsp;(logfile).&nbsp;Если&nbsp;временные&nbsp;метки&nbsp;включены,&nbsp;после&nbsp;двух&nbsp;минут&nbsp;без&nbsp;
активности screen выводит в журнал строку, содержащую текущее время. Когда вывод продолжается больше двух минут, добавляется 
второй вывод (When output  continues  и  more  than another two minutes have passed).  Величину таймаута можно изменить с помощью 
второй формы команды.  Третья форма предназначена для настройки формата строки временных меток (по умолчанию " .RS
<pre>-- %n:%t -- time-stamp  -- %M/%d/%y %c:%s --\n
</pre>

</dd></dl>

").
</dd></dl>
</dd></dl>

<p>
</p></dd><dt><b>mapdefault</b>

</dt><dd>
<br>

<br>&nbsp;Говорит&nbsp;screen&nbsp;о&nbsp;том,&nbsp;что&nbsp;следующий&nbsp;символ&nbsp;он&nbsp;должен&nbsp;искать&nbsp;в&nbsp;стандартной&nbsp;таблице&nbsp;привязки&nbsp;клавиш.&nbsp;См.&nbsp;также&nbsp;<i>bindkey</i>.&nbsp;
<p>
</p></dd><dt><b>mapnotnext</b>

</dt><dd>
<br>

<br>&nbsp;Как&nbsp;<b>mapdefault</b>,&nbsp;но&nbsp;не&nbsp;смотреть&nbsp;таблицу&nbsp;bindkey&nbsp;
<p>
</p></dd><dt><b>maptimeout</b> [<i>timo</i>]

</dt><dd>
<br>

<br>&nbsp;Задержка&nbsp;между&nbsp;симолами&nbsp;(в&nbsp;мс)&nbsp;при&nbsp;распознавании&nbsp;входных&nbsp;последовательностей.&nbsp;По&nbsp;умолчанию&nbsp;300мс.&nbsp;При&nbsp;вызове&nbsp;без&nbsp;аргументов&nbsp;
показывает текущую настройку. См. также <i>bindkey</i>. 
</dd><dt><b>markkeys</b> <i>string</i>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Изменить&nbsp;привязку&nbsp;клавиш&nbsp;для&nbsp;режима&nbsp;копирования/истории.&nbsp;Строка&nbsp;<i>string</i>&nbsp;состоит&nbsp;из&nbsp;пар&nbsp;
<dl compact=""><dt></dt><dd>
<pre>oldchar=newchar
</pre>

</dd></dl>

, разделённых двоеточиями.
<p>
<br>

<br>&nbsp;Пример:&nbsp;Строка&nbsp;"B=^B:F=^F"&nbsp;меняет&nbsp;привязку&nbsp;клавиш&nbsp;"C-b"&nbsp;и&nbsp;"C-f"&nbsp;на&nbsp;привязку&nbsp;в&nbsp;стиле&nbsp;vi&nbsp;(прокрутка&nbsp;вверх/вниз).&nbsp;&nbsp;По&nbsp;умолчанию&nbsp;
это привязка для клавиш <i>B</i> и <i>F</i>.  Команда " .RS
</p><pre>markkeys h=^B:l=^F:$=^E
</pre>

</dd></dl>

" меняет привязку клавиш на привязку в стиле GNU Emacs.  Если терминал отправляет символы, они снимают режим копирования, 
и здесь может помочь эта команда, которая отключает любое действие у этих символов. Символ " .RS
<pre>@
</pre>


" это символ no-op, он используется так: вызов "
<dl compact=""><dt></dt><dd>
<pre>markkeys @=L=H
</pre>

</dd></dl>

" отключает действие команд H и L. Как показано в примере, к одной функции за раз можно привязать множество клавиш. .RE
<p>
</p></dd><dt><b>maxwin</b> <i>num</i>

</dt><dd>
<br>

<br>&nbsp;Максимальное&nbsp;количество&nbsp;окон,&nbsp;которые&nbsp;можно&nbsp;создать.&nbsp;Не&nbsp;влияет&nbsp;на&nbsp;уже&nbsp;существующие&nbsp;окна.&nbsp;Число&nbsp;можно&nbsp;только&nbsp;уменьшать.&nbsp;
<p>
</p></dd><dt><b>meta</b>

</dt><dd>
<br>

<br>&nbsp;Вставляет&nbsp;управляющий&nbsp;символ&nbsp;(C-a)&nbsp;в&nbsp;текущий&nbsp;поток&nbsp;ввода&nbsp;окна.
<p>
</p></dd><dt><b>monitor</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Включает/выключает&nbsp;наблюдение&nbsp;за&nbsp;активностью&nbsp;в&nbsp;окнах.&nbsp;Когда&nbsp;мониторинг&nbsp;включен&nbsp;для&nbsp;какого-то&nbsp;окна,&nbsp;и&nbsp;оно&nbsp;уходит&nbsp;в&nbsp;фон,&nbsp;
система следит за активностью в нём и отправляет предупреждающее сообщение в строку статуса, как только хотя бы один символ 
будет выведен в окно. Название окна будет отмечено символом " .RS
<pre>@
</pre>

</dd></dl>

". По умолчанию мониторинг отключён для всех окон. 

<p>
</p></dd><dt><b>msgminwait</b> <i>sec</i>

</dt><dd>
<br>

<br>&nbsp;На&nbsp;протяжении&nbsp;какого&nbsp;времени&nbsp;обязательно&nbsp;показывается&nbsp;сообщение,&nbsp;даже&nbsp;если&nbsp;на&nbsp;экране&nbsp;есть&nbsp;какая-то&nbsp;другая&nbsp;активность.&nbsp;
По умолчанию 1 секунда. 
</dd><dt><b>msgwait</b> <i>sec</i>

</dt><dd>
<br>

<br>&nbsp;На&nbsp;протяжении&nbsp;какого&nbsp;времени&nbsp;показывается&nbsp;сообщение,&nbsp;если&nbsp;никакой&nbsp;другой&nbsp;активности&nbsp;нет.&nbsp;По&nbsp;умолчанию&nbsp;5&nbsp;секунд.&nbsp;
</dd><dt><b>multiuser</b> <i>on</i>|<i>off</i>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Переключается&nbsp;между&nbsp;однопользовательским&nbsp;и&nbsp;многопользовательским&nbsp;режимом.&nbsp;Стандартный&nbsp;режим&nbsp;работы&nbsp;&nbsp;однопользовательский.&nbsp;
В многопользовательском работают команды <i>acladd', </i>aclchg<i>, </i>aclgrp<i> и </i>acldel''. Они нужны для того 
чтобы дать (или забрать) доступ пользователям к сеансу screen. .RE
<p>
</p><dl compact="">
<dt><b>nethack</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Изменяет&nbsp;вид&nbsp;сообщений&nbsp;об&nbsp;ошибках,&nbsp;которые&nbsp;выводит&nbsp;screen.&nbsp;&nbsp;Если&nbsp;вы&nbsp;знакомы&nbsp;с&nbsp;игорой&nbsp;"nethack",&nbsp;возможно&nbsp;вам&nbsp;по&nbsp;нраву&nbsp;сообщения,&nbsp;
в которых факты немного искажаются. Так немного веселее. В любом случае, и стандартные сообщения не всегда можно понять. 
<br>&nbsp;Опция&nbsp;доступна&nbsp;только,&nbsp;когда&nbsp;screen&nbsp;откомпилирован&nbsp;с&nbsp;флагом&nbsp;.RS
<pre>NETHACK
</pre>

</dd></dl>
</dd></dl>

<br>&nbsp;&nbsp;Настройки&nbsp;по&nbsp;умолчанию&nbsp;определяются&nbsp;значением&nbsp;переменной&nbsp;
<dl compact=""><dt></dt><dd>
<pre>$NETHACKOPTIONS
</pre>

</dd></dl>

<p>
</p></dd><dt><b>next</b>

</dt><dd>
<br>

<br>&nbsp;Переключиться&nbsp;на&nbsp;следующее&nbsp;окно.&nbsp;Команда&nbsp;может&nbsp;использовать&nbsp;многократно,&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;циклически&nbsp;обойти&nbsp;все&nbsp;окна.&nbsp;
<p>
</p></dd><dt><b>nonblock</b> [<i>on</i>|<i>off</i>|<i>numsecs</i>]

</dt><dd>
<br>

<br>&nbsp;Говорит&nbsp;screen&nbsp;что&nbsp;нужно&nbsp;делать&nbsp;с&nbsp;интерфейсами&nbsp;(дисплеями),&nbsp;которые&nbsp;отказываются&nbsp;принимать&nbsp;ввод.&nbsp;Такое&nbsp;может&nbsp;произойти,&nbsp;
например, если пользователь нажмёт ^S или разорвётся TCP/модемное соединение. Если nonblock выключен (так по умолчанию), 
screen ждёи пока дисплей перезапустится и будет готов принимать ввод.Если nonblock включен, screen подождёт окончания 
таймаута. Если не указано особо, таймаут составляет 1 секунду. Если дисплей за это время не станет принимать символы, он 
считается заблокированным и больше символы туда не отправляются. Если через некоторое время символы начнут приниматься, 
экран будет разблокирован и его содержимое обновлено. 
</dd><dt><b>number</b> [<i>n</i>]

</dt><dd>
<br>

<br>&nbsp;Изменят&nbsp;текущий&nbsp;номер&nbsp;окна.&nbsp;Если&nbsp;заданный&nbsp;номер&nbsp;<i>n</i>&nbsp;уже&nbsp;занят,&nbsp;окна&nbsp;меняются&nbsp;номерами.&nbsp;Если&nbsp;номер&nbsp;не&nbsp;задан,&nbsp;выводится&nbsp;
номер (и имя) текущего окна. 
</dd><dt><b>obuflimit</b> [<i>limit</i>]

</dt><dd>
<br>

<br>&nbsp;Если&nbsp;буфер&nbsp;вывода&nbsp;содержит&nbsp;количество&nbsp;байтов&nbsp;больше&nbsp;заданного&nbsp;предела,&nbsp;новые&nbsp;данные&nbsp;из&nbsp;окон&nbsp;считываться&nbsp;не&nbsp;будут.&nbsp;&nbsp;По&nbsp;умолчанию:&nbsp;
256.  Для быстрых дисплеев (например, для xterm) можно установить значение побольше.  Если аргумент не задан, выводится 
текущее значение. 
</dd><dt><b>only</b>

</dt><dd>
<br>

<br>&nbsp;Убить&nbsp;все&nbsp;регионы,&nbsp;за&nbsp;исключением&nbsp;текущего.
<p>
</p></dd><dt><b>other</b>

</dt><dd>
<br>

<br>&nbsp;Переключиться&nbsp;на&nbsp;другое&nbsp;окно,&nbsp;которое&nbsp;было&nbsp;активным&nbsp;до&nbsp;этого.&nbsp;Если&nbsp;того&nbsp;окна&nbsp;уже&nbsp;нет,&nbsp;<i>other</i>&nbsp;работает&nbsp;как&nbsp;<i>next</i>&nbsp;
<p>
</p></dd><dt><b>partial</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Определяет&nbsp;должен&nbsp;ли&nbsp;дисплей&nbsp;перерисовываться&nbsp;(как&nbsp;при&nbsp;<i>redisplay</i>)&nbsp;при&nbsp;переходе&nbsp;на&nbsp;текущее&nbsp;окно.&nbsp;Команда&nbsp;действует&nbsp;
только на текущее окно. Чтобы подействовать на все окна сразу, нужно использовать команду <i>allpartial</i>. По умолчанию: 
<i>off</i>. Это значение по умолчанию фиксированное, команды <i>defpartial</i> нет. 
</dd><dt><b>password</b> [<i>crypted_pw</i>]

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;зашифрованный&nbsp;пароль,&nbsp;который&nbsp;screen&nbsp;спросит,&nbsp;если&nbsp;кто-то&nbsp;попытается&nbsp;подключиться&nbsp;к&nbsp;нему&nbsp;и&nbsp;возобновить&nbsp;его&nbsp;работу&nbsp;
из отключённого состояния. Полезно, если в screen работают привилегированные программы и вы бы хотели защитись сеанс 
от других пользователей, замаскировавшихся под ваш uid (даже от суперпользователя). Если зашифрованный пароль не задан, 
screen дважды попросит ввести пароль и запомнит зашифрованный пароль в своём буфере обмена (paste buffer). По умолчанию 
<i>none</i>, что отключает парольную проверку вообще. 
</dd><dt><b>paste</b> [<i>registers</i> [<i>dest_reg</i>]]

</dt><dd>
<br>

<br>&nbsp;Вывести&nbsp;содержимое&nbsp;указанных&nbsp;регистров&nbsp;на&nbsp;стандартный&nbsp;поток&nbsp;ввода&nbsp;текущего&nbsp;окна.&nbsp;&nbsp;Регистр&nbsp;"."&nbsp;обозначает&nbsp;буфер&nbsp;обмена&nbsp;
screen (paste buffer).  Если параметров не задать, имя регистра запрашивается у пользователя.  В буфер обмена screen (paste 
buffer) информация попадает при помощи команд <i>copy</i>, <i>history</i> и <i>readbuf</i>. В другие регистры информация 
попадает при помощи команд <i>register</i>, <i>readreg</i> и <i>paste</i>. Если <i>paste</i> вызывается со вторым аргументом, 
содержимое регистров вклеивается не в текущее окно, а в регистр с заданным названием. Если в качестве второго аргумента 
указана ".", данные вклеиваются в буфер обмена дисплея (displays paste buffer). Обратите внимание, что <i>paste</i>, 
если указать второй аргумент, даже не требуется окно; если манипуляции происходят только с регистрами, даже не обязательно 
чтобы screen был подключен к экрану. Буфер обмена привязан к процессу screen; если с этим процессом работает несколько 
пользователей, буфер для них общий. 
</dd><dt><b>pastefont</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<br>

<br>&nbsp;Сообщает&nbsp;screen&nbsp;нужно&nbsp;ли&nbsp;включать&nbsp;информацию&nbsp;о&nbsp;шрифтах&nbsp;в&nbsp;бувер&nbsp;вставки.&nbsp;По&nbsp;умолчанию&nbsp;включать&nbsp;не&nbsp;нужно.&nbsp;Эта&nbsp;команда&nbsp;имеет&nbsp;
особо важное значение для многобайтных кодировкок, таких, например, как kanji. 
</dd><dt><b>pow_break</b>

</dt><dd>
<br>

<br>&nbsp;Повторно&nbsp;открыть&nbsp;(reopen)&nbsp;термиинальную&nbsp;линию&nbsp;окна&nbsp;(window's&nbsp;терминал&nbsp;line)&nbsp;и&nbsp;отправить&nbsp;символ&nbsp;разрыва&nbsp;(break&nbsp;condition).&nbsp;
См. также <i>break</i> 
</dd><dt><b>pow_detach</b>

</dt><dd>
<br>

<br>&nbsp;Отключение&nbsp;питания&nbsp;(power&nbsp;detach).&nbsp;Очень&nbsp;похоже&nbsp;на&nbsp;обычное&nbsp;отключение&nbsp;(detach),&nbsp;но&nbsp;отправляется&nbsp;сигнал&nbsp;HANGUP&nbsp;родительскому&nbsp;
процессу screen. .br
<br>&nbsp;Предупреждение.&nbsp;Вызов&nbsp;этой&nbsp;команды&nbsp;приведёт&nbsp;к&nbsp;завершению&nbsp;сеанса&nbsp;работы,&nbsp;если&nbsp;screen&nbsp;был&nbsp;запущен&nbsp;из&nbsp;login-оболочки.&nbsp;
<p>
</p></dd><dt><b>pow_detach_msg</b> [<i>message</i>]

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;сообщение,&nbsp;которое&nbsp;выводится&nbsp;при&nbsp;выполнении&nbsp;
<dl compact=""><dt></dt><dd>
<pre>Power detach
</pre>

</dd></dl>

<br>&nbsp;&nbsp;Может&nbsp;использоваться&nbsp;как&nbsp;замена&nbsp;для&nbsp;logout-сообщения&nbsp;или&nbsp;для&nbsp;сброса&nbsp;настроек&nbsp;линии&nbsp;(baud&nbsp;rate&nbsp;и&nbsp;т.д.).&nbsp;&nbsp;При&nbsp;вызове&nbsp;без&nbsp;
параметров показывается текущее сообщение. 
</dd><dt><b>prev</b>

</dt><dd>
<br>

<br>&nbsp;Переключиться&nbsp;на&nbsp;предыдущее&nbsp;окно.&nbsp;Команда&nbsp;может&nbsp;использовать&nbsp;многократно,&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;циклически&nbsp;обойти&nbsp;все&nbsp;окна.&nbsp;
<p>
</p></dd><dt><b>printcmd</b> [<i>cmd</i>]

</dt><dd>
<br>

<br>&nbsp;Если&nbsp;<i>cmd</i>&nbsp;не&nbsp;пустая,&nbsp;screen,&nbsp;когда&nbsp;встретит&nbsp;Escape-последовательность&nbsp;
<dl compact=""><dt></dt><dd>
<pre>ESC [ 5
</pre>

</dd></dl>

, не будет использовать возможности (capabilities) терминала 
<dl compact=""><dt></dt><dd>
<pre>po/pf
</pre>

</dd></dl>

, а запустит вместо этого команду <i>cmd</i> и передаст вывод ей.  В качестве <i>cmd</i> хорошо подойдут команды <b>lpr</b> 
или "<b>cat</b> .RS
<pre>&gt; /tmp/scrprint
</pre>


" .  Если вызвать <i>printcmd</i> без команды, она покажет текущую настройку.  ANSI-последовательность ESC \ прекращает 
печать и закрывает канал. .br
<br>&nbsp;Предупреждение.&nbsp;Будьте&nbsp;осторожны&nbsp;с&nbsp;этой&nbsp;командой!&nbsp;Если&nbsp;у&nbsp;других&nbsp;пользователей&nbsp;есть&nbsp;доступ&nbsp;на&nbsp;запись&nbsp;в&nbsp;ваш&nbsp;терминал,&nbsp;они&nbsp;
смогут запустить процесс печати. 
</dd><dt><b>process</b> [<i>key</i>]

</dt><dd>
<br>

<br>&nbsp;Вывести&nbsp;содержимое&nbsp;указанного&nbsp;регистра&nbsp;в&nbsp;буфер&nbsp;ввода.&nbsp;Если&nbsp;аргумент&nbsp;не&nbsp;задан,&nbsp;нужно&nbsp;будет&nbsp;ввести&nbsp;имя&nbsp;регистра&nbsp;с&nbsp;клавиатуры.&nbsp;
Текст обрабатывается так, как будто он был введён с клавиатуры пользователя. Команда может использоваться для того чтобы 
привязать несколько действий к одному ключу. 
</dd><dt><b>quit</b>

</dt><dd>
<br>

<br>&nbsp;Убить&nbsp;все&nbsp;окна&nbsp;и&nbsp;завершить&nbsp;screen.&nbsp;Обратите&nbsp;внимание&nbsp;на&nbsp;то,&nbsp;что&nbsp;в&nbsp;VT100&nbsp;сигналы&nbsp;C-4&nbsp;и&nbsp;C-\&nbsp;идентичны.&nbsp;Из-за&nbsp;этого&nbsp;стандартная&nbsp;
привязка становится опасной: можно случайно нажать C-a C-4, когда выбираешь 4е окно. Для того чтобы отключить всякие 
действия от этой комбинации клавиш, можно вызывать пустой <i>bind</i>: " .RS
<pre>bind ^\
</pre>


".
<p>
</p></dd><dt><b>readbuf</b> [-e <i>encoding</i>] [<i>filename</i>]

</dt><dd>
<br>

<br>&nbsp;Считывает&nbsp;содержимое&nbsp;указанного&nbsp;файла&nbsp;в&nbsp;буфер&nbsp;обмена.&nbsp;&nbsp;Можно&nbsp;указать&nbsp;screen'у&nbsp;кодировку&nbsp;этого&nbsp;файла&nbsp;с&nbsp;помощью&nbsp;ключа&nbsp;-e.&nbsp;
Если файл не указан, используется стандартный файл (см. screen-exchange). См. также команду <i>buffer-file</i>. 
</dd><dt><b>readreg</b> [-e <i>encoding</i>] [<i>register</i> [<i>filename</i>]]

</dt><dd>
<br>

<br>&nbsp;Делает&nbsp;одно&nbsp;из&nbsp;двух,&nbsp;в&nbsp;зависимости&nbsp;от&nbsp;количества&nbsp;аргументов:&nbsp;без&nbsp;аргументов&nbsp;или&nbsp;с&nbsp;одним&nbsp;аргументов&nbsp;содержимое&nbsp;буфера&nbsp;обмена&nbsp;
дублируется в указанном в команде или введённом в приглашение регистре. При вызове с двумя аргументами содержимое файла 
считывается в регистр, точно также как при вызове команды .RS
<pre>readbuf
</pre>


<br>&nbsp;содержимое&nbsp;файла&nbsp;
<dl compact=""><dt></dt><dd>
<pre>screen-exchange
</pre>

</dd></dl>

<br>&nbsp;считывается&nbsp;в&nbsp;буфер&nbsp;обмена.&nbsp;Кодировку&nbsp;файла&nbsp;можно&nbsp;задать&nbsp;при&nbsp;помощи&nbsp;опции&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-e
</pre>

</dd></dl>

<br>&nbsp;В&nbsp;приведённый&nbsp;ниже&nbsp;примере&nbsp;содержимое&nbsp;файла&nbsp;
<dl compact=""><dt></dt><dd>
<pre>/etc/passwd
</pre>

</dd></dl>

<br>&nbsp;вставляется&nbsp;в&nbsp;окно&nbsp;screen&nbsp;(с&nbsp;использованием&nbsp;регистра&nbsp;
<dl compact=""><dt></dt><dd>
<pre>p
</pre>

</dd></dl>

, в котором остаётся копия):
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    C-a : readreg p /etc/passwd
    C-a : paste p

</pre>

</dd></dl>

</dd><dt><b>redisplay</b>

</dt><dd>
<br>

<br>&nbsp;Перерисовать&nbsp;текущее&nbsp;окно.&nbsp;Используется&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;выполнить&nbsp;полную&nbsp;перерисовку&nbsp;при&nbsp;работе&nbsp;в&nbsp;режиме&nbsp;частичной&nbsp;отрисовки&nbsp;
(partial redraw). 
</dd><dt><b>register</b> [-e <i>encoding</i>] <i>key</i> <i>string</i>

</dt><dd>
<br>

<br>&nbsp;Сохранить&nbsp;указанную&nbsp;строку&nbsp;в&nbsp;регистр&nbsp;с&nbsp;заданным&nbsp;ключом&nbsp;<i>key</i>.&nbsp;Кодировка&nbsp;строки&nbsp;может&nbsp;быть&nbsp;задана&nbsp;с&nbsp;помощью&nbsp;опции&nbsp;.RS
<pre>-e
</pre>


<br>&nbsp;Также&nbsp;смотрите&nbsp;опцию&nbsp;<i>command</i>.
<p>
</p></dd><dt><b>remove</b>

</dt><dd>
<br>

<br>&nbsp;Уничтожить&nbsp;текущий&nbsp;регион.&nbsp;Это&nbsp;команда&nbsp;не&nbsp;имеет&nbsp;эффекта,&nbsp;если&nbsp;регион&nbsp;только&nbsp;один.
<p>
</p></dd><dt><b>removebuf</b>

</dt><dd>
<br>

<br>&nbsp;Удалить&nbsp;файл&nbsp;screen-exchange,&nbsp;который&nbsp;использовался&nbsp;командами&nbsp;<i>writebuf</i>&nbsp;и&nbsp;<i>readbuf</i>.
<p>
</p></dd><dt><b>reset</b>

</dt><dd>
<br>

<br>&nbsp;Приводит&nbsp;настройки&nbsp;виртуального&nbsp;терминала&nbsp;в&nbsp;исходное&nbsp;состояние.&nbsp;Полезно,&nbsp;когда&nbsp;на&nbsp;терминале&nbsp;из-за&nbsp;некорректного&nbsp;использования&nbsp;
приложений появлюятся странные символы, типа квадратиков, вместо того чтобы выводился текст. 
</dd><dt><b>resize</b>

</dt><dd>
<br>

<br>&nbsp;Изменить&nbsp;размер&nbsp;текущего&nbsp;региона.&nbsp;Пространство&nbsp;будет&nbsp;добавлено&nbsp;или&nbsp;удалено&nbsp;из&nbsp;нижнего&nbsp;региона&nbsp;или,&nbsp;если&nbsp;его&nbsp;не&nbsp;хватит,&nbsp;
из региона который выше. 
<dl compact=""><dt></dt><dd>
<pre>    resize +N   увеличить высоту региона на N
    resize -N   уменьшить высоту региона на N
    resize  N   установить высоту региона равной N
    resize  =   сделать все регионы одинаковой высоты
    resize  max сделать текущий регион максимально высоким
    resize  min сделать текущий регион максимально низким

</pre>

</dd></dl>

</dd><dt><b>screen</b> [-<i>opts</i>] [<i>n</i>] [<i>cmd</i> [<i>args</i>]]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Создать&nbsp;новое&nbsp;окно.&nbsp;В&nbsp;команде&nbsp;могут&nbsp;быть&nbsp;указаны&nbsp;опции&nbsp;управления&nbsp;потоком&nbsp;(
<dl compact=""><dt></dt><dd>
<pre>-f
</pre>

</dd></dl>

,  
<dl compact=""><dt></dt><dd>
<pre>-fn
</pre>

</dd></dl>

<br>&nbsp;&nbsp;и&nbsp;&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-fa
</pre>

</dd></dl>

), опция названия (
<dl compact=""><dt></dt><dd>
<pre>-t
</pre>

</dd></dl>

), опции регистрации (
<dl compact=""><dt></dt><dd>
<pre>-l
</pre>

</dd></dl>

<br>&nbsp;и&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-ln
</pre>

</dd></dl>

) , опция типа терминала (
<dl compact=""><dt></dt><dd>
<pre>-T
</pre>

</dd></dl>

<br>&nbsp;<i>term</i>),&nbsp;опция&nbsp;флага&nbsp;всех&nbsp;возможностей&nbsp;(all-capability&nbsp;flag)&nbsp;(
<dl compact=""><dt></dt><dd>
<pre>-a
</pre>

</dd></dl>

) и опция буфера прокрутки (
<dl compact=""><dt></dt><dd>
<pre>-h
</pre>

</dd></dl>

<br>&nbsp;<i>num</i>).&nbsp;&nbsp;Опция&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-M
</pre>

</dd></dl>

<br>&nbsp;включает&nbsp;мониторинг&nbsp;окна.&nbsp;Опция&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-L
</pre>

</dd></dl>

<br>&nbsp;включает&nbsp;журнализацию&nbsp;вывода&nbsp;окна.&nbsp;Если&nbsp;задан&nbsp;опциональный&nbsp;номер&nbsp;<i>n</i>&nbsp;из&nbsp;диапазона&nbsp;0..9,&nbsp;этот&nbsp;номер&nbsp;присваивается&nbsp;
созданному окну (или,  если номер уже используется, следующий свободный).  Если после screen указана команда, она (вместе 
с заданными аргументами) запускается в окне; в противном случае создаётся окно с командным интерпретатором. Так, например, 
если в .RS
<pre></pre>

</dd></dl>

<br>&nbsp;есть&nbsp;строки:

<dl compact=""><dt></dt><dd>
<pre>    # example for .screenrc:
    screen 1
    screen -fn -t foobar -L 2 telnet foobar

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;screen&nbsp;создаст&nbsp;окно&nbsp;интерпретатора&nbsp;(в&nbsp;окне&nbsp;#1)&nbsp;и&nbsp;окно&nbsp;с&nbsp;TELNET-соединением&nbsp;на&nbsp;машину&nbsp;foobar&nbsp;(с&nbsp;отключённым&nbsp;flow-control,&nbsp;
с заголовком "foobar", в окне #2) и будет писать журнал ("screenlog.2") сеанса работы в Telnet. Обратите внимание, что 
в отличие от предыдущих версий screen дополнительных окон не создаётся, если в .RS
<pre></pre>

</dd></dl>

<br>&nbsp;есть&nbsp;хотя&nbsp;бы&nbsp;одна&nbsp;команда&nbsp;<i>screen</i>.&nbsp;Когда&nbsp;инициализации&nbsp;окончена,&nbsp;screen&nbsp;переключается&nbsp;на&nbsp;последнее&nbsp;окно,&nbsp;описанное&nbsp;
в файле .RS
<pre></pre>


, или, если таковых нет, открывает окно #0. В screen встроена некоторая функциональность <i>cu</i> и <i>telnet</i>. См. 
также раздел "Типы окон". .RE
<p>
</p></dd><dt><b>scrollback</b> <i>num</i>

</dt><dd>
<br>

<br>&nbsp;Устанавливает&nbsp;размер&nbsp;буфера&nbsp;прокрутки&nbsp;для&nbsp;текущих&nbsp;окон&nbsp;равным&nbsp;<i>num</i>&nbsp;строк.&nbsp;По&nbsp;умолчанию:&nbsp;100.&nbsp;См.&nbsp;также&nbsp;команду&nbsp;<i>defscrollback</i>,&nbsp;
которая устанавливает размер буфера прокрутки по умолчанию, а также комбинацию клавиш <i>C-a i</i>, которая показывает 
текущую настройку. 
</dd><dt><b>select</b> [<i>WindowID</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Выбрать&nbsp;окно&nbsp;с&nbsp;идентификатором&nbsp;WindowID.&nbsp;Это&nbsp;может&nbsp;быть&nbsp;или&nbsp;номер&nbsp;окна&nbsp;или&nbsp;префикс&nbsp;в&nbsp;имени&nbsp;окна&nbsp;(алфавитно-цифровое&nbsp;имя).&nbsp;
Если параметр не указывать, система попросит ввести идентификатор. При создании окон берётся первый незанятый номер. 
Поэтому переход на самое первое окно выполняется по команде .RS
<pre>select 0
</pre>

</dd></dl>

<br>&nbsp;Максимальное&nbsp;количество&nbsp;окон&nbsp;ограничивается&nbsp;при&nbsp;компиляции&nbsp;параметром&nbsp;
<dl compact=""><dt></dt><dd>
<pre>MAXWIN
</pre>

</dd></dl>

<br>&nbsp;Есть&nbsp;два&nbsp;специальных&nbsp;обозначения:&nbsp;"-"&nbsp;для&nbsp;внутреннего&nbsp;окна&nbsp;и&nbsp;"."&nbsp;для&nbsp;текущего&nbsp;окна.&nbsp;Последнее&nbsp;очень&nbsp;полезно&nbsp;при&nbsp;использовании&nbsp;
с " .RS
<pre>screen -X
</pre>


".

<p>
</p></dd><dt><b>sessionname</b> [<i>name</i>]

</dt><dd>
<br>

<br>&nbsp;Переименовать&nbsp;текущий&nbsp;сеанс.&nbsp;Обратите&nbsp;внимание,&nbsp;что&nbsp;в&nbsp;выводе&nbsp;'screen&nbsp;-list'&nbsp;имя&nbsp;показывается&nbsp;с&nbsp;идентификатором&nbsp;процесса.&nbsp;
Если аргумент <i>name</i> опущен, просто показывается имя сеанса. .br
<br>&nbsp;Предупреждение:&nbsp;переменная&nbsp;
<dl compact=""><dt></dt><dd>
<pre>$STY
</pre>

</dd></dl>

<br>&nbsp;после&nbsp;переименования&nbsp;всё&nbsp;равно&nbsp;содержит&nbsp;старое&nbsp;имя.&nbsp;Это&nbsp;может&nbsp;привести&nbsp;к&nbsp;путанице.&nbsp;По&nbsp;умолчанию&nbsp;имя&nbsp;составляется&nbsp;из&nbsp;названия&nbsp;
терминала и имени хоста. 
</dd><dt><b>setenv</b> [<i>var</i> [<i>string</i>]]

</dt><dd>
<br>

<br>&nbsp;Установить&nbsp;переменную&nbsp;окружения&nbsp;<i>var</i>&nbsp;равной&nbsp;<i>string</i>.&nbsp;Если&nbsp;указать&nbsp;только&nbsp;<i>var</i>,&nbsp;система&nbsp;попросит&nbsp;ввести&nbsp;
значение. Если параметры не заданы вообще, система попросит ввести и название переменной и значение. Среда окружения 
будет наследоваться всеми оболочками, которые будут запущены из screen. 
</dd><dt><b>setsid</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;В&nbsp;нормальном&nbsp;режиме&nbsp;screen&nbsp;использует&nbsp;отдельные&nbsp;группы&nbsp;сеансов&nbsp;и&nbsp;процессов&nbsp;для&nbsp;своих&nbsp;окон.&nbsp;Если&nbsp;выключить&nbsp;<i>setsid</i>,&nbsp;
так больше не происходит, и все окна находятся в одной группе процессов, с основным процессом screen (screen backend proccess). 
Обратите внимание, что в этом случае не будет работать управление работами (job control). По умолчанию <i>setsid</i> включен. 
Команда редко когда может оказаться полезной. .RE
<p>
</p><dl compact="">
<dt><b>shell</b> <i>command</i>

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;команду,&nbsp;которая&nbsp;должна&nbsp;использоваться&nbsp;при&nbsp;создании&nbsp;новой&nbsp;оболочки.&nbsp;Этот&nbsp;параметр&nbsp;перекрывает&nbsp;значение&nbsp;переменной&nbsp;
окружения .RS
<pre>$SHELL
</pre>

</dd></dl>
</dd></dl>

<br>&nbsp;Полезно,&nbsp;если&nbsp;вы&nbsp;любите&nbsp;запускать&nbsp;расширитель&nbsp;терминала&nbsp;(tty-enhancer),&nbsp;который&nbsp;запускает&nbsp;программу,&nbsp;указанную&nbsp;в&nbsp;
<dl compact=""><dt></dt><dd>
<pre>$SHELL
</pre>

</dd></dl>

<br>&nbsp;Если&nbsp;команда&nbsp;начинается&nbsp;символом&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-
</pre>

</dd></dl>

, оболочка будет запущена как login-оболочка (login-shell).
<p>
</p></dd><dt><b>shelltitle</b> <i>title</i>

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;заголовок&nbsp;для&nbsp;всех&nbsp;окон&nbsp;с&nbsp;командным&nbsp;интерпретатором,&nbsp;которые&nbsp;создаются&nbsp;при&nbsp;запуске&nbsp;или&nbsp;при&nbsp;нажатии&nbsp;<b>C-a&nbsp;C-c</b>.&nbsp;
Подробнее в разделе <i>Заголовки (наименования окон)</i>. 
</dd><dt><b>silence</b> [<i>on</i>|<i>off</i>|<i>sec</i>]

</dt><dd>
<br>

<br>&nbsp;Управляет&nbsp;наблюдением&nbsp;за&nbsp;тишиной&nbsp;(silence&nbsp;monitoring)&nbsp;в&nbsp;окнах.&nbsp;Когда&nbsp;silence&nbsp;для&nbsp;окна&nbsp;включен,&nbsp;и&nbsp;в&nbsp;течение&nbsp;некоторого&nbsp;
времени в нём нет изменений, в статусной строке появляется соответствующее сообщение.  Длительность ожидания можно изменять 
с помощью команды <i>sliencewait</i> или путём указания количества секунд в качестве аргумента (вместо <i>on</i> или <i>off</i>). 
По умолчанию: <i>off</i>. 
</dd><dt><b>silencewait</b> <i>sec</i>

</dt><dd>
<br>

<br>&nbsp;Определяет&nbsp;время,&nbsp;в&nbsp;течение&nbsp;которого&nbsp;в&nbsp;окнах,&nbsp;в&nbsp;которых&nbsp;отслеживается&nbsp;тишина,&nbsp;должно&nbsp;не&nbsp;происходить&nbsp;никаких&nbsp;действий,&nbsp;
прежде чем выводить соответствующее сообщение. По умолчанию 30 секунд. 
</dd><dt><b>sleep</b> <i>num</i>

</dt><dd>
<br>

<br>&nbsp;Приостанавливает&nbsp;выполнение&nbsp;файла&nbsp;.screenrc&nbsp;на&nbsp;заданное&nbsp;количество&nbsp;секунд.&nbsp;Любая&nbsp;клавиатурная&nbsp;активность&nbsp;останавливает&nbsp;
ожидание. Это может пригодиться, когда нужно сделать чтобы пользователь мог прочитать сообщение, выводимое с помощью 
<i>echo</i>. 
</dd><dt><b>slowpaste</b> <i>msec</i>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Определяет&nbsp;скорость,&nbsp;с&nbsp;которой&nbsp;текст&nbsp;будет&nbsp;вставляться&nbsp;в&nbsp;текущее&nbsp;окно&nbsp;при&nbsp;вызове&nbsp;команды&nbsp;<i>paste</i>&nbsp;(нажатии&nbsp;"C-a&nbsp;]").&nbsp;
Если значение slowpaste отлично от 0, текст вводится посимвольно и screen делает паузу <i>msec</i> миллисекунд после каждого 
символа, для того чтобы приложение могло успеть обработать ввод. Команду <i>slowpaste</i> нужно использовать только 
в тех случаях, когда доступная через screen система обрабатывает большие объёмы мгновенно вставляемого текста с ошибками. 
</dd></dl>

<p>
</p></dd><dt><b>source</b> <i>file</i>

</dt><dd>
<br>

<br>&nbsp;Прочитать&nbsp;и&nbsp;выполнить&nbsp;команды&nbsp;из&nbsp;файла&nbsp;<i>file</i>.&nbsp;Команда&nbsp;<i>source</i>&nbsp;может&nbsp;быть&nbsp;вложенной,&nbsp;с&nbsp;максимальной&nbsp;глубиной&nbsp;
рекурсии до 10. Если имя <i>file</i> не содержит абсолютного пути и screen сейчас выполняет команду <i>source</i>, новый 
файл ищется в родительском каталоге текущей команды <i>source</i>, и если там ничего не найдено, выполняется поиск в текущем 
каталоге. .br
<br>&nbsp;Обратите&nbsp;внимание,&nbsp;что&nbsp;команды&nbsp;<i>termcap</i>,&nbsp;<i>terminfo</i>&nbsp;и&nbsp;<i>termcapinfo</i>&nbsp;работают&nbsp;только&nbsp;при&nbsp;запуске&nbsp;и&nbsp;при&nbsp;
повторном подключении (reattach); поэтому, для того чтобы они имели эффект, их нужно вызывать из файлов screenrc. 
</dd><dt><b>sorendition</b> [<i>attr</i> [<i>color</i>]]

</dt><dd>
<br>

<br>&nbsp;Указывает&nbsp;способ,&nbsp;который&nbsp;screen&nbsp;использует&nbsp;для&nbsp;подсветки&nbsp;текста&nbsp;и&nbsp;печатаемых&nbsp;сообщений.&nbsp;Синтаксис&nbsp;модификаторов&nbsp;описан&nbsp;
в разделе  "Escape-последовательности". Сейчас по умолчанию "=s dd" (standout, цвета по умолчанию). 
</dd><dt><b>split</b>

</dt><dd>
<br>

<br>&nbsp;Разделить&nbsp;текущий&nbsp;регион&nbsp;на&nbsp;два&nbsp;новых.&nbsp;Размеры&nbsp;всех&nbsp;регионов&nbsp;на&nbsp;экране&nbsp;меняются&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;освободить&nbsp;место&nbsp;для&nbsp;ного&nbsp;
региона. В новом регионе отображается пустое окно. Удалить регион можно с помощью команды <i>remove</i> или <i>only</i>. 
<p>
</p></dd><dt><b>startup_message</b> <i>on</i>|<i>off</i>

</dt><dd>
<br>

<br>&nbsp;Должно&nbsp;ли&nbsp;показывать&nbsp;сообщение&nbsp;с&nbsp;информацией&nbsp;о&nbsp;правах&nbsp;на&nbsp;программу&nbsp;при&nbsp;её&nbsp;старте.&nbsp;По&nbsp;умолчанию&nbsp;<i>on</i>,&nbsp;как&nbsp;уже&nbsp;можно&nbsp;было&nbsp;
убедиться. 
</dd><dt><b>stuff</b> <i>string</i>

</dt><dd>
<br>

<br>&nbsp;Вставляет&nbsp;строку&nbsp;<i>string</i>&nbsp;&nbsp;в&nbsp;текущее&nbsp;окно.&nbsp;Похоже&nbsp;на&nbsp;команду&nbsp;<i>paste</i>,&nbsp;но&nbsp;с&nbsp;меньшими&nbsp;накладными&nbsp;расходами.&nbsp;С&nbsp;помощью&nbsp;
команды <i>stuff</i> нельзя вставить большие объёмы текста. Очень полезно для управления привязками клавиш. См. также 
<i>bindkey</i>. 
</dd><dt><b>su [</b><i>username</i> [<i>password</i> [<i>password2</i>]]

</dt><dd>
<br>

<br>&nbsp;Изменить&nbsp;пользователя&nbsp;дисплея.&nbsp;Команда&nbsp;спросит&nbsp;все&nbsp;параметры,&nbsp;которые&nbsp;не&nbsp;указаны&nbsp;как&nbsp;аргументы.&nbsp;Если&nbsp;в&nbsp;качестве&nbsp;аргументов&nbsp;
указываются пароли, они должны указываться не в зашифрованном виде. Первый пароль проверяется через системную базу паролей, 
а второй -- через собственную базу screen (в которую пароли попали через команды <i>acladd</i> и <i>password</i>). Команда 
<i>su</i> может пригодиться для администраторов screen, которые хотя проверить многопользовательские настройки. Если 
аутентификацию не пройти, доступ есть только к командам, доступным пользователю nobody. К этим командам относятся "<i>detach</i>", 
<br>&nbsp;"<i>license</i>",&nbsp;&nbsp;"<i>version</i>",&nbsp;"<i>help</i>"&nbsp;и&nbsp;"<i>displays</i>".&nbsp;
</dd><dt><b>suspend</b>

</dt><dd>
<br>

<br>&nbsp;Приостановить&nbsp;screen.&nbsp;Окна&nbsp;всё&nbsp;это&nbsp;время&nbsp;находятся&nbsp;в&nbsp;отключённом&nbsp;состоянии.&nbsp;Данная&nbsp;особенность&nbsp;полагается&nbsp;на&nbsp;возможности&nbsp;
командного интерпретатора по управлению работами (job control). 
</dd><dt><b>term</b> <i>term</i>

</dt><dd>
<br>

<br>&nbsp;В&nbsp;каждом&nbsp;окне,&nbsp;которое&nbsp;открывает&nbsp;screen,&nbsp;переменная&nbsp;
<dl compact=""><dt></dt><dd>
<pre>$TERM
</pre>

</dd></dl>

<br>&nbsp;устанавливается&nbsp;по&nbsp;умолчанию&nbsp;равной&nbsp;
<dl compact=""><dt></dt><dd>
<pre>screen
</pre>

</dd></dl>

<br>&nbsp;Но,&nbsp;когда&nbsp;в&nbsp;локальных&nbsp;базах&nbsp;данных&nbsp;termcap&nbsp;и&nbsp;terminfo&nbsp;нет&nbsp;поддержки&nbsp;screen,&nbsp;надо&nbsp;установить&nbsp;
<dl compact=""><dt></dt><dd>
<pre>$TERM
</pre>

</dd></dl>

<br>&nbsp;равной,&nbsp;скажем,&nbsp;
<dl compact=""><dt></dt><dd>
<pre>vt100
</pre>

</dd></dl>

<br>&nbsp;&nbsp;В&nbsp;этом&nbsp;нет&nbsp;ничего&nbsp;страшного,&nbsp;посколько&nbsp;screen&nbsp;совместим&nbsp;с&nbsp;VT100/ANSI.&nbsp;Не&nbsp;рекомендуется&nbsp;использовать&nbsp;эту&nbsp;команду&nbsp;за&nbsp;исключением&nbsp;
тех случаев, когда задаются настройки по умолчанию. Например, в случае, когда нужно задать настройки терминала для одной 
команды, скажем для .RS
<pre>screen  rlogin  othermachine
</pre>


, лучше использовать вызов "
<dl compact=""><dt></dt><dd>
<pre>screen -T vt100 rlogin othermachine
</pre>

</dd></dl>

" чем устанавливать или сбрасывать настройки по умолчанию.
<p>
</p></dd><dt><b>termcap</b> <i>term</i> <i>terminal-tweaks</i> [<i>window-tweaks</i>]

</dt><dd>
</dd><dt><b>terminfo</b> <i>term</i> <i>terminal-tweaks</i> [<i>window-tweaks</i>]

</dt><dd>
</dd><dt><b>termcapinfo</b> <i>term</i> <i>terminal-tweaks</i> [<i>window-tweaks</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Команда&nbsp;модифицирует&nbsp;termcap-запись&nbsp;терминала&nbsp;без&nbsp;необходимости&nbsp;выполнениях&nbsp;хитрых&nbsp;операций,&nbsp;связанных&nbsp;с&nbsp;созданием&nbsp;
собственной termcap-записи.  Кроме того, с её помощью можно подстраивать termcap-записи сгенерированные для окон. 
<br>&nbsp;Эти&nbsp;команды&nbsp;имеет&nbsp;смысл&nbsp;размещать&nbsp;только&nbsp;в&nbsp;.RS
<pre>screenrc
</pre>

</dd></dl>

, поскольку после того как screen запущен, команды уже не нужны. Если в системе используется база данных terminfo, а не termcap, 
screen поймёт команду <b>terminfo</b>, у которой такой же эффект как и у команды <b>termcap</b>.  Две отдельные команды существуют 
из-за нескольких тонких синтаксических отличий, в частности, там где выполняется интерполяция " .RS
<pre>%
</pre>


" параметров.  Обратите внимание, что даже с <i>terminfo</i> нужно использовать имена возможностей (capabilities) от 
termcap.  Во многих случаях, когда аргументы подходят как для <b>terminfo</b>, так и для <b>termcap</b>, можно использовать 
команду <b>termcapinfo</b>, которая является сокращением для пары команды (<b>termcap</b> и <b>terminfo</b>) с идентичными 
аргументами. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Первый&nbsp;аргумент&nbsp;указывает&nbsp;на&nbsp;какой&nbsp;терминал&nbsp;(или&nbsp;терминалы)&nbsp;должно&nbsp;подействовать&nbsp;определение.&nbsp;Можно&nbsp;задавать&nbsp;множество&nbsp;
имён терминалов через .RS
<pre>|
</pre>

</dd></dl>

, 
<dl compact=""><dt></dt><dd>
<pre>*
</pre>

</dd></dl>

<br>&nbsp;обозначает&nbsp;все&nbsp;терминалы,&nbsp;а&nbsp;
<dl compact=""><dt></dt><dd>
<pre>vt*
</pre>

</dd></dl>

<br>&nbsp;--&nbsp;все&nbsp;терминалы,&nbsp;начинающиеся&nbsp;на&nbsp;
<dl compact=""><dt></dt><dd>
<pre>vt
</pre>

</dd></dl>

<p>

</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Каждый&nbsp;аргумент&nbsp;<i>tweak</i>&nbsp;содержит&nbsp;одно&nbsp;(или&nbsp;более)&nbsp;определение&nbsp;termcap&nbsp;(разделённых&nbsp;сиволом&nbsp;":"),&nbsp;которые&nbsp;вставляются&nbsp;
в начало соответствующей записи termcap, дополняя или перекрывая существующие значения.  Первый <i>tweak</i>  изменяет 
termcap вашего терминала. Он содержит определения, которые терминал использует для выполнения определённых функций. 
Если указать пустую строку "", чтобы не делать никаких изменений.  Второй (опциональный) <i>tweak</i> изменяет  termcap'ы 
окон, он должен содержать определения, которые screen поймёт (см. раздел "Виртуальный терминал"). .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Некоторые&nbsp;примеры:
</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    termcap xterm*  LP:hs@

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Говорит&nbsp;screen&nbsp;о&nbsp;том,&nbsp;что&nbsp;у&nbsp;всех&nbsp;терминало,&nbsp;имя&nbsp;типа&nbsp;которых&nbsp;начинается&nbsp;с&nbsp;"
<dl compact=""><dt></dt><dd>
<pre>xterm
</pre>

</dd></dl>

", должны быть жёсткие автоотступы (firm auto-margins), которые позволят обновляеть последнюю позицию экрана (LP), 
и у которых нет статусной строки, hardstatus (нет "hs" --- если добавить " .RS
<pre>@
</pre>

</dd></dl>

" в конец записи, она выключается).
</dd></dl>

<dl compact=""><dt></dt><dd>
<pre>       

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Обратите&nbsp;внимание,&nbsp;что&nbsp;"
<dl compact=""><dt></dt><dd>
<pre>LP
</pre>

</dd></dl>

" подразумевается для всех терминалов, имя типа которых начинается с 
<dl compact=""><dt></dt><dd>
<pre>vt
</pre>

</dd></dl>

, за исключением тех терминалов, для которых указана команда <b>termcap</b>.
</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    termcap vt*  LP
    termcap vt102|vt220  Z0=\E[?3h:Z1=\E[?3l

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Определяет&nbsp;возможность&nbsp;(capability)&nbsp;"
<dl compact=""><dt></dt><dd>
<pre>LP
</pre>

</dd></dl>

" для всех терминалов, название типа которых начинается с "
<dl compact=""><dt></dt><dd>
<pre>vt
</pre>

</dd></dl>

".  Вторая строка добавляет поддержку escape-последовательностей для переключения в режим 132 символа на строку (Z0) 
и из него (Z1) для терминалов VT102 и VT220 (для того чтобы использовать команды по изменению ширины, нужно указать Z0 и Z1 
в файле termcap) .RE
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;Здесь&nbsp;termcap&nbsp;vt100&nbsp;остаётся&nbsp;нетронутым,&nbsp;а&nbsp;в&nbsp;termcap-записи&nbsp;окон&nbsp;добавляются&nbsp;метки&nbsp;функциональных&nbsp;клавиш.&nbsp;.RE
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    termcap h19|z19  am@:im=\E@:ei=\EO  dc=\E[P

</pre>

</dd></dl>

<dl compact=""><dt></dt><dd>
<br>&nbsp;В&nbsp;termcap'ах&nbsp;h19&nbsp;и&nbsp;z19&nbsp;выключаются&nbsp;автоотступы&nbsp;(
<dl compact=""><dt></dt><dd>
<pre>am@
</pre>

</dd></dl>

, auto margin) и включаются режим вставки (
<dl compact=""><dt></dt><dd>
<pre>im
</pre>

</dd></dl>

, insert mode) и конец вставки (
<dl compact=""><dt></dt><dd>
<pre>ei
</pre>

</dd></dl>

, end-insert) (символ "
<dl compact=""><dt></dt><dd>
<pre>@
</pre>

</dd></dl>

"  в строке "
<dl compact=""><dt></dt><dd>
<pre>im
</pre>

</dd></dl>

" идёт после "
<dl compact=""><dt></dt><dd>
<pre>=
</pre>

</dd></dl>

", так что это часть строки).  Если добавить определения "
<dl compact=""><dt></dt><dd>
<pre>im
</pre>

</dd></dl>

" и "
<dl compact=""><dt></dt><dd>
<pre>ei
</pre>

</dd></dl>

" в termcap терминала, где запущен screen, они автоматически будут передаваться в termcap каждого окна.В каждом окне появляется 
новая возможность (capability): удаление символа delete-character (dc), которое screen транслирует в обновление 
строки терминала (предполагается, что терминал не имеет возможности удалять символ). .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Если&nbsp;нужно&nbsp;полностью&nbsp;задать&nbsp;записть&nbsp;termcap,&nbsp;лучше&nbsp;использовать&nbsp;переменную&nbsp;
<dl compact=""><dt></dt><dd>
<pre>$SCREENCAP
</pre>

</dd></dl>

, которую установить до запуска screen. Подробнее в разделе "Виртуальный терминал" и в man-странице <a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=termcap&amp;category=5">termcap</a>(5), где 
подробно рассказывается об определениях termcap. .RE
<p>
</p><dl compact="">
<dt><b>time</b> [<i>string</i>]

</dt><dd>
<br>

<br>&nbsp;Показать&nbsp;в&nbsp;строке&nbsp;сообщений&nbsp;время,&nbsp;имя&nbsp;хоста&nbsp;и&nbsp;нагрузку&nbsp;(load&nbsp;average)&nbsp;за&nbsp;1,&nbsp;5&nbsp;и&nbsp;15&nbsp;минут&nbsp;(если&nbsp;это&nbsp;поддерживается&nbsp;в&nbsp;системе).&nbsp;
Для получения информации об окне используйте команду <i>info</i>. .br
<br>&nbsp;Если&nbsp;задан&nbsp;аргумент&nbsp;<i>string</i>,&nbsp;формат&nbsp;меняется&nbsp;как&nbsp;описано&nbsp;в&nbsp;разделе&nbsp;"Escape-последовательности".&nbsp;По&nbsp;умолчанию&nbsp;
" .RS
<pre>%c:%s %M %d %H%? %l%?
</pre>

</dd></dl>
</dd></dl>

".
<p>
</p><dl compact="">
<dt><b>title</b> [<i>windowtitle</i>]

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;имя&nbsp;текущего&nbsp;окна.&nbsp;Если&nbsp;имя&nbsp;не&nbsp;указано,&nbsp;screen&nbsp;выдаёт&nbsp;приглашение&nbsp;для&nbsp;его&nbsp;ввода.&nbsp;В&nbsp;более&nbsp;ранних&nbsp;версиях&nbsp;screen&nbsp;команда&nbsp;
была известнка как <i>aka</i>. 
</dd><dt><b>unsetenv</b> <i>var</i>

</dt><dd>
<br>

<br>&nbsp;Удалить&nbsp;переменную&nbsp;окружения.
<p>
</p></dd><dt><b>utf8</b> [<i>on</i>|<i>off</i> [<i>on</i>|<i>off</i>]]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Изменяет&nbsp;кодировку&nbsp;текущего&nbsp;окна.&nbsp;Если&nbsp;включён&nbsp;utf8,&nbsp;строки&nbsp;отправляемые&nbsp;в&nbsp;окно,&nbsp;будут&nbsp;перекодированы&nbsp;в&nbsp;UTF-8&nbsp;(и&nbsp;наоборот).&nbsp;
Если не задавать параметры, настройки переключаются на противоположные. Если задан второй параметр, меняется также 
настройка отображения (display encoding); обычно это делается с помощью опции командной строки -U. Также, смотрите 
команду <i>defutf8</i>, которая меняет начальные настройки для новых окон. .RE
<p>
</p><dl compact="">
<dt><b>vbell</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Настройка&nbsp;визуального&nbsp;звонка&nbsp;для&nbsp;окна.&nbsp;Если&nbsp;вызвать&nbsp;без&nbsp;параметра,&nbsp;настройка&nbsp;переключается.&nbsp;Если&nbsp;визуальный&nbsp;звонок&nbsp;
включен, но терминал не поддерживает его, при поступлении символа звонка (^G) в строке статуса выводится сообщение <i>vbell-message</i>. 
Поддержка визуального звонка терминалом определяется переменной termcap .RS
<pre>vb
</pre>

</dd></dl>

<br>&nbsp;(или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>flash
</pre>

</dd></dl>

<br>&nbsp;в&nbsp;terminfo).&nbsp;По&nbsp;умолчанию&nbsp;vbell&nbsp;выключен&nbsp;и&nbsp;используется&nbsp;звуковой&nbsp;звонок.&nbsp;См.&nbsp;также&nbsp;<i>bell_msg</i>.
</dd></dl>
</dd></dl>

<p>
</p></dd><dt><b>vbell_msg</b> [<i>message</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Задаёт&nbsp;сообщение&nbsp;для&nbsp;визуального&nbsp;звонка&nbsp;(visual&nbsp;bell).&nbsp;Сообщение&nbsp;<i>message</i>&nbsp;выводится&nbsp;в&nbsp;строке&nbsp;статуса&nbsp;в&nbsp;момент,&nbsp;
когда в окно выводится символ звонка (bell character, ^G) и при этом vbell включен, но терминал не поддерживает visual vell. 
По умолчанию выводится сообщение .RS
<pre>Wuff, Wuff!!
</pre>

</dd></dl>

<br>&nbsp;Если&nbsp;вызывать&nbsp;команду&nbsp;безе&nbsp;параметров,&nbsp;будет&nbsp;показано&nbsp;текущее&nbsp;сообщение.
</dd></dl>
</dd></dl>

<p>
</p><dl compact="">
<dt><b>vbellwait</b> <i>sec</i>

</dt><dd>
<br>

<br>&nbsp;Определяет&nbsp;задержку&nbsp;в&nbsp;секундах&nbsp;для&nbsp;каждого&nbsp;вывода&nbsp;визуального&nbsp;звонка&nbsp;(visual&nbsp;bell)&nbsp;в&nbsp;screen.&nbsp;По&nbsp;умолчанию,&nbsp;1&nbsp;секунда.&nbsp;
<p>
</p></dd><dt><b>verbose</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<br>

<br>&nbsp;Если&nbsp;включено,&nbsp;при&nbsp;создании&nbsp;(или&nbsp;восстановлении)&nbsp;окна,&nbsp;выводится&nbsp;имя&nbsp;вызванной&nbsp;команды.&nbsp;По&nbsp;умолчанию&nbsp;выключено.&nbsp;При&nbsp;
вызове без параметров показывается текущая настройка. 
</dd><dt><b>version</b>

</dt><dd>
<br>

<br>&nbsp;Вывести&nbsp;текущую&nbsp;версию&nbsp;и&nbsp;дату&nbsp;компиляции&nbsp;в&nbsp;строку&nbsp;статуса.
<p>
</p></dd><dt><b>wall</b> <i>message</i>

</dt><dd>
<br>

<br>&nbsp;Вывести&nbsp;сообщения&nbsp;на&nbsp;все&nbsp;окна.&nbsp;Это&nbsp;сообщение&nbsp;будет&nbsp;показано&nbsp;в&nbsp;строке&nbsp;статуса&nbsp;терминала.
<p>
</p></dd><dt><b>width</b> [-w|-d] [<i>cols</i> [<i>lines</i>]]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Переключает&nbsp;ширину&nbsp;окна&nbsp;между&nbsp;80&nbsp;и&nbsp;132&nbsp;(или&nbsp;устанавливает&nbsp;равной&nbsp;заданной,&nbsp;при&nbsp;условии,&nbsp;если&nbsp;она&nbsp;указана).&nbsp;Требует&nbsp;поддержки&nbsp;
со стороны терминала (записи Z0 и Z1). См. команду <i>termcap</i>. Можно менять не только ширину6 но и высоту. Для этого нужно 
указать второй аргумент. Если задать ключ -w, меняется только ширина окна; если задать ключ -d, меняется только размер 
видимой области (display size). .RE
<p>
</p><dl compact="">
<dt><b>windowlist</b> [-b] [-m]

</dt><dd>
</dd><dt><b>windowlist</b> <b>string</b> [<i>string</i>]

</dt><dd>
</dd><dt><b>windowlist</b> <b>title</b> [<i>title</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Показывает&nbsp;список&nbsp;всех&nbsp;окон&nbsp;в&nbsp;виде&nbsp;таблицы&nbsp;для&nbsp;того&nbsp;чтобы&nbsp;можно&nbsp;было&nbsp;выбрать&nbsp;окно&nbsp;визуально.&nbsp;Окно&nbsp;выбирается&nbsp;стандартными&nbsp;
клавишами управления курсором (см. команды <i>copy</i>) и активируется клавишей <i>return</i>. Если задана опция .RS
<pre>-b
</pre>

</dd></dl>

, screen перед тем как показать список переключится на пустое окно, поэтому текущее окно можно тоже будет выбрать. Опция 
<dl compact=""><dt></dt><dd>
<pre>-m
</pre>

</dd></dl>

<br>&nbsp;задаёт&nbsp;порядок&nbsp;окон:&nbsp;вместо&nbsp;того&nbsp;чтобы&nbsp;сортировать&nbsp;их&nbsp;в&nbsp;порядке&nbsp;возрастания&nbsp;номеров,&nbsp;они&nbsp;сортируются&nbsp;по&nbsp;принципу,&nbsp;кто&nbsp;
использовался последним. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Формат&nbsp;таблицы&nbsp;можно&nbsp;изменить&nbsp;опциями&nbsp;<i>string</i>&nbsp;и&nbsp;<i>title</i>;&nbsp;в&nbsp;качестве&nbsp;заголовка&nbsp;таблицы&nbsp;показывается&nbsp;<i>title</i>,&nbsp;
а строки создаются на основе строк <i>string</i>. По умолчанию: заголовок "Num Name%=Flags" и строки "%3n %t%=%f". См. 
раздел "Escape-последовательности", где описано большее число кодов (в том числе цветовых). .RE
<p>
</p><dl compact="">
<dt><b>windows</b>

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Выводит&nbsp;в&nbsp;строке&nbsp;сообщений&nbsp;список&nbsp;всех&nbsp;окон.&nbsp;Каждое&nbsp;окно&nbsp;выводится&nbsp;с&nbsp;номером&nbsp;и&nbsp;именем&nbsp;процесса,&nbsp;который&nbsp;запущен&nbsp;в&nbsp;этом&nbsp;окне&nbsp;
(или заголовком); текущее окно отмечено символом "*", а предыдущее --- символом "-"; все окна, которые зарегистрированы 
(logged in) отмечены символом " .RS
<pre>$
</pre>

</dd></dl>

"; фоновые окна, в которых был звонок (bell), отмечены символом "
<dl compact=""><dt></dt><dd>
<pre>!
</pre>

</dd></dl>

"; фоновые окна, за которыми выполняется наблюдение, и в которых была замечена активность, отмечаются символом " .RS
<pre>@
</pre>

</dd></dl>
</dd></dl>

"; окна, в которых включена запись (logging),  отмечены символом "
<dl compact=""><dt></dt><dd>
<pre>(L)
</pre>

</dd></dl>

"; окна, занятые другим пользователем, отмечены символом "
<dl compact=""><dt></dt><dd>
<pre>&amp;
</pre>

</dd></dl>

"; окна, находящиеся в состоянии зомби, отмечены символом "
<dl compact=""><dt></dt><dd>
<pre>Z
</pre>

</dd></dl>

". Если список окон слишком большой и не влазит полностью на терминал, выводится только его часть.
</dd></dl>
</dd></dl>

<p>
</p></dd><dt><b>wrap</b> [<i>on</i>|<i>off</i>]

</dt><dd>
<br>

<br>&nbsp;Задаёт&nbsp;настройки&nbsp;переноса&nbsp;(line-wrap)&nbsp;для&nbsp;текущего&nbsp;окна.&nbsp;Если&nbsp;line-wrap&nbsp;включен,&nbsp;символ,&nbsp;следующий&nbsp;за&nbsp;последним&nbsp;выведенным&nbsp;
в строке, будет выводиться на следующей строке. Backspace (^H) при этом будет переходить на предыдущую строку через левый 
край. По умолчанию: <i>on</i> 
</dd><dt><b>writebuf</b> [-e <i>encoding</i>] [<i>filename</i>]

</dt><dd>
<br>

<br>&nbsp;Выводит&nbsp;содержимое&nbsp;буфера&nbsp;обмена&nbsp;в&nbsp;указанный&nbsp;файл&nbsp;или&nbsp;в&nbsp;общедоступный&nbsp;файл&nbsp;screen-exchnage,&nbsp;если&nbsp;никакой&nbsp;файл&nbsp;не&nbsp;указан.&nbsp;
Эту команду можно использовать для организации примитивного обмена данными между пользователями screen, работающими 
на одном компьютере. Если указана кодировка, текст налету перекодируется. Имя файла для обмена задаётся с помощью команды 
<i>bufferfile</i>; по умолчанию равно .RS
<pre>/tmp/screen-exchange
</pre>

</dd></dl>
</dd></dl>

<p>
</p><dl compact="">
<dt><b>writelock</b> [<b>on</b>|<b>off</b>|<b>auto</b>]

</dt><dd>
<br>

<br>&nbsp;В&nbsp;дополнение&nbsp;к&nbsp;спискам&nbsp;контроля&nbsp;доступа&nbsp;есть&nbsp;еще&nbsp;ограничение,&nbsp;которое&nbsp;запрещает&nbsp;писать&nbsp;нескольким&nbsp;пользователем&nbsp;в&nbsp;одно&nbsp;
окно одновременно. По умолчанию, writelock находится в режиме <i>auto</i> и эксклюзивный доступ на запись предоставляется 
тому пользователю, который первым переключился в это окно. Когда этот пользователь покидает окно, другие пользователи 
могут захватить блокировку (автоматически). Блокировка записи в текущее окно может быть отключена при помощи команды 
<i>writelock off</i>. Если пользователь даст команду <i>writelock on</i>, он сохранит за собой экслюзивную блокировку 
даже на время переключения в другие окна. 
</dd><dt><b>xoff</b>

</dt><dd>
</dd><dt><b>xon</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вставляет&nbsp;символ&nbsp;CTRL-s&nbsp;/&nbsp;CTRL-q&nbsp;в&nbsp;поток&nbsp;stdin&nbsp;текущего&nbsp;окна.
<p>
</p></dd><dt><b>zmodem</b> [<b>off</b>|<b>auto</b>|<b>catch</b>|<b>pass</b>]

</dt><dd>
</dd><dt><b>zmodem</b> <b>sendcmd</b> [<i>string</i>]

</dt><dd>
</dd><dt><b>zmodem</b> <b>recvcmd</b> [<i>string</i>]

</dt><dd>
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Настройка&nbsp;поддержки&nbsp;zmodem.&nbsp;Когда&nbsp;программа&nbsp;screen&nbsp;видит&nbsp;запрос&nbsp;zmodem,&nbsp;она&nbsp;понимает&nbsp;два&nbsp;режима&nbsp;работы:&nbsp;<i>pass</i>&nbsp;и&nbsp;
<i>catch</i>. Если задан режим <i>pass</i>, screen будет ретранслировать все данные, до тех пор пока передача не окончится. 
В режиме <i>cactch</i> screen сам работает как конечная точка zmodem и выполняет соответствующие команды rz/sz. Если включен 
режим <i>auto</i>, screen смотрит является ли окно терминалом tty (например, последовательным портом) и переходит в режим 
<i>cacth</i>, иначе использует <i>pass</i>. Можно задавать шаблоны для режима <i>catch</i> при помощи второй и третьей 
формы вызова. 
<br>

<br>&nbsp;<i>Это&nbsp;экспериментальная&nbsp;возможность!</i>
</dd></dl>

<p>
</p></dd><dt><b>zombie</b> [<i>keys</i>]

</dt><dd>
</dd><dt><b>defzombie</b> [<i>keys</i>]

</dt><dd>
<br>

<br>&nbsp;По&nbsp;умолчанию&nbsp;окна&nbsp;screen&nbsp;удаляются&nbsp;из&nbsp;списка,&nbsp;как&nbsp;только&nbsp;процессы&nbsp;окон&nbsp;(т.е.&nbsp;оболочки)&nbsp;завершаются.&nbsp;Если&nbsp;вызвать&nbsp;команду&nbsp;
<i>zombie</i> с аргументом из двух ключей, мёртвые окна будут оставаться. Убить такое окно можно с помощью команды kill. 
<br>&nbsp;Нажатие&nbsp;первой&nbsp;кнопки&nbsp;в&nbsp;мёртвом&nbsp;окне&nbsp;делает&nbsp;то&nbsp;же&nbsp;самое.&nbsp;&nbsp;Если&nbsp;нажать&nbsp;вторую&nbsp;кнопку,&nbsp;screen&nbsp;пытается&nbsp;оживить&nbsp;окно.&nbsp;Процесс,&nbsp;
который изначально работал в окне, запускается снова.  Если вызвать <i>zombie</i> без параметров, настройки собьются, 
то есть окна будут исчезать, как только процессы в них завершаются. .br
<br>&nbsp;Посколько&nbsp;настройки&nbsp;для&nbsp;зомби&nbsp;задаются&nbsp;одновременно&nbsp;на&nbsp;все&nbsp;окна,&nbsp;эту&nbsp;команду&nbsp;правильнее&nbsp;было&nbsp;бы&nbsp;назвать&nbsp;<i>defzombie</i>.&nbsp;
Пока не возникнет необходимость в команде действующей на отдельное окно, команды <i>zombie</i> и <i>defzombie</i> синонимы. 
<p>
</p></dd></dl>
</dd></dl>
</dd></dl>
<a name="lbAI">&nbsp;</a>
<h2> Строка сообщений </h2>

<p>

</p><p>
Screen выводит информационные и другие диагностические сообщения в строку сообщений (message line).
По умолчанию она показывается в самом низу окна, но при компиляции можно задать, 
чтобы эта строка показывалась вверху. Если у терминала есть статусная строка (status line),
будет использоваться она. Иначе, вывод на текущий экран будет временно переписан сверху.
Сообщение удаляется после нескольких секунд задержки, но оно может быть удалено и раньше, 
если начать печатать.
</p><p>
Строку сообщение можно использовать в приложениях с помощью управляющей последовательности
ANSI Privacy message. Например, можно в командном интерпретаторе дать команду:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    echo '&lt;esc&gt;^Hello world from window '$WINDOW'&lt;esc&gt;\\'

</pre>

</dd></dl>

Здесь &lt;esc&gt;  это escape, 
<dl compact=""><dt></dt><dd>
<pre>^ 
</pre>

</dd></dl>

<br>&nbsp;это&nbsp;стрелка&nbsp;вверх,&nbsp;а&nbsp;
<dl compact=""><dt></dt><dd>
<pre>\\
</pre>

</dd></dl>

<br>&nbsp;превращается&nbsp;в&nbsp;обратный&nbsp;слэш.
<p>
<a name="lbAJ">&nbsp;</a>
</p><h2> Типы окон </h2>

<p>

</p><p>
У screen есть три различных типа окон.
Новые окна создаются при помощи команды <i>screen</i> (см. соответствующую запись в разделе Индивидуальная настройка). 
Первый аргумент команды screen задаёт тип создаваемого окна. Различные типы окон  это модификации
нормального типа.  Они были сделаны для эффективной работы при количестве окон от 100 и выше.
</p><p>
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Нормальное&nbsp;окно,&nbsp;в&nbsp;котором&nbsp;запущен&nbsp;командный&nbsp;интерпретатор&nbsp;(по&nbsp;умолчанию)&nbsp;или&nbsp;любая&nbsp;другая&nbsp;команда,&nbsp;которая&nbsp;должна&nbsp;
исполняться изнутри интерпретатора. 
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Если&nbsp;в&nbsp;качестве&nbsp;первого&nbsp;параметра&nbsp;указан&nbsp;специальный&nbsp;файл&nbsp;устройства&nbsp;(например,&nbsp;"/dev/ttya"),&nbsp;screen&nbsp;напрямую&nbsp;пытается&nbsp;
к нему подключиться.  Окно этого типа равносильно окну, в котором запущено "screen cu -l /dev/ttya".  Нужны права на чтение 
и запись для соответствующего файла устройства; для того чтобы показать что линия занята, screen пытается открыть файл 
эксклюзивно.  Опциональный параметр может принимать значение разделённого запятыми списка флагов в нотации <b>stty</b>: 
</p><p>
</p><dl compact="">
<dt><b>&lt;baud_rate&gt;</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Обычно&nbsp;300,&nbsp;&nbsp;1200,&nbsp;9600&nbsp;или&nbsp;19200.&nbsp;Влияет&nbsp;как&nbsp;на&nbsp;скорость&nbsp;передачи,&nbsp;так&nbsp;и&nbsp;на&nbsp;скорость&nbsp;приёма.&nbsp;
</dd><dt><b>cs8 или cs7</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Задаёт&nbsp;передачу&nbsp;восьми&nbsp;или&nbsp;семи&nbsp;битов&nbsp;на&nbsp;байт.
<p>
</p></dd><dt><b>ixon или -ixon</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Включает&nbsp;(или&nbsp;выключает)&nbsp;программное&nbsp;управление&nbsp;потоком&nbsp;(CTRL-S/CTRL-Q)&nbsp;при&nbsp;передаче&nbsp;данных.&nbsp;
</dd><dt><b>ixoff или -ixon</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Включает&nbsp;(или&nbsp;выключает)&nbsp;программное&nbsp;управление&nbsp;потоком&nbsp;при&nbsp;приёме&nbsp;данных.
<p>
</p></dd><dt><b>istrip или -istrip</b>

</dt><dd>
<br>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Удаляет&nbsp;(или&nbsp;сохраняет)&nbsp;восьмой&nbsp;бит&nbsp;в&nbsp;каждом&nbsp;полученном&nbsp;байте.
<p>
</p><dl compact=""><dt></dt><dd>
<br>&nbsp;Можно&nbsp;указывать&nbsp;столько&nbsp;этих&nbsp;опций&nbsp;сколько&nbsp;нужно.&nbsp;&nbsp;Если&nbsp;опции&nbsp;не&nbsp;задавать,&nbsp;решение&nbsp;о&nbsp;значении&nbsp;параметров&nbsp;соединения&nbsp;принимает&nbsp;
драйвер терминала.  Эти значения зависят от системы. Они могут или принимать значения по умолчанию или значения, сохранённые 
с прошлого соединения. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Для&nbsp;tty-окон&nbsp;команда&nbsp;<i>info</i>&nbsp;показывает&nbsp;в&nbsp;строке&nbsp;статуса&nbsp;состояние&nbsp;управляющих&nbsp;линий&nbsp;модема.&nbsp;&nbsp;В&nbsp;их&nbsp;числе&nbsp;могут&nbsp;быть&nbsp;
"RTS", "CTS",  "DTR", "DSR",  "CD"  и другие.  Список линий зависит от того какие ioctl() доступны, от системных заголовчных 
файлов, а также от физических возможностей платы последовательных портов.  Перед названием неактивных (low level) сигналов 
ставится восклицательный знак (!).  Если знака нет, значит сигнал активен (high level).  Сигналы, которые не поддерживаются 
оборудованием, но доступны через ioctl(), обычно показываются выключенными (low level).  Если локальный бит состояния 
CLOCAL включен, весь набор сигналов модема выводится в фигурных скобках ({ и }).  Если установлен бит CRTSCTS или TIOCSOFTCAR, 
в скобках показываются сигналы "CTS" или "CD",  соответственно. .RE
<dl compact=""><dt></dt><dd>
<br>&nbsp;Для&nbsp;tty-окон&nbsp;команда&nbsp;<i>break</i>&nbsp;переводит&nbsp;линию&nbsp;передачи&nbsp;данных&nbsp;(Data&nbsp;transmission&nbsp;line)&nbsp;(TxD)&nbsp;в&nbsp;неактивное&nbsp;состояние&nbsp;
на заданный период времени. На той стороне это должно проинтерпретироваться как сигнал разрыва.  При нажатии break данные 
не отправляются, линии управления модемом не трогаются. .RE
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Если&nbsp;первый&nbsp;параметр&nbsp;это&nbsp;"//telnet",&nbsp;&nbsp;второй&nbsp;параметр&nbsp;должен&nbsp;быть&nbsp;именем&nbsp;хоста,&nbsp;опциональный&nbsp;третий&nbsp;параметр&nbsp;&nbsp;номером&nbsp;
порта (по умолчанию 23, десятиричное).  Screen подсоединится к удалённому серверу при помощи протокола Telnet.  Для telnet-окон 
команда <i>info</i> показывает в конце статусной строки в квадратных скобках ([ и ]) детальную информацию о соединении. 
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    b      BINARY. Соединение в двоичном (бинарном) режиме.
    e      ECHO. Локальное эхо выключено.
    c      SGA.  Соединение в символьном режиме (character mode). По умолчанию в режиме строки (line mode).     t      TTYPE. Тип терминала был запрошен удалённым хостом.
        Screen отправляет имя "screen", если не задано ничего другого
        (см. также команду <i>term</i>).
    w      NAWS. Удалённая система предупреждается об изменении размера окна.
    f      LFLOW.  Удалённый хост отправит информацию об управлении потоком.
        (Сейчас игнорируется.)

</pre>

</dd></dl>

Дополнительные флаги для отладки: 
<dl compact=""><dt></dt><dd>
<pre>x
</pre>

</dd></dl>

, 
<dl compact=""><dt></dt><dd>
<pre>t
</pre>

</dd></dl>

<br>&nbsp;и&nbsp;
<dl compact=""><dt></dt><dd>
<pre>n
</pre>

</dd></dl>

<br>&nbsp;(XDISPLOC,&nbsp;TSPEED&nbsp;&nbsp;и&nbsp;NEWENV).
<p>
Для окон telnet команда <i>break</i> отправляет удалённому хосту Telnet-код IAC BREAK (десятичный 243). 
Этот тип окна доступен только в том случае, если screen был откомпилирован с опцией BUILTIN_TELNET.
</p><p>
</p></dd></dl>
</dd></dl>
</dd></dl>
</dd></dl>
<a name="lbAK">&nbsp;</a>
<h2> Escape-последовательности </h2>

<p>

</p><p>
У screen есть механизм escape-последовательностей,  с  помощью которых
в сообщения или имена  файлов  можно  вставлять  различную  информацию,
например, такую  как текущее время.  Escape-символ это всегда символ %,
за одним исключением: внутри строки hardstatus используется ^% (^E).
</p><p>
Полный список поддерживаемых escape-последовательностей:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>       %      сам escape-символ
       a      или "am", или "pm" 
       A      или "AM", или "PM"
       c      текущее время HH:MM в 24-часовом формате
       C      текущее время HH:MM в 12-часовом формате
       d      номер дня
       D      название дня недели
       f      флаги окна
       F      устанавливает %? равным true (истина), если окно получает фокус
       h      статус окна (hardstatus)
       H      имя системы (hostname)
       l      текущий уровень нагрузки на систему
       m      номер месяца
       M      имя месяца
       n      номер окна
       s      секунды
       t      заголовок окна
       u      остальные пользователи на этом окне
       w      номера и имена всех окон. С символом "-" до текущего окна; с символом "+"
              после текущего окна
       W      номера и имена всех окон за исключением текущего 
       y      последние две цифры года
       Y      полный год
       ?      показывается часть до следующего знака %? (только если % внутри этой части 
              раскрывается в не пустую строку)
       :      часть else %?

       =      заполнить строку на ширину экрана (как hfill в TeX). Если задан номер, 
              number is specified, pad  to  the  percentage  of  the  windows
              width.   Квалификатор  "0"  говорит о том, что номер надо воспринимать как 
              абсолютную позицию.
              You can specify to pad relative to the  last
              absolute  pad position by adding a "+" qualifier or to pad rela
              tive to the right margin by using "-". The padding truncates the
              string  if  the specified position lies before the current posi
              tion. Для того чтобы изменить это, нужно использовать квалификатор "L".

       &lt;      то же что и "%=", но только обрезать, и не заполнять пробелами

       &gt;      поставить отметку в текущей позиции для следующей обрезки.
              Когда screen должен сделать обрезку, он старается сделать её так,
              что бы маркированная позиция переместилась на заданный процент 
              области вывода.
              (Область начинается с последней абсолютной позиции заполнителя
              и заканчивается в месте, заданном оператором обрезки).
              Дополнительный символ "L" говорит screen о том, что нужно отметить
              обрезанный кусочек символами "...".

       {      строка-модификатор атрибута/цвета, заканчивающаяся следующим "}"

       `      Заменить команды внутри кавычек результатом их выполнения. The  length
              qualifier is misused to identify one of the commands.

</pre>

</dd></dl>

С последовательностями "c"  и "C" можно использовать квалификатор "0"  тогда для заполнения пустого пространства будет использоваться "0", а не пробел. Если использовать квалификатор "0", в escape-последовательности 
"=" позиции начинают восприниматься как абсолютные.
Escape-коды "n" и "=" понимают квалификатор длины
(например, "%3n"); перед "D" и "M" можно ставить "L" для того чтобы генерировать длинные имена "L", а если поставить "L" 
перед "w" или "W", будут показываться флаги окон.
<p>
Модификатор атрибута/цвета используется для изменения настроек атрибута
или цвета. Его формат "[модификатор атрибута] [описание цвета]".   Если 
модификатор атрибута можно перепутать с описанием цвета, перед ним надо
ставить специальный индикатор изменения типа.   Это  один  из следующих
символов:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    +      добавляет указанное множество к текущим атрибутам 
    -      удаляет указанное множество из текущих атрибутов
    !      инвертирует множество текущих атрибутов
    =      заменяет множество текущих атрибутов на указанное множество

</pre>

</dd></dl>

Множество атрибутов может быть задано или в виде шестнадцатеричного числа 
или в виде комбинации следующих букв:
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    d      тусклый
    u      подчёркнутый
    b      полужирный
    r      реверсивный
    s      выдающийся
    B      мигающий

</pre>

</dd></dl>

Цвета или кодируются шестнадцатеричным числом или комбинацией двух букв,
указывающих цвет фона и цвет символа (в таком порядке). Известны  такие
цвета:
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    k      чёрный
    r      красный
    g      зелёный
    y      жёлтый
    b      синий
    m      фиолетовый
    c      цвета морской волны
    w      белый 
    d      по умолчанию
    .      оставить цвет без изменения

</pre>

</dd></dl>

Буквы в верхнем регистре обозначают яркие цвета. Можно использовать букву
псевдо-цвет "i", которая меняет яркость, но оставляет сам цвет таким же.
A  one digit/letter color description is treated as foreground or back
ground color dependant on the current attributes: если установлен реверсивный режим, 
меняется фон, а не цвет символа.
Если поставить перед цветом ".", так происходить не будет. 
Если нужно такое же поведение, как при двусимвольном описании цвета,
нужно тоже ставить ".".
Особый случай, "%{ - }" восстанавливает атрибуты и цвет, которые были 
установлены до того как были сделаны последние изменения (грубо говоря, 
выталкивает один уровень изменений цвета из стека).
<p>
Примеры:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    "G"    установить ярко-зелёный цвет

    "+b r" использовать красный полужирный

    "= yd" стереть все атрибуты, писать цветом по умолчанию на жёлтом фоне

    %-Lw%{= BW}%50&gt;%n%f* %t%{ - }%+Lw%&lt;
            Список окон обрезанный до доступной величины (слева и справа). Имя
            текущего окна выводится белым на синем фоне. Можно использовать
            вместе с "hardstatus alwayslastline".

    %?%F%{.R.}%?%3n %t%? [%h]%?
            Номер окна, заголовок и hardstatus, если он установлен. Красный 
            фон, если есть фокус. Удобно для строки заголовка.

</pre>

</dd></dl>

<p>
<a name="lbAL">&nbsp;</a>
</p><h2> Управление потоком </h2>

<p>

</p><p>

</p><p>
У каждого окна есть настройки управления потоком (flow-control), которые определяют,
как screen будет работать с XON и XOFF символами (и, возможно, символом разрыва).
Когда управление потоком включено, screen игнорирует XON и XOFF символы, 
и пользователю для того чтобы отправить их в программу, нужно просто нажать их
(это полезно, например, для редактора Emacs).
Минус в том, что обычной программе нужно больше времени для того чтобы 
остановиться, когда она увидит XOFF. Если управление потоком включено,
XON и XOFF немедленно останавливают вывод в текущее окно.
Эти символы по-прежнему можно отправить программе, но для этого нужно 
использовать соответствующие двухсимвольные команды screen ("C-a q" (xon) и "C-a s" (xoff)).
Команды xon/xoff также полезны для передачи симолов C-s и C-q в обход терминала,
который перехватывает эти символы.
</p><p>
У каждого окна есть начальная настройка управления потоком, которая задаётся
или опцией 
</p><dl compact=""><dt></dt><dd>
<pre>-f
</pre>

</dd></dl>

<br>&nbsp;или&nbsp;командой&nbsp;<i>defflow</i>&nbsp;из&nbsp;файла&nbsp;
<dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<p>
По умолчанию окна настроены на автоматическое переключение потока.
Потом состояние можно интерактивно переключать с помощью комбинации
клави "C-a f" или команды "flow" между вариантами
"fixed on", "fixed off" и "automatic".
</p><p>
Режим автоматического переключения потока (automatic flow-switching mode)
работает с управлением потоком через режим TIOCPKT  (как "rlogin"). Если драйвер терминала не поддерживает TIOCPKT, screen пытается найти правильный режим исходя из текущих настроек
клавиш приложения (application keypad)  когда он включен, управление потоком выключено
и наоборот. Конечно, если нужно можно манипулировать управлением потоком вручную,
то такая возможность есть.
</p><p>
Если screen работает с включённым аппаратным управлением потоком,
и нажатие клавиши прерывания (обычно C-c) срабатывает не сразу, а 
после того как прокрутятся ещё 6-8 строк, нужно попробовать запустить
screen с опцией "interrupt" (нужно добавить флаг "interrupt" к команде "flow" в файле 
</p><dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<p>
или использовать опцию 
</p><dl compact=""><dt></dt><dd>
<pre>-i
</pre>

</dd></dl>

).
В этом случае вывод, который screen накопил от интерактивных программ,
очищается.
Минус заключается в том, что память виртуального терминала 
хранит не выведенный вывод, что иногда может приводить к неточностям
при отображении.  Например, если переключить экран, а потом вернуться,
или обновить экран при помощи "C-a l",
на экране будет вывод такой же, как если бы "interrupt" был выключен.
Если выполнять программу, которой нужно передать символ прерывания как ввод
(например, прервать вывод виртуального терминала на физический),
нужно выключать управление потоком (или использовать режим auto-flow для того чтобы выключать его автоматически) В этой ситуации простое обновление экрана screen с помощью "C-a l" вернёт всё в исходное состояние. Можно попробовать все режимы, и использовать тот, который удобнее.
<p>
<a name="lbAM">&nbsp;</a>
</p><h2> Названия (именование окон) </h2>

<p>

</p><p>
Имена окон (которые выводятся, например, по команде <i>windows</i>, "C-a w")
можно настраивать одной из команд <i>title</i>.
Обычно имя окна это имя команды, запущенной в этом окне.
Но иногда хочется что бы окна с одной командой как-то отличались,
или что бы имя менялось на ходу и отражало текущее состояние окна.
</p><p>
Имя по умолчанию для всех окон с оболчками (shell windows) можно задать командой <i>shelltitle</i>
из файла 
</p><dl compact=""><dt></dt><dd>
<pre></pre>

</dd></dl>

<br>&nbsp;Имена&nbsp;окон,&nbsp;которые&nbsp;создаются&nbsp;по&nbsp;команде&nbsp;screen,&nbsp;
можно задать при помощи ключа 
<dl compact=""><dt></dt><dd>
<pre>-t
</pre>

</dd></dl>

<br>&nbsp;в&nbsp;этой&nbsp;команде.
Для интерактивной смены есть escape-последовательность
(&lt;esc&gt;kname&lt;esc&gt;\)  и команда <i>title</i> (C-a A).
В первом случае строку может выводить приложение, работающее в окне, автоматически,
а во втором  имя вводится интерактивно в соответствующее приглашение.
И ещё можно создавать привязки установку предопределённых имён
на комбинации клавиш и не вводить их каждый раз.
<p>
Кроме всего прочего, у screen есть специальный механизм,
который включается путём установки имени окна равным "search|name".
Для этого нужно чтобы в приглашение выводилась специальная невидимая
escape-последовательность.
Часть "search" задаёт строку которая будет считаться концом приглашения,
а часть "name" определяет имя по умолчанию для этого окна.
Если имя оканчивается на ":", screen дописывает имя текущей команды (с его точки зрения), работающей в окне, к названию оболочки окна (например, "name:cmd"). Иначе имя команды, пока она выполняется, перекрывает имя оболочки. 
</p><p>
Вот как это работает:  нужно изменить приглашение командного интерпретатора
так, чтобы невидимая строка title-escape-sequence (&lt;esc&gt;k&lt;esc&gt;\) выводилась как его часть.
Последняя часть приглашения должна быть в точности равна 
строке, которая была задана как строка для поиска заголовка окна.
При такой настройке screen при помощи title-escape-sequence будет очищать название предыдущей
команды и ждать следующей.
Потом, когда он увидит что от оболочки получен перевод строки, он ищет окончание приглашения.
Если находит, первое слово после него считает именем команды.
Если команда начинается с "!", "%" или "^", screen возьмёт имя не из этой строки, а из следующей за ней. Это нужно для тех, кто пользуется механизмами управления работами (job control) и истории.
</p><p>
Вот несколько примеров команд из .screenrc:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    screen -t top 2 nice top

</pre>

</dd></dl>

Если добавить эту строку в файл .screenrc, то на окне 2 будет запускаться 
top с пониженным приоритетом (через nice).  Окно будет называться "top",
а не "nice".
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    shelltitle '&gt; |csh'
    screen 1

</pre>

</dd></dl>

В результате  выполнения  команды  будет  запущена  оболочка  с  заданным
заголовком shelltitle. 
Заголовок автоматический, который предполагает что 
приглашение  и  команда выглядят следующим образом:
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    /usr/joe/src/dir&gt; trn

</pre>

</dd></dl>

(имя команды ищется после 
<dl compact=""><dt></dt><dd>
<pre>&gt;
</pre>

</dd></dl>

).
В строке статуса окна будет "trn" пока команда выполнятся 
и "csh", после того как она завершится.
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bind R screen -t '% |root:' su

</pre>

</dd></dl>

Если добавить такую команду в файл .screenrc, комбинация клавиш 'C-a R'
будет привязана к команде "su" (с заголовком "root:"). Если это автоматическое именование работает, будет происходить 
так: 
<dl compact=""><dt></dt><dd>
<pre>    % !em
    emacs file.c

</pre>

</dd></dl>

Здесь пользователь ввёл команду истории "!em", которая вызвала введённую ранее
команду <i>emacs</i>.  Статусная строка окна во время исполнения команды 
будет показывать "root:emacs", а после того как она завершится, 
превратится в просто "root:".
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    bind o title
    bind E title ""
    bind u title (unknown)

</pre>

</dd></dl>

У  первой  привязки  нет  аргументов, поэтому при нажатии "C-a o" нужно
будет ввести заголовок. При нажатии второй комбинации "C-a E" очищаются настройки 
текущие автоматического заголовка (auto-title).
Третья привязка: по нажатию C-a u 
устанавливать заголовок текущего окна равным "(unknown)".
<p>
При добавлении невидимой строки в приглашение нужно помнить, что некоторые интерпретаторы 
(такие как csh) учитывают все неуправляющие символы 
при вычислении длины приглашения.
Если число этих невидимых символов не кратно 8, то при удалении табуляции с помощью backspace
появится ошибки при отображении.
Один способ обойти эту проблему  использовать
приглашение наподобие такого:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    set prompt='^[[0000m^[k^[\% '

</pre>

</dd></dl>

Escape-последовательность "&lt;esc&gt;[0000m" не только нормализует атрибуты символов,
но и округляет нулями число невидимых символов до кратного 8.
Пользователи <b>bash</b> могут задавать escape-последовательности в
переменной 
<dl compact=""><dt></dt><dd>
<pre>PROMPT_COMMAND
</pre>

</dd></dl>

:
<p>
</p><dl compact=""><dt></dt><dd>
<pre>    PROMPT_COMMAND='echo -n -e "\033k\033\134"'

</pre>

</dd></dl>

(Здесь используется строка "134" для вывода символа \ из за ошибки в версии 1.04).
<p>
<a name="lbAN">&nbsp;</a>
</p><h2> Виртуальный терминал </h2>

<p>

</p><p>
Каждое окно в сеансе screen эмулирует терминал VT100 с некоторыми дополнительными функциями.
Может эмулироваться только VT100, это жёстко зашитое ограничение screen.
Как правило, screen старается выполнять эмуляцию как можно ближе к VT100/ANSI.
Но если у терминала, на котором выполняется screen, не хватает некоторых возможностей,
эмуляция будет частичной. 
В этом случае screen должен сообщить приложению, что некоторых возможностей
не будет. Это несложно на машинах, использующих termcap, 
потому что screen может использовать переменную 
</p><dl compact=""><dt></dt><dd>
<pre>$TERMCAP
</pre>

</dd></dl>

<p>
для подстройки своего стандартного termcap.
</p><p>
Но при удалённом заходе на машину, которая поддерживает только terminfo, 
этот метод работать не будет. У screen есть способ, который он использует
в этой ситуации.
</p><p>
Когда screen хочет определить имя терминала для себя,
сначала он пытается найти запись "screen.&lt;term&gt;", где &lt;term&gt; это содержимое переменной
$TERM.  Если такой записи нет, screen пробует найти "screen"
(или  "screen-w" для широких терминалов (132 колонки или больше)).  Если и эту запись найти не удаётся, используется "vt100" как заменитель.
</p><p>
Если терминал не поддерживает важную функцию (например, удаление символа или очистку до конца строки), можно сделать новую запись termcap/terminfo для screen (и назвать её "screen.&lt;dumbterm&gt;"),
в которой эта возможность будет отключена. 
</p><p>
Когда такая запись есть на машине, при удалённом заходе на неё termcap/termifo-запись будет правильной. Имя терминала указывается в переменной  $TERM новых окон.
Кроме этого, screen устанавливает переменную 
</p><dl compact=""><dt></dt><dd>
<pre>$TERMCAP
</pre>

</dd></dl>

, так что бы она отражала возможности
эмулируемого терминала. Следует заметить, что на машинах, где используется
база данных terminfo, эта переменная ничего не значит.
И ещё в переменной $WINDOW устанавливается номер окна.
<p>
Действительное множество возможностей, поддерживаемых виртуальным терминалом, 
зависит от того какие возможности поддерживаются физическим терминалом.
Если, физический терминал не поддерживает, скажем, режим подчёркивания,
screen не указывает возможности <i>us</i> и <i>ue</i> в переменной 
</p><dl compact=""><dt></dt><dd>
<pre>$TERMCAP
</pre>

</dd></dl>

<p>
для окон. Тем не менее, для того чтобы screen работал, минимум возможностей
терминалом должен поддерживаться всё равно; в частности, прокрутка, очистка,
прямая адресация курсора (кроме того, screen не будет работать на hardcopy-терминалах
и на overstrike-терминалах).
</p><p>
Значение переменной 
</p><dl compact=""><dt></dt><dd>
<pre>$TERMCAP
</pre>

</dd></dl>

<br>&nbsp;можно&nbsp;изменить&nbsp;с&nbsp;помощью&nbsp;
команды .screenrc  "termcap" или, если задать переменную 
<dl compact=""><dt></dt><dd>
<pre>$SCREENCAP
</pre>

</dd></dl>

<br>&nbsp;
до запуска screen.
В последнем случае её значение копируется в неизменном виде в переменную TERMCAP для каждого окна.
В ней может быть или полное определение терминала или имя файла, где 
определён терминал "screen" и/или "screen-w".
<p>
Если в системе используется база данных terminfo, а не termcap,
имейте в виду, что у screen есть команда <i>terminfo</i>.
</p><p>
Если в записи termcap терминала, на котором был вызван screen, присутствует 
булевая возможность "G0", терминал поддерживает несколько наборов символов (charsets).
Это даёт возможность приложению использовать,
например, или псевдографическое множество символов, или множество символов национального алфавита
в терминале VT100.  Поддерживаются следующие управляющие функции из ISO 2022: 
lock  shift  G0  (SI), lock shift G1 (SO), lock shift G2, lock
shift G3, single shift G2, и single shift G3.  При создании или сбросе виртуального терминала
таблица символов ASCII назначается на G0, G1, G2 и G3.
Если есть возможность "G0" возможность, screen вычисляет возможности
"S0", "E0", и "C0", если есть. "S0" это последовательность, которую
терминал использует для того, чтобы включить псевдографический набор символов вместо SI.
"E0"  соответствующая замена для SO. "C0" даёт строку посимвольного соответствия.
Эта строка используется в псевдографическом режиме.
Строка строится так же как и возможность "acsc" terminfo.
</p><p>
Если в termcap-записи терминала присутствуют возможности "po" и "pf",
приложения, работающие в screen, могут отправлять вывод на печать
через порт печати терминала.
Приложение в одном окне отправляет данные на принтер, подсоединённый к терминалу,
а другие окна при этом продолжают работать
(порт принтера активируется и деактивируется заново для каждой порции выводимых данных).
Побочный эффект: программы, работающие в разных окнах одновременно, могут отправлять данные на печать одновременно. 
Данные, которые отправляются на печать, не показываются в окне.
Пока печать активна, команда <i>info</i> будет показывать строку, начинающуюся символами 
</p><dl compact=""><dt></dt><dd>
<pre>PRIN
</pre>

</dd></dl>

<p>
Каждому экрану screen предоставляет статусную строку hardstatus.  Когда какое-то окно становится
активным, hardstatus дисплея обновляется, и он отражает hardstatus соответствующего окна.
Если у дисплея нет строки hardstatus, строка показывается как обычное сообщение screen.
Строку hardstatus можно поменять с помощью  ANSI   Application   Program   Command   (APC):
"ESC_&lt;string&gt;ESC\". Для удобства пользователей xterm принимается строка "ESC]0..2;&lt;string&gt;^G".
</p><p>
Некоторые возможности только тогда указываются в переменной $TERMCAP для виртуального терминала,
если они могут быть эффективно реализованы с помощью физического терминала.
Например, "dl" (delete line) указывается в переменной $TERMCAP только при условии, если терминал 
поддерживает или удаление строки, или прокрутку регионов.
При переподключении с другого терминала может возникнуть путаница,
потому что значение 
</p><dl compact=""><dt></dt><dd>
<pre>$TERMCAP
</pre>

</dd></dl>

<br>&nbsp;родительские&nbsp;процессы&nbsp;у&nbsp;дочерних
уже изменить не смогут.
<p>
Альтернативный экран (alternate  screen) не включен по умолчанию. Для того чтобы его включить, 
нужно вызвать команду <i>altscreen</i>.
</p><p>
Ниже приводится список управляющих последовательностей,
которые распознаёт screen.
"(V)" и "(A)" обозначают функции специфичные для VT100- и для ANSI- или ISO- соответственно.
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>       ESC E                      Следующая строка
       ESC D                      Индекс
       ESC M                      Обратный индекс
       ESC H                      Horizontal Tab Set
       ESC Z                      Send VT100 Identification String
       ESC 7                 (V)  Save Cursor и Attributes
       ESC 8                 (V)  Восстановить курсор и атрибуты
       ESC [s                (A)  Save Cursor и Attributes
       ESC [u                (A)  Restore Cursor и Attributes
       ESC c                      Сбросить в начальное состояние
       ESC g                      Визуальный звонок
       ESC Pn p                   Видимость курсора (97801)
           Pn = 6                 Невидимый
                7                 Видимый
       ESC =                 (V)  Режим клавиатуры приложения
       ESC &gt;                 (V)  Режим цифровой клавиатуры
       ESC # 8               (V)  Заполнить экран E
       ESC \                 (A)  Завершение строки (string terminator)
       ESC ^                 (A)  Privacy Message String
       ESC !                      Global Message String
       ESC k                      A.k.a. Definition String
       ESC P                 (A)  Device Control  String.   Выводит строку прямо на терминал,
                                  без обработки.
       ESC _                 (A)  Команда приложения (Hardstatus)
       ESC ] 0 ; string ^G   (A)  Команда операционной систем (Hardstatus, xterm title hack)
       ESC ] 83 ; cmd ^G     (A)  Выполнить команду screen. Работает только если в screen вкомпилирована                                   многопользовательская поддержка.
                                  При проверке acl используется псевдопользователь ":window:".
                                  Команда "addacl  :window:  -rwx  #?"  создаёт пользователя без прав,                                   разрешает ему только нужные команды.
       Control-N             (A)  Lock Shift G1 (SO)
       Control-O             (A)  Lock Shift G0 (SI)
       ESC n                 (A)  Lock Shift G2
       ESC o                 (A)  Lock Shift G3
       ESC N                 (A)  Single Shift G2
       ESC O                 (A)  Single Shift G3
       ESC ( Pcs             (A)  Designate character set as G0
       ESC ) Pcs             (A)  Designate character set as G1
       ESC * Pcs             (A)  Designate character set as G2
       ESC + Pcs             (A)  Designate character set as G3
       ESC [ Pn ; Pn H            Прямая адресация курсора
       ESC [ Pn ; Pn f            то же
       ESC [ Pn J                 Удалить на экране
             Pn = None or 0       От курсора до конца экрана
                  1               От начала экрана до курсора
                  2               Весь экран
       ESC [ Pn K                 Удалить в строке
             Pn = None or 0       От курсора до конца строки
                  1               От начала строки до курсора
                  2               Всю строку
       ESC [ Pn X                 Удалить символ
       ESC [ Pn A                 Курсор вверх
       ESC [ Pn B                 Курсор вниз
       ESC [ Pn C                 Курсор вправо
       ESC [ Pn D                 Курсор влево
       ESC [ Pn E                 Курсор на следующую строку (cursor next line)
       ESC [ Pn F                 Курсор на предыдущую строку (cursor previous line)
       ESC [ Pn G                 Горизонтальная позиция курсора
       ESC [ Pn '                 то же
       ESC [ Pn d                 Вертикальная позиция курсора
       ESC [ Ps ;...; Ps m        Выбрать графическое начертание
             Ps = None or 0       Стандартное начертание
                  1               Полужирный
                  2          (A)  Бледный (faint)
                  3          (A)  Выделяющийся (ANSI: курсив)
                  4               Подчеркнутый
                  5               Мигающий
                  7               Инвертированный
                  22         (A)  Нормальная интенсивность
                  23         (A)  Выделение выключено (ANSI: курсив выключен)
                  24         (A)  Без подчёркивания
                  25         (A)  Не мигать
                  27         (A)  Позитивное изображение
                  30         (A)  Цвет символов чёрный
                  31         (A)  Цвет символов красный
                  32         (A)  Цвет символов зелёный
                  33         (A)  Цвет символов жёлтый
                  34         (A)  Цвет символов синий
                  35         (A)  Цвет символов фиолетовый
                  36         (A)  Цвет символов морской волны
                  37         (A)  Цвет символов белый
                  39         (A)  Цвет символов по умолчанию
                  40         (A)  Цвет фона чёрный
                  ...
                  49         (A)  Цвет фона по умолчанию
       ESC [ Pn g                 Удалить табуляцию
             Pn = None or 0       Удалить табуляцию на текущей позиции
                  3               Стереть все табуляции
       ESC [ Pn ; Pn r       (V)  Задать регион прокрутки
       ESC [ Pn I            (A)  Горизонтальная табуляция
       ESC [ Pn Z            (A)  Обратная табуляция
       ESC [ Pn L            (A)  Вставить строку
       ESC [ Pn M            (A)  Удалить строку
       ESC [ Pn @            (A)  Вставить символ
       ESC [ Pn P            (A)  Удалить символ
       ESC [ Pn S                 Прокрутить область прокрутки вверх
       ESC [ Pn T                 Прокрутить область прокрутки вниз
       ESC [ Pn ^                 то же
       ESC [ Ps ;...; Ps h        Режим Set
       ESC [ Ps ;...; Ps l        Режим Reset
             Ps = 4          (A)  Режим вставки (Insert)
                  20         (A)  Режим автоматической прокрутки (Automatic Linefeed)
                  34              Нормальная видимость курсора
                  ?1         (V)  Клавиши управления курсором приложения
                  ?3         (V)  Изменить ширину терминала на 132 колонки
                  ?5         (V)  Реверсивное видео
                  ?6         (V)  Origin-режим
                  ?7         (V)  Wrap-режим
                  ?9              Отслеживание мыши X10
                  ?25        (V)  Видимый курсор

                  ?47             Alternate Screen (old xterm code)
                  ?1000      (V)  Отслеживание мыши VT200
                  ?1047           Альтернативный экран (новый xterm-код)
                  ?1049           Альтернативный экран (новый xterm-код)

       ESC [ 5 i             (A)  Начать ретрансляцию на принтер (ANSI Media Copy)
       ESC [ 4 i             (A)  Остановить ретрансляцию на принтер (ANSI Media Copy)
       ESC [ 8 ; Ph ; Pw t        Изменить размер для Resize the window to  "Ph"  lines  и  "Pw"
                                  колонок (для SunView)
       ESC [ c                    Отправить идентификационную строку VT100
       ESC [ x                    Отправить отчёт с параметрами терминала
       ESC [ &gt; c                  Отправить строку атрибутов вторчного устройства VT220 
                                  (VT220   Secondary  Device  Attributes)
       ESC [ 6 n                  Отправить отчёт о позиции курсора

</pre>

</dd></dl>

<p>
<a name="lbAO">&nbsp;</a>
</p><h2> Трансляция при вводе </h2>

<p>

</p><p>
Для того чтобы полностью эмулировать VT100 
screen должен определять, нажатием какой клавиши
была сгенерирована последовательность во входном потоке,
и превращать её в последовательность подходящую VT100.
</p><p>
Screen очень гибок в этом вопросе  он позволяет привызывать произвольные команды
к произвольным последовательностям символов.
В случае простой эмуляции VT100 команда будет вставлять 
строку в буфер ввода окна (см. команду <i>stuff</i>).
Последовательности, которые генерируются по нажатию клавиши,
могут измениться при подключении из терминала с другим типом.
Чтобы обойти эту проблему, можно привязывать команды к termcap-именам клавиш.
Screen будет делать правильные привязки после каждого повторного подключения.
Более подробная информация и примеры использования есть в описании команды <i>bindkey</i>.
</p><p>
Ниже представлена таблица привязок по умолчанию (default key bindings). (A) обозначает,
что команда выполняется, если клавиатура переключена в режим приложения.
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>       Клавиша           Имя termcap     Команда
       ______________________________________________________
       Курсор вверх          ku          stuff \033[A
                                         stuff \033OA    (A)
       Курсор вниз           kd          stuff \033[B
                                         stuff \033OB    (A)
       Курсор вниз           kr          stuff \033[C
                                         stuff \033OC    (A)
       Курсор влево          kl          stuff \033[D
                                         stuff \033OD    (A)
       F0                    k0          stuff \033[10~
       F1                    k1          stuff \033OP
       F2                    k2          stuff \033OQ
       F3                    k3          stuff \033OR
       F4                    k4          stuff \033OS
       F5                    k5          stuff \033[15~
       F6                    k6          stuff \033[17~
       F7                    k7          stuff \033[18~
       F8                    k8          stuff \033[19~
       F9                    k9          stuff \033[20~
       F10                   k;          stuff \033[21~
       F11                   F1          stuff \033[23~
       F12                   F2          stuff \033[24~
       Home                  kh          stuff \033[1~
       End                   kH          stuff \033[4~
       Insert                kI          stuff \033[2~
       Delete                kD          stuff \033[3~
       Page up               kP          stuff \033[5~
       Page down             kN          stuff \033[6~
       Серый  0              f0          stuff 0
                                         stuff \033Op    (A)
       Серый  1              f1          stuff 1
                                         stuff \033Oq    (A)
       Серый  2              f2          stuff 2
                                         stuff \033Or    (A)
       Серый  3              f3          stuff 3
                                         stuff \033Os    (A)
       Серый  4              f4          stuff 4
                                         stuff \033Ot    (A)
       Серый  5              f5          stuff 5
                                         stuff \033Ou    (A)
       Серый  6              f6          stuff 6
                                         stuff \033Ov    (A)
       Серый  7              f7          stuff 7
                                         stuff \033Ow    (A)
       Серый  8              f8          stuff 8
                                         stuff \033Ox    (A)
       Серый  9              f9          stuff 9
                                         stuff \033Oy    (A)
       Серый  +              f+          stuff +
                                         stuff \033Ok    (A)
       Серый  -              f-          stuff -
                                         stuff \033Om    (A)
       Серый  *              f*          stuff *
                                         stuff \033Oj    (A)
       Серый  /              f/          stuff /
                                         stuff \033Oo    (A)
       Серый  =              fq          stuff =
                                         stuff \033OX    (A)
       Серый  .              f.          stuff .
                                         stuff \033On    (A)
       Серый  ,              f,          stuff ,
                                         stuff \033Ol    (A)
       Серый  enter          fe          stuff \015
                                         stuff \033OM    (A)

</pre>

</dd></dl>

<p>
<a name="lbAP">&nbsp;</a>
</p><h2> Специальные возможности терминала </h2>

<p>

</p><p>
Приведённая ниже таблица описывает все возможности терминала, которые распознаются screen, и отсутствуют в руководстве <i><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=termcap&amp;category=5">termcap</a>(5)</i>. Можно поместить эти возможности в записи termcap (в файле 
</p><dl compact=""><dt></dt><dd>
<pre>/etc/termcap
</pre>

</dd></dl>

) или 
использовать их с командами <i>termcap</i>, <i>terminfo</i> и <i>termcapinfo</i> в файле
screenrc. Добавить возможности внутрь базы terminfo чаще всего нельзя.
<p>
</p><dl compact=""><dt></dt><dd>
<pre>
    LP   (bool)  У терминала есть отступы в стиле  VT100 ("волшебные отступы", "magic margins"). Эта                  возможность устаревшая, screen использует стандартную xn вместо неё.
    Z0   (str)   Установить ширину равной 132 колонкам.
    Z1   (str)   Установить ширину равной 80 колонкам.
    WS   (str)   Изменить размер экрана. Желаемая ширина и высота передаются как аргументы.
                 Пример для SunView(tm): "\E[8;%d;%dt".
    NF   (bool)  Терминалу не нужно управление потоком. Передавать ^S и ^Q  непосредственно приложению.                  То же, что и "flow off". Возможность противоположная "nx".
    G0   (bool)  Терминал может работать с последовательностями выбора шрифта ISO 2022.
    S0   (str)   Переключить charset "G0" на заданный. По умолчанию "\E(%.".
    E0   (str)   Переключить charset "G0" обратно на стандартный.  По умолчанию "\E(B".
    C0   (str)   Использовать строку как таблицу преобразования для шрифта "0". См. также возможность "AC".     CS   (str)   Переключить клавиши управления курсором в режим приложения.
    CE   (str)   Переключить клавиши управления курсором обратно в нормальный режим.
    AN   (bool)  Включить autonuke. См. команду <i>autonuke</i>  
    OL   (num)   Задаёт лимит буфера вывода. См. команду <i>obuflimit</i>.
    KJ   (str)   Задать кодировку терминала. Для списка допустимых кодировок см. "encoding".
    AF   (str)   Изменить цвет символов способом соответствующим ANSI.
                 Эта возможность почти всегда равна "\E[3%dm"
                 (или "\E[3%p1%dm" на машинах с terminfo).

    AB   (str)   То же, что и "AF", но изменяет фон.
    AX   (bool)  Понимает ANSI-последовательности для установки цвета букв и цвета фона (\E[39m / \E[49m).     XC   (str)   Описать преобразование символов в строки в зависимости от текущего шрифта. Детали в следующем разделе.     XT   (bool)  Терминал понимает специальные последовательности xterm (OSC, слежение за мышью).
    C8   (bool)  Терминалу нужен полужирный текст для того чтобы выводить цвета высокой яркости (например, eterm).     TF   (bool)  Добавляет недостающие возможности в  запись termcap/info.  (Установлено по умолчанию). 
</pre>

</dd></dl>

<p>
<a name="lbAQ">&nbsp;</a>
</p><h2> Преобразование кодировки символов </h2>

<p>

</p><p>
У screen есть мощный механизм трансляции символов в зависимости
от текущего шрифта и типа терминала.
Эту возможность можно использовать, когда возникает необходимость
со стандартным набором символов на терминалах,
работающих с какими-то более экзотическими наборами.
</p><p>
Синтаксис:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    XC=&lt;charset-mapping&gt;{,,&lt;charset-mapping&gt;}
    &lt;charset-mapping&gt; := &lt;designator&gt;&lt;template&gt;{,&lt;mapping&gt;}
    &lt;mapping&gt; := &lt;char-to-be-mapped&gt;&lt;template-arg&gt;

</pre>

</dd></dl>

Элементы, заключённые в скобки, могут повторяться произвольное число раз.
<p>
Последовательность &lt;charset-mapping&gt; говорит screen как отображать символы в кодировке &lt;designator&gt; ("B": ASCII, 
"A": UK, "K":  german и т.д.) в строки. Каждый &lt;mapping&gt; описывает какие символы преобразуются в какие.
Используется механизм шаблонов, поскольку чаще всего кодировки имеют много общего
(например, строки которые нужны для того чтобы переключиться на другую и с другой кодировки).
Каждое вхождение символа "%" в шаблон &lt;template&gt; заменяется на
&lt;template-arg&gt;, заданный вместе с символом. 
Если строки вообще не похожи, нужно использовать "%" как шаблон и задавать полную строку в &lt;template-arg&gt;. Для использования настоящего символа "%" есть специальный механизм экранирования:
символ "\" экранирует специальные символы "\", "%" и ",".
</p><p>
Вот пример:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    termcap hp700 "XC=B\E(K%\E(B,\304[,\326\\\\,\334]"

</pre>

</dd></dl>

<p>

</p><p>
Строка говорит screen как транслировать символы с умляутами в верхнем регистре в кодировке ISOlatin1 (кодировка "B") 
на терминале hp700, на котором немецкая "german" кодировка:  "\304" транслируется в "\E(K[\E(B"  и так далее. 
Прежде чем построится внутренняя таблица поиска эти строки подвергаются обработке в три прохода,
поэтому для того чтобы вставить обычный "\" нужно столько экранов.
</p><p>
Для того чтобы эмуляция была лучше, сделано ещё одно расширение: 
Если отображение транслирует неэкранированный символ "%",
он отправляет на терминал каждый раз когда screen переключается на 
соответствующую кодировку &lt;designator&gt;.
</p><p>
В этом особенном случае предполагается что шаблон это просто "%", 
потому что последовательность смены кодировок и отображение символом
имеют мало общего.
</p><p>
В этом примере показан один из способов использования расширения:
</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    termcap xterm XC=K%,%\E(B,[\304,\\\\\326,]\334

</pre>

</dd></dl>

Здесь на xterm эмулируется часть немецкого ("K") набора символов (charset).
Если screen нужно будет перейти на набор символов "K", он отправит на терминал 
символ "\E(B", т.е. будет использоваться кодировка ASCII.
Шаблон это просто "%", поэтому отображение прямое: "[" на "\304", "\" на "\326" и "]" на "\334". 
<a name="lbAR">&nbsp;</a>
<h2> Переменные окружения </h2>

<p>

</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>    COLUMNS        Количество столбцов терминала (перекрывает запись termcap)
    HOME           Каталог, в котором нужно искать файл 
<dl compact=""><dt></dt><dd></dd></dl></pre>

</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    LINES          Количество строк терминала (перекрывает запись termcap)
    LOCKPRG        Программа блокирования (lock) терминала 
    NETHACKOPTIONS Включает опцию nethack
    PATH           Используется для обнаружения программ перед запуском
    SCREENCAP      Для модификации значения TERMCAP терминала
    SCREENDIR      Альтернативный катало для сокетов
    SCREENRC       Альтернативный конфигурационный файл .screenrc
    SHELL          Имя интерпретатора, который используется для открытия окон (по умолчанию
                   "/bin/sh").
    STY            Альтернативное имя сокета
    SYSSCREENRC    Альтернативный системный конфигурационный файл 
<dl compact=""><dt></dt><dd>screenrc
</dd></dl></pre>

</dd></dl>

<p>
</p><dl compact=""><dt></dt><dd>
<pre>    TERM           Имя терминала
    TERMCAP        Описание терминала
    WINDOW         Номер окна (в момент создания)

</pre>

</dd></dl>

<p>


<a name="lbAS">&nbsp;</a>
</p><h2> Файлы </h2>

<p>

</p><p>
</p><dl compact=""><dt></dt><dd>
<pre>       .../screen-4.?.??/etc/screenrc
       .../screen-4.?.??/etc/etcscreenrc Примеры в пользовательского и глобального
                                         инициализационных файлов,
                                         входящие в дистрибутив <i>screen</i>
       $SYSSCREENRC
       /etc/screenrc                     Команды инициализации screen
       $SCREENRC
       $HOME/.screenrc                   Считывается после /etc/screenrc
       $SCREENDIR/S-&lt;login&gt;
       /var/run/screen/S-&lt;login&gt;         Каталог с гнёздами(сокетами) screen (по умолчанию)
       /usr/tmp/screens/S-&lt;login&gt;        Альтернативный каталог с гнёздами
       &lt;socket directory&gt;/.termcap       Записанный функцией вывода "termcap"
       /usr/tmp/screens/screen-exchange  
       /tmp/screen-exchange              Буфер для межпроцессного взаимодействия screen
       hardcopy.[0-9]                    Образы screen, созданные функцией hardcopy
       screenlog.[0-9]                   Журнал, созданный функцией log
       /usr/lib/terminfo/?/* или
       /etc/termcap                      База данных возможностей терминала (Terminal capability databases)        /var/run/utmp                     Записи о входе в систему
       $LOCKPRG                          Программа, которая блокирует (lock) терминал

</pre>

</dd></dl>

<p>
<a name="lbAT">&nbsp;</a>
</p><h2> См. также </h2>

<p>

</p><p>
<a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=termcap&amp;category=5">termcap</a>(5), <a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=utmp&amp;category=5">utmp</a>(5), <a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=vi&amp;category=1">vi</a>(1), <a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=captoinfo&amp;category=1">captoinfo</a>(1), <a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=tic&amp;category=1">tic</a>(1)
</p><p>
<a name="lbAU">&nbsp;</a>
</p><h2> Авторы </h2>

<p>

Изначально программа была создана Оливером Ломанном (Oliver Laumann).
Последняя (эта) версия была сделана 
Вайеном Дэвисоном (Wayne Davison), Юргеном Вигертом (Juergen Weigert)
и Михаелем Шрёдером (Michael Schroeder).
</p><p>
<a name="lbAV">&nbsp;</a>
</p><h2> COPYLEFT </h2>

<p>

</p><p>
Copyright (C) 1993-2003
</p><p>
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Juergen&nbsp;Weigert&nbsp;(<a href="mailto:jnweiger@immd4.informatik.uni-erlangen.de">jnweiger@immd4.informatik.uni-erlangen.de</a>)
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Michael&nbsp;Schroeder&nbsp;(<a href="mailto:mlschroe@immd4.informatik.uni-erlangen.de">mlschroe@immd4.informatik.uni-erlangen.de</a>)
</p><p>
Copyright (C) 1987 Oliver Laumann
</p><p>
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published  by  the
Free  Software  Foundation;  either  version 2, or (at your option) any
later version.
</p><p>
This program is distributed in the hope that it  will  be  useful,  but
WITHOUT  ANY  WARRANTY;  without  even  the  implied  warranty  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
GNU  General Public License for more details.
</p><p>
You should have received a copy of the GNU General Public License along
with this program (see the file COPYING); if not,  write  to  the  Free
Software  Foundation,  Inc.,  59  Temple  Place - Suite 330, Boston, MA
02111-1307, USA
</p><p>
<a name="lbAW">&nbsp;</a>
</p><h2> Вклад </h2>

<p>

</p><p>
В развитие <i>GNU screen</i> сделали вклад:
</p><p>
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Ken&nbsp;Beal&nbsp;(<a href="mailto:kbeal@amber.ssd.csd.harris.com">kbeal@amber.ssd.csd.harris.com</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Rudolf&nbsp;Koenig&nbsp;(<a href="mailto:rfkoenig@immd4.informatik.uni-erlangen.de">rfkoenig@immd4.informatik.uni-erlangen.de</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Toerless&nbsp;Eckert&nbsp;(<a href="mailto:eckert@immd4.informatik.uni-erlangen.de">eckert@immd4.informatik.uni-erlangen.de</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Wayne&nbsp;Davison&nbsp;(<a href="mailto:davison@borland.com">davison@borland.com</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Patrick&nbsp;Wolfe&nbsp;(<a href="mailto:pat@kai.com">pat@kai.com</a>,&nbsp;kailand!pat),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Bart&nbsp;Schaefer&nbsp;(<a href="mailto:schaefer@cse.ogi.edu">schaefer@cse.ogi.edu</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Nathan&nbsp;Glasser&nbsp;(<a href="mailto:nathan@brokaw.lcs.mit.edu">nathan@brokaw.lcs.mit.edu</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Larry&nbsp;W.&nbsp;Virden&nbsp;(<a href="mailto:lvirden@cas.org">lvirden@cas.org</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Howard&nbsp;Chu&nbsp;(<a href="mailto:hyc@hanauma.jpl.nasa.gov">hyc@hanauma.jpl.nasa.gov</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Tim&nbsp;MacKenzie&nbsp;(<a href="mailto:tym@dibbler.cs.monash.edu.au">tym@dibbler.cs.monash.edu.au</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Markku&nbsp;Jarvinen&nbsp;(mta@{cc,cs,ee}.tut.fi),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Marc&nbsp;Boucher&nbsp;(<a href="mailto:marc@CAM.ORG">marc@CAM.ORG</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Doug&nbsp;Siebert&nbsp;(<a href="mailto:dsiebert@isca.uiowa.edu">dsiebert@isca.uiowa.edu</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Ken&nbsp;Stillson&nbsp;(<a href="mailto:stillson@tsfsrv.mitre.org">stillson@tsfsrv.mitre.org</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Ian&nbsp;Frechett&nbsp;(<a href="mailto:frechett@spot.Colorado.EDU">frechett@spot.Colorado.EDU</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Brian&nbsp;Koehmstedt&nbsp;(<a href="mailto:bpk@gnu.ai.mit.edu">bpk@gnu.ai.mit.edu</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Don&nbsp;Smith&nbsp;(<a href="mailto:djs6015@ultb.isc.rit.edu">djs6015@ultb.isc.rit.edu</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Frank&nbsp;van&nbsp;der&nbsp;Linden&nbsp;(<a href="mailto:vdlinden@fwi.uva.nl">vdlinden@fwi.uva.nl</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Martin&nbsp;Schweikert&nbsp;(<a href="mailto:schweik@cpp.ob.open.de">schweik@cpp.ob.open.de</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;David&nbsp;Vrona&nbsp;(<a href="mailto:dave@sashimi.lcu.com">dave@sashimi.lcu.com</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;E.&nbsp;Tye&nbsp;McQueen&nbsp;(<a href="mailto:tye%spillman.UUCP@uunet.uu.net">tye%spillman.UUCP@uunet.uu.net</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Matthew&nbsp;Green&nbsp;(<a href="mailto:mrg@eterna.com.au">mrg@eterna.com.au</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Christopher&nbsp;Williams&nbsp;(<a href="mailto:cgw@pobox.com">cgw@pobox.com</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Matt&nbsp;Mosley&nbsp;(<a href="mailto:mattm@access.digex.net">mattm@access.digex.net</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Gregory&nbsp;Neil&nbsp;Shapiro&nbsp;(<a href="mailto:gshapiro@wpi.WPI.EDU">gshapiro@wpi.WPI.EDU</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Johannes&nbsp;Zellner&nbsp;(<a href="mailto:johannes@zellner.org">johannes@zellner.org</a>),
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Pablo&nbsp;Averbuj&nbsp;(<a href="mailto:pablo@averbuj.com">pablo@averbuj.com</a>).
</p><p>
<a name="lbAX">&nbsp;</a>
</p><h2> Версия </h2>

<p>

</p><p>
Документация написана для <i>screen</i> версии 4.0.2.
Она основана на объединении версии 2.3 Вайана Дэвисона (Wayne Davison)
и нескольких улучшений к версии 2.0 Оливера Ломанна (Oliver Laumann).
Следует иметь в виду, что все версии 2.x принадлежат
Оливеру Ломанну (Oliver Laumann).
</p><p>
<a name="lbAY">&nbsp;</a>
</p><h2> Доступность </h2>

<p>

</p><p>
Последний официальный релиз <i>screen</i>
доступен с помощью анонимного FTP на
gnudist.gnu.org, nic.funet.fi 
и других сайтах, распространяющих GNU.
Домашний сайт <i>screen</i> это  <a href="ftp://ftp.uni-erlangen.de">ftp.uni-erlangen.de</a>,
каталог 
</p><dl compact=""><dt></dt><dd>
<pre>pub/utilities/screen
</pre>

</dd></dl>

<p>
Подкаталог 
</p><dl compact=""><dt></dt><dd>
<pre>private/
</pre>

</dd></dl>

<p>
содержит последний тестовый бета-релиз.
Если вы хотите помочь, 
отправьте сообщение на 
</p><dl compact=""><dt></dt><dd>
<pre><a href="mailto:screen@uni-erlangen.de">screen@uni-erlangen.de</a>
</pre>

</dd></dl>

<p>
<a name="lbAZ">&nbsp;</a>
</p><h2> Баги </h2>

<p>

<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;"dm"&nbsp;(delete&nbsp;mode,&nbsp;режим&nbsp;удаления)&nbsp;и&nbsp;"xs"&nbsp;не&nbsp;обрабатываются&nbsp;корректно,&nbsp;они&nbsp;игнорируются.&nbsp;"xn"&nbsp;воспринимается&nbsp;как&nbsp;волшебный&nbsp;
индикатор отступа. .br
<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Screen&nbsp;ничего&nbsp;не&nbsp;знает&nbsp;о&nbsp;символах&nbsp;двойной&nbsp;высоты&nbsp;и&nbsp;двойной&nbsp;ширины.&nbsp;Но&nbsp;это&nbsp;единственное&nbsp;место,&nbsp;где&nbsp;vttest&nbsp;может&nbsp;не&nbsp;работать.&nbsp;
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;При&nbsp;подключении&nbsp;из-под&nbsp;терминала&nbsp;с&nbsp;другим&nbsp;типом&nbsp;нет&nbsp;возможности&nbsp;поменять&nbsp;переменную&nbsp;окружения&nbsp;$TERMCAP&nbsp;.br
<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Поддержка&nbsp;terminfo-систем&nbsp;очень&nbsp;ограничена.&nbsp;Добавление&nbsp;новых&nbsp;возможностей&nbsp;в&nbsp;$TERMCAP&nbsp;не&nbsp;будет&nbsp;иметь&nbsp;должного&nbsp;эффекта.&nbsp;
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Screen&nbsp;не&nbsp;использует&nbsp;аппаратные&nbsp;табы.
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;В&nbsp;большинстве&nbsp;случаев&nbsp;screen&nbsp;должен&nbsp;быть&nbsp;установлен&nbsp;с&nbsp;битом&nbsp;set-uid&nbsp;и&nbsp;пользователем&nbsp;root.&nbsp;Это&nbsp;нужно&nbsp;для&nbsp;того,&nbsp;чтобы&nbsp;он&nbsp;
мог корректно менять владельца tty-устройства для каждого окна. Особые права ещё могут понадобиться для того, чтобы 
изменять файл "/var/run/utmp". .br
<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Записи&nbsp;в&nbsp;"/var/run/utmp"&nbsp;не&nbsp;удаляются,&nbsp;когда&nbsp;screen&nbsp;завершается&nbsp;по&nbsp;SIGKILL.&nbsp;&nbsp;В&nbsp;результате&nbsp;некоторые&nbsp;программы&nbsp;(такие&nbsp;
как "w" или "rwho") показывают, что пользователь зарегистрирован в системе, когда его на самом деле нет. .br
<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Screen&nbsp;может&nbsp;выдавать&nbsp;странное&nbsp;сообщение,&nbsp;когда&nbsp;для&nbsp;терминала&nbsp;нед&nbsp;записи&nbsp;в&nbsp;utmp
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Если&nbsp;модемная&nbsp;линия&nbsp;разорвалась,&nbsp;screen&nbsp;может&nbsp;и&nbsp;не&nbsp;отключиться&nbsp;(или&nbsp;завершиться)&nbsp;автоматически,&nbsp;если&nbsp;драйвер&nbsp;устройства&nbsp;
не настроен так, что отправляет сигнал HANGUP signal.   Для отключения сеанса screen нужно использовать опции командной 
строки .RS
</p><pre>-D
</pre>


<br>&nbsp;или&nbsp;
<dl compact=""><dt></dt><dd>
<pre>-d
</pre>

</dd></dl>

<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Опции&nbsp;-d&nbsp;и&nbsp;-D&nbsp;отключают&nbsp;сеанс&nbsp;без&nbsp;спроса,&nbsp;даже&nbsp;если&nbsp;установлен&nbsp;пароль.
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;И&nbsp;&nbsp;"breaktype",&nbsp;&nbsp;и&nbsp;&nbsp;"defbreaktype"&nbsp;&nbsp;меняют&nbsp;способ&nbsp;генерирования&nbsp;разрыва&nbsp;для&nbsp;всех&nbsp;терминальных&nbsp;устройств.&nbsp;Правда,&nbsp;первый&nbsp;
меняет только текущие настройки, а второй  задаёт настройки для новых, будущих окон. .br
<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;При&nbsp;подключении&nbsp;к&nbsp;многопользовательскому&nbsp;сеансу&nbsp;файл&nbsp;.screenrc&nbsp;пользователя&nbsp;не&nbsp;обрабатывается.&nbsp;Настройки&nbsp;пользователей&nbsp;
должны быть включены в файл .screenrc пользователя, который запускает screen, или их нужно задавать вручную, когда screen 
уже работает. .br
<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Для&nbsp;того&nbsp;чтобы&nbsp;воспользоваться&nbsp;всеми&nbsp;фичами,&nbsp;нужно&nbsp;иметь&nbsp;весьма&nbsp;незаурядное&nbsp;воображение.
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Сообщения&nbsp;об&nbsp;ошибках,&nbsp;исправления,&nbsp;улучшения,&nbsp;футболки,&nbsp;деньги,&nbsp;пиво&nbsp;и&nbsp;пиццу&nbsp;отправляйте&nbsp;по&nbsp;адресу&nbsp;<i><a href="mailto:screen@uni-erlangen.de">screen@uni-erlangen.de</a></i>.&nbsp;
<p>
<a name="lbBA">&nbsp;</a>
</p><h2> Перевод </h2>

<p>

</p><p>
<br>

<br>&nbsp;&nbsp;*&nbsp;&nbsp;Игорь&nbsp;Чубин&nbsp;&lt;igor&nbsp;ar&nbsp;chub.in&gt;
</p><p>

</p><hr>
<a name="index">&nbsp;</a><h2>Index</h2>
<dl>
<dt><a href="#lbAB"> Имя </a></dt><dd>
</dd><dt><a href="#lbAC"> Синтаксис </a></dt><dd>
</dd><dt><a href="#lbAD"> Описание </a></dt><dd>
</dd><dt><a href="#lbAE"> С чего начать? </a></dt><dd>
</dd><dt><a href="#lbAF"> Опции командной строки </a></dt><dd>
</dd><dt><a href="#lbAG"> Привязки клавиш </a></dt><dd>
</dd><dt><a href="#lbAH"> Индивидуальная настройка </a></dt><dd>
</dd><dt><a href="#lbAI"> Строка сообщений </a></dt><dd>
</dd><dt><a href="#lbAJ"> Типы окон </a></dt><dd>
</dd><dt><a href="#lbAK"> Escape-последовательности </a></dt><dd>
</dd><dt><a href="#lbAL"> Управление потоком </a></dt><dd>
</dd><dt><a href="#lbAM"> Названия (именование окон) </a></dt><dd>
</dd><dt><a href="#lbAN"> Виртуальный терминал </a></dt><dd>
</dd><dt><a href="#lbAO"> Трансляция при вводе </a></dt><dd>
</dd><dt><a href="#lbAP"> Специальные возможности терминала </a></dt><dd>
</dd><dt><a href="#lbAQ"> Преобразование кодировки символов </a></dt><dd>
</dd><dt><a href="#lbAR"> Переменные окружения </a></dt><dd>
</dd><dt><a href="#lbAS"> Файлы </a></dt><dd>
</dd><dt><a href="#lbAT"> См. также </a></dt><dd>
</dd><dt><a href="#lbAU"> Авторы </a></dt><dd>
</dd><dt><a href="#lbAV"> COPYLEFT </a></dt><dd>
</dd><dt><a href="#lbAW"> Вклад </a></dt><dd>
</dd><dt><a href="#lbAX"> Версия </a></dt><dd>
</dd><dt><a href="#lbAY"> Доступность </a></dt><dd>
</dd><dt><a href="#lbAZ"> Баги </a></dt><dd>
</dd><dt><a href="#lbBA"> Перевод </a></dt><dd>
</dd></dl>
<hr>
<br>
<form method="get" action="/search.shtml">
<font size="-1">
<font color="#555555">Поиск по тексту MAN-ов:&nbsp;</font><input size="30" name="words" value="screen" type="text">
<input name="restrict" value="/man" type="hidden">
<input value="Найти" type="submit">
</font>
<input name="method" value="and" type="hidden">
<input name="format" value="builtin-long" type="hidden">
<input name="sort" value="score" type="hidden">
</form>
<br>
<!--htdig_noindex-->
<noindex>
<br>


</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br><br>
<div style="background-color: #E9EAD6; width:100%; height: 61px;">
<div style="margin-right: 20px; float:left; line-height: 61px; vertical-align: middle; margin-left: 10px; font-size: 120%;">
Спонсоры:
</div>
<div style="float:left; height: 60px;  line-height: 60px; margin-left: 20px;">
<a style="align: middle;" target="_blank" href="https://inferno.name/"><img src="/img/inferno2.png" alt="Inferno Solutions" height="57" width="200"></a>
</div>
<div style="float:right; height: 60px;  line-height: 60px;  margin-left: 15px;">
<a style="align: middle;" target="_blank" href="http://hoster.ru/?utm_source=site&amp;utm_medium=banner&amp;utm_campaign=opennet"><img src="/img/dh143x60t.png" alt="Hosting by Hoster.ru" height="60" width="143"></a>
</div>
<div style="float:right;  height: 60px;  line-height: 60px; vertical-align: middle;font-size: 120%;">
Хостинг:
</div>

</div>

<div style="clear: both;"></div>


<br>
<table class="ttxt" style="border-top: 3px solid #C9CaB6;">
<tbody><tr><td width="35%">
<a href="/cgi-bin/opennet/bookmark.cgi">Закладки на сайте</a><br>
<a href="/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить за страницей</a>
</td>
<td align="RIGHT" width="65%">
Created&nbsp;1996-2021&nbsp;by <b><a href="/contact.shtml" title="email maxim.chirkov@gmail.com">Maxim&nbsp;Chirkov</a></b><br>
<a href="https://www.opennet.ru/add.shtml">Добавить</a>, <a href="https://www.opennet.ru/donate.shtml" style="color: #C00000;">Поддержать</a>, <a href="https://www.opennet.ru/banners2.shtml">Вебмастеру</a>
</td>
</tr>
</tbody></table>
<br><br>


<!--/htdig_noindex-->
<!-- end of footer -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>




</body>
<!---------------------------------------------  0  ---------------------------------------------->
