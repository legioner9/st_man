
<!--+++++++++++++++++++++++++++++++++++++++++++  0  +++++++++++++++++++++++++++++++++++++++++++--->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Проект OpenNet: MAN bash (1) Команды и прикладные программы пользовательского уровня (FreeBSD и Linux)</title><meta name="KeyWords" content="man, manual, MAN, системное руководство, linux, FreeBSD, OpenBSD, Solaris, ядро, программы, системный вызов, bash"><meta name="viewport" content="width=device-width, initial-scale=1"></head>


<body link="#0000FF" vlink="#000080" text="#000000" bgcolor="#E3E4D0" alink="#FF00FF">
<link rel="stylesheet" href="/opennet4.css" type="text/css">
<!--htdig_noindex-->
<form method="get" action="https://www.opennet.ru/search.shtml">
<aside>
<div style="width: 100%; text-align: right; font-size: 70%; background: #E9EAD6; margin-bottom:-10px;">
Профиль: <b><a href="/~" rel="nofollow" title="/~ - сводная страница участника"><u>Аноним</u></a></b> (<a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=login">вход</a> | <a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=user_register">регистрация</a>)</div>

<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody><tr>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" valign="BOTTOM" bgcolor="#E9EAD6" width="300">
<a href="https://www.opennet.ru/"><img src="/opennet2.gif" alt="The OpenNET Project" height="60" width="249" border="0"></a><br>
</td>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" bgcolor="#E9EAD6" align="CENTER" width="100">

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:10px;" bgcolor="#E9EAD6" align="CENTER" width="50%">
<table width="100%" border="0">
<tbody><tr>
<td width="22%">
 <a href="https://www.opennet.ru/opennews/" class="h"><b>НОВОСТИ</b></a> (<a href="https://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="18%%">
  <a href="https://www.opennet.ru/mp/" class="h"><b>КОНТЕНТ</b></a>
</td><td width="14%">
  <a href="http://wiki.opennet.ru" class="h"><b>WIKI</b></a>
</td><td width="14%">
   <a href="https://www.opennet.ru/man.shtml" class="h"><b>MAN'ы</b></a>
</td><td width="16%">
   <a href="https://www.opennet.ru/forum/" class="h"><b>ФОРУМ</b></a>
</td><td width="16%">
<a href="https://www.opennet.ru/search.shtml" class="h" onmouseover="document.getElementById('form12').style.display='block';">Поиск</a>&nbsp;(<a href="https://www.opennet.ru/keywords/" class="h">теги</a>)
<input id="form12" style="display: none;" size="10" name="words" value="" title="для поиска в google наберите &quot;g фраза&quot;" type="text">
</td></tr>
</tbody></table>

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:5px;" bgcolor="#E9EAD6" align="right" width="20%">

<a href="https://www.opennet.ru/opennews/opennews_all_utf.rss"><img src="/img/rss.png" alt="RSS" title="RSS" height="16" width="16" border="0"></a>&nbsp;<a href="https://twitter.com/opennetru"><img src="/twitter.png" alt="twitter" title="Twitter" height="16" width="16" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="/img/vkontakte.gif" title="ВКонтакте" height="16" width="16" border="0"></a>&nbsp;<a href="https://zen.yandex.ru/opennet"><img src="/img/zen.gif" title="Yandex Zen" height="16" width="16" border="0"></a>&nbsp;<a href="https://www.facebook.com/OpenNet.News/"><img src="/img/facebook.gif" title="Facebook" height="16" width="16" border="0"></a>&nbsp;<a href="https://telegram.space/opennet_ru"><img src="/img/telegram2.png" title="Telegram" height="16" width="16" border="0"></a>
</td></tr></tbody></table>
</aside>

<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class="hdr_mobile">
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url('/back.gif') repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<a href="https://www.opennet.ru"><img src="/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" alt="The OpenNET Project / Index page"></a>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="/opennews/">новости</a>&nbsp;/<a href="/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">+++</a> | <a href="/forum/">форум</a> | <a href="http://wiki.opennet.ru">wiki</a> | <a href="/keywords/">теги</a>
| <a href="tg://resolve?domain=opennet_ru"><img src="/img/telegram2.png" title="Telegram" style="margin-bottom: -4px;" height="16" width="16" border="0"></a>
]</small>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id="adv">
</div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id="adv2">
</div>
<div style="width: 279;float: right;" id="adv3">
</div>
<div style="clear: both;"></div>
<br>
</form>
<!--/htdig_noindex-->

<center><h3><font color="#000088">Интерактивная система просмотра системных руководств (man-ов)</font></h3></center>
<form method="GET" action="/man.shtml"> 
<table cellspacing="0" cellpadding="1" bgcolor="#B0B190" align="center" width="600" border="0">
<tbody><tr>
<td valign="TOP">

<table cellspacing="0" cellpadding="0" bgcolor="#E9EAD6" align="center" width="100%" border="0">
<tbody><tr><td>&nbsp;<font color="#555555">Тема</font></td><td><font color="#555555">Набор</font></td><td><font color="#555555">Категория</font></td><td>&nbsp;</td></tr>
<tr><td>

&nbsp;<input size="20" name="topic" value="bash" type="text"></td><td><select name="russian">
<option value="4">Solaris man
</option><option value="1">FreeBSD man
</option><option value="3">Разные man
</option><option value="0" selected="">Русские man
</option><option value="2">Linux man
</option><option value="5">POSIX man
</option></select></td>
<td><select size="1" name="category">
	  <option value="" selected="">All
	  </option><option value="1">1
	  </option><option value="2">2
	  </option><option value="3">3
	  </option><option value="4">4
	  </option><option value="5">5
	  </option><option value="6">6
	  </option><option value="7">7
	  </option><option value="8">8
	  </option><option value="9">9
</option></select></td>

<td><input name="submit" value="Показать man" type="submit"></td></tr>
<script async="" src="https://www.google-analytics.com/analytics.js"></script><script language="JavaScript" src="/print.js"></script>
<tr><td colspan="4" align="left">&nbsp;[<a href="/man.shtml">Cписок руководств</a> | <a href="#" onclick="pr('none');">Печать</a>]</td></tr>
</tbody></table>
</td></tr></tbody></table>
</form>
<h3></h3><font size="+2">bash (1)</font><hr><li> <a href="/man.shtml?topic=bash&amp;category=1&amp;russian=4"><u>bash</u></a> (1) <font color="#555555"> ( Solaris man: Команды и прикладные программы пользовательского уровня )</font></li><li>&gt;&gt; <a href="/man.shtml?topic=bash&amp;category=1&amp;russian=0"><u>bash</u></a> (1) <font color="#555555"> ( Русские man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=bash&amp;category=1&amp;russian=2"><u>bash</u></a> (1) <font color="#555555"> ( Linux man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=bash&amp;category=8&amp;russian=0"><u>bash</u></a> (8) <font color="#555555"> ( Русские man: Команды системного администрирования )</font></li>
<a name="lbAB">&nbsp;</a>
<h2>НАЗВАНИЕ</h2>

<p>

<b>bash</b> - командный интерпретатор GNU Bourne-Again SHell
</p><p>
</p><p>
</p><p>
<a name="lbAC">&nbsp;</a>
</p><h2>СИНТАКСИС</h2>

<dl compact="">
<dt></dt><dd>
<p>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>bash [<b>опции</b>] [<b>файл</b>]<br>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbAD">&nbsp;</a>
<h2>АВТОРСКИЕ ПРАВА</h2>

<p>

Командный интерпретатор <b>bash</b> создан Фондом свободно 
</p><p>
распространяемого программного обеспечения. 
</p><p>
Copyright (C) 1989-1999 by the Free Software Foundation, Inc.
</p><p>
</p><p>
</p><p>
<a name="lbAE">&nbsp;</a>
</p><h2>ОПИСАНИЕ</h2>

<p>

<b>bash</b> - это <b>sh</b>-совместимый интерпретатор командного языка,
</p><p>
выполняющий команды, прочитанные со стандартного входного потока
</p><p>
или из файла. Командный интерпретатор <b>bash</b> также включает
</p><p>
полезные средства командных интерпретаторов <b>Korn</b> и <b>C</b> (<b>ksh</b> и <b>csh</b>).
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор <b>bash</b> создавался как соответствующий
</p><p>
спецификации командного интерпретатора и инструментальных средств 
</p><p>
IEEE POSIX (IEEE 
</p><p>
POSIX Shell and Tools specification)
</p><p>
(IEEE Working Group 1003.2).
</p><p>
</p><p>
</p><p>
<a name="lbAF">&nbsp;</a>
</p><h2>ОПЦИИ</h2>

<p>

Помимо однобуквенных опций командного интерпретатора, представленных
</p><p>
в описании встроенной команды <b>set</b>, <b>bash</b> 
</p><p>
интерпретирует при вызове следующие опции:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>-c строка</b></dt><dd>
<p>
Если указана опция <b>-c</b>, команды читаются из строки. Если после строки
</p><p>
есть аргументы, их значения присваиваются позиционным параметрам, 
</p><p>
начиная с <b>$0</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>-r</b></dt><dd>
<p>
Если указана опция <b>-r</b>, командный интерпретатор становится ограниченным
</p><p>
(см. "<b>ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>-i</b></dt><dd>
<p>
Если указана опция <b>-i</b>, командный интерпретатор работает как
</p><p>
интерактивный.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>-s</b></dt><dd>
<p>
Если указана опция <b>-s</b> или если после обработки опций аргументов
</p><p>
не остается, команды читаются из стандартного входного потока.
</p><p>
Эта опция позволяет устанавливать позиционные параметры
</p><p>
при вызове интерактивного командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>-D</b></dt><dd>
<p>
Список всех строк в двойных кавычках с префиксом <b>$</b>
</p><p>
выдается в стандартный выходной поток. Это строки,
</p><p>
которые необходимо перевести на соответствующий язык, если
</p><p>
текущая локаль отличается от <b>C</b> или <b>POSIX</b>. При этом неявно
</p><p>
предполагается опция <b>-n</b>; никакие команды выполняться не будут.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--</b></dt><dd>
<p>
Пара дефисов (<b>--</b>) обозначает конец опций и отключает их дальнейшую
</p><p>
обработку. Любые аргументы после <b>--</b> рассматриваются как имена файлов
</p><p>
и аргументы. Аргумент <b>-</b> эквивалентен <b>--</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Командный интерпретатор <b>bash</b> также интерпретирует несколько
</p><p>
многосимвольных опций. Эти опции, чтобы они были распознаны, должны
</p><p>
указываться в командной строке перед односимвольными опциями.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>--dump-po-strings</b></dt><dd>
<p>
Аналогична опции <b>-D</b>, но результат выдается в формате файла GNU 
</p><p>
gettext po (portable object - <i>переносимый объект</i>).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--dump-strings</b></dt><dd>
<p>
Аналогична опции <b>-D</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--help</b></dt><dd>
<p>
Выдает в стандартный выходной поток сообщение об использовании и
</p><p>
успешно завершает работу.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--login</b></dt><dd>
<p>
Заставляет <b>bash</b> работать так, как если бы он был вызван в качестве
</p><p>
<i>начального командного интерпретатора</i> 
</p><p>
(см. "<b>ВЫЗОВ</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--noediting</b></dt><dd>
<p>
Не использует библиотеку GNU <b>readline</b> для чтения командных строк в
</p><p>
интерактивном режиме.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--noprofile</b></dt><dd>
<p>
Не читает ни общесистемный файл начального запуска 
</p><p>
<b>/etc/profile</b>, ни любой из персональных файлов инициализации
</p><p>
пользователя <b>~/.bash_profile</b>, <b>~/.bash_login</b> или <b>~/.profile</b>.
</p><p>
По умолчанию, <b>bash</b> читает эти файлы при вызове в качестве
</p><p>
начального командного интерпретатора (см. "<b>ВЫЗОВ</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--norc</b></dt><dd>
<p>
Не читает и не выполняет персональный файл инициализации
</p><p>
<b>~/.bashrc</b>, если командный интерпретатор работает интерактивно. Эта опция
</p><p>
по умолчанию включена, если интерпретатор вызван как <b>sh</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--posix</b></dt><dd>
<p>
Изменяет на стандартное поведение <b>bash</b> в тех случаях, когда оно
</p><p>
отличается от предполагаемого стандартом POSIX  1003.2.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--rcfile файл</b></dt><dd>
<p>
Выполняет команды из указанного <b>файла</b> вместо стандартного персонального
</p><p>
файла инициализации <b>~/.bashrc</b>, если командный интерпретатор работает 
</p><p>
интерактивно (см. "<b>ВЫЗОВ</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--restricted</b></dt><dd>
<p>
Командный интерпретатор становится ограниченным
</p><p>
(см. "<b>ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--verbose</b></dt><dd>
<p>
Аналогична опции <b>-v</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>--rpm-requires</b></dt><dd>
<p>
Создаёт список файлов, необходимых для выполнения сценария оболочки. Это подразумевает наличие '-n' и имеет те же ограничения, как и проверка ошибок во время компиляции; обратные кавычки, []-проверки и тождества не подлежат анализу, таким образом некоторые зависимости могут оказаться пропущены.
</p><p>
</p><p>
</p></dd><dt><b>--version</b></dt><dd>
<p>
Выдает информацию о версии данного экземпляра <b>bash</b> в стандартный выходной поток
</p><p>
и успешно завершает работу.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbAG">&nbsp;</a>
<h2>АРГУМЕНТЫ</h2>

<p>

Если после обработки опций остались аргументы и не указаны опции
</p><p>
<b>-c</b> или <b>-s</b>, 
</p><p>
первый аргумент считается именем файла, содержащего
</p><p>
команды интерпретатора. Если <b>bash</b> вызван таким образом, параметр <b>$0</b>
</p><p>
устанавливается равным имени файла, а значениями позиционных параметров
</p><p>
становятся другие аргументы. Командный интерпретатор <b>bash</b> читает и
</p><p>
выполняет команды из этого файла, а затем завершает работу. Статусом
</p><p>
выхода <b>bash</b> является статус выхода последней команды, выполненной в сценарии.
</p><p>
Если ни одна команда не выполнена, статус выхода - 0.
</p><p>
</p><p>
</p><p>
<a name="lbAH">&nbsp;</a>
</p><h2>ВЫЗОВ</h2>

<p>

<i>Начальный командный интерпретатор</i> (login shell) - это интерпретатор,
</p><p>
первый символ нулевого аргумента которого является дефисом (<b>-</b>) или
</p><p>
который запущен с опцией <b>--login</b>.
</p><p>
</p><p>
</p><p>
</p><p>

<i>Интерактивным</i> является командный интерпретатор, стандартный входной и 
</p><p>
выходной потоки которого подключены к терминалам (что определяется
</p><p>
с помощью функции <b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=isatty&amp;category=3">isatty</a>(3)</b>), или запущенный 
</p><p>
с опцией <b>-i</b>. Переменная
</p><p>
среды <b>PS1</b> устанавливается и флаги (<b>$-</b>) включают <b>i</b>, только если <b>bash</b> является
</p><p>
интерактивным интерпретатором, что позволяет проверить это в файле
</p><p>
начального запуска или в сценарии командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p><p>

Следующие абзацы описывают, как <b>bash</b> выполняет свои файлы начального
</p><p>
запуска. Если любой из этих файлов существует, но не может быть
</p><p>
прочитан, <b>bash</b> выдает сообщение об ошибке. Символы <i>тильды</i> (<b>~</b>) 
</p><p>
в именах файлов заменяются так, как описано в подразделе 
</p><p>
"<b>Замена тильды</b>" раздела 
</p><p>
"<b>ЗАМЕНЫ</b>".
</p><p>
</p><p>
</p><p>
</p><p>

При вызове <b>bash</b> как интерактивного начального командного интерпретатора,
</p><p>
или как неинтерактивного интерпретатора с опцией 
</p><p>
<b>--login</b>, он сначала
</p><p>
читает и выполняет команды из файла <b>/etc/profile</b>, если этот файл существует.
</p><p>
После прочтения этого файла, он последовательно ищет файлы <b>~/.bash_profile</b>,  
</p><p>
<b>~/.bash_login</b> и <b>~/.profile</b>, читает и выполняет команды из первого же из
</p><p>
них, который существует и доступен на чтение. Опция <b>--noprofile</b> может
</p><p>
использоваться при запуске командного интерпретатора, чтобы отменить
</p><p>
это действие.
</p><p>
</p><p>
</p><p>
</p><p>

При завершении работы в качестве начального командного интерпретатора
</p><p>
<b>bash</b> читает и выполняет команды в файле <b>~/.bash_logout</b>, если он существует.
</p><p>
</p><p>
</p><p>
</p><p>

При запуске интерактивного командного интерпретатора, не являющегося
</p><p>
начальным, <b>bash</b> читает и выполняет команды из файла <b>~/.bashrc</b>, если
</p><p>
он существует. Это действие можно отменить с помощью 
</p><p>
опции <b>--norc</b>.
</p><p>
Опция <b>--rcfile файл</b> заставляет <b>bash</b>
</p><p>
читать и выполнять команды из указанного <b>файла</b> вместо <b>~/.bashrc</b>.
</p><p>
</p><p>
</p><p>
</p><p>

При неинтерактивном запуске <b>bash</b>, например, для выполнения сценария,
</p><p>
командный интерпретатор ищет в среде переменную <b>BASH_ENV</b>, 
</p><p>
получает ее значение и использует его в качестве имени файла, который 
</p><p>
необходимо прочитать и выполнить. <b>bash</b> ведет себя так, как
</p><p>
если бы была выполнена следующая команда:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;[&nbsp;-n&nbsp;"$BASH_ENV"&nbsp;];&nbsp;then&nbsp;.&nbsp;"$BASH_ENV";&nbsp;fi
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

но при поиске имени файла не используется значение переменной <b>PATH</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Если <b>bash</b> вызван с именем <b>sh</b>, он пытается, наколько это возможно, 
</p><p>
имитировать поведение при запуске старых версий интерпретатора <b>sh</b>, 
</p><p>
соответствуя при этом стандарту POSIX. При вызове в качестве
</p><p>
интерактивного начального командного интерпретатора или 
</p><p>
неинтерактивного, но с опцией <b>--login</b>, он сначала пытается читать и
</p><p>
выполнять команды последовательно из файлов <b>/etc/profile</b> и <b>~/.profile</b>.
</p><p>
Для отмены этого действия можно использовать 
</p><p>
опцию <b>--noprofile</b>. При вызове
</p><p>
в качестве интерактивного командного интерпретатора с именем
</p><p>
<b>sh</b>, <b>bash</b> ищет переменную среды <b>ENV</b>, получает ее значение, если оно задано,
</p><p>
и использует это значение в качестве имени файла, который необходимо
</p><p>
прочитать и выполнить. Поскольку интерпретатор, вызванный как <b>sh</b>, не
</p><p>
пытается читать и выполнять команды в других файлах начального запуска,
</p><p>
опция <b>--rcfile</b> не действует. Неинтерактивный командый интерпретатор,
</p><p>
вызванный с именем <b>sh</b>, не пытается читать и выполнять никакие файлы начального
</p><p>
запуска. При вызове по имени <b>sh</b>, командный интерпретатор <b>bash</b> входит в режим
</p><p>
<b>posix</b> после прочтения файлов начального запуска.
</p><p>
</p><p>
</p><p>
</p><p>

При запуске <b>bash</b> в режиме <b>posix</b>, например, с помощью опции командной строки
</p><p>
<b>--posix</b>, он следует стандарту POSIX при работе с файлами начального запуска.
</p><p>
В этом режиме интерактивные командные интерпретаторы 
</p><p>
берут значение переменной среды <b>ENV</b>, читают и выполняют команды из
</p><p>
соответствующего файла. Никакие другие файлы начального
</p><p>
запуска не читаются.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор <b>bash</b> пытается определить, не запущен ли он
</p><p>
демоном удаленного командного интерпретатора, обычно, <b>rshd</b>.  Если
</p><p>
оказывается, что <b>bash</b> запущен демоном <b>rshd</b>, он читает и выполняет
</p><p>
команды из файла <b>~/.bashrc</b>, если этот файл существует и доступен
</p><p>
на чтение. Командный интерпретатор <b>bash</b> так не делает, если запущен
</p><p>
как <b>sh</b>. Для отмены этого действия можно использовать опцию
</p><p>
<b>--norc</b>, а с помощью опции 
</p><p>
<b>--rcfile</b> можно заставить читать другой файл, 
</p><p>
но обычно демон <b>rshd</b> не задает эти опции командному интерпретатору и не 
</p><p>
позволяет их указать.
</p><p>
</p><p>
</p><p>
</p><p>

Если командный интерпретатор запущен с эффективным идентификатором
</p><p>
пользователя (группы), не совпадающим с реальным идентификатором
</p><p>
пользователя (группы), и не указана опция <b>-p</b>, файлы
</p><p>
начального запуска не читаются, функции командного интерпретатора не
</p><p>
наследуются из среды, переменная <b>SHELLOPTS</b>, если она задана в среде,
</p><p>
игнорируется, а эффективный идентификатор пользователя устанавливается
</p><p>
равным реальному. Если при вызове задана опция <b>-p</b>, 
</p><p>
файлы начального запуска
</p><p>
тоже не читаются, но эффективный идентификатор пользователя не сбрасывается.
</p><p>
</p><p>
</p><p>
<a name="lbAI">&nbsp;</a>
</p><h2>ОПРЕДЕЛЕНИЯ</h2>

<p>

В оставшейся части документа используются следующие термины.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><i>пробел</i></dt><dd><i>
<p>
Символ пробела или символ табуляции.
</p><p>
</p><p>
</p><p>
</p></i></dd><dt><i>слово</i></dt><dd><i>
<p>
Последовательность символов, рассматриваемая командным интерпретатором
</p></i><p><i>
как единое целое. Также называется лексемой</i> (token).
</p><p>
</p><p>
</p><p>
</p></dd><dt><i>имя</i></dt><dd><i>
<p>
Слово, состоящее только из алфавитноцифровых символов и символов подчеркивания,
</p><p>
и начинающееся с буквы или символа подчеркивания. Также
</p></i><p><i>
называется идентификатором</i>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><i>метасимвол</i></dt><dd><i>
<p>
Символ, разделяющий слова, если он не замаскирован. Один из следующих
</p><p>
символов:
</p><p>
</p></i></dd><dt></dt><dd><i>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&amp;&nbsp;;&nbsp;(&nbsp;)&nbsp;&lt;&nbsp;&gt;&nbsp;пробел&nbsp;табуляция
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></i></dd><dt><i>управляющий оператор</i></dt><dd><i>
<p>
Лексема, выполняющая функцию управления. Это один из следующих символов:
</p><p>
</p></i></dd><dt></dt><dd><i>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;&amp;&nbsp;&amp;&amp;&nbsp;;&nbsp;;;&nbsp;(&nbsp;)&nbsp;|&nbsp;&lt;перевод&nbsp;строки&gt;
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></i></dd></dl><i>
</i><a name="lbAJ">&nbsp;</a>
<h2>ЗАРЕЗЕРВИРОВАННЫЕ СЛОВА</h2>

<p>

Зарезервированными являются слова, имеющие специальное значение для
</p><p>
командного интерпретатора. Следующие слова распознаются как 
</p><p>
зарезервированные, если не замаскированы и являются либо первым словом
</p><p>
простой команды (см. <b>"СИНТАКСИС КОМАНД"</b> ниже),
</p><p>
либо третьим словом команды <b>case</b> или 
</p><p>
<b>for</b>:
</p><p>
</p><p>
</p><p>
<b>!</b> <b>case</b> <b>do</b> <b>done</b> <b>elif</b> <b>else</b>
</p><p>
<b>esac</b> <b>fi</b> <b>for</b> <b>function</b> <b>if</b> <b>in</b>
</p><p>
<b>select</b> <b>then</b> <b>until</b> <b>while</b> <b>{ }</b>
</p><p>
<b>time</b> <b>[[ ]]</b>
</p><p>
</p><p>
</p><p>
<a name="lbAK">&nbsp;</a>
</p><h2>СИНТАКСИС КОМАНД</h2>

<a name="lbAL">&nbsp;</a>
<h3>Простые команды</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Простая команда</i> - это завершающаяся <i>управляющим оператором</i> 
</p><p>
последовательность необязательных присваиваний значений переменным,
</p><p>
после которых идут слова, разделенные пробелами, и
</p><p>
перенаправления потоков. Первое слово задает команду, которую 
</p><p>
надо выполнить. Оставшиеся слова передаются как аргументы вызванной
</p><p>
команде.
</p><p>
</p><p>
</p><p>
</p><p>

Возвращаемым значением <i>простой команды</i> является ее
</p><p>
статус выхода, или 128+<b>n</b>, если команда завершена сигналом <b>n</b>.
</p><p>
</p><p>
</p><p>
<a name="lbAM">&nbsp;</a>
</p><h3>Конвейеры</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Конвейер</i> - это последовательность одной или более команд,
</p><p>
разделенных символом <b>|</b>. Конвейер имеет следующий формат:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[time&nbsp;[-p]]&nbsp;[&nbsp;!&nbsp;]&nbsp;<b>команда</b>&nbsp;[&nbsp;|&nbsp;<b>команда2</b>&nbsp;...&nbsp;]
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Стандартный выходной поток <b>команды</b> связывается со стандартным входным
</p><p>
потоком <b>команды2</b>. Эта связь выполняется раньше, чем любые перенаправления,
</p><p>
задаваемые командой (см. "<b>ПЕРЕНАПРАВЛЕНИЕ</b>" ниже).
</p><p>
</p><p>
</p><p>
</p><p>

Если перед конвейером указано зарезервированное слово <b>!</b>,
</p><p>
статус выхода такого конвейера является логическим отрицанием
</p><p>
статуса выхода последней команды. В противном случае, статус
</p><p>
выхода конвейера совпадает со статусом выхода последней команды.
</p><p>
Прежде, чем возвращать значение, командный интерпретатор ждет завершения
</p><p>
всех команд в конвейере.
</p><p>
</p><p>
</p><p>
</p><p>

Если перед конвейером идет зарезервированное слово <b>time</b>,
</p><p>
после завершения конвейера выдается общее, пользовательское и 
</p><p>
системное время, потраченное на его выполнение. 
</p><p>
Опция <b>-p</b> изменяет
</p><p>
формат вывода на задаваемый стандартом POSIX. Переменная
</p><p>
<b>TIMEFORMAT</b> может задавать строку формата выдачи информации о времени;
</p><p>
см. описание переменной <b>TIMEFORMAT</b> в разделе 
</p><p>
"<b>Переменные командного интерпретатора</b>" ниже.
</p><p>
</p><p>
</p><p>
</p><p>

Каждая команда в конвейере выполняется как отдельный процесс
</p><p>
(т.е. в порожденном интерпретаторе).
</p><p>
</p><p>
</p><p>
<a name="lbAN">&nbsp;</a>
</p><h3>Списки</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Список</i> - это последовательность одного или более конвейеров, 
</p><p>
разделенных одним из операторов <b>;</b>, <b>&amp;</b>, <b>&amp;&amp;</b> 
</p><p>
или <b>||</b>, и не обязательно завершающаяся одним из операторов
</p><p>
<b>;</b>, <b>&amp;</b> или &lt;перевод строки&gt;.
</p><p>
</p><p>
</p><p>
</p><p>

Из этих операторов списка <b>&amp;&amp;</b> и <b>||</b> имеют равный приоритет, причем
</p><p>
больший, чем <b>;</b> и <b>&amp;</b>, тоже имеющие равный приоритет.
</p><p>
</p><p>
</p><p>
</p><p>

Если команда завершается управляющим оператором <b>&amp;</b>, интерпретатор
</p><p>
выполняет команду в <i>фоновом режиме</i> в порожденном интерпретаторе.
</p><p>
Командный интерпретатор не ждет завершения команды, а статус 
</p><p>
выхода в этом случае - 0. Команды, разделенные <b>;</b> выполняются
</p><p>
последовательно; командный интерпретатор ждет поочередно завершения каждой
</p><p>
из команд. Статус возврата списка в этом случае совпадает со
</p><p>
статусом возврата последней выполненной команды.
</p><p>
</p><p>
</p><p>
</p><p>

Управляющие операторы <b>&amp;&amp;</b> и <b>||</b> обозначают, соответственно, И-списки
</p><p>
и ИЛИ-списки. <i>И-список</i> имеет вид
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>команда</b>&nbsp;&amp;&amp;&nbsp;<b>команда2</b>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

<b>Команда2</b> выполняется только и если только <b>команда</b> вернула статус
</p><p>
выхода ноль.
</p><p>
</p><p>
</p><p>
</p><p>

<i>ИЛИ-список</i> имеет вид
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><b>команда</b> || <b>команда2</b><br>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

<b>Команда2</b> выполняется только и если только команда вернула ненулевой
</p><p>
статус выхода. И- и ИЛИ-списки возвращают статус последней команды,
</p><p>
выполненной в списке.
</p><p>
</p><p>
</p><p>
<a name="lbAO">&nbsp;</a>
</p><h3>Составные команды</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Составными</i> называют следующие команды:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt>(<b>список</b>)</dt><dd>
<p>
<b>Список</b> выполняется в порожденном командном интерпретаторе.
</p><p>
Присваивания переменным и встроенные команды, влияющие на 
</p><p>
среду командного интерпретатора, не действуют после завершения
</p><p>
команды. Статусом возврата является статус выхода <b>списка</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt>{ <b>список</b>; }</dt><dd>
<p>
<b>Список</b> просто выполняется в среде текущего командного интерпретатора.
</p><p>
Список должен завершаться переводом строки или точкой с запятой.
</p><p>
Эту команду называют <i>командой группировки</i>. Статусом возврата
</p><p>
является статус выхода <b>списка</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt>((<b>выражение</b>))</dt><dd>
<p>
<b>Выражение</b> вычисляется в соответствии с правилами, описанными ниже
</p><p>
в разделе 
</p><p>
"<b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b>". Если <b>выражение</b>
</p><p>
имеет ненулевое значение, статус возврата равен 0; в противном
</p><p>
случае - 1. Эта конструкция эквивалентна конструкции <b>let "выражение"</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt>[[ <b>выражение</b> ]]</dt><dd>
<p>
Возвращает статус 0 или 1 в зависимости от значения указанного
</p><p>
условного выражения. Выражения состоят из компонентов, описанных
</p><p>
ниже в разделе "<b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b>". 
</p><p>
Деление слов и подстановка
</p><p>
имен файлов в словах между <b>[[</b> и <b>]]</b> не выполняется; 
</p><p>
выполняется замена тильды, подстановка значений параметров и переменных,
</p><p>
арифметическая подстановка, подстановка результатов команд и 
</p><p>
подстановка процессов, а также удаление кавычек.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

При использовании операторов <b>==</b> и <b>!=</b> строка справа оператора
</p><p>
считается образцом и сопоставляется по правилам, описанным ниже в
</p><p>
подразделе "<b>Сопоставление с образцом</b>". Возвращается значение
</p><p>
0 если строка, соответственно, сопоставляется и не сопоставляется
</p><p>
с образцом, и 1 в противном случае. Любая часть образца может быть 
</p><p>
взята в кавычки, чтобы сопоставление с ней шло буквально.
</p><p>
</p><p>
</p><p>
</p><p>

Выражения можно комбинировать с помощью следующих операторов,
</p><p>
перечисленных в порядке снижения приоритета:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt>( <b>выражение</b> )</dt><dd>
<p>
Возвращает значение <b>выражения</b>. Круглые скобки можно использовать
</p><p>
для изменения обычного приоритета операторов.
</p><p>
</p><p>
</p><p>
</p></dd><dt>! <b>выражение</b></dt><dd>
<p>
Истинно, если <b>выражение</b> ложно.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>выражение1</b> &amp;&amp; <b>выражение2</b></dt><dd>
<p>
Истинно, если истинны оба выражения, <b>выражение1</b> и 
</p><p>
<b>выражение2</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>выражение1</b> || <b>выражение2</b></dt><dd>
<p>
Истинно, если истинно <b>выражение1</b> или <b>выражение2</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
Операторы <b>&amp;&amp;</b> и <b>||</b> не вычисляют <b>выражение2</b>, если
</p><p>
значения <b>выражения1</b> достаточно для определения возвращаемого
</p><p>
значения всего условного выражения.
</p><p>
</p><p>
</p><p>
</p></dd><dt>for <b>имя</b> [ in <b>список_слов</b> ] ; do <b>список</b> ; done</dt><dd>
<p>
Выполняются подстановки в <b>списке_слов</b> после <b>in</b>, в результате чего
</p><p>
получается список элементов. Переменная с соответствующим
</p><p>
<b>именем</b> последовательно получает значение каждого элемента этого
</p><p>
списка, и каждый раз выполняется <b>список</b>. Если слово <b>in</b> не указано,
</p><p>
команда <b>for</b> выполняет <b>список</b> для каждого установленного позиционного 
</p><p>
параметра (см. раздел "<b>ПАРАМЕТРЫ</b>" ниже). Сатусом возврата
</p><p>
является статус выхода последней выполненной команды. Если в 
</p><p>
результате подстановок элементов <b>списка_слов</b> после <b>in</b> получается
</p><p>
пустой список, команды не выполняются и возвращается статус 0.
</p><p>
</p><p>
</p><p>
</p></dd><dt>select <b>имя</b> [ in <b>список_слов</b> ] ; do <b>список</b> ; done</dt><dd>
<p>
Выполняются подстановки в <b>списке_слов</b> после <b>in</b>, в результате чего
</p><p>
получается список элементов. Набор полученных после подстановки
</p><p>
слов выдается в стандартный поток ошибок, причем перед каждым
</p><p>
элементом выдается его порядковый номер. Если слово <b>in</b> не указано,
</p><p>
выдаются установленные позиционные параметры
</p><p>
(см. раздел "<b>ПАРАМЕТРЫ</b>" ниже). Затем выдается приглашение <b>PS3</b>
</p><p>
и читается строка со стандартного входного потока. Если эта строка
</p><p>
содержит число, соответствующее одному из выданных слов, то переменная
</p><p>
<b>имя</b> получает его значение. Если строка пустая, слова и приглашение
</p><p>
выдаются снова. Если прочитан символ конца файла (<b>EOF</b>), команда
</p><p>
заврешается. При вводе любого другого значения переменная <b>имя</b>
</p><p>
получает пустое значение. Прочитанная строка сохраняется в
</p><p>
переменной <b>REPLY</b>. <b>Список</b> выполняется после каждого выбора, пока не 
</p><p>
будет выполнена команда <b>break</b> или <b>return</b>. Статусом выхода
</p><p>
команды <b>select</b> является статус выхода последней команды в списке, 
</p><p>
или 0, если ни одна команда не была выполнена.
</p><p>
</p><p>
</p><p>
</p></dd><dt>case <b>слово</b> in [ ( <b>образец</b> [ | <b>образец</b> ] ... ) <b>список</b> ;; ] ... esac</dt><dd>
<p>
Команда <b>case</b> сначала подставляет значение <b>слова</b> и пытается
</p><p>
его сопоставить поочередно с каждым <b>образцом</b>, используя те же
</p><p>
правила сопоставления, что и для имен файлов (см. подраздел "<b>Подстановка
</b></p><p><b>
имен файлов</b>"). Если найден сопоставляющийся <b>образец</b>, 
</p><p>
выполняется соответствующий <b>список</b>. После нахождения первого 
</p><p>
сопоставления дальнейшее сопоставление не выполняется и команда
</p><p>
завершается. Статус выхода равен 0, если ни один <b>образец</b> не сопоставился.
</p><p>
В противном случае, он равен статусу выхода последней выполненной 
</p><p>
команды из соответствующего <b>списка</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt>if <b>список</b>; then <b>список</b>; [ elif <b>список</b>; then <b>список</b>; ] ... [ else <b>список</b>; ] fi</dt><dd>
<p>
Выполняется <b>список</b> после <b>if</b>. Если его статус выхода - 0,
</p><p>
выполняется <b>список</b> после <b>then</b>. В противном случае, выполняется
</p><p>
последовательно <b>список</b> в очередной конструкции <b>elif</b>, и если его
</p><p>
статус выхода - 0, выполняется соответствующий <b>список</b> после <b>then</b>
</p><p>
и команда завершается. Если все конструкции <b>elif</b> проверены
</p><p>
и ни один из <b>списков</b> не вернул статус 0, выполняется <b>список</b> после <b>else</b>,
</p><p>
если эта конструкция задана. Статусом выхода является
</p><p>
статус выхода последней выполненной команды или 0, если ни одно из условий
</p><p>
не оказалось истинным.
</p><p>
</p><p>
</p><p>
</p></dd><dt>while <b>список</b>; do <b>список</b>; done</dt><dd>
<p>
until <b>список</b>; do <b>список</b>; done
</p><p>
Команда <b>while</b> циклически выполняет <b>список</b> после <b>do</b>, пока
</p><p>
последняя команда <b>списка</b> возвращает статус выхода 0.
</p><p>
Команда <b>until</b> идентична команде <b>while</b>, но условие завершения - 
</p><p>
противоположно; <b>список</b> после <b>do</b> выполняется, пока последняя команда 
</p><p>
<b>списка</b> возвращает ненулевой статус выхода. Статусом выхода команд
</p><p>
<b>while</b> и <b>until</b> является статус выхода последней выполненной
</p><p>
команды <b>списка</b> или 0, если ни одна команда не выполнена.
</p><p>
</p><p>
</p><p>
</p></dd><dt>[ function ] <b>имя</b> () { <b>список</b>; }</dt><dd>
<p>
Эта команда определяет функцию с указанным <b>именем</b>. <i>Тело
</i></p><p><i>
функции</i> образует <b>список</b> команд между фигурными скобками 
</p><p>
<b>{</b> и <b>}</b>. Этот <b>список</b> выполняется каждый раз, когда 
</p><p>
<b>имя</b> функции указывается как имя простой команлы. Статусом выхода функции
</p><p>
является статус выхода последней команды, выполненной в теле 
</p><p>
функции. (См. раздел "<b>ФУНКЦИИ</b>" ниже.)
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbAP">&nbsp;</a>
<h2>КОММЕНТАРИИ</h2>

<p>

В неинтерактивном командном интерпретаторе или в интерактивном с
</p><p>
включенной опцией <b>interactive_comments</b> встроенной команды
</p><p>
<b>shopt</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже), слово,
</p><p>
начинающиеся символом <b>#</b>, влечет игнорирование этого слова и последующих
</p><p>
символов в строке.  Интерактивный командный интерпретатор с не включенной
</p><p>
опцией <b>interactive_comments</b> не допускает использования комментариев.
</p><p>
Опция <b>interactive_comments</b> по умолчанию включается в интерактивных командных
</p><p>
интерпретаторах.
</p><p>
</p><p>
</p><p>
<a name="lbAQ">&nbsp;</a>
</p><h2>МАСКИРОВКА</h2>

<p>

<i>Маскировка</i> (quoting) используется для отмены специального значения для
</p><p>
командного интерпретатора определенных символов или слов. 
</p><p>
Маскировку можно использовать для отмены специфической обработки специальных
</p><p>
символов, для предотвращения распознавания зарезервированных слов, а также
</p><p>
для предотвращения подстановки параметров.
</p><p>
</p><p>
</p><p>
</p><p>

Каждый из метасимволов, перечисленных выше в разделе "<b>ОПРЕДЕЛЕНИЯ</b>",
</p><p>
имеет специальное значение для командного интерпретатора и должен 
</p><p>
маскироваться, если используется буквально. Имеется три механизма маскировки:
</p><p>
<i>символ маскировки</i> (escape character), одиночные кавычки и двойные кавычки.
</p><p>
</p><p>
</p><p>
</p><p>

Незамаскированная обратная косая черта является символом маскировки. Он
</p><p>
требует использовать следующий за ним символ (за исключением перевода строки) 
</p><p>
буквально. Если введена пара символов 
</p><p>
<b>\</b>

</p><p>
<i>&lt;перевод строки&gt;</i> и сама обратная
</p><p>
косая не замаскирована, эта пара обрабатывается как признак продолжения строки
</p><p>
(т.е. она удаляется из входного потока и, по сути, игнорируется).
</p><p>
</p><p>
</p><p>
</p><p>

Все символы в одиночных кавычках используются буквально. Символ одиночной
</p><p>
кавычки (апостроф) не должен указываться между одиночными кавычками, даже если
</p><p>
он предваряется обратной косой.
</p><p>
</p><p>
</p><p>
</p><p>

Символы в двойных кавычках используются буквально, за исключением символов
</p><p>
$, ` и 
</p><p>
<b>\</b>

</p><p>

</p><p>
Обратная косая имеет специальное значение только если после нее идет один
</p><p>
из следующих символов: $, `, ", 
</p><p>
<b>\</b>

</p><p>
<br>&nbsp;или&nbsp;&lt;перевод&nbsp;строки&gt;.&nbsp;Двойную&nbsp;кавычку&nbsp;можно&nbsp;
</p><p>
указывать в двойных кавычках, замаскировав обратной косой.
</p><p>
</p><p>
</p><p>
</p><p>

Специальные параметры * и @ имеют специальное значение при указании в двойных
</p><p>
кавычках (см. раздел "<b>ПАРАМЕТРЫ</b>" ниже).
</p><p>
</p><p>
</p><p>
</p><p>

Слова вида <b>$'строка'</b> обрабатываются особым образомy. Слово заменяется
</p><p>
строкой, в которой предваренные обратной косой символы заменяются в соответствии
</p><p>
со стандартом ANSI C. Управляющие последовательности, начинающиеся с обратной
</p><p>
косой, декодируются следующим образом:
</p><p>
</p><p>
</p><p>
</p><p>

</p><p>
<b>\a</b>

</p><p>
тревога (звонок)
</p><p>
</p><p>

</p><p>
<b>\b</b>

</p><p>
забой
</p><p>
</p><dl compact="">
<dt></dt><dd>
<b>\e</b>

<p>
управляющий символ
</p><p>
</p></dd><dt></dt><dd>
<b>\f</b>

<p>
прогон страницы (form feed)
</p><p>
</p></dd><dt></dt><dd>
<b>\n</b>

<p>
перевод строки (new line)
</p><p>
</p></dd><dt></dt><dd>
<b>\r</b>

<p>
carriage return (возврат каретки)
</p><p>
</p></dd><dt></dt><dd>
<b>\t</b>

<p>
табуляция
</p><p>
</p></dd><dt></dt><dd>
<b>\v</b>

<p>
вертикальная табудяция
</p><p>
</p></dd><dt></dt><dd>
<b>\\</b>

<p>
обратная косая
</p><p>
</p></dd><dt></dt><dd>
<b>\'</b>

<p>
одиночные кавычки
</p><p>
</p></dd><dt></dt><dd>
<b>\</b><i>nnn</i>

<p>
символ, ASCII-код которого совпадает с восьмеричным значением <b>nnn</b> (от одной до трех цифр)
</p><p>
</p></dd><dt></dt><dd>
<b>\x</b><i>HH</i>

<p>
символ, ASCII-код которого совпадает с шестнадцатеричным значением <b>nnn</b> 
</p><p>
(от одной до трех цифр)
</p><p>
</p></dd><dt></dt><dd>
<b>\c</b><i>x</i>

<p>
символа control-<i>x</i>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Преобразованный результат помещается в одиночные кавычки, как если бы
</p><p>
символа доллара просто не было.
</p><p>
</p><p>
</p><p>
</p><p>

Строка в двойных кавычках, перед которой идет символ доллара (<b>$</b>), будет
</p><p>
преобразована в соответствии с текущей локалью. Если текущая локаль - 
</p><p>
<b>C</b> или <b>POSIX</b>, символ доллара игнорируется. Если строка преобразована
</p><p>
и заменена, результат помещается в двойные кавычки.
</p><p>
</p><p>
</p><p>
<a name="lbAR">&nbsp;</a>
</p><h2>ПАРАМЕТРЫ</h2>

<p>

<i>Параметр</i> - это сущность, хранящая значение. Это может быть
</p><p>
имя, число или один из специальных символов, перечисленных ниже в
</p><p>
разделе "<b>Специальные параметры</b>". В контексте 
</p><p>
интерпретатора, <i>переменная</i> - это параметр, обозначаемый <i>именем</i>.
</p><p>
</p><p>
</p><p>
</p><p>

Параметр устанавливается, если ему присвоено значение. Пустая строка является
</p><p>
допустимым значением. После того, как переменная установлена, она может быть
</p><p>
удалена только с помощью встроенной команды <b>unset</b> 
</p><p>
(см. раздел "<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже).
</p><p>
</p><p>
</p><p>
</p><p>

Значение переменной может быть присвоено с помощью оператора вида
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>имя</b>=[<b>значение</b>]
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если <b>значение</b> не задано, переменной присваивается пустая строка. Во всех
</p><p>
<b>значениях</b> выполняется замена тильды, подстановка значений параметров и
</p><p>
переменных, обработка строк, подстановка результатов выполнения команд,
</p><p>
арифметические вычисления и удаление символов маскировки (см.
</p><p>
раздел "<b>ОБРАБОТКА</b>" ниже). Если для переменной
</p><p>
установлен атрибут целочисленная (integer) 
</p><p>
(см. <b>declare</b> в разделе 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>"
</p><p>
ниже), ее значение арифметически вычисляется, даже если арифметическое 
</p><p>
вычисление <b>$((...))</b> не указано явно (см. подраздел 
</p><p>
"<b>Арифметическое вычисление</b>" ниже). Разбиение на слова не выполняется, за исключением
</p><p>
значения <b>"$@"</b>, как объяснено ниже в подразделе 
</p><p>
"<b>Специальные параметры</b>". 
</p><p>
Подстановка имен файлов не выполняется.
</p><p>
</p><p>
</p><p>
<a name="lbAS">&nbsp;</a>
</p><h3>Позиционные параметры</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Позиционный параметр</i> - это параметр, обозначаемый одной или несколькими
</p><p>
цифрами, кроме цифры 0. Позиционным параметрам значения присваиваются на 
</p><p>
основе аргументов, переданных при вызове командного интерпретатора, и могут
</p><p>
быть переприсвоены с помощью встроенной команды <b>set</b>. Позиционным
</p><p>
параметрам нельзя присваивать значения с помощью операторов присваивания.
</p><p>
Позиционные параметры временно заменяются при выполнении функции командного
</p><p>
интерпретатора (см. раздел "<b>ФУНКЦИИ</b>" ниже).
</p><p>
</p><p>
</p><p>
</p><p>

Когда позиционный параметр состоит из нескольких цифр, его надо брать
</p><p>
в скобки (см. раздел "<b>ОБРАБОТКА</b>" ниже).
</p><p>
</p><p>
</p><p>
<a name="lbAT">&nbsp;</a>
</p><h3>Специальные параметры</h3>

<p>
<br>&nbsp;&nbsp;
</p><p>
</p><p>

Командный интерпретатор обрабатывает ряд параметров специальным образом.
</p><p>
Можно только ссылаться на значения этих параметров - присваивания им не
</p><p>
разрешены.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>*</b>
</p><p>
Заменяется позиционными параметрами, начиная с первого. 
</p><p>
Когда такая замена выполняется в двойных кавычках, результат будет
</p><p>
одним словом, в котором значения параметров разделены первым символом
</p><p>
значения специальной переменной <b>IFS</b>. То есть, <b>"$*"</b> эквивалентно
</p><p>
<b>"$1c$2c..."</b>,  где <b>c</b> - первый символ значения переменной <b>IFS</b>. Если переменная
</p><p>
<b>IFS</b> не установлена, значения параметров разделяются пробелами. Если переменная
</p><p>
<b>IFS</b> имеет пустое значение, значения параметров просто конкатенируются, без
</p><p>
разделителей.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>@</b></dt><dd>
<p>
Заменяется позиционными параметрами, начиная с первого. 
</p><p>
Когда такая замена выполняется в двойных кавычках, каждый параметр
</p><p>
заменяется отдельным словом. То есть, <b>"$@"</b>  эквивалентно 
</p><p>
<b>"$1"</b> <b>"$2"</b> ...  Когда позиционных параметров нет, <b>"$@"</b> 
</p><p>
и <b>$@</b> заменяются пустой строкой (т.е. они просто удаляются).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>#</b></dt><dd>
<p>
Заменяется десятичным значением количества позиционных параметров.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>?</b></dt><dd>
<p>
Заменяется статусом последнего выполненного в приоритетном режиме конвейера.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>-</b></dt><dd>
<p>
Заменяется флагами текущих опций, заданных при вызове, с помощью 
</p><p>
встроенной команды <b>set</b> или установленных самим командным
</p><p>
интерпретатором (как, например, опция <b>-i</b>).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>$</b></dt><dd>
<p>
Заменяется идентификатором процесса командного интерпретатора.
</p><p>
В порожденном командном интерпретаторе, запущенном с помощью <b>()</b>, заменяется
</p><p>
идентификатором процесса основного интерпретатора, а не порожденного.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>!</b></dt><dd>
<p>
Заменяется идентификатором последнего процесса, запущенного в фоновом 
</p><p>
(асинхронном) режиме.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>0</b></dt><dd>
<p>
Заменяется именем командного интерпретатора или сценария. Это значение
</p><p>
устанавливается при инициализации командного интерпретатора. Если 
</p><p>
<b>bash</b> вызван с командным файлом, <b>$0</b> будет установлен равным имени
</p><p>
этого файла. Если <b>bash</b> запущен с опцией <b>-c</b>, 
</p><p>
<b>$0</b> получает значение
</p><p>
первого аргумента после строки, которую надо выполнить, если он задан. 
</p><p>
В противном случае, этот специальный параметр получает значение имени
</p><p>
файла, использованного для вызова <b>bash</b>, которое задается нулевым
</p><p>
аргументом.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>_</b></dt><dd>
<p>
При запуске командного интерпретатора устанавливается равным <i>полному
</i></p><p><i>
имени файла</i> (absolute file name) командного интерпретатора или выполняемого 
</p><p>
сценария, переданного в списке аргументов. В последствии,
</p><p>
заменяется последним аргументом предыдущей команды, с учетом всех замен.
</p><p>
Также устанавливается равным полному имени файла каждой выполняемой внешней 
</p><p>
команды и помещается в среду, экспортируемую для этой команды. При проверке
</p><p>
почты этот параметр содержит имя проверяемого файла почты.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbAU">&nbsp;</a>
<h3>Переменные командного интерпретатора</h3>

<p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор устанавливает следующие переменные:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>PPID</b>
</p><p>
Идентификатор родительского процесса для командного интерпретатора. 
</p><p>
Эта переменная доступна только для чтения.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>PWD</b></dt><dd>
<p>
Текущий рабочий каталог, установленный с помощью команды <b>cd</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>OLDPWD</b></dt><dd>
<p>
Предыдущий рабочий каталог, который был установлен с помощью команды 
</p><p>
<b>cd</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>REPLY</b></dt><dd>
<p>
Устанавливается равной значению, прочитанному встроенной командой
</p><p>
<b>read</b>, при вызове ее без аргументов.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>UID</b></dt><dd>
<p>
Идентификатор текущего пользователя - устанавливается при запуске командного
</p><p>
интерпретатора. Эта переменная доступна только для чтения.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>EUID</b></dt><dd>
<p>
Эффективный идентификатор текущего пользователя - устанавливается 
</p><p>
при запуске командного интерпретатора. Эта переменная доступна 
</p><p>
только для чтения.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>GROUPS</b></dt><dd>
<p>
Переменная-массив, содержащая список групп, в которые входит текущий
</p><p>
пользователь. Эта переменная доступна только для чтения.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>BASH</b></dt><dd>
<p>
Полное имя файла, использованное для вызова данного экземпляра <b>bash</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>BASH_VERSION</b></dt><dd>
<p>
Строка, описывающая версию данного экземпляра <b>bash</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>BASH_VERSINFO</b></dt><dd>
<p>
Доступный только для чтения массив, элементы которого содержат информацию
</p><p>
о версии для данного экземпляра <b>bash</b>. Элементы массива имеют следующие
</p><p>
значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>BASH_VERSINFO[0]</b></dt><dd>
<p>
Главный номер версии (релиз).
</p><p>
</p></dd><dt><b>BASH_VERSINFO[1]</b></dt><dd>
<p>
Второстепенный номер версии (версия).
</p><p>
</p></dd><dt><b>BASH_VERSINFO[2]</b> </dt><dd>
<p>
Уровень исправлений.
</p><p>
</p></dd><dt><b>BASH_VERSINFO[3]</b></dt><dd>
<p>
Версия сборки.
</p><p>
</p></dd><dt><b>BASH_VERSINFO[4]</b></dt><dd>
<p>
Статус релиза (например, <b>beta1</b>).
</p><p>
</p></dd><dt><b>BASH_VERSINFO[5]</b></dt><dd>
<p>
Значение переменной <b>MACHTYPE</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>SHLVL</b></dt><dd>
<p>
Увеличивается на 1 при каждом запуске порожденного интерпретатора <b>bash</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>RANDOM</b></dt><dd>
<p>
При каждом обращении к этому параметру генерируется случайное число
</p><p>
от 0 до 32767. Конкретная последовательность случайных чисел
</p><p>
может быть проинициализирована путем присваивания значения переменной 
</p><p>
<b>RANDOM</b>. Если переменная <b>RANDOM</b> удаляется с помощью 
</p><p>
<b>unset</b>, она 
</p><p>
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>SECONDS</b></dt><dd>
<p>
При каждом обращении к этому параметру возвращается количество секунд,
</p><p>
прошедших с момента вызова данного командного интерпретатора. Если переменной
</p><p>
<b>SECONDS</b> присваивается значение, при последующем обращении будет получено
</p><p>
количество секунд, прошедшее с момента присваивания, плюс присвоенное
</p><p>
значение. Если переменная <b>SECONDS</b> удаляется 
</p><p>
с помощью <b>unset</b>, она
</p><p>
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>LINENO</b></dt><dd>
<p>
При каждом обращении к этому параметру командный интерпретатор
</p><p>
подставляет десятичное число, представляющее порядковый номер текущей
</p><p>
строки (начиная с 1) в сценарии или функции. При вызове не из
</p><p>
сценария или функции, не гарантируется подстановка осмысленного значения.
</p><p>
Если переменная <b>LINENO</b> удаляется 
</p><p>
с помощью <b>unset</b>, она 
</p><p>
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HISTCMD</b></dt><dd>
<p>
Исторический номер команды, или индекс текущей команды в списке выполненных 
</p><p>
команд. Если переменная <b>HISTCMD</b> удаляется 
</p><p>
с помощью <b>unset</b>, она 
</p><p>
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>DIRSTACK</b></dt><dd>
<p>
Переменная-массив (см. раздел "<b>Массивы</b>" далее), 
</p><p>
в которой хранится текущее содержимое
</p><p>
стека каталогов. Каталоги находятся в стеке в том же порядке, в котором
</p><p>
выдаются встроенной командой <b>dirs</b>. 
</p><p>
Путем присваивания элементам этого
</p><p>
массива можно изменять каталоги, уже находящиеся в стеке, но для
</p><p>
добавления и удаления каталогов надо использовать встроенные команды
</p><p>
<b>pushd</b> и <b>popd</b>. 
</p><p>
Присваивание значения этой переменной не меняет текущий каталог.
</p><p>
Если переменная <b>DIRSTACK</b> удаляется 
</p><p>
с помощью <b>unset</b>, она 
</p><p>
теряет свои специальные свойства, даже если в дальнейшем переустанавливается.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>PIPESTATUS</b></dt><dd>
<p>
Переменная-массив (см. раздел "<b>Массивы</b>" далее), содержащая список значений
</p><p>
статусов выхода процессов в последнем выполненном в приоритетном режиме
</p><p>
конвейере (который может состоять и всего из одной команды).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>OPTARG</b></dt><dd>
<p>
Значение последнего аргумента-опции, обработанного встроенной командной
</p><p>
<b>getopts</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>OPTIND</b></dt><dd>
<p>
Индекс следующего аргумента, который должен быть обработан встроенной
</p><p>
командой <b>getopts</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HOSTNAME</b></dt><dd>
<p>
Автоматически устанавливается равной имени текущего хоста.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HOSTTYPE</b></dt><dd>
<p>
Автоматически устанавливается равной строке, уникально описывающей тип
</p><p>
машины, на которой выполняется <b>bash</b>. Стандартное значение зависит от системы.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>OSTYPE</b></dt><dd>
<p>
Автоматически устанавливается равной строке, описывающей операционную систему,
</p><p>
на которой выполняется командный интерпретатор <b>bash</b>. Стандартное значение
</p><p>
зависит от системы.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>MACHTYPE</b></dt><dd>
<p>
Автоматически устанавливается равной строке, полностью описывающей тип системы,
</p><p>
на которой выполняется <b>bash</b>, в стандартном для GNU формате
</p><p>
<b>процессор-компания-система</b>. Стандартное значение зависит от системы.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>SHELLOPTS</b></dt><dd>
<p>
Список установленных опций командного интерпретатора через двоеточие.
</p><p>
Каждое слово в списке - допустимый аргумент для опции <b>-o</b> встроенной
</p><p>
команды <b>set</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже).
</p><p>
Опции, упоминающиеся в списке <b>SHELLOPTS</b>, совпадают с выдаваемыми 
</p><p>
как установленные командой <b>set -o</b>. 
</p><p>
Если эта переменная экспортирована в среду
</p><p>
при запуске командного интерпретатора <b>bash</b>, все упомянутые в списке
</p><p>
опции будут установлены до чтения любых файлов начального запуска.
</p><p>
Эта перменная доступна только для чтения.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Следующие переменные используются командным интерпретатором. В некоторых 
</p><p>
случаях <b>bash</b> присваивает переменным стандартные значения; эти случаи указаны 
</p><p>
ниже.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>IFS</b>
</p><p>
<i>Внутренний разделитель полей</i> (Internal Field Separator), используемый
</p><p>
для выделения слов после всех подстановок и для разбиения на слова строк,
</p><p>
прочитанных с помощью встроенной команды <b>read</b>. 
</p><p>
Стандартное значение - <b>"&lt;пробел&gt;&lt;табуляция&gt;&lt;перевод строки&gt;"</b>.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>PATH</b></dt><dd>
<p>
Путь поиска команд. Это список каталогов через двоеточие, в которых
</p><p>
командный интерпретатор ищет команды 
</p><p>
(см. раздел "<b>ВЫПОЛНЕНИЕ КОМАНД</b>"
</p><p>
ниже). Стандартный путь поиска зависит от системы и задается администратором,
</p><p>
устанавливающим <b>bash</b>. Типичное значение:
</p><p>
"/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.".
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HOME</b></dt><dd>
<p>
Начальный каталог текущего пользователя; стандартный аргумент для встроенной
</p><p>
команды <b>cd</b>. Значение этой переменной также используется 
</p><p>
при замене тильды.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>CDPATH</b></dt><dd>
<p>
Путь поиска для команды <b>cd</b>. Это список каталогов через
</p><p>
двоеточие, в которых командный интерпретатор ищет целевые каталоги, указанные 
</p><p>
по имени в команде <b>cd</b>. Пример возможного 
</p><p>
значения - ".:~:/usr".
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>BASH_ENV</b></dt><dd>
<p>
Если этот параметр установлен при выполнении командным интерпретатором
</p><p>
<b>bash</b> сценария, его значение интерпретируется как имя файла, содержащего команды
</p><p>
инициализации интерпретатора, аналогично <b>~/.bashrc</b>.
</p><p>
В значении <b>BASH_ENV</b> перед интерпретацией выполняется подстановка значений 
</p><p>
параметров, подстановка результатов выполнения команд и арифметические 
</p><p>
вычисления. Переменная <b>PATH</b> не используется для поиска результирующего имени
</p><p>
файла.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>MAIL</b></dt><dd>
<p>
Если этот параметр установлен равным имени файла 
</p><p>
и не установлена переменная <b>MAILPATH</b>, <b>bash</b> информирует пользователя
</p><p>
о получении электронной почты в указанный файл.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>MAILCHECK</b></dt><dd>
<p>
Задает частоту проверки (в секундах) электронной почты командным 
</p><p>
интерпретатором <b>bash</b>. Стандартное значение - 60 секунд.  
</p><p>
Когда приходит время проверять наличие новой почты, командный
</p><p>
интерпретатор делает это перед выдачей первичного приглашения.
</p><p>
Если эта переменная не установлена, проверка почты командным
</p><p>
интерпретатором отключается.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>MAILPATH</b></dt><dd>
<p>
Список имен файлов через двоеточие, в которых нужно проверять наличие
</p><p>
новых почтовых сообщений. Можно задавать сообщение, которое должно
</p><p>
выдаваться при поступлении почты в конкретный файл, отделяя сообщение от
</p><p>
имени файла вопросительным знаком (<b>?</b>). В тексте этого 
</p><p>
сообщения метасимвол <b>$_</b> заменяется именем текущего файла почты. Например:
</p><p>
<br>&nbsp;
</p><p>
MAILPATH='/usr/spool/mail/bfox?"You have mail":~/shell-mail?"$_ has mail!"'
</p><p>
</p></dd></dl>
<p>

</p><p>
</p><p>
Командный интерпретатор <b>bash</b> поддерживает стандартное значение 
</p><p>
для этой переменной, но используемое при этом местонахождение файлов почты
</p><p>
пользователя зависит от системы (например, <b>/usr/spool/mail/$USER</b>).
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>PS1</b></dt><dd>
<p>
Значение этого параметра обрабатывается (см. 
</p><p>
раздел "<b>ПРИГЛАШЕНИЯ</b>" ниже) и
</p><p>
используется для установки строки первичного приглашения. Стандартное
</p><p>
значение - "\s-\v\$ ".
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>PS2</b></dt><dd>
<p>
Значение этого параметра обрабатывается, как и <b>PS1</b>, и
</p><p>
используется для установки строки вторичного приглашения. 
</p><p>
Стандартное значение - "&gt; ".
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>PS3</b></dt><dd>
<p>
Значение этого параметра используется в качестве 
</p><p>
приглашения для команды <b>select</b> 
</p><p>
(см. раздел "<b>СИНТАКСИС КОМАНД</b>" выше).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>PS4</b></dt><dd>
<p>
Значение этого параметра обрабатывается, как и <b>PS1</b>, и
</p><p>
выдается перед каждой командой, показываемой интерпретатором
</p><p>
<b>bash</b> в ходе трассировки выполнения. Первый символ <b>PS4</b>
</p><p>
повторяется необходимое количество раз, показывая уровень
</p><p>
вложенности. Стандартное значение - "+".
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>TIMEFORMAT</b></dt><dd>
<p>
Значение этого параметра используется в качестве строки, задающей формат
</p><p>
выдачи информации о времени выполнения для конвейеров, перед которыми
</p><p>
задано зарезервированное слово <b>time</b>. Символ <b>%</b> начинает управляющую 
</p><p>
последовательность, заменяемую значением времени или другой информацией.
</p><p>
Управляющие последовательности имеют следующие значения (в квадратных
</p><p>
скобках представлены необязательные части):
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>%%</b>
</p><p>
Символ <b>%</b>.
</p><p>
</p></dd><dt><b>%[p][l]R</b></dt><dd>
<p>
Время выполнения, в секундах.
</p><p>
</p></dd><dt><b>%[p][l]U</b></dt><dd>
<p>
Количество секунд работы процессора в пользовательском режиме.
</p><p>
</p></dd><dt><b>%[p][l]S</b></dt><dd>
<p>
Количество секунд работы процессора в системном режиме.
</p><p>
</p></dd><dt><b>%P</b></dt><dd>
<p>
Процент использования процессора, вычисляемый как (<b>%U</b> + <b>%S</b>) / <b>%R</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
Необязательный параметр <b>p</b> - это цифра, задающая точность,
</p><p>
количество знаков (долей секунды) после запятой. Значение 0
</p><p>
отменяет выдачу долей секунды. Максимальная точность - три знака после запятой;
</p><p>
значения <b>p</b> больше 3 заменяются на 3. Если <b>p</b> не задано, используется значение 3.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Необязательный параметр <b>l</b> задает длинный формат, включая минуты, в виде
</p><p>
<b>MMmSS.FFs</b>. Значение праметра <b>p</b> определяет, включаются доли секунды или нет.
</p><p>
</p><p>
</p><p>
</p><p>

Если эта переменная не установлена, <b>bash</b> действует так, как если бы
</p><p>
она имела значение <b>$'\nreal\t%3lR\nuser\t%3lU\nsys%3lS'</b>. Если установлено
</p><p>
пустое значение, информация о времени выполнения не выдается.
</p><p>
При выводе строки по формату добавляется перевод строки.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>HISTSIZE</b></dt><dd>
<p>
Количество команд, которые необходимо запоминать в <i>списке истории</i> (см.
</p><p>
раздел "<b>ИСТОРИЯ КОМАНД</b>" ниже). Стандартное значение - 500.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HISTFILE</b></dt><dd>
<p>
Имя файла, в котором сохраняется история команд (см. раздел 
</p><p>
"<b>ИСТОРИЯ КОМАНД</b>" ниже). 
</p><p>
Стандартное значение - <b>~/.bash_history</b>.
</p><p>
Если эта переменная не установлена, история команд не сохраняется при
</p><p>
завершении работы интерактивного командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HISTFILESIZE</b></dt><dd>
<p>
Максимальное количество строк, содержащееся в файле истории.
</p><p>
Если этой переменной присвоено значение, файл истории, при необходимости,
</p><p>
усекается, и будет содержать не больше, чем указанное количество строк.
</p><p>
Стандартное значение - 500. Файл истории также усекается до этого размера после
</p><p>
записи при выходе из интерактивного командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>OPTERR</b></dt><dd>
<p>
Если имеет значение 1, <b>bash</b> показывает сообщения об ошибках, выдаваемые
</p><p>
встроенной командой <b>getopts</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>"
</p><p>
ниже). Переменная <b>OPTERR</b> инициализируется значением 1 при каждом вызове 
</p><p>
командного интерпретатора или выполнении сценария.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>LANG</b></dt><dd>
<p>
Используется для определения локали для всех категорий, не заданных явно с 
</p><p>
помощью переменной, имя которой начинается с <b>LC_</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>LC_ALL</b></dt><dd>
<p>
Эта переменная переопределяет значение переменной <b>LANG</b> и всех остальных
</p><p>
переменных <b>LC_</b>, задающих категорию локали.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>LC_COLLATE</b></dt><dd>
<p>
Эта переменная задает порядок сортировки, используемый при сортировке 
</p><p>
полученных по шаблону имен файлов, и определяет интерпретацию диапазонов,
</p><p>
<i>классов эквивалентостей</i> и правила сравнения символов для подстановки имен
</p><p>
файлов и сопоставления с образцом.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>LC_CTYPE</b></dt><dd>
<p>
Эта переменная определяет интерпретацию символов и принадлежность символов
</p><p>
к определенному классу для подстановки имен файлов и сопоставления с образцом.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>LC_MESSAGES</b></dt><dd>
<p>
Эта переменная определяет локаль, используемую для обработки строк в двойных
</p><p>
кавычках, перед которыми указан символ <b>$</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>PROMPT_COMMAND</b></dt><dd>
<p>
Если значение задано, оно выполняется как команда перед выдачей каждого 
</p><p>
первичного приглашения.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>IGNOREEOF</b></dt><dd>
<p>
Управляет действием командного интерпретатора при получении <i>символа
</i></p><p><i>
конца файла</i> (<b>EOF</b>) как единственного символа в строке. Если
</p><p>
эта переменная установлена, ее значение интерпретируется как количество
</p><p>
подряд идущих символов <b>EOF</b>, с которых должна начинаться строка, чтобы в 
</p><p>
результате работа командного интерпретатора <b>bash</b> завершилась. Если
</p><p>
переменная существует, но не имеет числового значения или не имеет значения вообще,
</p><p>
по умолчанию используется значение 10. Если эта переменная не существует,
</p><p>
<b>EOF</b> означает конец входных данных для командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>TMOUT</b></dt><dd>
<p>
Если установлено значение больше нуля, оно интерпретируется как количество
</p><p>
секунд ожидания ввода после выдачи первичного приглашения. Командный
</p><p>
интерпретатор <b>bash</b> завершает работу по истечении этого времени, если не
</p><p>
введена команда.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>FCEDIT</b></dt><dd>
<p>
Задает стандартный редактор для встроенной команды <b>fc</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>FIGNORE</b></dt><dd>
<p>
Список суффиксов через двоеточие, которые необходимо игнорировать при
</p><p>
завершении имен файлов (см. раздел 
</p><p>
"<b>БИБЛИОТЕКА READLINE</b>" ниже). Имя файла,
</p><p>
суффикс которого совпадает с одним из указанных в <b>FIGNORE</b>
</p><p>
значений, исключается из списка соответствующих имен файлов.
</p><p>
Пример значения - <b>".o:~"</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>GLOBIGNORE</b></dt><dd>
<p>
Список шаблонов через двоеточие, задающих набор имен файлов, которые
</p><p>
надо игнорировать при подстановке имен. Если имя файла, соответствующее шаблону,
</p><p>
также соответствует одному из шаблонов в <b>GLOBIGNORE</b>, оно удаляется
</p><p>
из списка соответствующих.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>INPUTRC</b></dt><dd>
<p>
Имя файла начального запуска <b>readline</b>, переопределяющего стандартные
</p><p>
установки в файле <b>~/.inputrc</b> (см. раздел 
</p><p>
"<b>БИБЛИОТЕКА READLINE</b>" ниже).
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HISTCONTROL</b></dt><dd>
<p>
Если имеет значение <b>ignorespace</b>, строки, начинающиеся символом
</p><p>
пробела, не попадают в список выполненных команд. Если имеет значение
</p><p>
<b>ignoredups</b>, строки, совпадающие с последней выполненной командой, в список
</p><p>
выполненных команд не попадают. Значение <b>ignoreboth</b> сочетает действие
</p><p>
обеих представленных опций. Если переменной нет или она имеет какое-то другое
</p><p>
значение, кроме перечисленных выше, все строки, прочитанные синтаксическим 
</p><p>
анализатором, сохраняются в списке истории, с учетом значения переменной
</p><p>
<b>HISTIGNORE</b>. Действие этой переменной переопределяется переменной
</p><p>
<b>HISTIGNORE</b>. Вторая и следующие строки многострочной составной команды не
</p><p>
проверяются, и добавляются в список истории независимо от значения 
</p><p>
<b>HISTCONTROL</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HISTIGNORE</b></dt><dd>
<p>
Список шаблонов через двоеточие, используемых для принятия решения о сохранении
</p><p>
командных строк в списке истории. Каждый шаблон привязывается к началу 
</p><p>
строки и должен задавать всю строку ('<b>*</b>' неявно не добавляется). Каждый
</p><p>
шаблон сравнивается со строкой после проверок, задаваемых
</p><p>
переменной <b>HISTCONTROL</b>. Кроме обычных символов сопоставления с образцом 
</p><p>
в командном интерпретаторе, символ '<b>&amp;</b>' сопоставляется с предыдущей строкой
</p><p>
в списке истории. Символ '<b>&amp;</b>' можно экранировать с помощью обратной косой. Перед
</p><p>
сопоставлением обратная косая убирается. Вторая и последующая строки составной
</p><p>
многострочной команды не проверяются и добавляются в список истории независимо от
</p><p>
значения переменной <b>HISTIGNORE</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>histchars</b></dt><dd>
<p>
Два или три символа, управляющих подстановкой и разбиением на лексемы
</p><p>
уже выполненных команд (см. раздел 
</p><p>
"<b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ВЫПОЛНЕННЫХ</b>"
</p><p>
ниже). Первый символ - это символ подстановки из списка, который
</p><p>
означает начало работы со списком истории. Обычно это символ '<b>!</b>'. 
</p><p>
Второй символ - это символ быстрой подстановки, используемый для быстрого
</p><p>
повторения предыдущей введенной команды, с подстановкой указанной строки вместо
</p><p>
другой, заданной в этой команде. По умолчанию используется символ '<b>^</b>'. 
</p><p>
Необязательный третий символ - это символ, указывающий, если является
</p><p>
первым символом слова, что остаток строки - это комментарий. Обычно в этом 
</p><p>
качестве используется символ '<b>#</b>'. Символ комментария для списка истории
</p><p>
приводит к отказу от подстановки из истории для оставшихся слов в командной
</p><p>
строке. Он не обязательно приводит к обработке синтаксическим анализатором
</p><p>
оставшейся части строки как комментария.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>HOSTFILE</b></dt><dd>
<p>
Содержит имя файла того же формата, что и файл <b>/etc/hosts</b>, который
</p><p>
будет читаться при необходимости подстановки имени хоста. Этот файл
</p><p>
можно менять интерактивно; при следующей попытке подстановки имени
</p><p>
хоста <b>bash</b> добавит содержимое нового файла к уже существующей базе данных.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>auto_resume</b></dt><dd>
<p>
Эта переменная управляет взаимодействием командного интерпретатора с
</p><p>
пользователем и средствами управления заданиями. Если она установлена,
</p><p>
простые команды из одного слова и без перенаправлений рассматриваются
</p><p>
как указатели возможного возобновления существующих остановленных заданий.
</p><p>
Неоднозначность не допускается; если с введенной строки начинается 
</p><p>
более одного задания, выбирается последнее по времени приостановки задание.
</p><p>
Имя остановленного задания, в этом контексте, - это командная строка,
</p><p>
использовавшаяся для его запуска. Если эта переменная имеет значение
</p><p>
<b>exact</b>, введенная строка должна точно совпадать с именем остановленного задания;
</p><p>
Если же задано значение <b>substring</b>, введенная строка должна быть
</p><p>
подстрокой имени остановленного задания. Это аналогично по возможностям
</p><p>
идентификатору задания <b>%?</b>
</p><p>
(см. раздел "<b>УПРАВЛЕНИЕ ЗАДАНИЯМИ</b>" ниже). 
</p><p>
Если установлено любое другое 
</p><p>
значение, введенная строка должна быть префиксом имени остановленного
</p><p>
задания; это аналогично по возможностям идентификатору задания <b>%</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbAV">&nbsp;</a>
<h3>Массивы</h3>

<p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор <b>bash</b> поддерживает <i>одномерные массивы</i>.
</p><p>
Любая переменная может использоваться как массив; встроенная
</p><p>
процедура <b>declare</b> позволяет объявить массив явно. 
</p><p>
Нет ограничения на рамер массива или требования непрерывности индексов. Массивы
</p><p>
индексируются целыми числами, начиная с нуля.
</p><p>
</p><p>
</p><p>
</p><p>

Массив создается автоматически при присваивании любой переменной значения
</p><p>
с помощью конструкции <b>имя[индекс]=значение</b>. Индекс обрабатывается как
</p><p>
арифметическое выражение, которое должно иметь неотрицательное значение.
</p><p>
Для явного объявления массива используется команда <b>declare -a имя</b>
</p><p>
(см. раздел "<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>"
</p><p>
ниже). Конструкция <b>declare -a имя[индекс]</b> также поддерживается; 
</p><p>
индекс просто игнорируется. Для переменной типа массив можно задать атрибуты 
</p><p>
с помощью встроенных команд <b>declare</b> и 
</p><p>
<b>readonly</b>. Атрибут применяется ко всем элементам массива.
</p><p>
</p><p>
</p><p>
</p><p>

Присваивания массивам выполняются с помощью конструкций вида 
</p><p>
<b>имя=(значение1  ...  значениеn)</b>, где каждое <b>значение</b> имеет вид
</p><p>
<b>[индекс]=строка</b>. Обязательно задавать только <b>строку</b>. Если необязательные
</p><p>
квадратные скобки и <b>индекс</b> указаны, присваивание выполняется элементу с
</p><p>
соответствующим индексом; в противном случае, в качестве индекса элемента 
</p><p>
используется индекс последнего элемента, которому было присвоено значение,
</p><p>
плюс один. Индексация начинается с нуля. Эту же конструкцию присваивания можно
</p><p>
использовать и во встроенной команде <b>declare</b>. 
</p><p>
Значения отдельным элементам массива присваиваются с помощью представленной 
</p><p>
выше конструкции <b>имя[индекс]=значение</b>.
</p><p>
</p><p>
</p><p>
</p><p>

На любой элемент массива можно сослаться с помощью конструкции 
</p><p>
<b>${имя[индекс]}</b>. Фигурные скобки необходимы, чтобы избежать конфликтов при
</p><p>
подстановке имен файлов. Если в качестве индекса указан символ <b>@</b> или <b>*</b>,
</p><p>
слово заменяется всеми элементами массива с указанным именем. Эти индексы
</p><p>
интерпретируются по-разному только если слово указано в двойных кавычках.
</p><p>
Если слово указано в двойных кавычках, конструкция <b>${имя[*]}</b> заменяется
</p><p>
одним словом, значение которого строится как значения каждого элемента
</p><p>
массива, разделенные первым символом из значения переменной среды <b>IFS</b>, а
</p><p>
конструкция <b>${имя[@]}</b> заменяет каждый элемент массива <b>имя</b> отдельным словом.
</p><p>
Когда массив пустой, <b>${имя[@]}</b> заменяется пустой строкой. Это аналогично замене
</p><p>
специальных параметров <b>*</b> и <b>@</b> (см. 
</p><p>
подраздел "<b>Специальные параметры</b>" выше).
</p><p>
Конструкция <b>${#имя[индекс]}</b> заменяется длиной элемента <b>${имя[индекс]}</b>.
</p><p>
Если в качестве индекса указан символ <b>*</b> или <b>@</b>, подставляется количество элементов
</p><p>
массива. Ссылка на переменную-массив без индекса эквивалентна ссылке на
</p><p>
элемент с индексом ноль.
</p><p>
</p><p>
</p><p>
</p><p>

Для уничтожения массивов используется встроенная команда 
</p><p>
<b>unset</b>.
</p><p>
Команда <b>unset имя[индекс]</b> уничтожает элемент массива с указанным индексом. 
</p><p>
Команда <b>unset name</b>, где <b>name</b> - имя массива, или <b>unset имя[индекс]</b>,
</p><p>
где индекс - <b>*</b> или <b>@</b>, удаляет весь массив.
</p><p>
</p><p>
</p><p>
</p><p>

Встроенные команды <b>declare</b>, 
</p><p>
<b>local</b> и <b>readonly</b>
</p><p>
воспринимают опцию <b>-a</b> для указания массива. 
</p><p>
Встроенная команда <b>read</b> воспринимает опцию <b>-a</b>
</p><p>
для присваивания массиву списка слов, прочитанных из станадартного
</p><p>
входного потока. Встроенные команды <b>set</b> и 
</p><p>
<b>declare</b> выдают значения массивов
</p><p>
так, что их можно повторно использовать в присваиваниях.
</p><p>
</p><p>
</p><p>
<a name="lbAW">&nbsp;</a>
</p><h2>ЗАМЕНЫ</h2>

<p>

Замена выполняется в командной строке после разбиения ее на слова.
</p><p>
Выполняется семь видов замен: замена выражений в фигурных скобках,  
</p><p>
замена тильды, подстановка значений переменных и параметров, подстановка
</p><p>
результатов выполнения команд, подстановка значений арифметических
</p><p>
выражений, разбиение слов и подстановка имен файлов.
</p><p>
</p><p>
</p><p>
</p><p>

Замена выполняется в следующем порядке: замена выражений в фигурных скобках,
</p><p>
замена тильды, подстановка значений переменных, параметров, арифметических 
</p><p>
выражений и результатов выполнения команд (слева направо), разбиение слов
</p><p>
и подстановка имен файлов.
</p><p>
</p><p>
</p><p>
</p><p>

В системах, где это может поддерживаться, выполняется дополнительная замена -
</p><p>
подстановка процессов.
</p><p>
</p><p>
</p><p>
</p><p>

Только замена выражений в фигурных скобках, разбиение слов 
</p><p>
и подстановка имен файлов может изменить количество слов в командной
</p><p>
строке; при других заменах одно слово просто заменяется другим. Единственное
</p><p>
исключение - подстановка <b>"$@"</b> и <b>"${имя[@]}"</b>, как объяснялось выше
</p><p>
(см. раздел "<b>ПАРАМЕТРЫ</b>").
</p><p>
</p><p>
</p><p>
<a name="lbAX">&nbsp;</a>
</p><h3>Замена выражений в фигурных скобках</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Замена выражений в фигурных скобках</i> - это механизм генерации произвольных 
</p><p>
строк. Он аналогичен подстановке имен файлов, но генерируемые имена
</p><p>
не обязательно должны существовать. Шаблоны в фигурных скобках имеют вид
</p><p>
необязательного префикса, за которым идет набор строк через запятую в фигурных 
</p><p>
скобках, после чего - необязательный суффикс. Префикс добавляется в начало 
</p><p>
каждой строки, содержащейся в фигурных скобках, а затем к каждой полученной 
</p><p>
так (слева направо) строке добавляется суффикс.
</p><p>
</p><p>
</p><p>
</p><p>

Выражения в фигурных скобках могут быть вложенными. Результаты каждой замены не
</p><p>
сортируются; порядок слева направо сохраняется. Например, конструкция
</p><p>
<b>a{d,c,b}e</b> заменяется на '<b>ade ace abe</b>'.
</p><p>
</p><p>
</p><p>
</p><p>

Замена выражений в фигурных скобках выполняется перед любыми другими заменами, и
</p><p>
в результате сохраняются все символы, имеющие специальное значение для других 
</p><p>
замен. Эта замена - строго текстуальная. Командный интерпретатор <b>bash</b> никак
</p><p>
не учитывает контекст подстановки или текст в фигурных скобках. 
</p><p>
</p><p>
</p><p>
</p><p>

Корректное выражение в фигурных скобках должно содержать незамаскированные
</p><p>
открывающую и закрывающую фигурную скобку и, по крайней мере, одну незамаскированную 
</p><p>
запятую. Любое некорректное выражение в фигурных скобках остается неизменным.
</p><p>
Символ <b>{</b> или <b>,</b> может маскироваться обратной косой для предотвращения его 
</p><p>
интерпретации на этапе замены выражений в фигурных скобках.
</p><p>
</p><p>
</p><p>
</p><p>

Эта конструкция обычно используется для сокращенной записи группы строк с
</p><p>
общим префиксом, более длинным чем в представленном выше примере:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdir&nbsp;/usr/local/src/bash/{old,new,dist,bugs}
</p><p>
</p><p>
</p><p>
или
</p><p>
</p></dd><dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chown&nbsp;root&nbsp;/usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

</p><p>
</p><p>
Замена выражений в фигурных скобках вносит небольшое рассогласование
</p><p>
с историческими версиями <b>sh</b>. Командный интерпретатор <b>sh</b> не рассматривает
</p><p>
открывающую и закрывающую фигурные скобки в слове специальным образом
</p><p>
и просто сохраняет их. Командный интерпретатор <b>bash</b> удаляет фигурные скобки
</p><p>
из слова при замене. Например, слово, введенное в <b>sh</b> как <b>file{1,2}</b>,
</p><p>
остается без изменений. Это же слово заменяется парой слов
</p><p>
<b>file1 file2</b> после замены выражения в фигурных скобках в <b>bash</b>.
</p><p>
Если требуется полная совместимость с <b>sh</b>, командный интерпретатор <b>bash</b>
</p><p>
надо запускать с опцией <b>+B</b> или отключать с помощью опции 
</p><p>
<b>+B</b> команды <b>set</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже).
</p><p>
</p><p>
</p><p>
<a name="lbAY">&nbsp;</a>
</p><h3>Замена тильды</h3>

<p>
</p><p>
</p><p>
</p><p>

Если слово начинается незамаскированным символом тильда (<b>~</b>),
</p><p>
все символы до первой незамаскированной косой черты (или все символы,
</p><p>
если незамаскированной косой черты в слове нет) считаются <i>тильда-префиксом</i>.
</p><p>
Если ни один из символов тильда-префикса не замаскирован, его символы после 
</p><p>
тильды рассматриваются как возможное регистрационное имя. Если это 
</p><p>
регистрационное имя представляет собой пустую строку, тильда заменяется
</p><p>
значением переменной <b>HOME</b>. Если переменная <b>HOME</b> не установлена, подставляется
</p><p>
начальный каталог пользователя, выполняющего процесс командного интерпретатора.
</p><p>
Если же тильда-префикс не пустой, подставляется начальный каталог 
</p><p>
соответствующего пользователя.
</p><p>
</p><p>
</p><p>
</p><p>

Если тильда-префикс имеет вид <b>~+</b>, вместо него подставляется значение
</p><p>
переменной <b>PWD</b>. Если тильда-префикс имеет вид <b>~-</b>, вместо него подставляется
</p><p>
значение переменной <b>OLDPWD</b>, если эта переменная установлена. 
</p><p>
Если среди символов после тильды в тильда-префиксе имеется число
</p><p>
<b>N</b>, с необязательными префиксами <b>+</b> или <b>-</b>, тильда-префикс заменяется
</p><p>
соответствующим элементом из стека каталогов, который был бы выдан
</p><p>
встроенной командой <b>dirs</b> при вызове с тильда-префиксом в
</p><p>
качестве аргумента. Если символы после тильды содержат число без начального знака
</p><p>
<b>+</b> или <b>-</b>, предполагается <b>+</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Если соответствующего регистрационного имени не существует или
</p><p>
замену тиильды выполнить не удалось, исходное слово остается без изменений.
</p><p>
</p><p>
</p><p>
</p><p>

Присваивания значений переменным проверяются на наличие незамаскированных
</p><p>
тильда-префиксов сразу после <b>:</b> или <b>=</b>. В этих случаях также выполняется 
</p><p>
замена тильды. Соответственно, можно использовать имена файлов с тильдами в
</p><p>
присваиваниях переменным <b>PATH</b>, <b>MAILPATH</b> и <b>CDPATH</b>, и командный
</p><p>
интерпретатор выполнит необходимые замены.
</p><p>
</p><p>
</p><p>
<a name="lbAZ">&nbsp;</a>
</p><h3>Подстановка значений параметров</h3>

<p>
</p><p>
</p><p>
</p><p>

Символ <b>$</b> обозначает подстановку значений параметров, подстановку
</p><p>
реультатов выполнения команд или подстановку значений арифметических выражений.
</p><p>
Имя параметра можно брать в фигурные скобки, что позволяет отделить его
</p><p>
от идущих непосредственно за ним символов, которые не являются частью имени.
</p><p>
</p><p>
</p><p>
</p><p>

При использовании фигурных скобок, завершающей считается первая скобка
</p><p>
<b>}</b>, не замаскированная обратной косой, не входящая в строку в кавычках, встроенное
</p><p>
арифметическое выражение или подставляемую команду, или в подстановку значения
</p><p>
другого параметра.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>${параметр}</b></dt><dd>
<p>
Подставляется значение указанного параметра. Фигурные скобки необходимы,
</p><p>
если параметр является позиционным и номер позиции состоит из нескольких
</p><p>
цифр или когда после параметра идет символ, не входящий в его имя.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если первый символ параметра - восклицательный знак, начинается косвенная
</p><p>
подстановка. Командный интерпретатор <b>bash</b> использует значение переменной, имя
</p><p>
которой задается остальной частью параметра, в качестве имени переменной,
</p><p>
значение которой необходимо подставить, а не собственно значения. Это 
</p><p>
называется косвенной заменой.
</p><p>
</p><p>
</p><p>
</p><p>

В каждом из описанных ниже случаев в полученном слове выполняется замена тильды,
</p><p>
подстановка значений параметров, подстановка результатов выполнения команд и
</p><p>
вычисление арифметических выражений. Если не выполняется подстановка подстрок,
</p><p>
<b>bash</b> проверяет, не является ли параметр не установленным или не имеет ли он
</p><p>
пустого значения; если не указать двоеточие, проверяется только, установлен ли
</p><p>
параметр.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>${параметр:-слово}</b></dt><dd>
<p>
Использовать стандартное значение. Если параметр не установлен или имеет пустое 
</p><p>
значение, подставляется значение указанного <b>слова</b>. Иначе подставляется значение
</p><p>
<b>параметра</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${параметр:=слово}</b></dt><dd>
<p>
Присвоить стандартное значение. Если <b>параметр</b> не установлен или имеет пустое
</p><p>
значение, <b>параметр</b> получает значение указанного слова. Затем подставляется значение <b>параметра</b>. Присваивать таким образом значения позиционным и 
</p><p>
специальным параметрам нельзя.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${параметр:?слово}</b></dt><dd>
<p>
Выдавать ошибку если <b>параметр</b> не установлен или имеет пустое значение.
</p><p>
Если параметр имеет пустое значение или не установлен, указанное <b>слово</b> (или стандартное
</p><p>
сообщение, если <b>слово</b> не задано) выдается в стандартный поток ошибок, 
</p><p>
и командный интерпретатор, если он не интерактивный, завершает работу. 
</p><p>
В противном случае, подставляется значение <b>параметра</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${параметр:+слово}</b></dt><dd>
<p>
Использовать альтернативное значение. Если <b>параметр</b> не установлен или имеет
</p><p>
пустое значение, не подставляется ничего, в противном случае, подставляется 
</p><p>
указанное <b>слово</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${параметр:m}</b></dt><dd><b>
</b><p><b>
${параметр:m:n}</b>
</p><p>
Подстановка подстрок. Подставляет символы значения параметра, начиная с указанного
</p><p>
смещения <b>m</b> и вплоть до заданной длины <b>n</b>. Если длина не указана, подставляет символы 
</p><p>
с указанного смещения и до конца. В качестве длины и смещения можно
</p><p>
задавать арифметические выражения (см. 
</p><p>
раздел "<b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b>"
</p><p>
ниже). Длина должна быть неотрицательным числом. Если смещение - отрицательное число,
</p><p>
оно отсчитывается с конца значения параметра. Если <b>параметр</b> - <b>@</b>,
</p><p>
результат - <b>n</b> позиционных параметров, начиная с параметра <b>m</b>. 
</p><p>
Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, 
</p><p>
результат - <b>n</b> элементов массива, начиная с <b>${параметр[m]}</b>.
</p><p>
Индексация подстрок начинается с нуля, за исключением позиционных параметров, 
</p><p>
которые индексируются, начиная с 1.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${#параметр}</b></dt><dd>
<p>
Подставляется длина значения <b>параметра</b> в символах. Если <b>параметр</b> - <b>*</b> или <b>@</b>,
</p><p>
подставляется количество позиционных параметров. Если <b>параметр</b> - массив с индексом
</p><p>
<b>*</b> или <b>@</b>, подставляется количество элементов массива.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${параметр#слово}</b></dt><dd><b>
</b><p><b>
${параметр##слово}</b>
</p><p>
<b>Слово</b> рассматривается как шаблон, аналогичный шаблону имен файлов. Если шаблон
</p><p>
сопоставляется с началом значения <b>параметра</b>, то результатом будет значение <b>параметра</b>,
</p><p>
из которого удалена самая короткая (в случае <b>#</b>) или самая длинная (в случае 
</p><p>
<b>##</b>) подстрока. Если <b>параметр</b> - <b>@</b> или <b>*</b>, операция удаления шаблона применяется
</p><p>
поочередно к каждому позиционному параметру и подставляется полученный в результате 
</p><p>
список. Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, операция удаления шаблона
</p><p>
применяется поочередно к каждому элементу массива и подставляется полученный
</p><p>
в результате список.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${параметр%слово}</b></dt><dd><b>
</b><p><b>
${параметр%%слово}</b>
</p><p>
<b>Слово</b> рассматривается как шаблон, аналогичный шаблону имен файлов. Если шаблон
</p><p>
сопоставляется с конечной частью значения параметра, то результатом будет значение параметра,
</p><p>
из которого удалена самая короткая (в случае <b>%</b>) или самая длинная (в случае 
</p><p>
<b>%%</b>) подстрока. Если <b>параметр</b> - <b>@</b> или <b>*</b>, операция удаления шаблона применяется
</p><p>
поочередно к каждому позиционному параметру и подставляется полученный в результате 
</p><p>
список. Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, операция удаления шаблона
</p><p>
применяется поочередно к каждому элементу массива и подставляется полученный
</p><p>
в результате список.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>${параметр/шаблон/строка}</b></dt><dd><b>
</b><p><b>
${параметр//шаблон/строка}</b>
</p><p>
<b>Шаблон</b> задается аналогично шаблонам имен файлов. Самая длинная подстрока значения
</p><p>
параметра, соответствующая шаблону, заменяется указанной <b>строкой</b>. В первом случае,
</p><p>
заменяется только первое вхождение.  Во втором случае, заменяются все вхождения 
</p><p>
шаблона. Если шаблон начинается с <b>#</b>, он должен сопоставляться начиная с начала
</p><p>
значения <b>параметра</b>. Если же шаблон начинается с <b>%</b>, он должен сопоставляться с 
</p><p>
окончанием значения <b>параметра</b>. Если <b>строка</b> - пустая, соответсвующие шаблону подстроки
</p><p>
удаляются и <b>/</b> после шаблона можно не указывать. Если <b>параметр</b> - <b>@</b> или <b>*</b>,
</p><p>
операция замены шаблона применяется поочередно к каждому позиционному параметру, и подставляется
</p><p>
полученный в результате список. Если <b>параметр</b> - массив с индексом <b>@</b> или <b>*</b>, 
</p><p>
операция замены шаблона применяется поочередно к каждому элементу массива и 
</p><p>
подставляется полученный в результате список.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbBA">&nbsp;</a>
<h3>Подстановка результатов выполнения команд</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Подстановка результатов выполнения команд</i> позволяет результат,
</p><p>
выдаваемый командой в стандартный выходной поток, подставить вместо имени 
</p><p>
команды. Имеется две формы такой подстановки:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(<b>команда</b>)
</p><p>
</p><p>
</p><p>
или
</p><p>
</p></dd><dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<b>команда</b>`
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Командный интерпретатор <b>bash</b> делает эту подстановку путем выполнения 
</p><p>
<b>команды</b> и замены конструкции подстановки содержимым стандартного выходного
</p><p>
потока команды, из которого удалены завершающие переводы строк. 
</p><p>
Встроенные переводы строк не удаляются, но они могут быть удалены при разбиении
</p><p>
на слова. Подстановку результатов выполнения команды <b>$(cat  file)</b> можно
</p><p>
заменить эквивалентной, но более быстрой: <b>$(&lt; file)</b>.
</p><p>
</p><p>
</p><p>
</p><p>

При использовании старой формы подстановки в обратных апострофах
</p><p>
обратная косая интерпретируется как литерал, если только после нее не идут
</p><p>
символы <b>$</b>, <b>`</b> или <b>\</b>. Первый же обратный апостроф, не замаскированный обратной
</p><p>
косой, завершает подставляемую команду. При использовании формы <b>$(команда)</b>
</p><p>
все символы между круглыми скобками образуют команду - ни один не имеет
</p><p>
специального значения.
</p><p>
</p><p>
</p><p>
</p><p>

Подстановка результатов выполнения команд может быть <i>вложенной</i>.
</p><p>
Для задания вложенной подстановки в форме с обратными апострофами замаскируйте
</p><p>
внутренние обратные апострофы обратными косыми.
</p><p>
</p><p>
</p><p>
</p><p>

Если подстановка задана в двойных кавычках, разбиение на слова и подстановка
</p><p>
имен файлов в результатах не выполняется.
</p><p>
</p><p>
</p><p>
&amp;nbsp;&amp;nbsp;&amp;nbsp; Подстановка значений арифметических выражений
</p><p>
</p><p>
</p><p>
</p><p>

При <i>вычислении арифметических выражений</i> вместо выражения подставляется результат
</p><p>
его вычисления. Для вычисления арифметических выражений используется следующий
</p><p>
формат:.PP 
</p><p>
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$((<b>выражение</b>))
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

<b>Выражение</b> обрабатывается так, как если бы оно было взято в двойные кавычки, но
</p><p>
двойные кавычки в самом выражении не имеют специального значения. Во всех
</p><p>
лексемах выражения выполняется подстановка значений параметров, подстановка строк,
</p><p>
подстановка результатов выполнения команд и удаление кавычек. Вычисления 
</p><p>
арифметических выражений могут быть вложенными.
</p><p>
</p><p>
</p><p>
</p><p>

Вычисление выполняется по правилам, перечисленным ниже в разделе 
</p><p>
"<b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b>". 
</p><p>
Если <b>выражение</b> недопустимо, командный интерпретатор
</p><p>
<b>bash</b> выдает сообщение о невозможности вычисления и подстановка не выполняется.
</p><p>
</p><p>
</p><p>
<a name="lbBB">&nbsp;</a>
</p><h3>Подстановка процессов</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Подстановка процессов</i> доступна в системах, поддерживающих
</p><p>
<i>именованные каналы</i> (FIFO) или метод именования открытых файлов через
</p><p>
<b>/dev/fd</b>. Она имеет вид <b>&lt;(список)</b> или <b>&gt;(список)</b>. Процесс <b>список</b> запускается и его
</p><p>
входной или выходной поток связывается с именованным каналом FIFO или
</p><p>
одним из файлов в <b>/dev/fd</b>. Имя этого файла передается в качестве аргумента
</p><p>
текущей команде как результат подстановки. Если использована форма
</p><p>
<b>&gt;(список)</b>, запись в файл будет давать входные данные процессу <b>список</b>. Если же
</p><p>
использована форма <b>&lt;(список)</b>, файл, переданный в качестве аргумента, необходимо 
</p><p>
читать для получения результатов работы процесса <b>список</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Если подстановка процессов поддерживается, она выполняется одновременно с 
</p><p>
подстановкой значений параметров, подстановкой результатов выполнения команд 
</p><p>
и вычислением арифметических выражений.
</p><p>
</p><p>
</p><p>
<a name="lbBC">&nbsp;</a>
</p><h3>Разбиение на слова</h3>

<p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор обрабатывает результаты подстановки значений параметров,
</p><p>
результатов выполнения команд и арифметических вычислений, не взятых в 
</p><p>
двойные кавычки, разбивая их на слова.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор рассматривает каждый символ значения переменной <b>IFS</b>
</p><p>
как <i>разделитель</i> и разбивает результаты подстановок на слова по этим символам.
</p><p>
Если переменная <b>IFS</b> не установлена или ее значение -     
</p><p>
&lt;пробел&gt;&lt;табуляция&gt;&lt;перевод строки&gt;, т.е. стандартное, то любая 
</p><p>
последовательность подряд идущих символов из <b>IFS</b> считается разделителем слов.
</p><p>
Если же переменная <b>IFS</b> имеет значение, отличающееся от стандартного,
</p><p>
то последовательность <i>пробельных символов</i> (пробелов и символов табуляции)
</p><p>
в начале и в конце слова игнорируется, если пробельные символы входят в значение
</p><p>
<b>IFS</b> (их обобщенно называют <i>пробельным символом </i><b>IFS</b>). Любые символы в значении
</p><p>
<b>IFS</b>, не являющиеся пробельными, вместе с любыми идущими за ними пробельными
</p><p>
символами <b>IFS</b>, ограничивают слово. Последовательность пробельных символов
</p><p>
<b>IFS</b> также считается разделителем. Если переменная <b>IFS</b> имеет пустое значение, 
</p><p>
разбиение на слова не происходит.
</p><p>
</p><p>
</p><p>
</p><p>

Явные пустые строки (<b>""</b> или <b>''</b>) оставляются. Не взятые в кавычки неявные
</p><p>
пустые строки, получающиеся в результате подстановки параметров, не имеющих
</p><p>
значения, удаляются. Если параметр, не имеющий значения, подставляется в двойных 
</p><p>
кавычках, получается пустая строка, и она остается в командной строке.
</p><p>
</p><p>
</p><p>
</p><p>

Учтите, что если не было подстановок, то и разбиение на слова не выполняется.
</p><p>
</p><p>
</p><p>
<a name="lbBD">&nbsp;</a>
</p><h3>Подстановка имен файлов</h3>

<p>
</p><p>
</p><p>
</p><p>

После разбиения на слова, если только не установлена опция <b>-f</b>,
</p><p>
командный интерпретатор <b>bash</b> просматривает каждое слово в поисках символов
</p><p>
<b>*</b>, <b>?</b>, <b>(</b> и <b>[</b>. Если найден любой из этих символов,
</p><p>
слово считается <i>шаблоном</i> и
</p><p>
заменяется упорядоченным по алфавиту списком имен файлов, соответствующих 
</p><p>
шаблону. Если соответствующие имена файлов не найдены и опция командного
</p><p>
интерпретатора <b>nullglob</b> отключена, 
</p><p>
слово остается без изменений. Если опция
</p><p>
<b>nullglob</b> установлена и соответствующие файлы не найдены, слово удаляется.
</p><p>
Если включена опция командного интерпретатора 
</p><p>
<b>nocaseglob</b>, сопоставление
</p><p>
выполняется без учета регистра алфавитных символов. Если шаблон используется
</p><p>
для подстановки имен файлов, символ "<b>.</b>" в начале имени или сразу после косой
</p><p>
черты должен сопоставляться явно, если только не установлена опция 
</p><p>
интерпретатора <b>dotglob</b>. При сопоставлении имен файлов косые черты 
</p><p>
всегда должны сопоставляться явно. В других случаях символ "<b>.</b>" обрабатывается 
</p><p>
как любые другие символы. См. описание опций командного интерпретатора 
</p><p>
<b>nocaseglob</b>, <b>nullglob</b> 
</p><p>
и <b>dotglob</b> 
</p><p>
ниже в разделе "<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>".
</p><p>
</p><p>
</p><p>
</p><p>

Переменная командного интерпретатора <b>GLOBIGNORE</b> может использоваться
</p><p>
для ограничения множества имен файлов, соответствующих шаблону. Если 
</p><p>
переменная <b>GLOBIGNORE</b> установлена, каждое сопоставившееся имя файла, 
</p><p>
соответствующее также одному из шаблонов, заданных в <b>GLOBIGNORE</b>, удаляется
</p><p>
из списка сопоставившихся. Имена файлов "<b>.</b>" и "<b>..</b>" игнорируются всегда, даже
</p><p>
если установлена переменная <b>GLOBIGNORE</b>. Однако при установке переменной
</p><p>
<b>GLOBIGNORE</b> автоматически устанавливается опция интерпретатора 
</p><p>
<b>dotglob</b>,
</p><p>
так что все остальные имена файлов, начинающиеся с "<b>.</b>", будут подставлены.
</p><p>
Для получения старого поведения - игнорирования имен файлов, начинающихся с "<b>.</b>", -
</p><p>
задайте "<b>.*</b>" как один из шаблонов в переменной <b>GLOBIGNORE</b>. 
</p><p>
Опция <b>dotglob</b> отключается, если переменная <b>GLOBIGNORE</b> не установлена.
</p><p>
</p><p>
</p><p>
&amp;nbsp;&amp;nbsp;&amp;nbsp;     Сопоставление с образцом
</p><p>
</p><p>
</p><p>
</p><p>

Любой символ в шаблоне, отличающийся от специальных, описанных ниже, 
</p><p>
сопоставляется буквально. Символ NUL в шаблоне указывать нельзя.
</p><p>
Специальные символы шаблона для буквального сопоставления необходимо
</p><p>
маскировать.
</p><p>
</p><p>
</p><p>
</p><p>

Специальные символы шаблона имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>*</b></dt><dd>
<p>
Соответствует любой строке, в том числе, пустой.
</p><p>
</p></dd><dt><b>?</b></dt><dd>
<p>
Соответствует любому одиночному символу.
</p><p>
</p></dd><dt><b>[...]</b></dt><dd>
<p>
Соответствует любому из символов в квадратных скобках. Пара символов,
</p><p>
разделенная дефисом, задает <i>диапазон</i>; любой символ, лексически находящийся между
</p><p>
этими двумя символами, включительно, будет соответствовать этой конструкции.
</p><p>
Если сразу после <b>[</b> идет символ <b>!</b> или <b>^</b>, то конструкции соответствует любой
</p><p>
символ, не указанный в квадратных скобках. Для сопоставления с дефисом (<b>-</b>)
</p><p>
его необходимо указать в квадратных скобках первым или последним. Для задания
</p><p>
закрывающей квадратной скобки (<b>]</b>), ее необходимо указать как первый символ набора.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

В квадратных скобках можно задавать <i>классы символов</i> с помощью конструкции
</p><p>
<b>[:класс:]</b>, где <b>класс</b> - один из следующих классов, определяемых стандартом
</p><p>
POSIX.2:
</p><p>
</p><p>
</p><p>
alnum alpha ascii blank cntrl digit graph  lower  print
</p><p>
punct space upper xdigit
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
Класс символов сопоставляется с любым символом, принадлежащим к этому классу.
</p><p>
</p><p>
</p><p>
</p><p>

В квадратных скобках можно задавать <i>класс эквивалентности</i> с помощью конструкции
</p><p>
<b>[=c=]</b>, соответствующей всем символам с тем же <i>порядком сортировки</i>
</p><p>
(collation  weight), определяемым текущей локалью, что и символ <b>c</b>.
</p><p>
</p><p>
</p><p>
</p><p>

В квадратных скобках конструкция <b>[.символ.]</b> соответствует <b>символу</b> с
</p><p>
указанным порядком сортировки.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>

Если с помощью встроенной команды <b>shopt</b> установлена опция
</p><p>
командного интерпретатора <b>extglob</b>, распознается ряд дополнительных
</p><p>
операторов сопоставления с образцом. В следующем описании <b>список_шаблонов</b> -
</p><p>
это список из одного или нескольких шаблонов через вертикальную черту (<b>|</b>).
</p><p>
Составные шаблоны можно формировать из одного или нескольких следующих 
</p><p>
подшаблонов:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>?(список_шаблонов)</b></dt><dd>
<p>
Соответствует нулю или одному вхождению указанных шаблонов
</p><p>
</p></dd><dt><b>*(список_шаблонов)</b></dt><dd>
<p>
Соответствует нулю или более вхождений указанных шаблонов
</p><p>
</p></dd><dt><b>+(список_шаблонов)</b></dt><dd>
<p>
Соответствует одному или оболее вхождений указанных шаблонов
</p><p>
</p></dd><dt><b>@(список_шаблонов)</b></dt><dd>
<p>
Соответствует ровно одному вхождению указанных шаблонов
</p><p>
</p></dd><dt><b>!(список_шаблонов)</b></dt><dd>
<p>
Соответствует любой строке, кроме соответствующей одному из указанных шаблонов.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbBE">&nbsp;</a>
<h3>Удаление кавычек</h3>

<p>
</p><p>
</p><p>
</p><p>

После выполнения всех перечисленных выше подстановок все незамаскированные
</p><p>
вхождения символов <b>\</b>, <b>'</b> и <b>"</b>, не являющиеся результатом этих подстановок,
</p><p>
удаляются.
</p><p>
</p><p>
</p><p>
<a name="lbBF">&nbsp;</a>
</p><h2>ПЕРЕНАПРАВЛЕНИЕ</h2>

<p>

Перед выполнением команды ее входной и выходной потоки могут быть 
</p><p>
<i>перенаправлены</i> с помощью специальных конструкций, обрабатываемых командным
</p><p>
интерпретатором. Перенаправления также можно использовать для открытия и закрытия
</p><p>
файлов в текущей среде работы командного интерпретатора. Следующие операторы
</p><p>
перенаправления могут предшествовать <i>простой команде</i> или указываться в любом 
</p><p>
ее месте, или указываться после <i>команды</i>. Перенаправления обрабатываются в 
</p><p>
порядке их указания, слева направо.
</p><p>
</p><p>
</p><p>
</p><p>

В следующих описаниях если номер дескриптора файла не указан и первый символ
</p><p>
оператора перенаправления - <b>&lt;</b>, выполняется перенаправление стандартного
</p><p>
входного потока (дескриптор файла 0). Если же первым символом оператора
</p><p>
перенаправления является символ <b>&gt;</b>, выполняется перенаправление стандартного
</p><p>
выходного потока (дескриптор файла 1).
</p><p>
</p><p>
</p><p>
</p><p>

В слове, идущем за оператором перенаправления в следующих описаниях, если не
</p><p>
сказано иначе, выполняется подстановка фигурных скобок, замена тильды, 
</p><p>
подстановка значений параметров, подстановка результатов выполнения команд,
</p><p>
вычисление арифметических выражений, удаление кавычек и подстановка имен 
</p><p>
файлов. Если в результате получается более одного слова, командный 
</p><p>
интерпретатор <b>bash</b> выдает сообщение об ошибке.
</p><p>
</p><p>
</p><p>
</p><p>

Учтите, что порядок указания перенаправлений имеет значение. Например, команда
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls&nbsp;&gt;&nbsp;dirlist&nbsp;2&gt;&amp;1
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

перенаправляет в файл <b>dirlist</b> стандартный выходной поток и стандартный поток 
</p><p>
ошибок, тогда как команда
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls&nbsp;2&gt;&amp;1&nbsp;&gt;&nbsp;dirlist
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

перенаправляет в файл <b>dirlist</b> только стандартный выходной поток, поскольку
</p><p>
стандартный поток ошибок был направлен туде же, куда и стандартный выходной поток
</p><p>
до его перенаправления в файл <b>dirlist</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Ошибка при открытии или создании файла приводит к отмене перенаправления.
</p><p>
</p><p>
</p><p>
<a name="lbBG">&nbsp;</a>
</p><h3>Перенаправление входного потока</h3>

<p>
<br>&nbsp;&nbsp;
</p><p>
</p><p>

Перенаправление входного потока приводит к открытию на чтение файла,
</p><p>
имя которого получается в результате подстановок в <b>слове</b>, через дескриптор
</p><p>
файла <b>n</b>, или как стандартного входного потока (дескриптор файла 0), если 
</p><p>
<b>n</b> не указано.
</p><p>
</p><p>
</p><p>
</p><p>

В общем случае перенаправление входного потока имеет вид:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b>n</b>]&lt;<b>слово</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbBH">&nbsp;</a>
<h3>Перенаправление выходного потока</h3>

<p>
</p><p>
</p><p>
</p><p>

Перенаправление входного потока приводит к открытию на запись файла,
</p><p>
имя которого получается в результате подстановок в <b>слове</b>, через дескриптор
</p><p>
файла <b>n</b>, или как стандартного выходного потока (дескриптор файла 1), если <b>n</b>
</p><p>
не указано. Если файл не существует, он создается; если существует - он 
</p><p>
усекается до нулевого размера.
</p><p>
</p><p>
</p><p>
</p><p>

В общем случае перенаправление выходного потока имеет вид:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b>n</b>]&gt;<b>слово</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если используется оператор перенаправления <b>&gt;</b> и с помощью встроенной команды 
</p><p>
<b>set</b> установлена опция <b>noclobber</b>, перенаправление не будет выполнено, если
</p><p>
файл с соответствующим именем существует и является обычным файлом.
</p><p>
Если используется оператор перенаправления <b>&gt;|</b>, либо оператор 
</p><p>
перенаправления - <b>&gt;</b> и опция <b>noclobber</b> с помощью встроенной команды 
</p><p>
<b>set</b> не 
</p><p>
установлена, перенаправление выполняется, даже если соответствующий файл существует.
</p><p>
</p><p>
</p><p>
<a name="lbBI">&nbsp;</a>
</p><h3>Добавление перенаправленного вывода</h3>

<p>
</p><p>
</p><p>
</p><p>

Такое перенаправление вывода приводит к открытию файла, имя которого получается
</p><p>
в результате подстановок в <b>слове</b>, в режиме добавления через дескриптор файла
</p><p>
<b>n</b>, или к добавлению в стандартный выходной поток (дескриптор файла 1) если
</p><p>
<b>n</b> не указано. Если файл не существует, он создается.
</p><p>
</p><p>
</p><p>
</p><p>

Перенаправление вывода на добавление имеет следующий общий вид:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b>n</b>]&gt;&gt;<b>слово</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbBJ">&nbsp;</a>
<h3>Перенаправление стандартного выходного потока и стандартного потока ошибок</h3>

<p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор <b>bash</b> позволяет перенаправить как стандартный выходной
</p><p>
поток (дескриптор файла 1), так и стандартный поток ошибок (дескриптор файла 2)
</p><p>
в файл, имя которого получается в результате подстановок в <b>слове</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Для этого предлагается два формата конструкции перенаправления:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&gt;<b>слово</b>
</p><p>
</p><p>
</p><p>
и
</p><p>
</p></dd><dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&amp;<b>слово</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Первый формат является предпочтительным. Эта конструкция семантически 
</p><p>
эквивалентна следующей:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;<b>слово</b>&nbsp;2&gt;&amp;1
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbBK">&nbsp;</a>
<h3>Конструкция документ здесь</h3>

<p>
</p><p>
</p><p>
</p><p>

При этом типе перенаправления командный интерпретатор будет читать входные 
</p><p>
данные из текущего файла, пока не встретится строка, содержащая только указанное
</p><p>
<b>слово</b> (без хвостовых пробелов). Все прочитанные до этого строки затем 
</p><p>
используются как стандартный входной поток для команды.
</p><p>
</p><p>
</p><p>
</p><p>

Конструкция "документ здесь" имеет следующий формат:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
&lt;&lt;[-]<b>слово</b>
</p><p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>документ-здесь</b>
</p><p>
<b>ограничитель</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

В <b>слове</b> не выполняется подстановка значений параметров, результатов выполнения
</p><p>
команд, имен файлов или вычисление арифметических выражений. Если в <b>слове</b> есть 
</p><p>
замаскированный символ, <b>ограничитель</b> является результатом удаления символов 
</p><p>
маскировки из <b>слова</b>. Если в <b>слове</b> нет замаскированных символов, во всех строках 
</p><p>
"документа здесь" выполняется подстановка значений параметров, результатов
</p><p>
выполнения команд и вычисление арифметических выражений. В этом случае
</p><p>
пара <b>\&lt;перевод строки&gt;</b> игнорируется, и необходимо использовать <b>\</b> для маскировки
</p><p>
символов <b>\</b>, <b>$</b> и <b>`</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Если в качестве оператора перенаправления используется &lt;&lt;-, то все
</p><p>
начальные табуляции из входных строк и строки, содержащей <b>ограничитель</b>,
</p><p>
удаляются. Это позволяет естственным образом выравнивать конструкции
</p><p>
"документ здесь" в сценариях командного интерпретатора.
</p><p>
</p><p>
</p><p>
<a name="lbBL">&nbsp;</a>
</p><h3>Дублирование дескрипторов файлов</h3>

<p>
</p><p>
</p><p>
</p><p>

Оператор перенаправления
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b>n</b>]&lt;&amp;<b>слово</b>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

используется для дублирования дескрипторов входных файлов. Если в результате
</p><p>
подстановок <b>слово</b> представляет собой одну или несколько цифр, дескриптор
</p><p>
файла <b>n</b> становится копией соответствующего дескриптора файла. Если
</p><p>
файл с дескриптором, задаваемым цифрами <b>слова</b>, не открыт на чтение, возникает 
</p><p>
ошибка перенаправления. Если после подстановок в <b>слове</b> получается <b>-</b>,
</p><p>
файл с дескриптором <b>n</b> закрывается. Если <b>n</b> не указано, используется
</p><p>
стандартный входной поток (дескриптор файла 0).
</p><p>
</p><p>
</p><p>
</p><p>

Оператор
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b>n</b>]&gt;&amp;<b>слово</b>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

используется аналогично для дублирования дескрипторов выходных файлов. Если
</p><p>
<b>n</b> не указано, используется стандартный выходной поток (дескриптор файла 1).
</p><p>
Если цифры в <b>слове</b> не задают дескриптор файла, открытого на запись, возникает
</p><p>
ошибка перенаправления. В качестве специального случая, если <b>n</b> не указано и <b>слово</b>
</p><p>
после подстановок не представляет собой одну или несколько цифр, стандартный
</p><p>
выходной поток и стандартный поток ошибок перенаправляются так, как было
</p><p>
описано выше.
</p><p>
</p><p>
</p><p>
<a name="lbBM">&nbsp;</a>
</p><h3>Открытие дескрипторов файлов для чтения и записи</h3>

<p>
</p><p>
</p><p>
</p><p>

Оператор перенаправления
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b>n</b>]&lt;&gt;<b>слово</b>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

вызывает открытие файла, имя которого получается в результате подстановок
</p><p>
в <b>слове</b>, для чтения и записи через дескриптор файла <b>n</b> или через дескриптор
</p><p>
файла 0, если <b>n</b> не указано. Если файл не существует, он создается.
</p><p>
</p><p>
</p><p>
<a name="lbBN">&nbsp;</a>
</p><h2>ПСЕВДОНИМЫ</h2>

<p>

<i>Псеводнимы</i> позволяют подставлять вместо первого слова простой команды строку.
</p><p>
Командный интерпретатор поддерживает список псевдонимов, которые можно 
</p><p>
устанавливать и удалять с помощью встроенных команд <b>alias</b> и
</p><p>
<b>unalias</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже). Первое слово
</p><p>
каждой команды, если оно не взято в кавычки, ищется в списке псевдонимов.
</p><p>
Если соответствующий псевдоним найден, слово заменяется текстом псевдонима.
</p><p>
Имя псевдонима и подставляемый текст может включать любые допустимые входные данные
</p><p>
для командного интерпретатора, включая перечисленные ранее <i>метасимволы</i>. 
</p><p>
Единственное исключение - имя псевдонима не может содержать знак <b>=</b>.
</p><p>
Первое слово текста псевдонима также ищется в списке псевдонимов, но если оно
</p><p>
совпадает с именем подставляемого псевдонима, повторной подстановки не 
</p><p>
происходит. Это означает, что можно задать псевдоним <b>ls</b> для <b>ls -F</b>,
</p><p>
например, и <b>bash</b> не будет пытаться выполнять рекурсивные подстановки в тексте
</p><p>
псевдонима. Если последний символ текста псевдонима - пробел, следующее за
</p><p>
псевдонимом слово исходной команды также ищется в списке псевдонимов и,
</p><p>
если найдено, заменяется.
</p><p>
</p><p>
</p><p>
</p><p>

Псевдонимы создаются и просматриваются с помощью комадны <b>alias</b>,
</p><p>
а удаляются с помощью команды <b>unalias</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Нет механизма передачи аргументов в подставляемый текст. Если необходимы
</p><p>
аргументы, используйте функцию командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p><p>

Псевдонимы не подставляются, если командный интерпретатор не является 
</p><p>
интерактивным, если только с помощью встроенной команды <b>shopt</b> 
</p><p>
не установлена опция <b>expand_aliases</b> 
</p><p>
(см. описание команды <b>shopt</b> ниже, в разделе
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>").
</p><p>
</p><p>
</p><p>
</p><p>

Правила определения и использования псевдонимов несколько запутаны. 
</p><p>
Командный интерпретатор <b>bash</b> всегда читает по крайней мере одну
</p><p>
полную строку ввода, прежде чем выполнять любые указанные в ней команды.
</p><p>
Псевдонимы подставляются при чтении строки, а не при ее выполнении. Поэтому
</p><p>
определение псевдонима, заданное в одной строке с другой командой, не учитывается,
</p><p>
пока не будет прочитана следующая строка. Команды, идущие после определения
</p><p>
псевдонима в той же строке, этот новый псевдоним не учитывают. Это поведение
</p><p>
также необходимо учитывать при выполнении функций. Псевдонимы подставляются
</p><p>
при чтении определения функции, а не при ее выполнении, поскольку определение
</p><p>
функции само является составной командой. Как следствие, псевдонимы, определенные
</p><p>
в функции, не доступны до тех пор, пока функция не выполнится. Для простоты,
</p><p>
всегда задавайте определения псевдонимов в отдельной строке и не используйте
</p><p>
команду <b>alias</b> в составных командах.
</p><p>
</p><p>
</p><p>
</p><p>

Практически все варианты использования псевдонимов покрываются функциями
</p><p>
командного интерпретатора.
</p><p>
</p><p>
</p><p>
<a name="lbBO">&nbsp;</a>
</p><h2>ФУНКЦИИ</h2>

<p>

Функция командного интерпретатора, определенная как было представлено ранее
</p><p>
в разделе "<b>СИНТАКСИС КОМАНД</b>", сохраняет под заданным именем 
</p><p>
последовательность команд для выполнения в дальнейшем. 
</p><p>
Функции выполняются в контексте текущего командного интерпретатора; для их
</p><p>
интерпретации не создается новый процесс (сравните с выполнением сценария
</p><p>
командного интерпретатора). При вызове функции ее аргументы становятся 
</p><p>
позиционными параметрами. Специальный параметр <b>#</b> обновляется, отражая
</p><p>
это изменение. Позиционный параметр 0 не изменяется. Все остальные особенности
</p><p>
среды выполнения командного интерпретатора у функции и вызывающей ее команды
</p><p>
идентичны, только обработчик сигнала <b>DEBUG</b> (см. описание встроенной команды
</p><p>
<b>trap</b> в разделе 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже) не наследуется.
</p><p>
</p><p>
</p><p>
</p><p>

Можно объявлять локальные переменные функции с помощью встроенной команды
</p><p>
<b>local</b>. Обычно переменные и их значения совместно используются функцией и
</p><p>
вызвавшей ее командой.
</p><p>
</p><p>
</p><p>
</p><p>

Если в функции выполняется встроенная команда <b>return</b>, эта функция
</p><p>
завершается, и выполнение продолжается со следующей команды после вызова 
</p><p>
функции. Когда функция завершается, восстанавливаются значения позиционных 
</p><p>
параметров и специального параметра <b>#</b>, которые были до выполнения функции.
</p><p>
</p><p>
</p><p>
</p><p>

Имена и определения функций можно получить с помощью опции <b>-f</b> встроенных
</p><p>
команд <b>declare</b> или <b>typeset</b>. 
</p><p>
С опцией <b>-F</b> встроенные команды <b>declare</b> и 
</p><p>
<b>typeset</b> будут выдавать только имена функций. Функции можно
</p><p>
экспортировать, с помощью опции <b>-f</b> встроенной команды <b>export</b>,
</p><p>
так что они будут автоматически определены в порожденных командных 
</p><p>
интерпретаторах.
</p><p>
</p><p>
</p><p>
</p><p>

Функции могут быть рекурсивными. Глубина рекурсии не ограничена.
</p><p>
</p><p>
</p><p>
<a name="lbBP">&nbsp;</a>
</p><h2>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</h2>

<p>

Командный интерпретатор в определенных случаях обеспечивает вычисление 
</p><p>
арифметических выражений (см. встроенную команду <b>let</b> и подраздел
</p><p>
"<b>Подстановка арифметических выражений</b>" ранее). 
</p><p>
Вычисление выполняется в 
</p><p>
длинных целых числах без проверки переполнения, хотя деление на 0
</p><p>
перехватывается и выдается соответствующее сообщение об ошибке. 
</p><p>
Операторы в следующем списке сгруппированы по уровням с одинаковым
</p><p>
приоритетом. Уровни перечислены в порядке убывания приоритета.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>- +</b></dt><dd>
<p>
унарные минус и плюс
</p><p>
</p></dd><dt><b>! ~ </b></dt><dd>
<p>
логическое и побитовое отрицание
</p><p>
</p></dd><dt><b>**</b></dt><dd>
<p>
возведение в степень
</p><p>
</p></dd><dt><b>* / %</b></dt><dd>
<p>
умножение, деление, получение остатка от деления
</p><p>
</p></dd><dt><b>+ -</b></dt><dd>
<p>
сложение, вычитание
</p><p>
</p></dd><dt><b>&lt;&lt; &gt;&gt;</b></dt><dd>
<p>
побитовый сдвиг влево и вправо
</p><p>
</p></dd><dt><b>&lt;= &gt;= &lt; &gt;</b></dt><dd>
<p>
сравнение
</p><p>
</p></dd><dt><b>== !=</b></dt><dd>
<p>
равенство и неравенство
</p><p>
</p></dd><dt><b>&amp;</b></dt><dd>
<p>
побитовое И
</p><p>
</p></dd><dt><b>^</b></dt><dd>
<p>
побитовое исключающее ИЛИ
</p><p>
</p></dd><dt><b>|</b></dt><dd>
<p>
побитовое ИЛИ
</p><p>
</p></dd><dt><b>&amp;&amp;</b></dt><dd>
<p>
логическое И
</p><p>
</p></dd><dt><b>||</b></dt><dd>
<p>
логическое ИЛИ
</p><p>
</p></dd><dt><b>выражение?выражение:выражение</b></dt><dd>
<p>
условное вычисление
</p><p>
</p></dd><dt><b>= *= /= %= += -=</b></dt><dd>
<p>
присваивание
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

В качестве операндов можно использовать переменные командного интерпретатора;
</p><p>
перед вычислением выполняется подстановка значений параметров. Значение
</p><p>
параметра в арифметическом выражении приводится к длинному целому. 
</p><p>
Чтобы переменную командного интерпретатора можно было использовать в
</p><p>
арифметических выражениях, ее атрибут <b>integer</b> устанавливать
</p><p>
не обязательно.
</p><p>
</p><p>
</p><p>
</p><p>

Константы с начальным 0 интерпретируются как восьмеричные числа.
</p><p>
Начальные <b>0x</b> или <b>0X</b> обозначают шестнадцатеричную константу.
</p><p>
В остальных случаях числа имеют вид <b>[основание#]n</b>, где <b>основание</b> -
</p><p>
десятичное число от 2 до 64, представляющее основание системы счисления,
</p><p>
а <b>n</b> - число в этой системе счисления. Если основание не указано,
</p><p>
используется основание 10. Цифры, большие 9, представляются
</p><p>
строчными буквами, прописными буквами, символами <b>_</b> и <b>@</b>, именно в таком порядке.
</p><p>
Если основание меньше или равно 36, прописные и строчные буквы эквивалентны и
</p><p>
используются для представления чисел от 10 до 35.
</p><p>
</p><p>
</p><p>
</p><p>

Операторы вычисляются в порядке приоритетов. Сначала вычисляются подвыражения в
</p><p>
круглых скобках, которые позволяют переопределить представленные выше
</p><p>
стандартные приоритеты операторов.
</p><p>
</p><p>
</p><p>
<a name="lbBQ">&nbsp;</a>
</p><h2>УСЛОВНЫЕ ВЫРАЖЕНИЯ</h2>

<p>

Условные выражения используются составной командой <b>[[</b> и встроенными командами
</p><p>
<b>test</b> и <b>[</b> для проверки атрибутов файла и выполнения 
</p><p>
строковых и арифметических
</p><p>
сравнений. Выражения формируются из следующих унарных и бинарных элементарных
</p><p>
условий. Если любой из аргументов <b>файл</b> в одном из условий имеет вид <b>/dev/fd/n</b>, 
</p><p>
проверяется файл с дескриптором <b>n</b>.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>-a файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует.
</p><p>
</p></dd><dt><b>-b файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и являтся специальным блочным устройством.
</p><p>
</p></dd><dt><b>-c файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является специальным символьным устройством.
</p><p>
</p></dd><dt><b>-d файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является каталогом.
</p><p>
</p></dd><dt><b>-e файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует
</p><p>
</p></dd><dt><b>-f файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является обычным файлом.
</p><p>
</p></dd><dt><b>-g файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и имеет установленный бит <b>SGID</b>.
</p><p>
</p></dd><dt><b>-h файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является символической связью.
</p><p>
</p></dd><dt><b>-k файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и имеет установленный "клейкий" бит.
</p><p>
</p></dd><dt><b>-p файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является именованным каналом (FIFO).
</p><p>
</p></dd><dt><b>-r файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и доступен для чтения.
</p><p>
</p></dd><dt><b>-s файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и имеет ненулевой размер.
</p><p>
</p></dd><dt><b>-t fd</b></dt><dd>
<p>
Истинно, если дескриптор файла <b>fd</b> открыт и связан с терминалом.
</p><p>
</p></dd><dt><b>-u файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и имеет установленный бит <b>SUID</b>.
</p><p>
</p></dd><dt><b>-w файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и доступен для записи.
</p><p>
</p></dd><dt><b>-x файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является выполняемым.
</p><p>
</p></dd><dt><b>-O файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и принадлежит пользователю, задаваемому текущим
</p><p>
эффективным идентификатором пользователя.
</p><p>
</p></dd><dt><b>-G файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и принадлежит группе, задаваемой текущим
</p><p>
эффективным идентификатором группы.
</p><p>
</p></dd><dt><b>-L файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является символической связью.
</p><p>
</p></dd><dt><b>-S файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и является сокетом.
</p><p>
</p></dd><dt><b>-N файл</b></dt><dd>
<p>
Истинно, если <b>файл</b> существует и был изменен с момента последнего чтения.
</p><p>
</p></dd><dt><b>файл1 -nt файл2</b></dt><dd>
<p>
Истинно, если <b>файл1</b> новее (в соответствии с датой изменения), чем <b>файл2</b>.
</p><p>
</p></dd><dt><b>файл1 -ot файл2</b></dt><dd>
<p>
Истинно, если <b>файл1</b> старее, чем <b>файл2</b>.
</p><p>
</p></dd><dt><b>файл1 -ef файл2</b></dt><dd>
<p>
Истинно, если <b>файл1</b> и <b>файл2</b> находятся на одном устройстве и имеют одинаковые
</p><p>
номера индексных дескрипторов.
</p><p>
</p></dd><dt><b>-o опция</b></dt><dd>
<p>
Истинно, если установлена указанная <b>опция</b> командного интерпретатора. Список
</p><p>
опций см. далее в описании опции <b>-o</b> встроенной 
</p><p>
команды <b>set</b>.
</p><p>
</p></dd><dt><b>-z строка</b></dt><dd>
<p>
Истинно, если длина <b>строки</b> - ноль (т.е. строка - пустая).
</p><p>
</p></dd><dt><b>-n строка</b></dt><dd><b>
</b><p><b>
строка</b>
</p><p>
Истинно, если длина <b>строки</b> - не ноль.
</p><p>
</p></dd><dt><b>строка1 == строка2</b></dt><dd>
<p>
Истинно, если строки совпадают. Вместо <b>==</b> можно использовать просто <b>=</b>.
</p><p>
</p></dd><dt><b>строка1 != строка2</b></dt><dd>
<p>
Истинно, если строки не совпадают.
</p><p>
</p></dd><dt><b>строка1 &lt; строка2</b></dt><dd>
<p>
Истинно, если <b>строка1</b> в текущей локали при лексикографическом
</p><p>
упорядочении предшествует <b>строке2</b>.
</p><p>
</p></dd><dt><b>строка1 &gt; строка2</b></dt><dd>
<p>
Истинно, если <b>строка1</b> в текущей локали при лексикографическом
</p><p>
упорядочении идет после <b>строки2</b>.
</p><p>
</p></dd><dt><b>arg1 OP arg2</b></dt><dd>
<p>
Оператор <b>OP</b> - один из следующих: <b>-eq</b>, <b>-ne</b>, <b>-lt</b>,
</p><p>
<b>-le</b>, <b>-gt</b> или <b>-ge</b>. Эти бинарные арифметические операторы возвращают 
</p><p>
истину, если <b>arg1</b> равен, не равен, меньше, меньше или равен,больше, больше или равен
</p><p>
<b>arg2</b>, соответственно. Аргументы <b>arg1</b> и <b>arg2</b> могут быть любыми целыми числами.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbBR">&nbsp;</a>
<h2>ОБРАБОТКА ПРОСТОЙ КОМАНДЫ</h2>

<p>

При обработке простой команды командный интерпретатор делает, слева направо,
</p><p>
следующие подстановки, присваивания и перенаправления.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt>*</dt><dd>
Слова, помеченные синтаксическим анализатором как присваивания переменным 
<p>
(те, что идут перед именем команды) и перенаправления, сохраняются для
</p><p>
дальнейшей обработки.
</p><p>
</p></dd><dt>*</dt><dd>
В остальных словах выполняются подстановки и замены. Если после этого
<p>
остались какие-то слова, первое из них считается именем команды, а остальные -
</p><p>
ее аргументами.
</p><p>
</p></dd><dt>*</dt><dd>
Перенаправления выполняются так, как описано ранее 
<p>
в разделе "<b>ПЕРЕНАПРАВЛЕНИЕ</b>".
</p><p>
</p></dd><dt>*</dt><dd>
В тексте после <b>=</b> в каждом присваивании переменной перед присваиванием 
<p>
выполняется замена тильды, подстановка значений параметров, подстановка 
</p><p>
результатов выполнения команд и вычисление арифметических выражений, а также
</p><p>
удаление кавычек.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если в результате имени команды нет, присваивания переменным влияют на среду
</p><p>
текущего командного интерпретатора. В противном случае, переменные добавляются в 
</p><p>
среду выполняемой команды и не влияют на среду текущего командного 
</p><p>
интерпретатора. Если происходит попытка присвоить значение переменной с атрибутом
</p><p>
только для чтения, выдается сообщение об ошибке и команда завершается с
</p><p>
ненулевым статусом выхода.
</p><p>
</p><p>
</p><p>
</p><p>

Если в результате имени команды нет, перенаправления выполняются,
</p><p>
но не влияют на среду текущего командного интерпретатора. При ошибке
</p><p>
перенаправления команда завершается с ненулевым статусом выхода.
</p><p>
</p><p>
</p><p>
</p><p>

Если после подстановок имя команды осталось, выполнение продолжается так,
</p><p>
как описано ниже. В противном случае, выполнение команды завершается.
</p><p>
При этом если выполнялись подстановки результатов выполнения команд,
</p><p>
статус выхода будет равен статусу последней команды, результаты которой были
</p><p>
подставлены. Если подстановок результатов выполнения команд не было, команда
</p><p>
завершается со статусом выхода ноль.
</p><p>
</p><p>
</p><p>
<a name="lbBS">&nbsp;</a>
</p><h2>ВЫПОЛНЕНИЕ КОМАНДЫ</h2>

<p>

После разбиения команды на слова, если в результате получилась простая команда
</p><p>
с необязательным списком аргументов, выполняются следующие действия..PP 
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>

Если имя команды не содержит сиволов косой черты, командный интерпретатор
</p><p>
пытается ее найти. Если существует функция командного интерпретатора с
</p><p>
таким именем, она вызывается как было описано выше 
</p><p>
в разделе "<b>ФУНКЦИИ</b>".
</p><p>
Если же функции с таким именем нет, командный интерпретатор ищет ее в списке
</p><p>
встроенных команд. Если такая встроенная команда есть, она выполняется.
</p><p>
</p><p>
</p><p>
</p><p>

Если имя не является именем функции или именем встроенной команды и не содержит
</p><p>
пробелы, командный интерпретатор <b>bash</b> просматривает каждый
</p><p>
каталог в значении переменной <b>PATH</b> в поисках выполняемого файла с 
</p><p>
соответствующим именем. Для запоминания полных имен выполняемых файлов
</p><p>
<b>bash</b> использует хэш-таблицу (см. описание команды <b>hash</b> 
</p><p>
в разделе "<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" далее). 
</p><p>
Полный поиск по каталогам в <b>PATH</b>
</p><p>
выполняется только если команда не найдена в этой хэш-таблице.
</p><p>
Если команда при таком поиске не найдена, командный интерпретатор выдает 
</p><p>
соответствующее сообщение и завершает выполнение команды со статусом выхода 127.
</p><p>
</p><p>
</p><p>
</p><p>

Если команда найдена или имя команды содержит косые черты, командный 
</p><p>
интерпретатор выполняет соответствующую команду в отдельной среде выполнения.
</p><p>
Аргумент 0 устанавливается равным имени команды, и ей передаются параметры,
</p><p>
соответствующие аргументам в командной строке, если они заданы.
</p><p>
</p><p>
</p><p>
</p><p>

Если выполнить команду не удалось, потому что файл не соответствует поддерживаемым 
</p><p>
выполняемым форматам, и этот файл не является каталогом, предполагается,
</p><p>
что файл является <i>сценарием командного интерпретатора</i>, содержащим его команды.
</p><p>
Для его выполнения запускается порожденный командный интерпретатор. Этот
</p><p>
порожденный командный интерпретатор переинициализируется, как если бы для
</p><p>
обработки сценария был вызван новый командный интерпретатор, но только 
</p><p>
местонахождения команд, запомненные родительским интерпретатором (см. описание
</p><p>
команды <b>hash</b> ниже в разделе 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>"),
</p><p>
передаются порожденному.
</p><p>
</p><p>
</p><p>
</p><p>

Если текст в файле начинается с <b>#!</b>, остаток первой строки задает интерпретатор
</p><p>
для программы. Командный интерпретатор запускает указанный интерпретатор
</p><p>
в операционных системах, которые не поддерживают соответствующий формат 
</p><p>
выполняемого файла непосредственно. Этому интерпретатору в качестве аргументов
</p><p>
передается один необязательный аргумент, затем имя интерпретатора из первой
</p><p>
строки программы, затем имя самой программы и ее аргументы, если они заданы.
</p><p>
</p><p>
</p><p>
<a name="lbBT">&nbsp;</a>
</p><h2>СРЕДА ВЫПОЛНЕНИЯ КОМАНД</h2>

<p>

У командного интерпретатора есть <i>среда выполнения</i>, содержащая следующие
</p><p>
компоненты:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt>*</dt><dd>
открытые файлы, унаследованные командным интерпретатором при вызове, с учетом
<p>
изменений, вызванных перенаправлениями, переданными встроенной 
</p><p>
команде <b>exec</b>
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
текущий рабочий каталог, установленный командами <b>cd</b>, 
<p>
<b>pushd</b> или <b>popd</b>, 
</p><p>
или унаследованный командным интерпретатором при вызове
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
маска режима создания файла, установленная с помощью команды <b>umask</b>
<p>
или унаследованная от родительского процесса
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
текущие обработчики сигналов, установленные с помощью <b>trap</b>
<p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
параметры командного интерпретатора, установленные путем присваивания 
<p>
переменным или унаследованные из среды родительского процесса
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
функции командного интерпретатора, заданные в ходе выполнения или унаследованные
<p>
из среды родительского процесса
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
опции, установленные при вызове (как стандартные, так и заданные явно в 
<p>
командной строке) или установленные с помощью комнады <b>set</b>
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
опции, установленные с помощью команды <b>shopt</b>
<p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
псевдонимы, заданные с помощью команды <b>alias</b>
<p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
идентификаторы различных процессов, в том числе, для фоновых заданий, значение
<p>
параметра <b>$$</b> и значение параметра <b>$PPID</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Когда необходимо выполнить команду, не являющуюся встроенной или функцией
</p><p>
командного интерпретатора, она вызывается в отдельной среде выполнения, 
</p><p>
состоящей из указанных ниже компонентов. Если не указано иначе, все значения
</p><p>
наследуются от командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt>*</dt><dd>
открытые файлы командного интерпретатора плюс любые изменения и дополнения,
<p>
заданные для команды перенаправлениями
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
текущий рабочий каталог
<p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
маска режима создания файлов
<p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
переменные командного интерпретатора, помеченные как экспортированные, а также 
<p>
переменные, экспортированные для команды и переданные в среде
</p><p>
</p><p>
</p><p>
</p></dd><dt>*</dt><dd>
наследуются установленные в родительском командном интерпретаторе обработчики
<p>
сигналов, а сигналы, в нем игнорировавшиеся, также игнорируются.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Команда, вызванная в этой отдельной среде, не может повлиять на среду
</p><p>
выполнения родительского командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p><p>

Команды, результаты которых необходимо подставить, и асинхронные команды 
</p><p>
вызываются в средах порожденных командных интерпретаторов, которые совпадают
</p><p>
со средой родительского, но обработчки сигналов устанавливаются такие, как были 
</p><p>
унаследованы родительским командным интерпретатором при вызове.
</p><p>
Встроенные команды, вызываемые как часть конвейера, также выполняются в среде 
</p><p>
порожденного командного интерпретатора. Изменения в среде порожденного
</p><p>
командного интерпретатора не затрагивают среду выполнения родительского.
</p><p>
</p><p>
</p><p>
<a name="lbBU">&nbsp;</a>
</p><h2>СРЕДА</h2>

<p>

При вызове программы ей передается массив строк, который называют <i>средой</i>.
</p><p>
Это список пар имя-значение вида <b>name=value</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор позволяет манипулировать средой несколькими способами.
</p><p>
При вызове командный интерпретатор просматривает свою среду и создает 
</p><p>
одноименный параметр для каждого имени, автоматически <i>экспортируя</i> его для
</p><p>
порожденных процессов. Выполняемые команды наследуют среду. Команды
</p><p>
<b>export</b> и <b>declare  -x</b>  
</p><p>
позволяют добавлять и удалять параметры и функции из 
</p><p>
среды. Если значение параметра, входящего в среду, изменено, новое значение
</p><p>
становится частью среды, заменяя старое. Среда, наследуемая выполняемой командой,
</p><p>
состоит из начальной среды командного интерпретатора, значения которой могли
</p><p>
быть изменены в ходе его работы, за исключением пар, удаленных с помощью
</p><p>
команды <b>unset</b>, и новых параметров, добавленных с 
</p><p>
помощью команд <b>export</b> и <b>declare -x</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Среда для любой <i>простой команды</i> или функции может быть временно дополнена путем
</p><p>
задания перед именем присваиваний параметрам, как описано ранее в разделе
</p><p>
"<b>ПАРАМЕТРЫ</b>". Эти операторы присваивания влияют 
</p><p>
только на среду вызываемой команды.
</p><p>
</p><p>
</p><p>
</p><p>

Если установлена опция <b>-k</b>, (см. описание встроенной команды 
</p><p>
<b>set</b> ниже), то все параметры с присвоенными при вызове значениями, 
</p><p>
а не только предшествующие имени команды, помещаются в ее среду.
</p><p>
</p><p>
</p><p>
</p><p>

Когда командный интерпретатор <b>bash</b> вызывает внешнюю команду, переменная <b>_</b>
</p><p>
устанавливается равной полному имени файла команды и передается этой команде
</p><p>
в среде.
</p><p>
</p><p>
</p><p>
<a name="lbBV">&nbsp;</a>
</p><h2>СТАТУС ВЫХОДА</h2>

<p>

С точки зрения командного интерпретатора, команда, завершившаяся со статусом
</p><p>
выхода 0, сработала успешно. Статус выхода 0 означает успешное завершение.
</p><p>
Ненулевой статус выхода означает неудачу. Если работа команды прервана сигналом,
</p><p>
командный интерпретатор <b>bash</b> использует в качестве статуса выхода
</p><p>
значение 128+сигнал.
</p><p>
</p><p>
</p><p>
</p><p>

Если команда не найдена, порожденный для ее выполнения процесс возвращает
</p><p>
статус выхода 127. Если команда найдена, но не является выполняемой, 
</p><p>
возвращается статус выхода 126.
</p><p>
</p><p>
</p><p>
</p><p>

Если команда не сработала, поскольку ошибка произошла при подстановках или 
</p><p>
перенаправлениях, возвращается положительный статус выхода.
</p><p>
</p><p>
</p><p>
</p><p>

Встроенные команды интерпретатора возвращают статус 0 (<b>истина</b>) при успешном
</p><p>
выполнении, и ненулевой статус (<b>ложь</b>), если при выполнении произошла ошибка.
</p><p>
При некорректном использовании все встроенные команды возвращают статус 2.
</p><p>
</p><p>
</p><p>
</p><p>

Сам командный интерпретатор <b>bash</b> возвращает статус выхода последней выполненной
</p><p>
команды, если только не обнаруживает синтаксическую ошибку. В этом случае
</p><p>
он завершает работу с ненулевым статусом. См. также описание встроенной
</p><p>
команды <b>exit</b> ниже.
</p><p>
</p><p>
</p><p>
<a name="lbBW">&nbsp;</a>
</p><h2>СИГНАЛЫ</h2>

<p>

Когда командный интерпретатор <b>bash</b> работает в интерактивном режиме,
</p><p>
при отсутствии обработчиков сигналов, он игнорирует сигнал <b>SIGTERM</b> (так что
</p><p>
команда <b>kill 0</b> не прекращает работу интерактивного 
</p><p>
командного интерпретатора),
</p><p>
а сигнал <b>SIGINT</b> перехватывается и обрабатывается (так, что встроенная команда
</p><p>
<b>wait</b> им не прерывается). Во всех случаях, 
</p><p>
<b>bash</b> игнорирует сигнал <b>SIGQUIT</b>.
</p><p>
Если действует управление заданиями, <b>bash</b> игнорирует сигналы <b>SIGTTIN</b>,
</p><p>
<b>SIGTTOU</b> и <b>SIGTSTP</b>.
</p><p>
</p><p>
</p><p>
</p><p>

У синхронных заданий, запущенных командным интерпретатором <b>bash</b>,
</p><p>
устанавливаются обработчики сигналов, унаследованные командным интерпретатором
</p><p>
от родительского процесса. Если управление заданиями не действует, асинхронные
</p><p>
команды также игнорируют сигналы <b>SIGINT</b> и <b>SIGQUIT</b>. Команды, выполняемые для
</p><p>
подстановки результатов выполнения, игнорируют сигналы управления заданиями
</p><p>
<b>SIGTTIN</b>, <b>SIGTTOU</b> и <b>SIGTSTP</b>, посланные с клавиатуры.
</p><p>
</p><p>
</p><p>
</p><p>

По умолчанию командный интерпретатор завершает работу при получении сигнала
</p><p>
<b>SIGHUP</b>. Перед завершением он посылает сигналы <b>SIGHUP</b> всем заданиям, как
</p><p>
выполняющимся, так и остановленным. Остановленным заданиям предварительно 
</p><p>
посылается сигнал <b>SIGCONT</b>, гарантирующий получение ими сигнала <b>SIGHUP</b>. Для
</p><p>
предотвращения послыки интерпретатором сигнала конкретному заданию, его
</p><p>
необходимо удалить из таблицы заданий с помощью встроенной 
</p><p>
команды <b>disown</b>
</p><p>
(см. раздел "<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" далее) 
</p><p>
или пометить как не получающие сигнал <b>SIGHUP</b> 
</p><p>
с помощью <b>disown -h</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Если с помощью команды <b>shopt</b> установлена опция 
</p><p>
командного интерпретатора <b>huponexit</b>, 
</p><p>
<b>bash</b> посылает сигнал <b>SIGHUP</b> всем заданиям при завершении
</p><p>
работы интерактивного начального командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p><p>

При получении командным интерпретатором <b>bash</b> сигнала, для которого установлен
</p><p>
обработчик, в то время, когда ожидается завершение команды, обработчик
</p><p>
не выполняется, пока команда не завершится. Когда <b>bash</b> ожидает завершения
</p><p>
асинхронной команды с помощью встроенной команды <b>wait</b>, 
</p><p>
получение сигнала, для которого установлен обработчик, приводит к немедленному 
</p><p>
завершению встроенной команды <b>wait</b> со статусом выхода 
</p><p>
более 128 сразу же после выполнения кода обработчика.
</p><p>
</p><p>
</p><p>
<a name="lbBX">&nbsp;</a>
</p><h2>УПРАВЛЕНИЕ ЗАДАНИЯМИ</h2>

<p>

<i>Управление заданиями</i> - это возможность избирательно останавливать 
</p><p>
(<i>приостанавливать</i>) выполнение процессов и продолжать (<i>возобновлять</i>)
</p><p>
их выполнение в дальнейшем. Пользователи обычно делают это через 
</p><p>
интерактивный интерфейс, совместно реализуемый драйвером терминала и
</p><p>
командным интерпретатором <b>bash</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор связывает <i>задание</i> с каждым конвейером. Он поддерживает
</p><p>
таблицу выполняющихся заданий, которую можно просматривать с помощью
</p><p>
команды <b>jobs</b>. 
</p><p>
При запуске задания асинхронно (<i>в фоновом режиме</i>) <b>bash</b> 
</p><p>
выдает строку следующего вида:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1]&nbsp;25647
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

показывающую, что это задание с номером 1, а идентификатор последнего
</p><p>
процесса в конвейере, связанном с данным заданием - 25647. Все процессы в одном
</p><p>
конвейере являются частями одного задания. Командный интерпретатор <b>bash</b>
</p><p>
использует понятие <i>задания</i> как основу для управления заданиями.
</p><p>
</p><p>
</p><p>
</p><p>

Для упрощения реализации пользовательского интерфейса для управления заданиями
</p><p>
система поддерживает понятие <i>идентификатора группы процессов текущего терминала</i>.
</p><p>
Члены этой группы процессов (процессы, идентификатор группы процессов которых
</p><p>
равен идентификатору группы процессов терминала) получают сигналы с клавиатуры,
</p><p>
например, сигнал <b>SIGINT</b>. Эти процессы называют <i>приритетными</i> (процессами переднего
</p><p>
плана). <i>Фоновые</i> процессы - это те, идентификатор группы процессов которых не
</p><p>
совпадает с терминальным; таким процессам сигналы с клавиатуры не посылаются.
</p><p>
Только приоритетные процессы могут читать данные с терминала и выдавать
</p><p>
данные в него. Фоновые процессы, пытающиеся читать с терминала (или выдавать 
</p><p>
в него данные) получают от драйвера терминала сигнал <b>SIGTTIN</b> (<b>SIGTTOU</b>),
</p><p>
который, если не перехвачен, приостанавливает работу процесса.
</p><p>
</p><p>
</p><p>
</p><p>

Если операционная система, в которой работает <b>bash</b>, поддерживает управление
</p><p>
заданиями, <b>bash</b> позволяет его использовать. При нажатии клавиши <i>приостановки</i>
</p><p>
(обычно <b>^Z</b>, <b>Control-Z</b>) по ходу работы процесса, этот процесс останавливается и
</p><p>
управление возвращается командному интерпретатору <b>bash</b>. При нажатии клавиши
</p><p>
<i>отложенной приостановки</i> (обычно <b>^Y</b>, <b>Control-Y</b>) процесс останавливается при 
</p><p>
попытке чтения данных с терминала, и управление возвращается командному
</p><p>
интерпретатору <b>bash</b>. Затем пользователь может управлять состоянием этого задания,
</p><p>
используя команду <b>bg</b> для его продолжения в фоновом режиме, 
</p><p>
команду <b>fg</b> - для
</p><p>
продолжения в приоритетном режиме или команду <b>kill</b> для его прекращения.
</p><p>
Нажатие <b>^Z</b> срабатывает немедленно и имеет дополнительный побочный
</p><p>
эффект в виде сброса данных, ожидающих вывода и ввода.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор поддерживает несколько способов сослаться на задание.
</p><p>
Символ <b>%</b> означает начало имени задания. На задание с номером <b>n</b> можно
</p><p>
сослаться как <b>%n</b>. На задание можно сослаться также с помощью префикса имени
</p><p>
команды, использованной для его начала, или подстроки, входящей в 
</p><p>
соответствующую командную строку. Например, <b>%ce</b> ссылается на остановленное 
</p><p>
задание <b>ce</b>. Если префикс соответствует нескольким заданиям, <b>bash</b> выдает
</p><p>
сообщение об ошибке. Обращение вида <b>%?ce</b>, с другой стороны, ссылается на любое
</p><p>
задание, в командной строке которого содержится подстрока <b>ce</b>. Если эта 
</p><p>
подстрока содержится в нескольких заданиях, <b>bash</b> выдает сообщение об ошибке.
</p><p>
Строки <b>%%</b> и <b>%+</b> обозначают <i>текущее задание</i> командного интерпретатора -
</p><p>
последнее задание, остановленное при работе в приоритетном режиме или запущенное в
</p><p>
фоновом режиме. На <i>предыдущее задание</i> можно сослаться с помощью строки <b>%-</b>.
</p><p>
В результатах работы команд, связанных с управлением заданиями, (в частности,
</p><p>
в результатах выполнения команды <b>jobs</b>), текущее задание всегда 
</p><p>
помечается знаком <b>+</b>, а предыдущее - знаком <b>-</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Для перевода задания в приоритетный режим достаточно ввести только его имя:
</p><p>
<b>%1</b> - это синоним для команды "<b>fg %1</b>", переводящей задание 1 из фонового
</p><p>
в приоритетный режим. Аналогично, команда "<b>%1  &amp;</b>" продолжает работу задания
</p><p>
1 в фоновом режиме и эквивалентна команде "<b>bg %1</b>".
</p><p>
</p><p>
</p><p>
</p><p>

Об изменении состояния задания командный интерпретатор узнает сразу.
</p><p>
Обычно <b>bash</b> информирует об изменениях в состоянии заданий при выдаче очередного
</p><p>
приглашения, чтобы не прерывать этой информацией выдачу любых других результатов.
</p><p>
Если с помощью встроенной команды <b>set</b> установлена 
</p><p>
опция <b>-b</b>, <b>bash</b> информирует о таких изменениях немедленно.
</p><p>
</p><p>
</p><p>
</p><p>

Если при наличии остановленных заданий происходит попытка выхода из <b>bash</b>,
</p><p>
командный интерпретатор выдает соответствующее предупреждение. Затем
</p><p>
с помощью команды <b>jobs</b> можно проверить состояние этих заданий. Если
</p><p>
сразу же выполняется повторная попытка завершить работу, командный интерпретатор не выдает
</p><p>
предупреждения и остановленные задания прекращаются.
</p><p>
</p><p>
</p><p>
<a name="lbBY">&nbsp;</a>
</p><h2>ПРИГЛАШЕНИЯ</h2>

<p>

При интерактивной работе командный интерпретатор <b>bash</b> выдает первичное 
</p><p>
приглашение, <b>PS1</b>, когда он готов к вводу команды, и вторичное приглашение,
</p><p>
<b>PS2</b>, когда для завершения команды необходимы дополнительные данные. 
</p><p>
Командный интерпретатор <b>bash</b> позволяет настраивать эти строки приглашения 
</p><p>
с помощью ряда маскируемых обратной косой специальных символов со следующими
</p><p>
значениями:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
</p><p>
</p><p>
<b>\a</b>
</p><p>
символ сигнала ASCII (звонок - 07)
</p><p>
<b>\d</b>
</p><p>
дата в формате "День_недели Месяц Число" (т.е., "Tue May 26")
</p><p>
<b>\e</b>
</p><p>
управляющий символ ASCII (033)
</p><p>
<b>\h</b>
</p><p>
имя хоста вплоть до первого символа '<b>.</b>'
</p><p>
<b>\H</b>
</p><p>
имя хоста
</p><p>
<b>\n</b>
</p><p>
перевод строки
</p><p>
<b>\r</b>
</p><p>
возврат каретки
</p><p>
<b>\s</b>
</p><p>
имя командного интерпретатора - базовое имя из параметра <b>$0</b> (часть полного
</p><p>
имени после последней косой черты)
</p><p>
<b>\t</b>
</p><p>
текущее время в 24-часовом формате <b>ЧЧ:ММ:СС</b>
</p><p>
<b>\T</b>
</p><p>
текущее время в 12-часовом формате <b>ЧЧ:ММ:СС</b>
</p><p>
<b>\@</b>
</p><p>
текущее время в 12-часовом формате am/pm (утра/вечера)
</p><p>
<b>\u</b>
</p><p>
имя текущего пользователя
</p><p>
<b>\v</b>
</p><p>
версия командного интерпретатора <b>bash</b> (например, 2.00)
</p><p>
<b>\V</b>
</p><p>
релиз командного интерпретатора <b>bash</b>, версия + уровень исправлений 
</p><p>
(например, 2.00.0)
</p><p>
<b>\w</b>
</p><p>
текущий рабочий каталог
</p><p>
<b>\W</b>
</p><p>
базовое имя текущего рабочего каталога
</p><p>
<b>\!</b>
</p><p>
порядковый номер данной команды в списке истории
</p><p>
<b>\#</b>
</p><p>
порядковый номер данной команды
</p><p>
<b>\$</b>
</p><p>
если эффективный идентификатор пользователя - 0, то <b>#</b>, иначе - <b>$</b>
</p><p>
<b>\nnn</b>
</p><p>
символ, соответствующий восьмеричному числу <b>nnn</b>
</p><p>
<b>\\</b>
</p><p>
обратная косая
</p><p>
<b>\[</b>
</p><p>
начало последовательности непечатных символов, которая может использоваться 
</p><p>
для включения в приглашение управляющих символов терминала
</p><p>
<b>\]</b>
</p><p>
завeршение последовательности непечатных символов
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Порядковый номер команды и порядковый номер команды в списке истории обычно
</p><p>
различаются: порядковый номер в списке истории задает ее позицию в списке,
</p><p>
который может содержать команды, прочитанные из файла истории
</p><p>
(см. раздел "<b>ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</b>" далее), тогда как порядковый
</p><p>
номер команды задает ее позицию в списке команд, выполненных в текущем сеансе
</p><p>
командного интерпретатора. После декодирования строки приглашения в ней
</p><p>
выполняется подстановка значений параметров, подстановка результатов выполнения
</p><p>
команд, результатов вычисления арифметических выражений, подстановка строк и
</p><p>
удаление кавычек, в зависимости от значения опции командного интерпретатора
</p><p>
<b>promptvars</b> 
</p><p>
(см. описание команды <b>shopt</b> в разделе 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" далее).
</p><p>
</p><p>
</p><p>
<a name="lbBZ">&nbsp;</a>
</p><h2>БИБЛИОТЕКА READLINE</h2>

<p>

Это библиотека, обрабатывающая входные данные при работе командного
</p><p>
интерпретатора в интерактивном режиме, если при его вызове не была указана
</p><p>
опция <b>--noediting</b>. По умолчанию, команды редактирования 
</p><p>
строки подобны используемым в редакторе <b>emacs</b>. Также предоставляется интерфейс для 
</p><p>
редактирования командной строки в стиле редактора <b>vi</b>. Для отключения 
</p><p>
возможности редактирования после запуска командного интерпретатора используются
</p><p>
опции <b>+o emacs</b> или <b>+o vi</b> встроенной команды <b>set</b> 
</p><p>
(см. раздел "<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже).
</p><p>
</p><p>
</p><p>
<a name="lbCA">&nbsp;</a>
</p><h3>Соглашения по записи команд readline</h3>

<p>
</p><p>
</p><p>
</p><p>

В этом разделе для записи нажимаемых клавиш используются соглашения в стиле
</p><p>
редактора <b>emacs</b>. <i>Управляющие клавиши</i> обозначаются <b>C-клавиша</b>, так что <b>C-n</b>
</p><p>
сокращенно обозначает <b>Control-N</b>. Аналогично, <i>метаклавиши</i> обозначаются
</p><p>
<b>M-клавиша</b>, так что <b>M-x</b> обозначает <b>Meta-X</b>. (На клавиатурах, где нет клавиши 
</p><p>
<b>meta</b>, <b>M-x</b> обозначает <b>ESC x</b>, т.е. нажать клавишу <b>Escape</b> и затем 
</p><p>
нажать клавишу <b>x</b>. Тем самым, клавиша <b>ESC</b> реализует префикс <b>meta</b>. 
</p><p>
Комбинация <b>M-C-x</b> обозначает <b>ESC-Control-x</b>, или нажать клавишу <b>Escape</b>,
</p><p>
затем, удерживая клавишу <b>Control</b>, нажать клавишу <b>x</b>.)
</p><p>
</p><p>
</p><p>
</p><p>

Команды библиотеки <b>readline</b> могут иметь числовые <i>аргументы</i>, обычно обозначающие 
</p><p>
количество повторений. Иногда, однако, они являются признаком значимости аргумента.
</p><p>
Передача отрицательного аргумента команде, работающей с дальнейшим текстом
</p><p>
(например, <b>kill-line</b>) приводит к ее применению к предшествующему тексту.
</p><p>
Команды, работа которых отличается от описанной здесь, специально отмечены ниже.
</p><p>
</p><p>
</p><p>
</p><p>

Если команда <i>удаляет</i> текст, этот текст сохраняется для дальнейшего извлечения 
</p><p>
(вставки). Удаленый текст помещается в кольцевой буфер. Последовательные удаления
</p><p>
пополняют буфер, формируя единицу вставки. Команды, не удаляющие текст,
</p><p>
разделяют фрагменты в кольцевом буфере удаления.
</p><p>
</p><p>
</p><p>
<a name="lbCB">&nbsp;</a>
</p><h3>Инициализация библиотеки readline</h3>

<p>
</p><p>
</p><p>
</p><p>

Библиотека <b>readline</b> настраивается с помощью команд в <i>файле инициализации</i>
</p><p>
(файл <b>inputrc</b>). В качестве имени этого файла берется значение переменной
</p><p>
<b>INPUTRC</b>. Если эта переменная не установлена, используется стандартный файл,
</p><p>
<b>~/.inputrc</b>. При запуске программы, использующей библиотеку <b>readline</b>, 
</p><p>
файл инициализации читается и устанавливаются соответствующие переменные
</p><p>
и горячие клавиши. В файле инициализации <b>readline</b> допускаются лишь несколько
</p><p>
простых конструкций. Пустые строки игнорируются. Строки, начинающиеся символом
</p><p>
<b>#</b>, являются <i>комментариями</i>. Строки, начинающиеся символом <b>$</b>, обозначают <i>условные
</i></p><p><i>
конструкции</i>. Остальные строки обозначают установки горячих клавиш и присваивания
</p><p>
значений переменным.
</p><p>
</p><p>
</p><p>
</p><p>

Стандартные горячие клавиши можно изменить в файле <b>inputrc</b>. Другие программы, 
</p><p>
использующие эту библиотеку, могут добавлять собственные команды и горячие 
</p><p>
клавиши.
</p><p>
</p><p>
</p><p>
</p><p>

Например, поместив в файл инициализации
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
M-Control-u: universal-argument
</p><p>
</p><p>
</p><p>
или
</p><p>
</p></dd><dt></dt><dd>
<p>
C-Meta-u: universal-argument
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

мы привязываем к комбинации клавиш <b>M-C-u</b> команду <b>universal-argument</b> библиотеки
</p><p>
<b>readline</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Распознаются следующие имена символов: <b>RUBOUT</b>, <b>DEL</b>, <b>ESC</b>, 
</p><p>
<b>LFD</b>, <b>NEWLINE</b>, <b>RET</b>, <b>RETURN</b>, <b>SPC</b>, <b>SPACE</b> и <b>TAB</b>. Кроме
</p><p>
имен команд, библиотека <b>readline</b> позволяет привязывать к клавишам строки,
</p><p>
которые будут вставляться при их нажатии (т.е. задвать макроподстановки).
</p><p>
</p><p>
</p><p>
<a name="lbCC">&nbsp;</a>
</p><h3>Горячие клавиши readline</h3>

<p>
</p><p>
</p><p>
</p><p>

Привязки клавиш в файле <b>inputrc</b> задаются с помощью простого синтаксиса.
</p><p>
Необходимо указать только имя команды или текст макроподстановки, и горячие
</p><p>
клавиши, с которыми его надо связать. Горячие клавиши можно задавать двумя 
</p><p>
способами: как символическое имя клавиши, возможно, с префиксом <b>Meta-</b> или 
</p><p>
<b>Control-</b>, или как комбинацию клавиш. При использовании формы 
</p><p>
<b>имя_клавиши:имя_функции или макроподстановка</b>, <b>имя_клавиши</b> просто задается на
</p><p>
английском. Например:
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
Control-u: universal-argument
</p><p>
Meta-Rubout: backward-kill-word
</p><p>
Control-o: "&gt; output"
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

В этом примере комбинация клавиш <b>C-u</b> связывается с функцией <b>universal-argument</b>,
</p><p>
<b>M-DEL</b> - с функцией <b>backward-kill-word</b>, а <b>C-o</b> - с макроподстановкой, указанной 
</p><p>
в правой части (т.е. приведет к вставке текста <b>&gt; output</b> в строку).
</p><p>
</p><p>
</p><p>
</p><p>

Во второй форме, <b>"комбинация_клавиш":имя_функции или макроподстановка</b>, комбинация
</p><p>
клавиш отличается от использованного выше имени клавиши тем, что может
</p><p>
задаваться в двойных кавычках. При этом можно использовать некоторые
</p><p>
управляющие символы в стиле GNU Emacs, как в следующем примере.
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
</p></dd></dl>
<p>

</p><p>
"\C-u": universal-argument
</p><p>
</p><p>
</p><p>
</p><p>

</p><p>
"\C-x\C-r": re-read-init-file
</p><p>
</p><p>
</p><p>
</p><p>

</p><p>
"\e[11~": "Function Key 1"
</p><p>
</p><p>
</p><p>
</p><p>

В этом примере, комбинация клавиш <b>C-u</b> опять связывается с функцией
</p><p>
<b>universal-argument</b>. Комбинация <b>C-x C-r</b> связывается с функцией <b>re-read-init-file</b>,
</p><p>
а комбинация <b>ESC [ 1 1 ~</b> будет приводить к вставке текста <b>Function Key 1</b>.
</p><p>
Полный набор управляющих последовательностей в стиле GNU Emacs представлен ниже.
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
</p><p>
</p><p>
</p></dd><dt><b>\C-</b></dt><dd>
<p>
префикс клавиши <b>Control</b>
</p><p>
</p></dd><dt><b>\M-</b></dt><dd>
<p>
префикс клавиши <b>Meta</b>
</p><p>
</p></dd><dt><b>\e</b></dt><dd>
<p>
управляющий символ
</p><p>
</p></dd><dt><b>\\</b></dt><dd>
<p>
обратная косая
</p><p>
</p></dd><dt><b>\"</b></dt><dd>
<p>
символ "
</p><p>
</p></dd><dt><b>\'</b></dt><dd>
<p>
символ '
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Помимо управляющих последовательностей в стиле GNU  Emacs, имеется еще один
</p><p>
набор управляющих последовательностей, начинающихся с обратной косой:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
</p></dd><dt><b>\a</b></dt><dd>
<p>
предупреждение (звонок)
</p><p>
</p></dd><dt><b>\b</b></dt><dd>
<p>
забой (backspace)
</p><p>
</p></dd><dt><b>\d</b></dt><dd>
<p>
удаление символа (delete)
</p><p>
</p></dd><dt><b>\f</b></dt><dd>
<p>
перевод страницы (form feed)
</p><p>
</p></dd><dt><b>\n</b></dt><dd>
<p>
новая строка
</p><p>
</p></dd><dt><b>\r</b></dt><dd>
<p>
возврат каретки
</p><p>
</p></dd><dt><b>\t</b></dt><dd>
<p>
горизонтальная табуляция
</p><p>
</p></dd><dt><b>\v</b></dt><dd>
<p>
вертикальная табуляция
</p><p>
</p></dd><dt><b>\nnn</b></dt><dd>
<p>
символ, ASCII-код которого имеет восьмеричное значение <b>nnn</b> (от одной до трех цифр)
</p><p>
</p></dd><dt><b>\xnnn</b></dt><dd>
<p>
символ, ASCII-код которого имеет щестнадцатеричное значение <b>nnn</b>
</p><p>
(от одной до трех цифр)
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

При вводе текста макроподстановки необходимо для ее обозначения указывать 
</p><p>
одиночные или двойные кавычки. Текст без кавычек считается именем функции. В теле
</p><p>
макроподстановки интерпретируются перечисленные выше управляющие 
</p><p>
последовательности, начинающиеся с обратной косой. Обратная косая маскирует
</p><p>
любой другой символ в тексте макроподстановки, в том числе, символы <b>"</b> и <b>'</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор <b>bash</b> позволяет просмотреть или изменить текущие горячие
</p><p>
клавиши библиотеки <b>readline</b> с помощью встроенной команды <b>bind</b>.
</p><p>
Режим редактирования можно переключать в ходе интерактивной работы с помощью опции
</p><p>
<b>-o</b> встроенной команды <b>set</b> 
</p><p>
(см. раздел "<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже).
</p><p>
</p><p>
</p><p>
<a name="lbCD">&nbsp;</a>
</p><h3>Переменные readline</h3>

<p>
</p><p>
</p><p>
</p><p>

Библиотека <b>readline</b> поддерживает переменные, которые можно использовать для
</p><p>
дополнительной настройки ее работы. Значение переменной можно установить в файле
</p><p>
<b>inputrc</b> или с помощью оператора вида
</p><p>
</p><dl compact="">
<dt></dt><dd>
<p>
set имя_переменной значение
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

За исключением явно указанных случаев, переменные <b>readline</b> могут иметь значения
</p><p>
<b>On</b> или <b>Off</b>. Ниже представлены эти переменные и их стандартные значения:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>bell-style (audible)</b></dt><dd>
<p>
Управляет тем, что происходит, когда библиотека <b>readline</b> должна выдать звонок 
</p><p>
(звуковой сигнал) терминала. Если задано значение <b>none</b>, <b>readline</b> никогда не 
</p><p>
выдает звуковой сигнал. Если задано значение <b>visible</b>, <b>readline</b> использует 
</p><p>
визуальный сигнал, если он поддерживается терминалом. Если задано значение
</p><p>
<b>audible</b>, <b>readline</b> пытается выдать звуковой сигнал терминала.
</p><p>
</p></dd><dt><b>comment-begin ("#")</b></dt><dd>
<p>
Строка, вставляемая при выполнении команды <b>insert-comment</b> библиотеки <b>readline</b>.
</p><p>
Эта команда привязана к клавишам <b>M-#</b> в режиме <b>emacs</b> и к клавише <b>#</b> в режиме <b>vi</b>.
</p><p>
</p></dd><dt><b>completion-ignore-case (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, библиотека <b>readline</b> выполняет подстановку имен файлов
</p><p>
и дополнение командной строки с учетом регистра.
</p><p>
</p></dd><dt><b>completion-query-items (100)</b></dt><dd>
<p>
Определяет, когда у пользователя запрашивают подтверждение выдачи всех завершений 
</p><p>
команды, генерируемых командой <b>possible-completions</b>. Можно задавать любое
</p><p>
неотрицательное целочисленное значение. Если количество возможных завершений
</p><p>
больше или равно значению этой переменной, у пользователя запрашивают, желает
</p><p>
ли он все их увидеть; иначе они просто выдаются на терминал.
</p><p>
</p></dd><dt><b>convert-meta (On)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, <b>readline</b> будет преобразовывать символы с установленным
</p><p>
восьмым битом в последовательность символов ASCII путем сброса восьмого бита и
</p><p>
добавления управляющего символа (фактически, используя управляющий символ как 
</p><p>
мета-префикс).
</p><p>
</p></dd><dt><b>disable-completion (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, <b>readline</b> не будет выполнять завершение слов. Символы 
</p><p>
завершения будут вставляться в строку буквально.
</p><p>
</p></dd><dt><b>editing-mode (emacs)</b></dt><dd>
<p>
Управляет тем, с каким набором горячих клавиш начинает работать библиотека <b>readline</b> -
</p><p>
анаголичным <b>emacs</b> или <b>vi</b>. Переменная <b>editing-mode</b> может иметь значения <b>emacs</b> или <b>vi</b>.
</p><p>
</p></dd><dt><b>enable-keypad (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, <b>readline</b> будет пытаться включить поддержку цифрового
</p><p>
блока клавиатуры справа при вызове. Некоторым системам это необходимо для поддержки
</p><p>
клавиш со стрелками.
</p><p>
</p></dd><dt><b>expand-tilde (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, при попытке завершеная слов выполняется замена тильды.
</p><p>
</p></dd><dt><b>horizontal-scroll-mode (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, <b>readline</b> будет использовать одну строку для показа, 
</p><p>
прокручивая ее при необходимости в одной строке, когда ее длина превышает ширину 
</p><p>
экрана, а не перенося визуально на новую строку.
</p><p>
</p></dd><dt><b>input-meta (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, <b>readline</b> будет поддерживать ввод восьмибитовых
</p><p>
символов (т.е. не будет сбрасывать старший бит символов при чтении), независимо
</p><p>
от того, поддерживает ли восьмибитовые символы терминал. Имя <b>meta-flag</b> - синоним
</p><p>
для данной переменной.
</p><p>
</p></dd><dt><b>isearch-terminators ("C-[C-J")</b></dt><dd>
<p>
Строка символов, которые должны прекращать инкрементный поиск без последующего
</p><p>
выполнения символа как команды. Если значение этой переменной не задано, инкрементный
</p><p>
поиск будут прекращать клавиши <b>ESC</b> и <b>C-J</b>.
</p><p>
</p></dd><dt><b>keymap (emacs)</b></dt><dd>
<p>
Устанавливает текущую раскладку горячих клавиш для <b>readline</b>. Допускаются имена раскладок
</p><p>
<b>emacs</b>, <b>emacs-standard</b>, <b>emacs-meta</b>, <b>emacs-ctlx</b>, <b>vi</b>, <b>vi-command</b> и <b>vi-insert</b>. 
</p><p>
<b>vi</b> эквивалентно <b>vi-command</b>; <b>emacs</b> эквивалентно <b>emacs-standard</b>. Стандартное значение -
</p><p>
<b>emacs</b>; значение переменной <b>editing-mode</b> также влияет на горячие клавиши.
</p><p>
</p></dd><dt><b>mark-directories (On)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, к завершенным именам каталогов добавляется косая черта.
</p><p>
</p></dd><dt><b>mark-modified-lines (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, перед строками списка истории команд, которые были изменены,
</p><p>
выдается звездочка (<b>*</b>).
</p><p>
</p></dd><dt><b>output-meta (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, <b>readline</b> будет выдавать символы с установленным
</p><p>
восьмым битом непосредственно, а не как управляющую последовательность,
</p><p>
начинающуюся метасимволом.
</p><p>
</p></dd><dt><b>print-completions-horizontally (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, <b>readline</b> будет выдавать возможные завершения
</p><p>
отсортированные в алфавитном порядке по горизонтали, в строках, а не по вертикали,
</p><p>
в столбцах.
</p><p>
</p></dd><dt><b>show-all-if-ambiguous (Off)</b></dt><dd>
<p>
Изменяет стандартное поведение функций завершения. Если установлено значение <b>On</b>,
</p><p>
для слов, имеющих более одного возможного завершения, список возможных
</p><p>
выдается сразу, а не после звукового сигнала.
</p><p>
</p></dd><dt><b>visible-stats (Off)</b></dt><dd>
<p>
Если установлено значение <b>On</b>, к именам файлов при выдаче возможных завершений
</p><p>
добавляется символ, задающий их тип в соответствии с функцией <b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=stat&amp;category=2">stat</a>(2)</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCE">&nbsp;</a>
<h3>Управляющие конструкции readline</h3>

<p>
</p><p>
</p><p>
</p><p>

Библиотека <b>readline</b> реализует средства, аналогичные по духу возможностям
</p><p>
условной компиляции препроцессора языка C и позволяющие назначать горячие клавиши или
</p><p>
присваивать значения переменным в зависимости от условий. Поддерживается
</p><p>
четыре директивы анализатора.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>$if</b></dt><dd>
<p>
Конструкция <b>$if</b> позволяет назначать те или иные клавиши в зависимости от используемого 
</p><p>
режима редактирования, тип терминала или приложения, использующего библиотеку
</p><p>
<b>readline</b>. Текст условия продолжается до конца строки - никакие завершающие символы
</p><p>
не нужны.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>mode</b></dt><dd>
<p>
Форма <b>mode=</b> директивы <b>$if</b> используется для проверки того, работает ли библиотека
</p><p>
<b>readline</b> в режиме <b>emacs</b> или <b>vi</b>. Ее можно использовать совместно с командой
</p><p>
<b>set keymap</b>, например, для установки горячих клавиш стандарта <b>emacs</b> и
</p><p>
раскладки <b>emacs-ctlx</b> только если <b>readline</b> запускается в режиме <b>emacs</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>term</b></dt><dd>
<p>
Форма <b>term=</b> может использоваться для включения специфических горячих клавиш
</p><p>
для данного терминала, в частности, для привязки последовательностей символов к
</p><p>
функциональным клавишам терминала. Слово справа от символа <b>=</b> сравнивается с
</p><p>
полным именем терминала и частью имени терминала до первого вхождения <b>-</b>.
</p><p>
Это позволяет задавать, например, <b>sun</b> для сопоставления как с <b>sun</b>, так и 
</p><p>
с <b>sun-cmd</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>приложение</b></dt><dd>
<p>
Конструкция приложение используется для включения специфических настроек
</p><p>
приложения. Каждая программа, использующая библиотеку <b>readline</b>, устанавливает
</p><p>
имя приложения, а в инициализационном файле можно проверять установку определенного
</p><p>
значения. Это можно использовать для привязки клавиш к функциям, существенным для 
</p><p>
конкретной программы. Например, следующая команда задает последовательность клавиш,
</p><p>
берущую в кавычки текущее или предыдущее слово в <b>bash</b>:
</p><p>
</p></dd><dt></dt><dd>
<p>
$if Bash
</p><p>
# Взять в кавычки текущее или предыдущее слово
</p><p>
"\C-xq": "\eb\"\ef\""
</p><p>
$endif
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>$endif</b></dt><dd>
<p>
Эта команда, как видно по предыдущему примеру, завершает команду <b>$if</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>$else</b></dt><dd>
<p>
Команды в этой ветке директивы <b>$if</b> выполняются, если не выполнено условие проверки.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>$include</b></dt><dd>
<p>
Эта директива принимает в качестве аргумента имя файла и читает команды и привязки
</p><p>
клавиш из этого файла. Например, следующая директива требует прочитать файл
</p><p>
<b>/etc/inputrc</b>:
</p><p>
</p></dd><dt></dt><dd>
<p>
$include  /etc/inputrc
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCF">&nbsp;</a>
<h3>Поиск</h3>

<p>
</p><p>
</p><p>
</p><p>

Библиотека <b>readline</b> предлагает команды для поиска в списке истории команд 
</p><p>
(см. раздел "<b>ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</b>" ниже) строк, содержащих определенную подстроку. Имеется два режима поиска: инкрементный и не инкрементный.
</p><p>
</p><p>
</p><p>
</p><p>

Инкрементные поиски начинаются прежде, чем пользователь закончит ввод искомой строки.
</p><p>
Привводе каждого символа искомой строки, <b>readline</b> выдает следующую
</p><p>
запись из списка истории, соответствующую уже набранной подстроке. При
</p><p>
инкрементном поиске достаточно ввести ровно столько символов, сколько надо
</p><p>
для нахождения интересующей команды. Символы значения переменной
</p><p>
<b>isearch-terminators</b> используются для завершения инкрементного поиска. Если
</p><p>
значение этой переменной не задано, инкрементный поиск прерывается клавишами
</p><p>
<b>Escape</b> и <b>Control-J</b>. Нажатие <b>Control-G</b> прерывает инкрементный поиск и восстанавливает
</p><p>
исходную строку. При завершении поиска, запись из списка истории, содержащая строку 
</p><p>
поиска, становится текущей строкой. Для поиска других соответствующих записей в 
</p><p>
списке истории, нажмите <b>Control-S</b> или <b>Control-R</b>, в зависимости от направления
</p><p>
поиска. В результате, будет выполнен поиск в обратном или прямом направлении
</p><p>
следующей записи, соответствующей уже набранному фрагменту строки. Ввод любой другой
</p><p>
последовательности символов, привязанной к команде библиотеки <b>readline</b>,
</p><p>
приводит к завершению поиска и выполнению команды. Например, нажатие клавиши <b>Enter</b>
</p><p>
завершит поиск и выполнит выбранную команду из списка истории.
</p><p>
</p><p>
</p><p>
</p><p>

При неинкрементом поиске перед началом поиска читается вся искомая строка. Искомая строка
</p><p>
может быть набрана пользователем или быть частью содержимого текущей строки.
</p><p>
</p><p>
</p><p>
&amp;nbsp;&amp;nbsp;&amp;nbsp;   Имена команд readline
</p><p>
</p><p>
</p><p>
</p><p>

Ниже представлен список имен команд и стандартные комбинации клавиш, к
</p><p>
которым они привязаны. Имена команд, для которых не указана комбинация
</p><p>
клавиш, по умолчанию ни к какой комбинации не привязаны.
</p><p>
</p><p>
</p><p>
<a name="lbCG">&nbsp;</a>
</p><h3>Команды для перемещения</h3>

<p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>beginning-of-line (C-a)</b></dt><dd>
<p>
Перемещает курсор в начало текущей строки.
</p><p>
</p></dd><dt><b>end-of-line (C-e)</b></dt><dd>
<p>
Перемещает курсор в конец строки.
</p><p>
</p></dd><dt><b>forward-char (C-f)</b></dt><dd>
<p>
Перемещает курсор на один символ вперед.
</p><p>
</p></dd><dt><b>backward-char (C-b)</b></dt><dd>
<p>
Перемещает курсор на один символ назад.
</p><p>
</p></dd><dt><b>forward-word (M-f)</b></dt><dd>
<p>
Перемещает курсор на одно слово вперед. Слова состоят из алфавитно-цифровых 
</p><p>
символов (букв и цифр).
</p><p>
</p></dd><dt><b>backward-word (M-b)</b></dt><dd>
<p>
Переходит к началу текущего или предыдущего слова. Слова состоят из 
</p><p>
алфавитноцифровых символов (букв и цифр).
</p><p>
</p></dd><dt><b>clear-screen (C-l)</b></dt><dd>
<p>
Очищает экран, оставляя текущую строку вверху экрана. При указании аргумента
</p><p>
обновляет текущую строку, не очищая экрана.
</p><p>
</p></dd><dt><b>redraw-current-line</b></dt><dd>
<p>
Обновляет текущую строку.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCH">&nbsp;</a>
<h3>Команды для работы со списком истории</h3>

<p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>accept-line (Newline, Return)</b></dt><dd>
<p>
Принимает строку, независимо от позиции курсора. Если эта строка - не пустая,
</p><p>
добавляет ее в список истории в соответствии с состоянием переменной
</p><p>
<b>HISTCONTROL</b>. Если строка представляет собой измененную строку из списка 
</p><p>
истории, то строка истории восстанавливается в исходное состояние.
</p><p>
</p></dd><dt><b>previous-history (C-p)</b></dt><dd>
<p>
Извлекает предыдущую команду из списка истории, возвращаясь к началу списка.
</p><p>
</p></dd><dt><b>next-history (C-n)</b></dt><dd>
<p>
Извлекает следующую команду из списка истории, направляясь к концу списка.
</p><p>
</p></dd><dt><b>beginning-of-history (M-&lt;)</b></dt><dd>
<p>
Переходит к первой строке в списке истории.
</p><p>
</p></dd><dt><b>end-of-history (M-&gt;)</b></dt><dd>
<p>
Переходит к концу истории введенных команд, т.е. к текущей вводимой строке.
</p><p>
</p></dd><dt><b>reverse-search-history (C-r)</b></dt><dd>
<p>
Ищет команду среди предыдущих, начиная с текущей строки и продвигаясь, при 
</p><p>
необходимости, к началу списка истории. Этот поиск - инкрементный.
</p><p>
</p></dd><dt><b>forward-search-history (C-s)</b></dt><dd>
<p>
Поиск далее, начиная с текущей строки и продвигаясь, при необходимости,
</p><p>
к концу списка истории. Этот поиск - инкрементный.
</p><p>
</p></dd><dt><b>non-incremental-reverse-search-history (M-p)</b></dt><dd>
<p>
Неинкрементный поиск введенной пользователем строки в обратном направлении, 
</p><p>
начиная с текущей строки.
</p><p>
</p></dd><dt><b>non-incremental-forward-search-history (M-n)</b></dt><dd>
<p>
Неинкрементный поиск введенной пользователем строки далее, 
</p><p>
начиная с текущей строки.
</p><p>
</p></dd><dt><b>history-search-forward</b></dt><dd>
<p>
Поиск далее в списке истории строки символов от начала текущей строки до
</p><p>
<i>позиции курсора</i> (текущей позиции). Этот поиск - не инкрементный.
</p><p>
</p></dd><dt><b>history-search-backward</b></dt><dd>
<p>
Поиск в обратном направлении в списке истории строки символов от начала 
</p><p>
текущей строки до позиции курсора (текущей позиции). Этот поиск - не инкрементный.
</p><p>
</p></dd><dt><b>yank-nth-arg (M-C-y)</b></dt><dd>
<p>
Вставляет первый аргумент предыдущей команды (обычно это второе слово
</p><p>
предыдущей строки) в текущую позицию курсора. Если указан аргумент <b>n</b>,
</p><p>
вставляет <b>n</b>-ное слово предыдущей команды (слова в предыдущей команде нумеруются
</p><p>
с 0). Если аргумент - отрицательный, вставляется <b>n</b>-ное слово от конца
</p><p>
предыдущей команды.
</p><p>
</p></dd><dt><b>yank-last-arg (M-., M-_)</b></dt><dd>
<p>
Вставляет последний аргумент предыдущей команды (последнее слово в предыдущей
</p><p>
записи списка истории). Если указан аргумент, работает так же, как и
</p><p>
команда <b>yank-nth-arg</b>. При последовательном вызове команды
</p><p>
<b>yank-last-arg</b> выполняется проход в обратном направлении по списку истории,
</p><p>
со вставкой последнего аргумента очередной строки.
</p><p>
</p></dd><dt><b>shell-expand-line (M-C-e)</b></dt><dd>
<p>
Выполняет подстановки в строке по аналогии с командным интерпретатором.
</p><p>
Выполняются подстановки псевдонимов и команд из списка истории,
</p><p>
а также подстановка слов. Описание подстановки команд из списка истории
</p><p>
см. далее в разделе "<b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</b>".
</p><p>
</p></dd><dt><b>history-expand-line (M-^)</b></dt><dd>
<p>
Выполняет подстановку команд из списка истории в текущей строке.
</p><p>
Описание подстановки команд из списка истории
</p><p>
см. далее в разделе "<b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</b>".
</p><p>
</p></dd><dt><b>magic-space</b></dt><dd>
<p>
Выполняет подстановку команд из списка истории в текущей строке 
</p><p>
и добавляет пробел. Описание подстановки команд из списка истории
</p><p>
см. далее в разделе "<b>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</b>".
</p><p>
</p></dd><dt><b>alias-expand-line</b></dt><dd>
<p>
Выполняет подстановку псевдонимов в текущей строке. Описание подстановки
</p><p>
псевдонимов см. ранее в разделе ""<b>ПСЕВДОНИМЫ</b>".
</p><p>
</p></dd><dt><b>history-and-alias-expand-line</b></dt><dd>
<p>
Выполняет подстановки псевдонимов и команд из списка истории в текущей строке.
</p><p>
</p></dd><dt><b>insert-last-argument (M-., M-_)</b></dt><dd>
<p>
Синоним для команды <b>yank-last-arg</b>.
</p><p>
</p></dd><dt><b>operate-and-get-next (C-o)</b></dt><dd>
<p>
Принимает текущую строку для выполнения и извлекает следующую строку
</p><p>
после текущей из списка истории для редактирования. Аргументы игнорируются.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
&amp;nbsp;&amp;nbsp;&amp;nbsp;   Команды для изменения текста
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>delete-char (C-d)</b></dt><dd>
<p>
Удаляет символ в позиции курсора. Если текущая позиция - начало строки,
</p><p>
в строке нет символов и последняя нажатая клавиша не привязана к команде
</p><p>
<b>delete-char</b>, возвращает <b>EOF</b>.
</p><p>
</p></dd><dt><b>backward-delete-char (Backspace)</b></dt><dd>
<p>
Удаляет символ перед курсором. При указании числового аргумента
</p><p>
сохраняет удаленный текст в <i>кольцевом буфере</i> (kill ring).
</p><p>
</p></dd><dt><b>forward-backward-delete-char</b></dt><dd>
<p>
Удаляет символ в позиции курсора, если куросор не в конце строки, - в
</p><p>
этом случае удаляется символ перед курсором. По умолчанию эта команда ни к
</p><p>
какой комбинации клавиш не привязана.
</p><p>
</p></dd><dt><b>quoted-insert (C-q, C-v)</b></dt><dd>
<p>
Добавляет следующий набранный символ буквально. Так можно вставлять, например,
</p><p>
символы типа <b>C-q</b>.
</p><p>
</p></dd><dt><b>tab-insert (C-v TAB)</b></dt><dd>
<p>
Вставляет символ табуляции.
</p><p>
</p></dd><dt><b>self-insert (a, b, A, 1, !, ...)</b></dt><dd>
<p>
Вставляет набранный символ.
</p><p>
</p></dd><dt><b>transpose-chars (C-t)</b></dt><dd>
<p>
Переносит символ перед текущей позицией за текущую позицию. Текущая позиция 
</p><p>
также перемещается вперед на один символ. Если текущая позиция - конец строки,
</p><p>
меняет местами два символа перед текущей позицией. Отрицательные аргументы не
</p><p>
поддерживаются.
</p><p>
</p></dd><dt><b>transpose-words (M-t)</b></dt><dd>
<p>
Переносит предыдущее слово за слово, на котором (или после которого) стоит 
</p><p>
курсор. Курсор перемещается в конец перенесенного слова.
</p><p>
</p></dd><dt><b>upcase-word (M-u)</b></dt><dd>
<p>
Переводит в верхний регистр текущее (или следующее слово). Если указан 
</p><p>
отрицательный аргумент, переводит в верхний регистр предыдущее слово, но не
</p><p>
меняет текущей позиции.
</p><p>
</p></dd><dt><b>downcase-word (M-l)</b></dt><dd>
<p>
Переводит в нижний регистр текущее (или следующее слово). Если указан 
</p><p>
отрицательный аргумент, переводит в верхний регистр предыдущее слово, но не
</p><p>
меняет текущей позиции.
</p><p>
</p></dd><dt><b>capitalize-word (M-c)</b></dt><dd>
<p>
Начинает с прописной буквы текущее или следующее слово. Если указан
</p><p>
отрицательный аргумент, начинает с прописной буквы предыдущее слово, но
</p><p>
не меняет текущей позиции.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCI">&nbsp;</a>
<h3>Удаление и вставка</h3>

<p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>kill-line (C-k)</b></dt><dd>
<p>
Удаляет текст от текущей позиции курсора до конца строки.
</p><p>
</p></dd><dt><b>backward-kill-line (C-x Backspace)</b></dt><dd>
<p>
Удаляет текст до начала строки.
</p><p>
</p></dd><dt><b>unix-line-discard (C-u)</b></dt><dd>
<p>
Удаляет текст от текущей позиции до начала строки. Удаленный текст помещается в
</p><p>
<i>кольцевой буфер</i>.
</p><p>
</p></dd><dt><b>kill-whole-line</b></dt><dd>
<p>
Удаляет все символы текущей строки, независимо от позиции курсора.
</p><p>
</p></dd><dt><b>kill-word (M-d)</b></dt><dd>
<p>
Удаляет символы от курсора до конца слова или, если курсор стоит между словами, до 
</p><p>
конца следующего слова. Границы слов определяются так же, как и для
</p><p>
команды <b>forward-word</b>.
</p><p>
</p></dd><dt><b>backward-kill-word (M-Backspace)</b></dt><dd>
<p>
Удаляет слово перед курсором. Границы слова определяются так же,
</p><p>
как и в команде <b>backward-word</b>.
</p><p>
</p></dd><dt><b>unix-word-rubout (C-w)</b></dt><dd>
<p>
Удаляет слово перед курсором, используя в качестве ограничителя слов <i>пробельные 
</i></p><p><i>
символы</i>. Границы слова, таким образом, отличаются от принятых в команде
</p><p>
<b>backward-kill-word</b>.
</p><p>
</p></dd><dt><b>delete-horizontal-space (M-\)</b></dt><dd>
<p>
Удаляет все пробелы и символы табуляции вокруг текущей позиции.
</p><p>
</p></dd><dt><b>kill-region</b></dt><dd>
<p>
Удаляет весь текст от текущей позиции до отметки (запомненной позиции
</p><p>
курсора). Этот текст называют <i>областью</i> (region).
</p><p>
</p></dd><dt><b>copy-region-as-kill</b></dt><dd>
<p>
Копирует текст области в буфер.
</p><p>
</p></dd><dt><b>copy-backward-word</b></dt><dd>
<p>
Копирует слово перед текущей позицией в буфер. Границы слов определяются так же,
</p><p>
как в команде <b>backward-word</b>.
</p><p>
</p></dd><dt><b>copy-forward-word</b></dt><dd>
<p>
Копирует слово после текущей позиции в буфер. Границы слов определяются так же,
</p><p>
как в команде <b>forward-word</b>.
</p><p>
</p></dd><dt><b>yank (C-y)</b></dt><dd>
<p>
Вставляет верхний элемент кольцевого буфера в позиции курсора.
</p><p>
</p></dd><dt><b>yank-pop (M-y)</b></dt><dd>
<p>
Прокручивает кольцевой буфер и вставляет новый верхний элемент. Работает
</p><p>
только после команды <b>yank</b> или <b>yank-pop</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCJ">&nbsp;</a>
<h3>Числовые аргументы</h3>

<p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>digit-argument (M-0, M-1, ..., M--)</b></dt><dd>
<p>
Добавляет соответствующую цифру к уже накопленному аргументу или начинает
</p><p>
новый аргумент. <b>M--</b> начинает отрицательный аргумент.
</p><p>
</p></dd><dt><b>universal-argument</b></dt><dd>
<p>
Это еще один способ задания аргумента. Если после этой команды идет одна
</p><p>
или несколько цифр, возможно, начинающихся со знака минус, эти цифры образуют
</p><p>
аргумент. Если после команды идут цифры, повторное выполнение 
</p><p>
<b>universal-argument</b> завершает числовой аргумент, в противном случае -
</p><p>
игнорируется. В качестве специального случая, если сразу после команды идет
</p><p>
символ, отличный от цифры или знака минус, аргумент <b>count</b> для следующей
</p><p>
команды умножается на четыре. Аргумент <b>count</b> первоначально имеет занчение 1, 
</p><p>
так что при первом выполнении получается четыре, затем - шестнадцать и так далее.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCK">&nbsp;</a>
<h3>Завершение</h3>

<p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>complete (TAB)</b></dt><dd>
<p>
Пытается завершить текст, введенный до текущей позиции.
</p><p>
Командный интерпретатор <b>bash</b> пытается выполнить завершение,
</p><p>
рассматривая текст последовательно как обращение к переменной 
</p><p>
(если текст начинается с <b>$</b>), как имя пользователя (если текст начинается 
</p><p>
с <b>~</b>), как имя хоста (если текст начинается с <b>@</b>), или как команду 
</p><p>
(включая псевдонимы и функции). Если ни одним из этих способов завершить
</p><p>
строку не удалось, выполняется попытка завершения имени файла.
</p><p>
</p></dd><dt><b>possible-completions (M-?)</b></dt><dd>
<p>
Список возможных завершений текста до текущей позиции.
</p><p>
</p></dd><dt><b>insert-completions (M-*)</b></dt><dd>
<p>
Вставляет все завершения введенного текста, генерируемые командой
</p><p>
<b>possible-completions</b>.
</p><p>
</p></dd><dt><b>menu-complete</b></dt><dd>
<p>
Аналогична команде <b>complete</b>, но заменяет завершаемое слово
</p><p>
первым из возможных завершений. Повторное выполнение команды
</p><p>
<b>menu-complete</b> вставляет следующий элемент из списка возможных завершений.
</p><p>
В конце списка завершений выдается сигнал и восстанавливается исходный 
</p><p>
текст. Аргумент <b>n</b> вызывает преход на <b>n</b> позиций вперед в списке завершений;
</p><p>
отрицательный аргумент вызывает переход по списку в обратном направлении. 
</p><p>
Предполагается привязка этой команды к клавише <b>TAB</b>, но стандартно она ни к
</p><p>
какой комбинации клавиш не привязана.
</p><p>
</p></dd><dt><b>delete-char-or-list</b></dt><dd>
<p>
Удаляет символ в позиции курсора, если курсор не находится в начале
</p><p>
или в конце строки (аналогично команде <b>delete-char</b>). Если курсор - в конце
</p><p>
строки, ведет себя аналогично команде <b>possible-completions</b>. Эта
</p><p>
команда стандартно ни к какой комбинации клавиш не привязана.
</p><p>
</p></dd><dt><b>complete-filename (M-/)</b></dt><dd>
<p>
Пытается завершить введенный текст до текущей позиции как имя файла.
</p><p>
</p></dd><dt><b>possible-filename-completions (C-x /)</b></dt><dd>
<p>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
</p><p>
имя файла.
</p><p>
</p></dd><dt><b>complete-username (M-~)</b></dt><dd>
<p>
Пытается завершить введенный текст до текущей позиции как имя пользователя.
</p><p>
</p></dd><dt><b>possible-username-completions (C-x ~)</b></dt><dd>
<p>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
</p><p>
имя пользователя.
</p><p>
</p></dd><dt><b>complete-variable (M-$)</b></dt><dd>
<p>
Пытается завершить введенный текст до текущей позиции как обращение к
</p><p>
переменной командного интерпретатора.
</p><p>
</p></dd><dt><b>possible-variable-completions (C-x $)</b></dt><dd>
<p>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
</p><p>
обращение к переменной командного интерпретатора.
</p><p>
</p></dd><dt><b>complete-hostname (M-@)</b></dt><dd>
<p>
Пытается завершить введенный текст до текущей позиции как имя хоста.
</p><p>
</p></dd><dt><b>possible-hostname-completions (C-x @)</b></dt><dd>
<p>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
</p><p>
имя хоста.
</p><p>
</p></dd><dt><b>complete-command (M-!)</b></dt><dd>
<p>
Пытается завершить введенный текст до текущей позиции как имя команды.
</p><p>
При завершении команд текст сопоставляется последовательно с псевдонимами, 
</p><p>
зарезервированными словами, функциями командного интерпретатора, 
</p><p>
встроенными функциями командного интерпретатора и, наконец, 
</p><p>
с именами выполняемых файлов.
</p><p>
</p></dd><dt><b>possible-command-completions (C-x !)</b></dt><dd>
<p>
Выдает возможные завершения текста до текущей позиции, интерпретируемого как
</p><p>
имя команды.
</p><p>
</p></dd><dt><b>dynamic-complete-history (M-TAB)</b></dt><dd>
<p>
Пытается завершить введенный текст до текущей позиции, сравнивая его
</p><p>
со строками из списка истории выполненных команд в поисках возможных
</p><p>
соответствий.
</p><p>
</p></dd><dt><b>complete-into-braces (M-{)</b></dt><dd>
<p>
Выполняет завершение имени файла и возвращает список возможных завершений
</p><p>
в фигурных скобках, чтобы он мог быть обработан командным интерпретатором
</p><p>
(см. раздел "<b>Подстановка значений в фигурных скобках</b>" ранее).
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCL">&nbsp;</a>
<h3>Клавиатурные макросы</h3>

<p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>start-kbd-macro (C-x ()</b></dt><dd>
<p>
Начинает запоминание набранных символов в текущий <i>клавиатурный макрос</i>.
</p><p>
</p></dd><dt><b>end-kbd-macro (C-x ))</b></dt><dd>
<p>
Завершает запоминание набранных символов в текущий клавиатурный макрос и
</p><p>
сохраняет его определение.
</p><p>
</p></dd><dt><b>call-last-kbd-macro (C-x e)</b></dt><dd>
<p>
Выполняет последний определенный клавиатурный макрос, выводя символы
</p><p>
макроса так, как если бы они были введены с клавиатуры.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCM">&nbsp;</a>
<h3>Прочие команды</h3>

<p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>re-read-init-file (C-x C-r)</b></dt><dd>
<p>
Перечитывает содержимое файла <b>inputrc</b> и учитывает все указанные в нем
</p><p>
привязки клавиш и значения переменных.
</p><p>
</p></dd><dt><b>abort (C-g)</b></dt><dd>
<p>
Прерывает текущую команду редактирования и выдает сигнал терминала
</p><p>
(вид сигнала задается командой <b>bell-style</b>).
</p><p>
</p></dd><dt><b>do-uppercase-version (M-a, M-b, M-x, ...)</b></dt><dd>
<p>
Если символ <b>x</b>, введенный вместе с клавишей <b>Meta</b>, является символом нижнего
</p><p>
регистра, выполнить команду, привязанную к соответствующему символу
</p><p>
в верхнем регистре.
</p><p>
</p></dd><dt><b>prefix-meta (ESC)</b></dt><dd>
<p>
Рассматривать следующий введенный символ как предваренный клавишей <b>Meta</b>.
</p><p>
<b>ESC f</b> эквивалентно <b>Meta-f</b>.
</p><p>
</p></dd><dt><b>undo (C-_, C-x C-u)</b></dt><dd>
<p>
Инкрементная отмена, запоминаемая отдельно для каждой строки.
</p><p>
</p></dd><dt><b>revert-line (M-r)</b></dt><dd>
<p>
Отмена всех изменений текущей строки. Аналогично выполнению команды
</p><p>
<b>undo</b> несколько раз до возвращения строки в исходное состояние.
</p><p>
</p></dd><dt><b>tilde-expand (M-&amp;)</b></dt><dd>
<p>
Выполняет замену тильды в текущем слове.
</p><p>
</p></dd><dt><b>set-mark (C-@, M-&lt;space&gt;)</b></dt><dd>
<p>
Устанавливает метку в текущей позиции. Если задан числовой аргумент, метка
</p><p>
устанавливается в соответствующей позиции.
</p><p>
</p></dd><dt><b>exchange-point-and-mark (C-x C-x)</b></dt><dd>
<p>
Меняет местами метку и текущую позицию. Текущей позицией курсора становится
</p><p>
запомненная в метке, а прежняя позиция курсора запоминается в метке.
</p><p>
</p></dd><dt><b>character-search (C-])</b></dt><dd>
<p>
Читается символ, и курсор переводится на следующее вхождение этого
</p><p>
символа. Отрицательный аргумент означает поиск предыдущего вхождения.
</p><p>
</p></dd><dt><b>character-search-backward (M-C-])</b></dt><dd>
<p>
Читается символ, и курсор переводится на предыдущее вхождение этого
</p><p>
символа. Отрицательный аргумент означает поиск следующего вхождения.
</p><p>
</p></dd><dt><b>insert-comment (M-#)</b></dt><dd>
<p>
Значение переменной <b>comment-begin</b> библиотеки <b>readline</b> вставляется в
</p><p>
начало текущей строки, и строка принимается, как если бы была нажата
</p><p>
клавиша <b>Enter</b>. В результате, текущая строка становится <i>комментарием</i>
</p><p>
командного интерпретатора.
</p><p>
</p></dd><dt><b>glob-expand-word (C-x *)</b></dt><dd>
<p>
Слово перед текущей позицией рассматривается как шаблон имен файлов и
</p><p>
вместо него вставляется список соответствующих имен файлов.
</p><p>
</p></dd><dt><b>glob-list-expansions (C-x g)</b></dt><dd>
<p>
Выдается список имен файлов, генерируемых командой 
</p><p>
<b>glob-expand-word</b>, а затем снова исходная строка.
</p><p>
</p></dd><dt><b>dump-functions</b></dt><dd>
<p>
Выдает все функции и комбинации клавиш, к которым они привязаны, в
</p><p>
выходной поток <b>readline</b>. Если задан числовой аргумент,
</p><p>
результат форматируется так, что его можно непосредственно включить в файл <b>inputrc</b>.
</p><p>
</p></dd><dt><b>dump-variables</b></dt><dd>
<p>
Выдает все <i>изменяемые</i> переменные <b>readline</b> вместе с их значениями в
</p><p>
выходной поток <b>readline</b>. Если задан числовой аргумент,
</p><p>
результат форматируется так, что его можно непосредственно включить в файл <b>inputrc</b>.
</p><p>
</p></dd><dt><b>dump-macros</b></dt><dd>
<p>
Выдает все комбинации клавиш <b>readline</b>, привязанные к макросам, и
</p><p>
строки, которые выдаются при их нажатии. Если задан числовой аргумент,
</p><p>
результат форматируется так, что его можно непосредственно включить в файл <b>inputrc</b>.
</p><p>
</p></dd><dt><b>display-shell-version (C-x C-v)</b></dt><dd>
<p>
Выдает информацию о версии текущего экземпляра командного интерпретатора <b>bash</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCN">&nbsp;</a>
<h2>ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</h2>

<p>

При включении опции <b>-o history</b> с помощью встроенной команды <b>set</b>,
</p><p>
командный интерпретатор обеспечивает доступ к истории выполнения
</p><p>
команд - списку ранее введенных команд. Текст последних
</p><p>
<b>HISTSIZE</b> команд (по умолчанию - 500) сохраняется в <i>списке истории</i>.
</p><p>
Командный интерпретатор сохраняет в списке истории команды до подстановки
</p><p>
значений параметров и переменных (см. раздел "<b>ЗАМЕНА</b>" ранее), 
</p><p>
но после подстановки команд из списка истории, с учетом значений переменных
</p><p>
командного интерпретатора <b>HISTIGNORE</b> и <b>HISTCONTROL</b>. При запуске история 
</p><p>
выполнения команд считывается из файла, имя которого задается переменной
</p><p>
<b>HISTFILE</b> (стандартно - <b>~/.bash_history</b>). Файл <b>HISTFILE</b> при необходимости
</p><p>
усекается, чтобы в нем было не более <b>HISTFILESIZE</b> строк. При завершении работы
</p><p>
интерактивного командного интерпретатора последние
</p><p>
<b>HISTSIZE</b> строк копируются из списка истории выполнения команд
</p><p>
в файл <b>HISTFILE</b>. Если установлена опция командного интерпретатора 
</p><p>
<b>histappend</b> (см. описание 
</p><p>
команды <b>shopt</b> в разделе 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже), 
</p><p>
строки добавляются к файлу истории, 
</p><p>
иначе файл истории перезаписывается. Если переменная <b>HISTFILE</b> не установлена
</p><p>
или файл истории не доступен на запись, история выполнения команд не
</p><p>
сохраняется. После сохранения истории файл усекается до не более чем
</p><p>
<b>HISTFILESIZE</b> строк. Если переменная <b>HISTFILESIZE</b> не установлена
</p><p>
усечение файла не выполняется.
</p><p>
</p><p>
</p><p>
</p><p>

Встроенная команда <b>fc</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" ниже)
</p><p>
может использоваться для выдачи или редактирования и повторного выполнения
</p><p>
части списка истории. Встроенная команда <b>history</b> позволяет 
</p><p>
выдавать и изменять список истории выполнения команд, а также
</p><p>
управлять файлом истории. При редактировании командной строки во всех режимах
</p><p>
редактирования доступны команды поиска по списку истории выполнения команд.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор позволяет управлять тем, какие команды сохраняются в
</p><p>
списке истории. Переменные <b>HISTCONTROL</b> и <b>HISTIGNORE</b> позволяют ограничить
</p><p>
множество сохраняемых команд. Опция командного интерпретатора 
</p><p>
<b>cmdhist</b>, при 
</p><p>
включении, заставляет командный интерпретатор пытаться сохранять все строки 
</p><p>
многострочной команды в одной записи списка истории, вставляя при необходимости
</p><p>
точки с запятой для обеспечения синтаксической корректности. Опция
</p><p>
командного интерпретатора <b>lithist</b> заставляет сохранять команды со
</p><p>
встроенными переводами встрок вместо вставки точек с запятой. Установка и сброс 
</p><p>
опций командного интерпретатора рассмотрены ниже в описании встроенной
</p><p>
команды <b>shopt</b> в разделе 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>".
</p><p>
</p><p>
</p><p>
<a name="lbCO">&nbsp;</a>
</p><h2>ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</h2>

<p>

Командный интерпретатор <b>bash</b> поддерживает возможность <i>подстановки
</i></p><p><i>
команд из списка истории</i>, аналогично командному интерпретатору <b>csh</b>.
</p><p>
В этом разделе описан соответствующий синтаксис. Эта возможность
</p><p>
включается по умолчанию для интерактивных командных интерпретаторов
</p><p>
и может быть отключена с помощью опции <b>+H</b> встроенной команды
</p><p>
<b>set</b> (см. раздел 
</p><p>
"<b>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</b>" далее). 
</p><p>
Не интерактивные командные интерпретаторы по умолчанию не выполняют
</p><p>
подстановку команд из списка истории.
</p><p>
</p><p>
</p><p>
</p><p>

С помощью этой подстановки слова из списка истории можно вставлять
</p><p>
во входной поток, что упрощает повторение команд, вставку аргументов
</p><p>
предыдущей команды в текущую строку и исправление ошибок в предыдущих 
</p><p>
командах.
</p><p>
</p><p>
</p><p>
</p><p>

Подстановка из списка истории выполняется сразу же после считывания
</p><p>
всей строки, прежде чем командный интерпретатор разобъет ее на слова.
</p><p>
Это выполняется в два приема. Сначала определяется, какую строку
</p><p>
из списка истории использовать при подстановке. Затем из этой строки 
</p><p>
выбираются части для вставки в текущую строку. Строка, выбираемая из
</p><p>
списка истории, - это <i>событие</i>, а ее части, с которыми происходит 
</p><p>
работа, - <i>слова</i>. Для манипулирования выбранными словами поддерживаются
</p><p>
различные <i>модификаторы</i>. Строка разбивается на слова точно так же, как
</p><p>
и при чтении команды, так что несколько слов, разделенных 
</p><p>
метасимволами и взятые в кавычки, считаются одним словом. 
</p><p>
Подстановка из списка истории инициируется <i>метасимволом подстановки из
</i></p><p><i>
списка истории</i>. По умолчанию - это символ <b>!</b>. Замаскировать
</p><p>
этот метасимвол можно только обратной косой (<b>\</b>) и одиночными
</p><p>
кавычками.
</p><p>
</p><p>
</p><p>
</p><p>

Особенностями подстановки из списка истории можно управлять путем 
</p><p>
установки ряда опций командного интерпретатора с помощью встроенной
</p><p>
команды <b>shopt</b>. Если установлена опция командного интерпретатора 
</p><p>
<b>histverify</b> 
</p><p>
(см. описание встроенной команды <b>shopt</b>) и используется
</p><p>
библиотека <b>readline</b>, результаты подстановки из списка истории не
</p><p>
передаются сразу анализатору командного интерпретатора. Вместо этого,
</p><p>
полученная в результате подстановки строка снова загружается в буфер
</p><p>
редактирования <b>readline</b> для дальнейшего изменения. Если используется
</p><p>
библиотека <b>readline</b> и установлена опция командного интерпретатора
</p><p>
<b>histreedit</b>, неудавшаяся подстановка из списка истории команд
</p><p>
будет повторно загружена в буфер редактирования <b>readline</b> для
</p><p>
исправления. Опция <b>-p</b> встроенной команды <b>history</b> 
</p><p>
может использоваться для предварительного просмотра результатов подстановки 
</p><p>
из списка истории перед ее использованием. Опция <b>-s</b> встроенной команды
</p><p>
<b>history</b> позволяет добавлять команды в 
</p><p>
конец списка истории без их фактического добавления, так что их можно будет повторно 
</p><p>
использовать в дальнейшем.
</p><p>
</p><p>
</p><p>
</p><p>

Командный интерпретатор позволяет управлять назначением различных
</p><p>
метасимволов, используемых механизмом подстановки команд из списка 
</p><p>
истории (см. описание переменной <b>histchars</b> ранее в разделе
</p><p>
"<b>Переменные командного интерпретатора</b>").
</p><p>
</p><p>
</p><p>
<a name="lbCP">&nbsp;</a>
</p><h3>Пометки событий</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Пометка события</i> - это ссылка на элемент командной строки в списке 
</p><p>
истории.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>!</b></dt><dd>
<p>
Начинает подстановку из списка выполненных команд, если только
</p><p>
далее не идет пробел, перевод строки, <b>=</b> или <b>(</b>.
</p><p>
</p></dd><dt><b>!n</b></dt><dd>
<p>
Ссылка на командную строку <b>n</b>.
</p><p>
</p></dd><dt><b>!-n</b></dt><dd>
<p>
Ссылка на текущую строку минус <b>n</b>.
</p><p>
</p></dd><dt><b>!!</b></dt><dd>
<p>
Ссылка на предыдущую команду. Это синоним для команды <b>!-1</b>.
</p><p>
</p></dd><dt><b>!строка</b></dt><dd>
<p>
Ссылка на самую недавнюю команду, начинающуюся со <b>строки</b>.
</p><p>
</p></dd><dt><b>!?строка[?]</b></dt><dd>
<p>
Ссылка на самую недавнюю команду, содержащую <b>строку</b>. Завершающий символ
</p><p>
<b>?</b> можно не указывать, если сразу после <b>строки</b> идет новая строка.
</p><p>
</p></dd><dt><b>^строка1^строка2^</b></dt><dd>
<p>
Быстрая подстановка. Повторить последнюю команду, заменяя 
</p><p>
<b>строку1</b> <b>строкой2</b>. Аналогично <b>!!:s/строка1/строка2/</b> 
</p><p>
(см. подраздел "<b>Модификаторы</b>" ниже).
</p><p>
</p></dd><dt><b>!#</b></dt><dd>
<p>
Вся набранная до этого момента командная строка.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCQ">&nbsp;</a>
<h3>Пометки слов</h3>

<p>
</p><p>
</p><p>
</p><p>

<i>Пометки слов</i> (word  designators) используются для выбора необходимых слов из события. 
</p><p>
Двоеточие (<b>:</b>) отделяет пометку слова от спецификации события. Двоеточие можно
</p><p>
не указывать, если пометка слова начинается символом 
</p><p>
<b>^</b>, <b>$</b>, <b>*</b>, <b>-</b> или <b>%</b>. Слова нумеруются с начала строки, 
</p><p>
причем первое слово имеет номер 0. Слова вставляются в текущую строку через один пробел.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>0</b></dt><dd>
<p>
Нулевое слово. Для командного интерпретатора это - имя команды.
</p><p>
</p></dd><dt><b>n</b></dt><dd>
<p>
<b>n</b>-ное слово.
</p><p>
</p></dd><dt><b>^</b></dt><dd>
<p>
Первый аргумент. Т.е. слово 1.
</p><p>
</p></dd><dt><b>$</b></dt><dd>
<p>
Последний аргумент.
</p><p>
</p></dd><dt><b>%</b></dt><dd>
<p>
Слово, сопоставившееся при последнем поиске '<b>?строка?</b>'.
</p><p>
</p></dd><dt><b>x-y</b></dt><dd>
<p>
Диапазон слов; '<b>-y</b>' - это сокращение для '<b>0-y</b>'.
</p><p>
</p></dd><dt><b>*</b></dt><dd>
<p>
Все слова, кроме нулевого. Это синоним '<b>1-$</b>'.
</p><p>
Вполне допустимо использовать <b>*</b> если в событии есть всего одно слово -
</p><p>
в этом случае возвращается пустая строка.
</p><p>
</p></dd><dt><b>x*</b></dt><dd>
<p>
Сокращение для <b>x-$</b>.
</p><p>
</p></dd><dt><b>x-</b></dt><dd>
<p>
Сокращенная форма для <b>x-$</b>, аналогично <b>x*</b>, но не включая последнее слово.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если пометка слова указана без спецификации события, в качестве
</p><p>
события используется предыдущая команда.
</p><p>
</p><p>
</p><p>
<a name="lbCR">&nbsp;</a>
</p><h3>Модификаторы</h3>

<p>
</p><p>
</p><p>
</p><p>

После необязательной пометки слова может идти последовательность одного или
</p><p>
нескольких следующих <i>модификаторов</i>, предваряемых двоеточием - '<b>:</b>'.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>h</b></dt><dd>
<p>
Удаляет последний компонент имени файла, оставляя только начало.
</p><p>
</p></dd><dt><b>t</b></dt><dd>
<p>
Удаляет все начальные компоненты имени файла, оставляя только последний.
</p><p>
</p></dd><dt><b>r</b></dt><dd>
<p>
Удаляет хвостовой суффикс вида <b>.xxx</b>, оставляя базовое имя файла.
</p><p>
</p></dd><dt><b>e</b></dt><dd>
<p>
Удаляет все, кроме хвостового суффикса.
</p><p>
</p></dd><dt><b>p</b></dt><dd>
<p>
Выдает новую команду на экран, но не выполняет ее.
</p><p>
</p></dd><dt><b>q</b></dt><dd>
<p>
Берет подставляемые слова в кавычки для предотвращения дальнейших подстановок.
</p><p>
</p></dd><dt><b>x</b></dt><dd>
<p>
Берет подставляемые слова в кавычки, как и модификатор <b>q</b>, но разбивает на
</p><p>
слова по пробелам и символам новой строки.
</p><p>
</p></dd><dt><b>s/old/new/</b></dt><dd>
<p>
Подставляет <b>new</b> вместо первого вхождения <b>old</b> в строке события. Вместо
</p><p>
<b>/</b> можно использовать любой <i>ограничитель</i>. Завершающий ограничитель не 
</p><p>
обязателен, если он является последним символом в строке события. 
</p><p>
Ограничитель в строках <b>old</b> и <b>new</b> можно маскировать обратной косой.
</p><p>
Если в строке <b>new</b> есть метасимвол <b>&amp;</b>, он заменяется строкой <b>old</b>.
</p><p>
Обратная косая маскирует метасимвол <b>&amp;</b>. Если строка <b>old</b> - пустая, 
</p><p>
вместо нее используется строка из последней по времени подстановки или,
</p><p>
если подстановок из списка истории ранее не было, последняя строка,
</p><p>
искавшаяся с помощью конструкции <b>!?строка</b>[<b>?</b>].
</p><p>
</p></dd><dt><b>&amp;</b></dt><dd>
<p>
Повторяет предыдущую подстановку.
</p><p>
</p></dd><dt><b>g</b></dt><dd>
<p>
Применяет изменения ко всей строке события. Этот модификатор используется
</p><p>
совместно с '<b>:s</b>'  (например, '<b>:gs/old/new/</b>') или '<b>:&amp;</b>'. При использовании
</p><p>
с '<b>:s</b>', вместо косой (<b>/</b>) можно указывать любой ограничитель, а завершающий
</p><p>
ограничитель указывать не обязательно, если он является последним символом 
</p><p>
в строке события.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCS">&nbsp;</a>
<h2>ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</h2>

<p>

Если явно не указано иначе, каждая из описанных в этом разделе
</p><p>
встроенных команд, принимающих опции, начинающиеся с дефиса (<b>-</b>),
</p><p>
распознает два дефиса (<b>--</b>) как признак завершения опций.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>: [аргументы]</b></dt><dd>
<p>
Никакого эффекта; команда не делает ничего, 
</p><p>
кроме подстановки <b>аргументов</b> и выполнения указанных перенаправлений. 
</p><p>
Возвращает нулевой код возврата.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>. имя_файла [аргументы]</b></dt><dd><b>
</b><p><b>
source имя_файла [аргументы]</b>
</p><p>
Читает и выполняет команды из указанного <b>файла</b> в среде текущего командного 
</p><p>
интерпретатора и возвращает статус выхода последней выполненной команды из 
</p><p>
файла. Если <b>имя_файла</b> не содержит косой черты, файл ищется в каталогах, 
</p><p>
перечисленных в переменной <b>PATH</b>. Искомый файл не обязательно должен быть 
</p><p>
выполняемым. Если ни в одном из каталогов, перечисленных в <b>PATH</b>, файл с 
</p><p>
указанным именем не найден, он ищется в текущем каталоге.  Если отключена 
</p><p>
опция <b>sourcepath</b> встроенной 
</p><p>
команды <b>shopt</b>, перечисленные в <b>PATH</b> каталоги не 
</p><p>
просматриваются. Если переданы <b>аргументы</b>, они становятся позиционными 
</p><p>
параметрами при выполнении <b>файла</b>. Иначе значения позиционных параметров не 
</p><p>
изменяются. Статусом выхода становится статус последней выполненной в 
</p><p>
сценарии команды (статус выхода равен 0, если ни одна команда не выполнялась), 
</p><p>
или 1, если файл не найден или не может быть прочитан.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>alias [-p] [имя[=значение] ...]</b></dt><dd>
<p>
Команда <b>alias</b> без аргументов или с опцией <b>-p</b> выдает список псевдонимов команд в 
</p><p>
виде <b>alias имя=значение</b> в стандартный выходной поток. Если переданы 
</p><p>
аргументы, каждое <b>имя</b>, для которого задано <b>значение</b>, становится <b>псевдонимом</b>. 
</p><p>
Если значение завершается <b>пробелом</b>, в следующем слове при подстановке будет 
</p><p>
выполняться замена псевдонима. Для каждого <b>имени</b> в списке аргументов без 
</p><p>
соответствующего <b>значения</b> выдается имя и значение соответствующего 
</p><p>
псевдонима. Команда <b>alias</b> возвращает истину, если только не задано <b>имя</b>, не 
</p><p>
являющееся именем псевдонима.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>bg [задание]</b></dt><dd>
<p>
Возобновляет выполнение указанного <b>задания</b> в фоновом режиме, как если бы оно 
</p><p>
было запущено с конструкцией <b>&amp;</b>. Если <b>задание</b> не указано, в фоновый режим 
</p><p>
переводится <i>текущее задание</i> командного интерпретатора. Команда <b>bg задание</b> 
</p><p>
возвращает 0, если только управление заданиями не отключено или, при 
</p><p>
включенном управлении заданиями, соответствующее <b>задание</b> не найдено или 
</p><p>
запускалось при отключенном управлении заданиями.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>bind [-m keymap] [-lpsvPSV]</b></dt><dd><b>
<p>
bind [-m keymap] [-q функция] [-u функция] [-r keyseq]
</p><p>
bind [-m keymap] -f имя_файла
</p></b><p><b>
bind [-m keymap] keyseq:имя_функции</b>
</p><p>
Выдает текущие привязки клавиш и функций библиотеки <b>readline</b> или привязывает 
</p><p>
комбинацию клавиш к функции или макросу <b>readline</b>. При этом поддерживается 
</p><p>
такой же синтаксис привязки, как и в файле <b>.inputrc</b>, но каждая привязка должна 
</p><p>
передаваться как отдельный аргумент;  т.е. <b>'"\C-x\C-r":    re-read-init-file'</b>.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Опции, если они переданы, имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>-m keymap</b></dt><dd>
<p>
Использовать набор привязок  для последующих привязок. Допускаются имена 
</p><p>
привязок <b>emacs</b>, <b>emacs-standard</b>, <b>emacs-meta</b>, <b>emacs-ctlx</b>, 
</p><p>
<b>vi</b>, <b>vi-command</b> и <b>vi-insert</b>. <b>vi</b> 
</p><p>
эквивалентно <b>vi-command</b>; <b>emacs</b> эквивалентно <b>emacs-standard</b>.
</p><p>
</p></dd><dt><b>-l</b></dt><dd>
<p>
Список имен всех функций <b>readline</b>.
</p><p>
</p></dd><dt><b>-p</b></dt><dd>
<p>
Выдает имена функций и привязки <b>readline</b> так, чтобы их можно было прочитать 
</p><p>
повторно.
</p><p>
</p></dd><dt><b>-P</b></dt><dd>
<p>
Выдает текущие имена функций и привязки <b>readline</b>.
</p><p>
</p></dd><dt><b>-v</b></dt><dd>
<p>
Выдает имена и значения переменных <b>readline</b> так, чтобы их можно было 
</p><p>
прочитать повторно.
</p><p>
</p></dd><dt><b>-V</b></dt><dd>
<p>
Выдает имена и значения текущих переменных <b>readline</b>.
</p><p>
</p></dd><dt><b>-s</b></dt><dd>
<p>
Выдает комбинации клавиш <b>readline</b>, привязанные к макросам, и выдаваемые при 
</p><p>
их нажатии строки так, чтобы их можно было прочитать повторно.
</p><p>
</p></dd><dt><b>-S</b></dt><dd>
<p>
Выдает комбинации клавиш <b>readline</b>, привязанные к макросам, и выдаваемые при 
</p><p>
их нажатии строки
</p><p>
</p></dd><dt><b>-f имя_файла</b></dt><dd>
<p>
Читать привязки клавиш из указанного <b>файла</b>.
</p><p>
</p></dd><dt><b>-q функция</b></dt><dd>
<p>
Выдает комбинации клавиш, привязанные к указанной <b>функции</b>.
</p><p>
</p></dd><dt><b>-u функция</b></dt><dd>
<p>
Снять все привязки комбинаций клавиш к указанной <b>функции</b>.
</p><p>
</p></dd><dt><b>-r keyseq</b></dt><dd>
<p>
Удалить привязку к указанной комбинации клавиш <b>keyseq</b>.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Команда возвращает значение 0, кроме случаев, когда передана нераспознанная опция или 
</p><p>
произошла ошибка.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>break [n]</b></dt><dd>
<p>
Выход из цикла <b>for</b>, <b>while</b>, 
</p><p>
<b>until</b> или <b>select</b>. 
</p><p>
Если значение <b>n</b> указано, выход из <b>n</b> 
</p><p>
уровней циклов. <b>n</b> должно быть больше 1. Если значение <b>n</b> превышает количество 
</p><p>
вложенных циклов, происходит выход из всех циклов. Команда возвращает 
</p><p>
значение 0, если только не выполнена вне цикла.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>builtin встроенная_команда [аргументы]</b></dt><dd>
<p>
Выполняет указанную <b>встроенную_команду</b> интерпретатора, передает ей 
</p><p>
<b>аргументы</b> и возвращает ее статус выхода. Это полезно при определении функции, 
</p><p>
имя которой совпадает с именем встроенной команды интерпретатора так, чтобы 
</p><p>
можно использовать вызов встроенной команды в функции. Обычно так 
</p><p>
переопределяется встроенная команда <b>cd</b>. Если указанная команда не является 
</p><p>
встроенной командой интерпретатора, возвращается статус 1.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>cd [-LP] [каталог]</b></dt><dd>
<p>
Делает указанный <b>каталог</b> текущим. <i>Стандартный каталог</i> хранится в переменной 
</p><p>
<b>HOME</b>. Пременная <b>CDPATH</b> определяет пути поиска каталогов, содержащих 
</p><p>
указанный <b>каталог</b>.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Альтернативные имена каталогов в значении <b>CDPATH</b> разделяются двоеточием 
</p><p>
(<b>:</b>). Пустое имя каталога в <b>CDPATH</b> соответствует текущему каталогу, т.е. "<b>.</b>".
</p><p>
Если <b>каталог</b> начинается с косой черты (<b>/</b>), то значение переменной <b>CDPATH</b> не 
</p><p>
используется. Опция <b>-P</b> требует использовать физическую структуру каталогов 
</p><p>
вместо следования по символьным связям (см. также опцию <b>-P</b> встроенной 
</p><p>
команды <b>set</b>); 
</p><p>
опция <b>-L</b> требует следовать по символьным связям. Аргумент <b>-</b> 
</p><p>
эквивалентен <b>$OLDPWD</b>. При успешной смене текущего каталога возвращается 
</p><p>
значение 0, в противном случае - 1.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>command [-pVv] команда [аргумент ...]</b></dt><dd>
<p>
Выполняет <b>команду</b> с <b>аргументами</b>, не выполняя обычный поиск функций 
</p><p>
командного интерпретатора. Выполняются только встроенные команды или 
</p><p>
команды, которые находятся в указанных в переменной <b>PATH</b> каталогах. Если 
</p><p>
задана опция <b>-p</b>, поиск <b>команды</b> выполняется по стандартному значению 
</p><p>
переменной <b>PATH</b>, гарантирующему, что будут найдены все стандартные утилиты. 
</p><p>
Если указана опция <b>-V</b> или <b>-v</b>, выдается описание команды. Опция <b>-v</b> выдает одно 
</p><p>
слово - имя команды или имя файла, представляющего команду;  опция <b>-V</b> дает 
</p><p>
немного более детальное описание. Если указана опция <b>-V</b> или <b>-v</b>, статус выхода 
</p><p>
будет 0, если команда найдена, и 1 в противном случае. Если ни одна из этих 
</p><p>
опций не задана и возникла ошибка или команду не удалось найти, будет получен 
</p><p>
статус выхода 127. В противном случае статусом выхода встроенной команды 
</p><p>
<b>command</b> является статус выхода выполненной <b>команды</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>continue [n]</b></dt><dd>
<p>
Перейти к следующей итерации цикла <b>for</b>, 
</p><p>
<b>while</b>, <b>until</b> или 
</p><p>
<b>select</b>. Если указано 
</p><p>
значение <b>n</b>, перейти к следующей итерации <b>n</b>-го внешнего цикла. Значение <b>n</b> 
</p><p>
должно быть больше 1. Если <b>n</b> превышает количество имеющихся внешних циклов, 
</p><p>
выполняется следующая итерация самого внешнего цикла (цикла "верхнего 
</p><p>
уровня"). Возвращается значение 0, если только команда не вызвана вне цикла
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>declare [-afFirx] [-p] [имя[=значение]]</b></dt><dd><b>
</b><p><b>
typeset [-afFirx] [-p] [имя[=значение]]</b>
</p><p>
Объявляет переменные и/или задает их атрибуты. Если <b>имена</b> не заданы, выдаются 
</p><p>
значения переменных. Опция <b>-p</b> будет выдавать атрибуты и значения переменных с 
</p><p>
указанными <b>именами</b>. Когда используется опция <b>-p</b>, остальные опции 
</p><p>
игнорируются. Опция <b>-F</b> запрещает выдачу определений функций; выдаются 
</p><p>
только имена и атрибуты функций. Опция <b>-F</b> автоматически устанавливает <b>-f</b>. 
</p><p>
Следующие опции можно использовать для выдачи переменных только с 
</p><p>
указанными атрибутами или для задания атрибутов переменных:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>-a</b>
</p><p>
Каждое <b>имя</b> - переменная типа массив (см. раздел "<b>Массивы</b>" ранее).
</p><p>
</p></dd><dt><b>-f</b></dt><dd>
<p>
Использовать только имена функций.
</p><p>
</p></dd><dt><b>-i</b></dt><dd>
<p>
Переменная считается целочисленной; при присваивании переменной значения 
</p><p>
вычисляются арифметические выражения (см. раздел 
</p><p>
"<b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b>").
</p><p>
</p></dd><dt><b>-r</b></dt><dd>
<p>
Делает соответствующие переменные доступными только для чтения. Этим 
</p><p>
переменным нельзя присваивать значения в следующих операторах и их нельзя 
</p><p>
сбрасывать.
</p><p>
</p></dd><dt><b>-x</b></dt><dd>
<p>
Помечает имена для экспортирования в среду для последующих команд.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

При задании '<b>+</b>' вместо '<b>-</b>' атрибут сбрасывается, за исключением того, что опцию 
</p><p>
<b>+a</b> нельзя использовать для уничтожения массива. При использовании в функции, 
</p><p>
команда делает каждую опцию локальной, как и команда <b>local</b>. Возвращается 
</p><p>
значение 0, если только не указана недействительная опция, не делается попытка 
</p><p>
определить функцию с помощью конструкции "<b>-f foo=bar</b>", не делается попытка 
</p><p>
присвоить значение переменной, доступной только для чтения, не делается 
</p><p>
попытка присвоить значение массиву без использования конструкции 
</p><p>
присваивания для массива (см. раздел "<b>Массивы</b>" ранее), 
</p><p>
не используется <b>имя</b> 
</p><p>
несуществующей переменной командного интерпретатора, не выполняется 
</p><p>
попытка отменить статус только для чтения переменной, созданной как доступная 
</p><p>
только для чтения, не делается попытка отменить статус массива для переменной 
</p><p>
типа массив, и не предлагается выдать определение несуществующей функции с 
</p><p>
помощью опции <b>-f</b>.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>dirs [-clpv] [+n] [-n]</b></dt><dd>
<p>
Без опций эта команда выдает список текущих запомненных каталогов. По 
</p><p>
умолчанию каталоги выдаются в одну строку через пробел. Каталоги добавляются 
</p><p>
в список с помощью команды <b>pushd</b>; 
</p><p>
команда <b>popd</b> удаляет записи из списка.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>+n</b> 
</p><p>
Выдает <b>n</b>-ную запись слева списка, выдаваемого командой <b>dirs</b> при вызове без 
</p><p>
опций. Нумерация начинается с нуля.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Выдает <b>n</b>-ную запись справа списка, выдаваемого командой <b>dirs</b> при вызове без 
</p><p>
опций. Нумерация начинается с нуля.
</p><p>
</p></dd><dt><b>-c</b></dt><dd>
<p>
Очищает стек каталогов, удаляя все записи.
</p><p>
</p></dd><dt><b>-l</b></dt><dd>
<p>
Выдает более длинный листинг; в стандартном формате листинга для обозначения 
</p><p>
начального каталога используется тильда.
</p><p>
</p></dd><dt><b>-p</b></dt><dd>
<p>
Выдает стек каталогов по одной записи в строку.
</p><p>
</p></dd><dt><b>-v</b></dt><dd>
<p>
Выдает стек каталогов по одной записи в строку, выдавая индекс записи перед 
</p><p>
каждой записью.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если не указана недопустимая опция, и индекс <b>n</b> не выходит за пределы стека, 
</p><p>
возвращается значение 0.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>disown [-ar] [-h] [задание ...]</b></dt><dd>
<p>
При вызове без опций каждое указанное <b>задание</b> удаляется из таблицы активных 
</p><p>
заданий. Если задана опция <b>-h</b>, <b>задания</b> не удаляются из таблицы, а помечаются так, 
</p><p>
что сигнал <b>SIGHUP</b> не посылается заданию при получении сигнала <b>SIGHUP</b> командным 
</p><p>
интерпретатором. Если <b>задание</b> не указано и не заданы опции <b>-a</b> и <b>-r</b>, 
</p><p>
используется <i>текущее задание</i>. Если <b>задание</b> не указано, опция <b>-a</b> 
</p><p>
означает удалить или пометить все 
</p><p>
задания; опция <b>-r</b> без аргумента задание ограничивает действие выполняющимися 
</p><p>
заданиями. Команда возвращает значение 0, если только не указано несуществующее 
</p><p>
задание.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>echo [-neE] [аргумент ...]</b></dt><dd>
<p>
Выдает <b>аргументы</b> через пробел, дополняя в конце символом новой строки. Статус 
</p><p>
возврата - всегда 0. Если указана опция <b>-n</b>, символ новой строки не выдается. Если 
</p><p>
указана опция <b>-e</b>, включается интерпретация следующих управляющих комбинаций 
</p><p>
символов с обратной косой. Опция <b>-E</b> отключает интерпретацию этих управляющих 
</p><p>
последовательностей даже в системах, где они интерпретируются по умолчанию. 
</p><p>
Команда <b>echo</b> не интерпретирует <b>--</b> как признак завершения опций. Команда <b>echo</b> 
</p><p>
интерпретирует следующие управляющие последовательности:
</p><p>
</p><p>
</p><p>
</p></dd><dt></dt><dd>
<b>\a</b>

<p>
сигнал (звонок)
</p><p>
</p></dd><dt></dt><dd>
<b>\b</b>

<p>
забой
</p><p>
</p></dd><dt></dt><dd>
<b>\c</b>

<p>
не выводить завершающие символы новой строки
</p><p>
</p></dd><dt></dt><dd>
<b>\\</b>

<p>
управляющий символ
</p><p>
</p></dd><dt></dt><dd>
<b>\f</b>

<p>
прогон страницы
</p><p>
</p></dd><dt></dt><dd>
<b>\n</b>

<p>
новая строка
</p><p>
</p></dd><dt></dt><dd>
<b>\r</b>

<p>
возврат каретки
</p><p>
</p></dd><dt></dt><dd>
<b>\t</b>

<p>
горизонтальная табуляция
</p><p>
</p></dd><dt></dt><dd>
<b>\v</b>

<p>
вертикальная табуляция
</p><p>
</p></dd><dt></dt><dd>
<b>\
</b>

обратная косая
<p>
</p></dd><dt></dt><dd>
<b>\nnn</b>

<p>
символ, ASCII-код которого - восьмеричное значение <b>nnn</b> (от одной до трех цифр)
</p><p>
</p></dd><dt></dt><dd>
<b>\xnnn</b>

<p>
символ, ASCII-код которого - шестнадцатеричное значение <b>nnn</b> (от одной до трех 
</p><p>
цифр)
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>enable [-adnps] [-f имя_файла] [имя ...]</b></dt><dd>
<p>
Включает и отключает встроенные команды интерпретатора. Отключение встроенной 
</p><p>
команды позволяет выполнять без указания полного имени файл на диске, имя 
</p><p>
которого совпадает со встроенной командой, хотя обычно встроенные команды 
</p><p>
просматриваются первыми. Если используется опция <b>-n</b>, указанные по <b>именам</b> 
</p><p>
команды отключаются, в противном случае они влючаются. Например, чтобы 
</p><p>
использовать двоичную программу <b>test</b>, которая находится в одном из указанных в 
</p><p>
переменной <b>PATH</b> каталогов, вместо встроенной версии интерпретатора, выполните 
</p><p>
<b>enable -n test</b>. Опция <b>-f</b> требует загрузить новую встроенную команду с указанным 
</p><p>
именем из заданного <i>разделяемого объектного файла</i> в системах, поддерживающих 
</p><p>
динамическую загрузку. Опция <b>-d</b> удаляет встроенную команду, ранее загруженную с 
</p><p>
помощью опции <b>-f</b>. Если <b>имена</b> не заданы или если указана опция <b>-p</b>, 
</p><p>
выдается список встроенных команд интерпретатора. При отсутствии других опций и аргументов этот 
</p><p>
список содержит все включенные встроенные команды интерпретатора. Если опция <b>-n</b> 
</p><p>
не указана, выдаются только отключенные встроенные команды. Если указана опция
</p><p>
<b>-a</b>, выдаваемый список включает все встроенные команды с признаком включена или 
</p><p>
отключена. Если указана опция <b>-s</b>, выдаются только встроенные команды, 
</p><p>
предполагаемые <i>стандартом POSIX</i>. Возвращается значение 0, если только <b>имя</b> 
</p><p>
являеся именем встроенной команды интерпретатора и не возникла проблема при 
</p><p>
загрузке новой встроенной команды из разделямого объектного файла.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>eval [аргумент ...]</b></dt><dd>
<p>
<b>Аргументы</b> читаются и соединяются в единую команду. Эта команда затем читается и 
</p><p>
выполняется командным интерпретатором, а ее статус выхода возвращается в 
</p><p>
качестве значения команды <b>eval</b>. Если аргументов нет или все аргументы пустые, 
</p><p>
команда <b>eval</b> возвращает 0.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>exec [-cl] [-a имя] [команда [аргументы]]</b></dt><dd>
<p>
Если указана <b>команда</b>, она заменяет командный интерпретатор. При этом новый 
</p><p>
процесс не создается. <b>Аргументы</b> становятся аргументами команды. Если указана 
</p><p>
опция <b>-l</b>, командный интерпретатор помещает дефис в качестве нулевого аргумента, 
</p><p>
передаваемого команде. Именно так делает команда 
</p><p>
<b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=login&amp;category=1">login</a>(1)</b>. 
</p><p>
Опция <b>-c</b> вызывает 
</p><p>
выполнение команды с пустой средой. Если указана опция <b>-a</b>, командный 
</p><p>
интерпретатор передает имя как нулевой аргумент выполняемой <b>команде</b>. Если 
</p><p>
<b>команда</b> не может быть выполнена по той или иной причине, неинтерактивный 
</p><p>
командный интерпретатор завершает работу, если только не включена опция 
</p><p>
интерпретатора <b>execfail</b>, - в этом случае команда возвращает 
</p><p>
код ошибки. Интерактивный командный интерпретатор возвращает код ошибки если файл не 
</p><p>
может быть выполнен. Если команда не указана, любые перенаправления срабатывают 
</p><p>
в текущем командном интерпретаторе и статус выхода будет 0. Если при 
</p><p>
перенаправлении произошла ошибка, статус выхода будет 1.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>exit [n]</b></dt><dd>
<p>
Вызывает завершение работы командного интерпретатора со статусом <b>n</b>. Если 
</p><p>
значение <b>n</b> не указано, статусом выхода будет статус выхода последней выполненной 
</p><p>
команды. Перед заврешением работы интерпретатора срабатыват обработчик сигнала 
</p><p>
<b>EXIT</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>export [-fn] [имя[=слово]] ...</b></dt><dd><b>
</b><p><b>
export -p</b>
</p><p>
Указанные <b>имена</b> помечаются для автоматического <i>экспортирования в среду</i> 
</p><p>
следующих выполняемых команд. Если указана опция <b>-f</b>, экспортируются имена 
</p><p>
функций. Если имена не указаны или задана опция <b>-p</b>, выдается список всех имен, 
</p><p>
экспортированных данным командным интерпретатором. Опция <b>-n</b> вызывает удаление 
</p><p>
признака экспортирования с указанных переменных. Команда <b>export</b> возвращает 
</p><p>
сатутус выхода 0, если только не указана недопустимая опция, имя несуществующей 
</p><p>
переменной или в опции <b>-f</b> не указано <b>имя</b>, не являющееся именем функции.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>fc [-e редактор] [-nlr] [первая] [последняя]</b></dt><dd><b>
</b><p><b>
fc -s [pat=rep] [команда]</b>
</p><p>
Исправить команду. Первая форма выбирает диапазон команд, от <b>первой</b> до 
</p><p>
<b>последней</b>, из списка истории выполнения. <b>Первую</b> и <b>последнюю</b> команду можно 
</p><p>
задавать строкой (найти последнюю команду, начинающуюся с соответствующей 
</p><p>
строки) или числом (индекс в списке истории, причем отрицательные значения 
</p><p>
используются как смещение от номера текущей команды). Если <b>последняя</b> не указана, 
</p><p>
при выдаче последней считается текущая команда (так что <b>fc -l -10</b> выдает последних 
</p><p>
10 команд), а для остальных опций предполагается, что <b>последняя</b> совпадает с <b>первой</b>. 
</p><p>
Если <b>первая</b> не указана, ею становится предыдущая команда при редактировании и -16 
</p><p>
(шестнадцатая с конца списка истории) при выдаче.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Опция <b>-n</b> подавляет выдачу номеров команд. Опция <b>-r</b> изменяет порядок выдачи 
</p><p>
команд на противоположный. Если указана опция <b>-l</b>, команды выдаются в стандартный 
</p><p>
выходной поток. В противном случае вызывается указанный <b>редактор</b>, которому 
</p><p>
передается файл с соответствующими командами. Если <b>редактор</b> не задан, 
</p><p>
используется значение переменной <b>FCEDIT</b> или значение переменной <b>EDITOR</b>, если 
</p><p>
<b>FCEDIT</b> не установлена. Если не установлены обе переменные, используется редактор 
</p><p>
<b>vi</b>. По завершении редактирования, отредактированные команды выдаются и 
</p><p>
выполняются.
</p><p>
</p><p>
</p><p>
</p><p>

Вторая форма требует повторного выполнения команды после замены каждого 
</p><p>
вхождения <b>pat</b> на <b>rep</b>. Полезно задать псевдоним "<b>r=fc -s</b>",
</p><p>
так что при наборе "<b>r cc</b>" будет выполнена последняя команда, начинавшаяся 
</p><p>
со строки "<b>cc</b>", а при вводе "<b>r</b>" будет повторно выполняться последняя команда.
</p><p>
</p><p>
</p><p>
</p><p>

Если используется первая форма, команда возвращает значение 0, если только не 
</p><p>
указана недопустимая опция или <b>первая</b> или <b>последняя</b> команда выходит за пределы 
</p><p>
номеров команд в списке истоии. Если указана опция <b>-e</b>, возвращается статус выхода 
</p><p>
последней выполненной команды или ошибка, произошедшая при работе с временным 
</p><p>
файлом команд. Если используется вторая форма, возвращается статус выхода 
</p><p>
повторно выполненной команды, если только команда не задает несуществующую 
</p><p>
строку в списке истории, - в этом случае команда <b>fc</b> возвращает 1.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>fg [задание]</b></dt><dd>
<p>
Возобновляет работу <i>задания</i> в <i>приоритетном режиме</i> и делает это <b>задание</b> 
</p><p>
<i>текущим</i>. Если <b>задание</b> не указано, используется текущее задание командного интерпретатора. Возвращается значение статуса выхода команды, переведенной в приоритетный
</p><p>
режим, или 1 если управление заданиями отключено или, при включенном управлении 
</p><p>
заданиями, если указано несуществующее <b>задание</b> или <b>задание</b>, запущенное при 
</p><p>
отключенном управлении заданиями.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>getopts строка_опций имя [аргументы]</b></dt><dd>
<p>
Команда <b>getopts</b> используется процедурами командного интерпретатора для разбора 
</p><p>
позиционных параметров. <b>Строка_опций</b> содержит буквы опций, которые необходимо 
</p><p>
распознать; если после буквы указано двоеточие, предполагается, что у опции должен 
</p><p>
быть аргумент, отделяемый от нее пробельным символом. При каждом вызове команда 
</p><p>
<b>getopts</b> помещает в переменную интерпретатора с указанным именем очередную 
</p><p>
опцию, создавая переменную, если она еще не существует, а индекс следующего 
</p><p>
аргмента - в переменную <b>OPTIND</b>. <b>OPTIND</b> получает значение 1 при каждом вызове 
</p><p>
командного интерпретатора или сценария. Если опция должна иметь аргумент, 
</p><p>
команда <b>getopts</b> помещает этот аргумент в переменную <b>OPTARG</b>. Командный 
</p><p>
интерпретатор не сбрасывает значение <b>OPTIND</b> автоматически. Между вызовами 
</p><p>
команды <b>getopts</b> в том же командном интерпретаторе, если необходимо использовать 
</p><p>
новый набор параметров, надо сбрасывать это значение явно.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Когда все опции обработаны, команда <b>getopts</b> завершает работу со значением, 
</p><p>
большим нуля. <b>OPTIND</b> при этом содержит индекс первого аргумента, не являющегося 
</p><p>
опцией, а переменная <b>имя</b> получает значение <b>?</b>.
</p><p>
</p><p>
</p><p>
</p><p>

Команда <b>getopts</b> обычно обрабатывает позиционные параметры, но если заданы 
</p><p>
<b>аргументы</b>, <b>getopts</b> разбирает их.
</p><p>
</p><p>
</p><p>
</p><p>

Команда <b>getopts</b> может сообщать об ошибках двумя способами. Если первый символ 
</p><p>
<b>строки_опций</b> - двоеточие, используется немногословное информирование об 
</p><p>
ошибках. При обычной работе выдаются диагностические сообщения, если 
</p><p>
обнаруживаются недопустимые опции или недостающие аргументы. Если переменная 
</p><p>
<b>OPTERR</b> имеет значение 0, сообщения об ошибках не выдаются, даже если первым 
</p><p>
символом <b>строки_опций</b> не является двоеточие.
</p><p>
</p><p>
</p><p>
</p><p>

Если обнаружена недопустимая опция, <b>getopts</b> помещает <b>?</b> в переменную 
</p><p>
<b>имя</b> и, если не задано немногословное информирование, выдает сообщение об ошибке и 
</p><p>
сбрасывает переменную <b>OPTARG</b>. Если <b>getopts</b> работает в режиме немногословного 
</p><p>
информирования, символ опции помещается в переменную <b>OPTARG</b> и никакие 
</p><p>
диагностические сообщения не выдаются.
</p><p>
</p><p>
</p><p>
</p><p>

Если обязательный <b>аргумент</b> не обнаружен, и для <b>getopts</b> не задано немногословное 
</p><p>
информирование, переменная <b>имя</b> получает значение <b>?</b>, переменная <b>OPTARG</b> 
</p><p>
сбрасывается, и выдается диагностическое сообщение. Если <b>getopts</b> работает в режиме 
</p><p>
немногословного информирования, переменная <b>имя</b> получает значение <b>:</b>, а в 
</p><p>
переменную <b>OPTARG</b> помещается символ опции.
</p><p>
</p><p>
</p><p>
</p><p>

Команда <b>getopts</b> возвращает 0, если опция, указанная или не указанная, обнаружена. 
</p><p>
Она возвращает ложь, если достигнут конец опций или произошла ошибка.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>hash [-r] [-p имя_файла] [имя]</b></dt><dd>
<p>
Для каждого <b>имени</b> определяется и запоминается полное имя команды 
</p><p>
путем поиска в каталогах, перечисленных в переменной <b>$PATH</b>.
</p><p>
Если указана опция <b>-p</b>, поиск по каталогам не выполняется, и указанное
</p><p>
<b>имя файла</b> используется как полное имя команды. Опция <b>-r</b> вызывает 
</p><p>
сброс всех запомненных имен. Если аргументы не заданы, выдается 
</p><p>
информация о запомненных командах. Статус выхода - истина, если  
</p><p>
только имя удалось найти и не указана недопустимая опция.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>help [шаблон]</b></dt><dd>
<p>
Выдает полезную информацию о встроенных командах. Если <b>шаблон</b> указан,
</p><p>
команда <b>help</b> выдает детальную справочную информацию о всех командах, 
</p><p>
соответствующих <b>шаблону</b>; в противном случае, выдается справка по всем
</p><p>
встроенным командам и управляющим структурам интерпретатора. Статус 
</p><p>
выхода - 0, если удалось найти команду, соответствующую <b>шаблону</b>.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>history [-c] [n]</b></dt><dd><b>
<p>
history -anrw [имя_файла]
</p><p>
history -p аргумент [аргумент ...]
</p></b><p><b>
history -s аргумент [аргумент ...]</b>
</p><p>
Если опции не указаны, выдает список истории команд с номерами строк.
</p><p>
Строки, для которых указана звездочка (<b>*</b>), были изменены.
</p><p>
При указании аргумента <b>n</b> выдаются только последние <b>n</b> строк.
</p><p>
Если указано <b>имя_файла</b>, список истории берется из этого файла; если файл
</p><p>
не указан, используется значение переменной <b>HISTFILE</b>.
</p><p>
Опции имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>-a</b>
</p><p>
Добавлять "новые" строки истории (строки истории, введенные с начала
</p><p>
текущего сеанса <b>bash</b>) в файл истории.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Читать строки истории, еще не прочитанные из файла истории, в текущий список 
</p><p>
истории команд. Речь идет о строках, добавленных в файл истории с начала
</p><p>
текущего сеанса <b>bash</b>.
</p><p>
</p></dd><dt><b>-r</b></dt><dd>
<p>
Читать содержимое файла истории и использовать его в качестве текущего списка
</p><p>
истории выполнения команд.
</p><p>
</p></dd><dt><b>-w</b></dt><dd>
<p>
Записывать текущий список истории команд в файл истории, переписывая его 
</p><p>
текущее содержимое.
</p><p>
</p></dd><dt><b>-c</b></dt><dd>
<p>
Очистить список истории выполнения команд, удаляя все записи.
</p><p>
</p></dd><dt><b>-p</b></dt><dd>
<p>
Выполнить подстановку из списка истории для последующих аргументов и выдать
</p><p>
результат в стандартный выходной поток. Результат не запоминается в 
</p><p>
списке истории. Для отключения обычной подстановки из списка истории,
</p><p>
необходимо маскировать (брать в кавычки) каждый аргумент.
</p><p>
</p></dd><dt><b>-s</b></dt><dd>
<p>
Сохранить аргументы в списке истории как одну запись. Последняя команда
</p><p>
в списке истории удаляется перед добавлением аргументов.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Возвращается значение 0, если не передана недопустимая опция
</p><p>
или при попытке чтения или записи файла истории не произошла ошибка.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>jobs [-lnprs] [ задание ... ]</b></dt><dd><b>
</b><p><b>
jobs -x команда [ аргументы ... ]</b>
</p><p>
Первое из списка активных заданий. Опции имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>-l</b>
</p><p>
Помимо обычной информации выдает идентификаторы процессов.
</p><p>
</p></dd><dt><b>-p</b></dt><dd>
<p>
Выдает только идентификаторы процессов-лидеров групп процессов, образующих
</p><p>
<b>задание</b>.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Выдает информацию только о заданиях, состояние которых изменилось с момента 
</p><p>
последнего уведомления пользователя о состоянии заданий.
</p><p>
</p></dd><dt><b>-r</b></dt><dd>
<p>
Выдает только выполняющиеся задания.
</p><p>
</p></dd><dt><b>-s</b></dt><dd>
<p>
Выдает только остановленные задания.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если указано <b>задание</b>, выдается информация только об этом задании. 
</p><p>
Статус выхода - 0, кроме случаев, когда указана недопустимая опция или идентификатор
</p><p>
несуществующего задания.
</p><p>
</p><p>
</p><p>
</p><p>

Если указана опция <b>-x</b>, команда <b>jobs</b> заменяет любой идентификатор
</p><p>
задания в команде или аргументах соответствующим идентификатором группы
</p><p>
процессов, и выполняет команду, передавая ей аргументы и возвращая ее статус выхода.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>kill [-s сигнал | -n номер_сигнала | -сигнал] [идентификатор_процесса | задание] ...</b></dt><dd><b>
<p>
</p></b></dd><dt><b>kill -l [сигнал | статус_выхода]</b></dt><dd>
<p>
Посылает указанный по имени или номеру <b>сигнал</b> процессам с указанными
</p><p>
<b>идентификаторами</b> или входящим в <b>задание</b> с указанным идентификатором.
</p><p>
<b>Сигнал</b> задается либо по имени, например, <b>SIGKILL</b>, либо по номеру. 
</p><p>
Если <b>сигнал</b> задается по имени, имя может включать префикс <b>SIG</b>, а может 
</p><p>
и не включать. Если сигнал не задан явно, предполагается сигнал 
</p><p>
<b>SIGTERM</b>. При указании опции <b>-l</b> выдаются имена сигналов.
</p><p>
Если при указании опции <b>-l</b> заданы аргументы, выдаются только имена 
</p><p>
сигналов, соответствующих аргументам, и возвращается статус 0. 
</p><p>
Аргумент <b>статус_выхода</b> опции <b>-l</b> - число, задающее либо номер сигнала, 
</p><p>
либо статус выхода процесса, прерванного этим сигналом. Команда <b>kill</b>
</p><p>
возвращает истину, если, по крайней мере, один сигнал был послан 
</p><p>
успешно, или ложь, если возникла ошибка или была указана недопустимая опция.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>let аргумент [аргумент ...]</b></dt><dd>
<p>
Каждый аргумент - арифметическое выражение, которое необходимо 
</p><p>
вычислить (см. раздел "<b>ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</b>").  
</p><p>
Если последний аргумент имеет значение 0, команда <b>let</b> возвращает 1,
</p><p>
в противном случае, она возвращает зачение 0.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>local [имя[=значение] ...]</b></dt><dd>
<p>
Для каждого аргумента создается локальная переменная с указанным 
</p><p>
<b>именем</b>, получающая соответствующее <b>значение</b>. Когда команда <b>local</b> 
</p><p>
используется в функции, она ограничивает область действия этой 
</p><p>
переменной соответствующей функцией и вызванными из нее функциями.
</p><p>
При вызове без операндов команда <b>local</b> выдает список локальных
</p><p>
переменных в стандартный выходной поток. Использование команды
</p><p>
<b>local</b> вне функции - ошибка. Статус возврата - 0, если только 
</p><p>
команда <b>local</b> не использована вне функции или не передано 
</p><p>
недопустимое имя.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>logout</b></dt><dd>
<p>
Выход из начального командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>popd [-n] [+n] [-n]</b></dt><dd>
<p>
Удаляет записи из стека каталогов. При вызове без аргументов
</p><p>
удаляет верхний каталог из стека и выполняет переход в новый
</p><p>
верхний каталог. Аргументы имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>+n</b>
</p><p>
Удаляет <b>n</b>-ную запись слева списка каталогов, начиная с нуля.
</p><p>
Например: "<b>popd +0</b>" удаляет первый каталог, а "<b>popd +1</b>" - второй.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Удаляет <b>n</b>-ную запись справа списка каталогов, начиная с нуля.
</p><p>
Например: "<b>popd -0</b>" удаляет последний каталог, а 
</p><p>
"<b>popd -1</b>" - предпоследний.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Подавляет обычное измнение текущего каталога при удалении каталогов 
</p><p>
из стека, так что изменяется только содержимое стека.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если команда <b>popd</b> завершается успешно, выполняется также команда
</p><p>
<b>dirs</b> и возвращается статус 0. Команда <b>popd</b> возвращает ложь,
</p><p>
если выявлена недопустимая опция, стек каталогов - пустой, указана
</p><p>
несуществующая запись в стеке каталогов или не удалось перейти в
</p><p>
соответствующий каталог.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>printf формат [аргументы]</b></dt><dd>
<p>
Выдает <b>аргументы</b> в соответствии с <b>форматом</b> в стандартный
</p><p>
выходной поток. <b>Формат</b> - строка символов, содержащая три
</p><p>
типа объектов: обычные символы, которые просто копируются
</p><p>
в стандартный выходной поток, управляющие последовательности 
</p><p>
символов, преобразуемые и копируемые в стандартный выходной поток, и
</p><p>
спецификации формата, каждая из которых вызывает выдачу последующего
</p><p>
аргумента. Помимо стандартных форматов <b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=printf&amp;category=1">printf</a>(1)</b>, спецификатор <b>%b</b>
</p><p>
вызывает замену управляющих последовательностей, начинающихся с 
</p><p>
обратной косой, а спецификатор <b>%q</b> требует выдать соответствующий 
</p><p>
аргумент в формате, который можно повторно использовать в качестве
</p><p>
входных данных командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

<b>Формат</b> при необходимости используется повторно, чтобы покрыть все 
</p><p>
<b>аргументы</b>. Если <b>формат</b> требует больше <b>аргументов</b>, чем передано,
</p><p>
дополнительные спецификации формата раскрываются как если бы были 
</p><p>
переданы нулевые значения или пустые строки, соответственно.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>pushd [-n] [каталог]</b></dt><dd><b>
</b><p><b>
pushd [-n] [+n] [-n]</b>
</p><p>
Добавляет каталог на вершину стека каталогов или прокручивает стек, делая новый 
</p><p>
верхний элемент стека текущим рабочим каталогом. При вызове без аргументов,
</p><p>
меняет местами два верхних каталога и возвращает 0, если
</p><p>
стек каталогов не пустой. Аргументы имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>+n</b>
</p><p>
Прокручивает стек так, что <b>n</b>-ный каталог (при подсчете слева
</p><p>
по списку каталогов, начиная с 0) становится вершиной.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Прокручивает стек так, что <b>n</b>-ный каталог (при подсчете справа
</p><p>
по списку каталогов, начиная с 0) становится вершиной.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Эта опция подавляет обычный переход в каталог при добавлении каталогов в
</p><p>
стек, так что действия выполняются только со стеком.
</p><p>
</p></dd><dt><b>каталог</b></dt><dd>
<p>
Добавляет каталог на вершину стека каталогов, делая его текущим
</p><p>
рабочим каталогом.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если команда <b>pushd</b> выполнена успешно, выполняется также команда 
</p><p>
<b>dirs</b>. Если
</p><p>
используется первая форма, <b>pushd</b> возвращает 0 за исключением случая, 
</p><p>
когда не удалось перейти в каталог. При использовании второй формы
</p><p>
<b>pushd</b>  возвращает 0, если только стек каталогов не пустой, не указан несуществующий
</p><p>
элемент стека и удалось перейти в новый текущий каталог.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>pwd [-LP]</b></dt><dd>
<p>
Выдает полное имя текущего каталога. Выдаваемое имя файла не содержит символьных
</p><p>
связей, если указана опция <b>-P</b> или включена опция <b>-o  physical</b>
</p><p>
встроенной команды <b>set</b>. Если использована опция 
</p><p>
<b>-L</b>, выполняется проход по символьным связям. Статус выхода - 0, если не 
</p><p>
возникла ошибка при чтении имени текущего каталога или не передана недопустимая опция.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>read [-er] [-a имя_массива] [-p приглашение] [имя ...]</b></dt><dd>
<p>
Читает одну строку из стандартного входного потока и присваивает первое слово
</p><p>
первому <b>имени</b>, второе слово - второму <b>имени</b>, и так далее, так что оставшиеся слова
</p><p>
вместе с разделителями между ними присваиваются в качестве значения последнему 
</p><p>
<b>имени</b>. Если из входного потока прочитано меньше слов, чем указано <b>имен</b>, остальные
</p><p>
<b>имена</b> получают пустые значения. Для разбиения строки на слова используются символы,
</p><p>
указанные в значении переменной <b>IFS</b>. Символ обратной косой (\) можно использовать
</p><p>
для литеральной интерпретации следующего прочитанного символа и для продолжения ввода
</p><p>
на следующей строке. Опции имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>-r</b>
</p><p>
Обратная косая не обрабатывается как символ маскировки. Она считается частью строки.  
</p><p>
В частности, для продолжения на следующей строке нельзя использовать пару
</p><p>
обратная косая/новая строка.
</p><p>
</p></dd><dt><b>-p</b></dt><dd>
<p>
Выдает <b>приглашение</b>, без завершающего перевода строки, перед чтением входного
</p><p>
потока. <b>Приглашение</b> выдается только если входные данные идут с терминала.
</p><p>
</p></dd><dt><b>-a</b></dt><dd>
<p>
Слова присваиваются последовательным элементам массива <b>имя_массива</b>, начиная с 0.
</p><p>
<b>Имя_массива</b> сбрасывается перед присваиванием новых значений. Другие имена в аргументах игнорируются.
</p><p>
</p></dd><dt><b>-e</b></dt><dd>
<p>
Если стандартный входной поток идет с терминала, для получения строки используется
</p><p>
библиотека <b>readline</b> (см. раздел "<b>БИБЛИОТЕКА READLINE</b>" ранее).
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если имена не указаны, прочитанная строка присваивается переменной <b>REPLY</b>.
</p><p>
Статус выхода - 0, если только не встретился символ конца файла.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>readonly [-apf] [имя ...]</b></dt><dd>
<p>
Указанные <b>имена</b> помечаются как доступные только для чтения; значения соответствующих
</p><p>
переменных нельзя изменять в дальнейшем с помощью присваивания. Если указана опция
</p><p>
<b>-f</b>, функции, соответствующие <b>именам</b>, тоже помечаются. Опция <b>-a</b> ограничивает
</p><p>
действие только массивами. Если ни одно <b>имя</b> не указано или задана опция <b>-p</b>,
</p><p>
выдается список имен, доступных только для чтения. Опция <b>-p</b> вызывает выдачу 
</p><p>
результатов в формате, который можно использовать как входной. Статус выхода - 0, 
</p><p>
если только не передана недопустимая опция, одно из <b>имен</b> не является именем 
</p><p>
переменной или опция <b>-f</b> не указана перед именем, не являющимся именем функции.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>return [n]</b></dt><dd>
<p>
Вызывает завершение работы функции с указанным статусом выхода <b>n</b>. Если <b>n</b> не указано,
</p><p>
возвращается статус выхода последней команды, выполненной в теле функции. При использовании вне функции, но в ходе выполнения сценария командой <b>.</b> (<b>source</b>),
</p><p>
вызывает прекращение выполнения сценария и возврат либо значения <b>n</b>, либо
</p><p>
статуса выхода последней команды сценария. При использовании вне функции и не при
</p><p>
выполнении сценария командой <b>.</b>, возвращает 1.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>set [--abefhkmnptuvxBCHP] [-o опция] [аргумент ...]</b></dt><dd>
<p>
При вызове без опций выдает имя и значение всех переменных командного интерпретатора в виде, пригодном для повторного выполнения присваиваний. Результат отсортирован по
</p><p>
именам в соответствии с текущей локалью. Если опции указаны, они устанавливают или сбрасывают атрибуты командного интерпретатора. Все оставшиеся после обработки опций
</p><p>
аргументы присваиваются последовательно в качестве значений позиционным параметрам
</p><p>
<b>$1</b>, <b>$2</b>,... <b>$n</b>. Опции имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>-a</b>
</p><p>
Автоматически помечать изменяемые или создаваемые переменные как экспортируемые 
</p><p>
в среду для последующих команд.
</p><p>
</p></dd><dt><b>-b</b></dt><dd>
<p>
Сообщать о состоянии прерванных фоновых заданий немедленно, а не перед выдачей
</p><p>
следующего первичного приглашения. Эта опция действует только если включено управление
</p><p>
заданиями.
</p><p>
</p></dd><dt><b>-e</b></dt><dd>
<p>
Немедленно завершать работу, если <i>простая команда</i> 
</p><p>
(см. раздел "<b>СИНТАКСИС КОМАНД</b>" ранее)  
</p><p>
завершает работу с ненулевым статусом выхода. Работа командного интерпретатора не
</p><p>
завершается, если закончившаяся неудачно команда является частью 
</p><p>
цикла <b>until</b> или <b>while</b>,
</p><p>
частью оператора <b>if</b>, частью списка <b>&amp;&amp;</b> или <b>||</b>, или 
</p><p>
если к статусу выхода команды применяется отрицание с помощью оператора <b>!</b>.
</p><p>
</p></dd><dt><b>-f</b></dt><dd>
<p>
Отключить подстановку имен файлов.
</p><p>
</p></dd><dt><b>-h</b></dt><dd>
<p>
Запоминать местонахождение команд, найденное при выполнении. Эта опция включена по
</p><p>
умолчанию.
</p><p>
</p></dd><dt><b>-k</b></dt><dd>
<p>
Помещать в среду все аргументы в виде операторов присваивания, а не только
</p><p>
предшествующие имени команды.
</p><p>
</p></dd><dt><b>-m</b></dt><dd>
<p>
Режим мониторинга. Управление заданиями включено. Эта опция стандартно устанавливается
</p><p>
для интерактивных командных интерпретаторов в системах, где управление заданиями
</p><p>
поддерживается (см. раздел 
</p><p>
"<b>УПРАВЛЕНИЕ ЗАДАНИЯМИ</b>" ранее). Фоновые процессы
</p><p>
работают в отдельной группе процессов, и строка, содержащая их статус выхода, выдается
</p><p>
при завершении их работы.
</p><p>
</p></dd><dt><b>-n</b></dt><dd>
<p>
Читать команды, но не выполнять их. Эту опцию можно использовать для проверки
</p><p>
наличия синтаксических ошибок в сценариях командного интерпретатора. Интерактивные 
</p><p>
командные интерпретаторы ее игнорируют.
</p><p>
</p></dd><dt><b>-o имя_опции</b></dt><dd>
<p>
<b>Имя_опции</b> может иметь одно из следующих значений:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>allexport</b>
</p><p>
То же, что и опция <b>-a</b>
</p><p>
</p></dd><dt><b>braceexpand</b></dt><dd>
<p>
То же, что и опция <b>-B</b>
</p><p>
</p></dd><dt><b>emacs</b></dt><dd>
<p>
Использовать интерфейс редактирования командной строки в стиле редактора <b>emacs</b>.
</p><p>
Эта опция установлена по умолчанию в интерактивных командных интерпретаторах, если
</p><p>
только они не запущены с опцией <b>--noediting</b>
</p><p>
</p></dd><dt><b>errexit</b></dt><dd>
<p>
То же, что и опция <b>-e</b>
</p><p>
</p></dd><dt><b>hashall</b> </dt><dd>
<p>
То же, что и опция <b>-h</b>
</p><p>
</p></dd><dt><b>histexpand</b></dt><dd>
<p>
То же, что и опция <b>-H</b>
</p><p>
</p></dd><dt><b>history</b></dt><dd>
<p>
Включить поддержку истории выполнения команд, как описано ранее 
</p><p>
в разделе "<b>ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</b>". 
</p><p>
Эта опция установлена по умолчанию для интерактивных командных интерпретаторов.
</p><p>
</p></dd><dt><b>ignoreeof</b></dt><dd>
<p>
Результат такой же, как и после выполнения команды <b>IGNOREEOF=10</b> (см. раздел
</p><p>
"<b>Переменные командного интерпретатора</b>" ранее)
</p><p>
</p></dd><dt><b>keyword</b></dt><dd>
<p>
То же, что и опция <b>-k</b>
</p><p>
</p></dd><dt><b>monitor</b></dt><dd>
<p>
То же, что и опция <b>-m</b>
</p><p>
</p></dd><dt><b>noclobber</b></dt><dd>
<p>
То же, что и опция <b>-C</b>
</p><p>
</p></dd><dt><b>noexec</b></dt><dd>
<p>
То же, что и опция <b>-n</b>
</p><p>
</p></dd><dt><b>noglob</b></dt><dd>
<p>
То же, что и опция <b>-f</b>
</p><p>
</p></dd><dt><b>notify</b></dt><dd>
<p>
То же, что и опция <b>-b</b>
</p><p>
</p></dd><dt><b>nounset</b></dt><dd>
<p>
То же, что и опция <b>-u</b>
</p><p>
</p></dd><dt><b>onecmd</b></dt><dd>
<p>
То же, что и опция <b>-t</b>
</p><p>
</p></dd><dt><b>physical</b></dt><dd>
<p>
То же, что и опция <b>-P</b>
</p><p>
</p></dd><dt><b>posix</b></dt><dd>
<p>
Изменяет поведение <b>bash</b> на соответствующее стандарту
</p><p>
POSIX  1003.2, там, где оно отличается
</p><p>
</p></dd><dt><b>privileged</b></dt><dd>
<p>
То же, что и опция <b>-p</b>
</p><p>
</p></dd><dt><b>verbose</b></dt><dd>
<p>
То же, что и опция <b>-v</b>
</p><p>
</p></dd><dt><b>vi</b></dt><dd>
<p>
Использовать интерфейс редактирования командной строки в стиле редактора <b>vi</b>.
</p><p>
</p></dd><dt><b>xtrace</b></dt><dd>
<p>
То же, что и опция <b>-x</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
Если указана опция <b>-o</b> без <b>имени_опции</b>, выдаются значения текущих установленных опций.
</p><p>
Если указана опция <b>+o</b> без <b>имени_опции</b>, в стандартный выходной поток выдается набор
</p><p>
команд <b>set</b>, необходимый для воссоздания текущего набора опций.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>-p</b></dt><dd>
<p>
Включить привилегированный режим. В этом режиме файлы <b>$ENV</b> и <b>$BASH_ENV</b> не
</p><p>
обрабатываются, функции командного интерпертатора не наследуются из среды, а переменная
</p><p>
среды <b>SHELLOPTS</b> игнорируется. Если командный интерпретатор запущен с эффективным
</p><p>
идентификатором пользователя (группы), не совпадающим с реальным, а опция <b>-p</b> не
</p><p>
задана, выполняются перечилсенные действия и эффективный идентификатор
</p><p>
устанавливается равным реальному. Если опция <b>-p</b> задана при запуске, эффективный
</p><p>
идентификатор не сбрасывается. Отключение данной опции приводит к установке эффективных идентификаторов пользователя и группы равными реальным.
</p><p>
</p></dd><dt><b>-t</b></dt><dd>
<p>
Завершить после чтения и выполнения одной команды.
</p><p>
</p></dd><dt><b>-u</b></dt><dd>
<p>
При подстановке значений параметров рассматривать не установленную переменную как
</p><p>
ошибку. При попытке подстановки значения не существующей переменной командный
</p><p>
интерпретатор выдает сообщение об ошибке и, если он - не интерактивный, завершает
</p><p>
работу с ненулевым статусом выхода.
</p><p>
</p></dd><dt><b>-v</b></dt><dd>
<p>
Выдавать строки команд по мере чтения.
</p><p>
</p></dd><dt><b>-x</b></dt><dd>
<p>
После подстановок в каждой простой команде выдавать значение переменной <b>PS4</b>, а затем -
</p><p>
команду с результатами подстановок в аргументах.
</p><p>
</p></dd><dt><b>-B</b></dt><dd>
<p>
Выполнять подстановку квадратных скобок в командном интерпретаторе (см. раздел
</p><p>
"<b>Подстановка выражений в скобках</b>" ранее).
</p><p>
Эта опция установлена по умолчанию.
</p><p>
</p></dd><dt><b>-C</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> не переписывает существующий файл при перенаправлениях
</p><p>
с помощью операторов <b>&gt;</b>, <b>&gt;&amp;</b> и <b>&lt;&gt;</b>. Это поведение можно 
</p><p>
переопределить при создании выходных файлов, применяя оператор перенаправления 
</p><p>
<b>|&gt;</b> вместо <b>&gt;</b>.
</p><p>
</p></dd><dt><b>-H</b> </dt><dd>
<p>
Включить подстановку из списка истории с помощью метасимвола <b>!</b>. Эта опция
</p><p>
по умолчанию установлена в интерактивных командных интерпретаторах.
</p><p>
</p></dd><dt><b>-P</b></dt><dd>
<p>
Если эта опция установлена, командный интерпретатор не следует по символьным
</p><p>
связям при выполнении команд типа <b>cd</b>, изменяющих текущий рабочий каталог. Вместо этого,
</p><p>
он использует физическую структуру каталогов. По умолчанию, <b>bash</b> следует по
</p><p>
логической цепочке каталогов при выполнении команд, изменяющих текущий каталог.
</p><p>
</p></dd><dt><b>--</b></dt><dd>
<p>
Если после этой опции нет аргументов, сбрасываются значения позиционных параметров.
</p><p>
В противном случае, позиционные параметры устанавливаются в соответствии с 
</p><p>
аргументами, даже если некоторые из них начинаются с дефиса (<b>-</b>).
</p><p>
</p></dd><dt><b>-</b></dt><dd>
<p>
Сигнализирует об окончании опций, так что все оставшиеся аргументы присваиваются
</p><p>
позиционным параметрам. Опции <b>-x</b> и <b>-v</b> при этом отключаются. Если больше 
</p><p>
аргументов нет, позиционные параметры остаются без изменений.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Опции по умолчанию отключены, если явно не сказано иначе. При указании <b>+</b> вместо <b>-</b> 
</p><p>
перед буквой опции, опция отключается. Опции также можно задавать как аргументы при
</p><p>
вызове командного интерпретатора. Текущий набор опций представлен в виде значения
</p><p>
параметра <b>$-</b>. Статус выхода - 0, если только не указана недопустимая опция.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>shift [n]</b></dt><dd>
<p>
Позиционные параметры <b>n+1</b> ... переименовываются в <b>$1</b> .... Параметры от <b>$#-n+1</b> до
</p><p>
<b>$#</b> сбрасываются. <b>n</b> должно быть неотрицательным целым числом, не превышающим <b>$#</b>.
</p><p>
Если <b>n</b> равно 0, параметры не изменяются. Если <b>n</b> не указано, предполагается 
</p><p>
значение 1. Если <b>n</b> больше <b>$#</b>, поизиционные параметры не изменяются. Статус выхода -
</p><p>
больше нуля, если <b>n</b> больше <b>$#</b> или отрицательное и 0 в противном случае.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>shopt [-pqsu] [-o] [имя_опции ...]</b></dt><dd>
<p>
Переключает значения переменных, управляющих не обязательным поведением командного
</p><p>
интерпретатора. Если опции не указаны или задана опция <b>-p</b>, выдается список всех
</p><p>
возможных опций, с указанием, установлена опция или нет. Опция <b>-p</b> вызывает 
</p><p>
выдачу результатов в формате, позволяющем использовать их в качестве входных команд.  
</p><p>
Остальные опции имеют следующие значения:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>-s</b>
</p><p>
Включает (устанавливает) все указанные опции.
</p><p>
</p></dd><dt><b>-u</b></dt><dd>
<p>
Отключает (сбрасывает) все указанные опции.
</p><p>
</p></dd><dt><b>-q</b></dt><dd>
<p>
Подавляет выдачу стандартной информации (немногословный режим); статус выхода
</p><p>
показывает, установлена опция или нет. Если после <b>-q</b> указано несколько <b>имен_опций</b>,
</p><p>
статус выхода - 0, если все указанные опции включены и не 0 в противном случае.
</p><p>
</p></dd><dt><b>-o</b></dt><dd>
<p>
Ограничивает значения <b>имен_опций</b> только поддерживаемыми в 
</p><p>
опции <b>-o</b> встроенной команды <b>set</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если опция <b>-s</b> или <b>-u</b> использована без аргументов, выдается информация только об
</p><p>
установленных или неустановленных опциях, соответственно. Если не указано иначе, опции
</p><p>
команды <b>shopt</b> по умолчанию отключены (сброшены).
</p><p>
</p><p>
</p><p>
</p><p>

Статус выхода при выдаче опций - 0, если все указанные опции включены и не 0 в 
</p><p>
противном случае. При установке или сбросе опций статус выхода - 0, если только не
</p><p>
указана недопустимая опция командного интерпретатора.
</p><p>
</p><p>
</p><p>
</p><p>

Вот список допустимых опций команды <b>shopt</b>:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>cdable_vars</b></dt><dd>
<p>
Если эта опция установлена и переданный встроенной команде <b>cd</b> 
</p><p>
аргумент не является именем каталога, то предполагается, что это - имя переменной, 
</p><p>
значение которой - каталог для перехода.
</p><p>
</p></dd><dt><b>cdspell</b> </dt><dd>
<p>
Если эта опция установлена, небольшие ошибки в написании имен каталогов для
</p><p>
команды <b>cd</b> будут исправляться. Речь идет о переставленных местами символах,
</p><p>
пропущенном символе и одном лишнем символе. Если при исправлении найден подходящий
</p><p>
вариант, выдается исправленное имя каталога и команда выполняется. Эта опция
</p><p>
используется только интерактивными командными интерпретаторами.
</p><p>
</p></dd><dt><b>checkhash</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> проверяет, что найденная в хэше команда
</p><p>
существует, прежде чем пытаться ее выполнить. Если находящаяся в хэше команда больше не
</p><p>
существует, выполняется обычный поиск по каталогам.
</p><p>
</p></dd><dt><b>checkwinsize</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> проверяет размер окна после выполнения каждой
</p><p>
команды и, при необходимости, обновляет значения переменных <b>LINES</b> и <b>COLUMNS</b>.
</p><p>
</p></dd><dt><b>cmdhist</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> пытается сохранить все строки многострочной
</p><p>
команды в одной записи списка истории. Это позволяет легко редактировать многострочные
</p><p>
команды.
</p><p>
</p></dd><dt><b>dotglob</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> включает в результаты подстановки имен файлов
</p><p>
имена, начинающиеся с точки (<b>.</b>).
</p><p>
</p></dd><dt><b>execfail</b></dt><dd>
<p>
Если эта опция установлена, не интерактивный командный интерпретатор не будет 
</p><p>
завершать работу, если не сможет выполнить файл, указанный в качестве аргумента для
</p><p>
встроенной команды <b>exec</b>. 
</p><p>
Интерактивный командный интерпретатор не завершает работу, 
</p><p>
если команда <b>exec</b> не срабатывает.
</p><p>
</p></dd><dt><b>expand_aliases</b></dt><dd>
<p>
Если эта опция установлена, псевдонимы заменяются так, как было описано ранее в
</p><p>
разделе "<b>ПСЕВДОНИМЫ</b>". Эта опция включена по умолчанию 
</p><p>
в интерактивных командных интерпретаторах.
</p><p>
</p></dd><dt><b>extglob</b></dt><dd>
<p>
Если эта опция установлена, поддерживаются расширенные возможности сопоставления с образцом, описанные ранее в разделе 
</p><p>
"<b>Подстановка имен файлов</b>".
</p><p>
</p></dd><dt><b>histappend</b></dt><dd>
<p>
Если эта опция установлена, список истории добавляется в файл, имя которого является
</p><p>
значением пременной <b>HISTFILE</b>, при завершении работы командного интерпретатора, а не 
</p><p>
переписывает файл.
</p><p>
</p></dd><dt><b>histreedit</b></dt><dd>
<p>
Если эта опция установлена и используется библиотека <b>readline</b>, пользователь получает
</p><p>
возможность повторно редактировать команду при невозможности подстановки из списка 
</p><p>
истории.
</p><p>
</p></dd><dt><b>histverify</b></dt><dd>
<p>
Если эта опция установлена и используется библиотека <b>readline</b>, результаты подстановки
</p><p>
из списка истории не передаются анализатору командного интерпретатора немедленно.
</p><p>
Вместо этого, полученная в результате строка загружается в буфер редактирования
</p><p>
<b>readline</b> для дальнейших изменений.
</p><p>
</p></dd><dt><b>hostcomplete</b></dt><dd>
<p>
Если эта опция установлена и используется библиотека <b>readline</b>, <b>bash</b> будет пытаться
</p><p>
выполнить подстановку имен хостов после завершения слова, содержащего символ <b>@</b>, (см.
</p><p>
подраздел "<b>Завершение</b>" в разделе 
</p><p>
"<b>БИБЛИОТЕКА READLINE</b>" ранее). 
</p><p>
Эта опция включена по умолчанию.
</p><p>
</p></dd><dt><b>huponexit</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> будет посылать сигнал <b>SIGHUP</b> всем заданиям
</p><p>
при завершении работы интерактивного начального командного интерпретатора.
</p><p>
</p></dd><dt><b>interactive_comments</b></dt><dd>
<p>
Если эта опция установлена, слово, начинающееся символом <b>#</b>, и все остальные символы в
</p><p>
этой строке игнорируются интерактивным команжным интерпретатором (см. раздел
</p><p>
"<b>КОММЕНТАРИИ</b>" ранее). Эта опция включена по умолчанию.
</p><p>
</p></dd><dt><b>lithist</b></dt><dd>
<p>
Если эта опция установлена, и установлена опция <b>cmdhist</b>, 
</p><p>
многострочные команды, по возможности, сохраняются в списке истории со встроенными 
</p><p>
символами новой строки вместо точек с запятыми.
</p><p>
</p></dd><dt><b>mailwarn</b></dt><dd>
<p>
Если эта опция установлена и файл, проверяемый командным интерпретатором <b>bash</b> как
</p><p>
почтовый ящик, читался с момента последней проверки, выдается сообщение
</p><p>
"<b>The mail in имя_файла has been read</b>".
</p><p>
</p></dd><dt><b>nocaseglob</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> при подстановке имен файлов выполняет сопоставление
</p><p>
с образцом без учета регистра символов (см. раздел 
</p><p>
"<b>Подстановка имен файлов</b>" ранее).
</p><p>
</p></dd><dt><b>nullglob</b></dt><dd>
<p>
Если эта опция установлена, <b>bash</b> подставляет пустую строку вместо шаблонов, которым
</p><p>
не соответствует ни один файл (см. раздел 
</p><p>
"<b>Подстановка имен файлов</b>" ранее), а не 
</p><p>
сам шаблон.
</p><p>
</p></dd><dt><b>promptvars</b></dt><dd>
<p>
Если эта опция установлена, в строках приглашения выполняется подстановка значений
</p><p>
переменных и параметров после стандартных подстановок, описанных в разделе
</p><p>
"<b>ПРИГЛАШЕНИЯ</b>" ранее. Эта опция установлена по умолчанию.
</p><p>
</p></dd><dt><b>restricted_shell</b></dt><dd>
<p>
Командный интерпретатор устанавливает эту опцию, если он запущен в ограниченном
</p><p>
режиме (см. раздел "
</p><p>
<b>ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</b>" ниже). Значение этой
</p><p>
опции изменять нельзя. Она не сбрасывается при выполнении файлов начального запуска,
</p><p>
что позволяет в этих файлах учесть, является ли командный интерпретатор ограниченным.
</p><p>
</p></dd><dt><b>shift_verbose</b></dt><dd>
<p>
Если эта опция установлена, встроенная команда <b>shift</b> выдает сообщение об
</p><p>
ошибке, когда параметр сдвига превышает количество позиционных параметров.
</p><p>
</p></dd><dt><b>sourcepath</b></dt><dd>
<p>
Если эта опция установлена, встроенная команда <b>source</b> 
</p><p>
(<b>.</b>) использует значение переменной <b>PATH</b> для поиска каталога, содержащего файл, 
</p><p>
переданный в качестве аргумента. Эта опция по умолчанию включена.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>suspend [-f]</b></dt><dd>
<p>
Приостанавливает работу текущего командного интерпретатора, пока он не получит
</p><p>
сигнал <b>SIGCONT</b>. Опция <b>-f</b> отключает предупреждения, если эта команда выполняется в
</p><p>
начальном командном интерпретаторе - безусловно приостановить работу. Статус выхода -
</p><p>
0, если только командный интерпретатор не является начальным, а опция <b>-f</b> - не указана,
</p><p>
или если управление заданиями отключено.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>test выражение</b></dt><dd><b>
</b><p><b>
[ выражение ]</b>
</p><p>
Возвращает статус 0 или 1, в зависимости от результатов проверки условного выражения.
</p><p>
Каждый оператор или операнд должен быть отдельным аргументом. Выражения состоят из
</p><p>
элементов, описанных ранее в разделе "<b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b>".
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Выражения можно комбинировать с помощью следующих операторов, перечисленных по
</p><p>
убыванию приоритета.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>! выражение</b></dt><dd>
<p>
Истинно, если <b>выражение</b> ложно.
</p><p>
</p></dd><dt><b>( выражение )</b></dt><dd>
<p>
Возвращает значение <b>выражения</b>. Можно использовать для переопределения обычного
</p><p>
приоритета выполнения операторов.
</p><p>
</p></dd><dt><b>выражение1 -a выражение2</b></dt><dd>
<p>
Истинно, если истинны оба <b>выражения</b>.
</p><p>
</p></dd><dt><b>выражение1 -o выражение2</b></dt><dd>
<p>
Истинно, если истинно <b>выражение1</b> или <b>выражение2</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Команды <b>test</b> и <b>[</b> проверяют условные выражения с помощью набора правил, основанного
</p><p>
на количестве аргументов.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>0 аргументов</b></dt><dd>
<p>
Выражение ложно.
</p><p>
</p></dd><dt><b>1 аргумент</b></dt><dd>
<p>
Выражение истинно только если <b>аргумент</b> - не пустой.
</p><p>
</p></dd><dt><b>2 аргумента</b></dt><dd>
<p>
Если первый <b>аргумент</b> - <b>!</b>, выражение истинно только если второй <b>аргумент</b> -
</p><p>
пустой. Если первый аргумент - один из <i>унарных условных операторов</i>, перечисленных ранее 
</p><p>
в разделе "<b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b>", выражение истинно, 
</p><p>
если унарный оператор возвращает истину. Если первый <b>аргумент</b> не является 
</p><p>
допустимым унарным условным оператором, выражение ложно.
</p><p>
</p></dd><dt><b>3 аргумента</b></dt><dd>
<p>
Если второй <b>аргумент</b> - один из бинарных условных операторов, перечисленных 
</p><p>
ранее в разделе "<b>УСЛОВНЫЕ ВЫРАЖЕНИЯ</b>", 
</p><p>
результатом проверки будет значение бинарного
</p><p>
условного выражения, использующего первый и третий <b>аргументы</b> в качестве операндов. Если
</p><p>
первый <b>аргумент</b> - <b>!</b>, результат - отрицание двухаргументной проверки второго и третьего
</p><p>
<b>аргументов</b>. Если первый <b>аргумент</b> - только <b>(</b>, а третий - только <b>)</b>,
</p><p>
результатом будет результат одноаргументной проверки второго <b>аргумента</b>. В противном случае,
</p><p>
выражение ложно. В этом контексте операторы <b>-a</b> и <b>-o</b> считаются бинарными.
</p><p>
</p></dd><dt><b>4 аргумента</b></dt><dd>
<p>
Если первый <b>аргумент</b> - <b>!</b>, результат - отрицание трехаргументной проверки оставшихся
</p><p>
<b>аргументов</b>. В противном случае, выражение разбирается и проверяется в соответствии
</p><p>
с приоритетами по перечисленным выше правилам.
</p><p>
</p></dd><dt><b>5 и более аргументов</b></dt><dd>
<p>
Выражение разбирается и проверяется в соответствии с приоритетами по перечисленным выше правилам.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>times</b></dt><dd>
<p>
Выдает накопленные пользовательское и системное время работы для командного
</p><p>
интерпретатора и запущенных из него процессов. Статус выхода - 0.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>trap [-lp] [аргумент] [сигнал ...]</b></dt><dd>
<p>
Команда <b>аргумент</b> читается и выполняется при получении командным интерпретатором
</p><p>
указанных <b>сигналов</b>. Если <b>аргумент</b> не указан или задан как <b>-</b>, для всех указанных
</p><p>
<b>сигналов</b> устанавливаются исходные обработчики (те, что были при запуске
</p><p>
командного интерпретатора). Если <b>аргумент</b> - пустая строка, все указанные сигналы
</p><p>
игнорируются командным интерпретатором и вызываемыми им командами. Если указана
</p><p>
опция <b>-p</b>, выдаются команды <b>trap</b>, связанные с каждым из перечисленных <b>сигналов</b>.
</p><p>
Если аргументов нет или указана только опция <b>-p</b>, команда <b>trap</b> выдает список 
</p><p>
команд (<i>обработчиков</i>), связанных с каждым из <b>сигналов</b>. 
</p><p>
<b>Сигнал</b> можно задавать как по имени,
</p><p>
определенному в файле <b>&lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;</b>, так и по номеру. Если в качестве <b>сигнала</b>
</p><p>
указана конструкция <b>EXIT (0)</b>, команда-<b>аргумент</b> выполняется при завершении работы
</p><p>
командного интерпретатора. Если в качестве <b>сигнала</b> указано <b>DEBUG</b>, 
</p><p>
команда-<b>аргумент</b> выполняется после каждой <i>простой команды</i> 
</p><p>
(см. раздел "<b>СИНТАКСИС КОМАНД</b>" ранее).
</p><p>
Опция <b>-l</b> приводит к выдаче списка имен сигналов и соответствующих им номеров.
</p><p>
Сигналы, игнорировавшиеся при входе в командный интерпретатор, нельзя перехватить или
</p><p>
переустановить. Перехваченные сигналы сбрасываются в исходные значения в порожденных
</p><p>
процессах при создании. Статус возврата - 1, если указан недопустимый <b>сигнал</b>; в
</p><p>
противном случае, <b>trap</b> возвращает 0.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>type [-atp] имя [имя ...]</b></dt><dd>
<p>
При вызове без опций показывает, как имена будут интерпретироваться
</p><p>
при использовании в качестве имени команды. Если указана опция <b>-t</b>, <b>type</b> выдает
</p><p>
одну из строк <b>alias</b>,  <b>keyword</b>,  <b>function</b>,  <b>builtin</b> или <b>file</b>,
</p><p>
если <b>имя</b>, соответственно,
</p><p>
представляет собой псевдоним, зарезервированное слово командного интерпретатора,
</p><p>
функцию, встроенную команду или файл на диске. Если <b>имя</b> не найдено, ничего не
</p><p>
выдается и возвращается статус выхода 1. Если указана опция <b>-p</b>, <b>type</b> вернет
</p><p>
либо имя файла на диске, который будет выполняться при указании имени в качестве
</p><p>
имени команды, либо ничего, если обращения к файлу не будет. Если команда хранится в
</p><p>
хэше, опция <b>-p</b> приводит к выдаче значения из хэша, а не обязательно первого файла,
</p><p>
выбираемого по перечисленным в <b>PATH</b> каталогам. Если использована опция <b>-a</b>, команда 
</p><p>
<b>type</b> выдает список всех каталогов, где есть выполняемый файл с соответствующим именем.  В список включаются также псевдонимы и функции, если только не указана опция <b>-p</b>. К 
</p><p>
хэшу команд не обращаются, если указана опция <b>-a</b>. Команда <b>type</b> возвращает 0,
</p><p>
если хоть один из аргументов найден, и 1 в противном случае.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>ulimit [-SHacdflmnpstuv [ограничение]]</b></dt><dd>
<p>
Обеспечивает управление ресурсами, доступными для командного интерпретатора и
</p><p>
запущенных им процессов в системах, поддерживающих такое управление. Значение
</p><p>
ограничения может быть числом единиц измерения ресурса или строкой <b>unlimited</b>.
</p><p>
Опции <b>-H</b> и <b>-S</b> указывают, что для данного ресурса устанавливается жесткое или мягкое
</p><p>
ограничение. <i>Жесткое ограничение</i> после установки превосходить нельзя; <i>мягкое
</i></p><p><i>
ограничение</i> можно превосходить вплоть до значения соответствующего жесткого
</p><p>
ограничения. Если опции <b>-H</b> и <b>-S</b> не указаны, устанавливаются и мягкое, и жесткое
</p><p>
ограничение. Если ограничение не указано, выдается текущее значение мягкого ограничения
</p><p>
на ресурс, если только не указана опция <b>-H</b>. Если указано несколько ресурсов, 
</p><p>
перед значением выдается название и единица измерения ресурса. Другие опции
</p><p>
интерпретируются следующим образом:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
<b>-a</b>
</p><p>
Выдается информация о всех текущих ограничениях
</p><p>
</p></dd><dt><b>-c</b></dt><dd>
<p>
Максимальный размер создаваемых файлов <b>core</b>
</p><p>
<b>-d</b>
</p><p>
Максимальный размер сегмента данных процесса
</p><p>
<b>-f</b>
</p><p>
Максимальный размер файлов, создаваемых командным интерпретатором
</p><p>
<b>-l</b>
</p><p>
Максимальный размер сегмента, который может быть привязан к памяти
</p><p>
<b>-m</b>
</p><p>
Максимальный размер резидентного набора
</p><p>
<b>-n</b>
</p><p>
Максимальное количество открытых <i>файловых дескрипторов</i> (большинство систем не
</p><p>
позволяет устанавливать это значение)
</p><p>
<b>-p</b>
</p><p>
Размер программного канала в 512-байтовых блоках (его устанавливать нельзя)
</p><p>
<b>-s</b>
</p><p>
Максимальный размер стека
</p><p>
<b>-t</b>
</p><p>
Максимальное количество процессорного времени в секундах
</p><p>
<b>-u</b>
</p><p>
Максимальное количество процессов для одного пользователя
</p><p>
<b>-v</b>
</p><p>
Максимальный объем виртуальной памяти, доступный командному интерпретатору
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Если ограничение указано, оно становится новым предельным значением для 
</p><p>
соответствующего ресурса (опция <b>-a</b> только выдает информацию). Если опции не
</p><p>
заданы, предполагается опция <b>-f</b>. Значения представляются в единицах 1024 байта, за
</p><p>
исключением опции <b>-t</b>, где значения - в секундах, <b>-p</b>, где значения - в 512-байтовых
</p><p>
блоках, и опций <b>-n</b> и <b>-u</b>, для которых значения не масштабируются. Статус выхода - 0,
</p><p>
если не указана недопустимая опция, в качестве ограничения не задано не числовое значение, отличное от <b>unlimited</b>, и при установке нового ограничения не произошла ошибка.
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt><b>umask [-p] [-S] [маска]</b></dt><dd>
<p>
Пользовательская маска создания файла устанавливается равной аргументу <b>маска</b>. Если
</p><p>
<b>маска</b> начинается с цифры, она интерпретируется как восьмеричное число; иначе - как
</p><p>
маска в символьном формате, аналогичном используемому в команде <b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=chmod&amp;category=1">chmod</a>(1)</b>. Если
</p><p>
<b>маска</b> не указана или задана опция <b>-S</b>, выдается текущее значение маски. Опция <b>-S</b>
</p><p>
вызывает выдачу маски в символьном формате; по умолчанию выдается восьмеричное
</p><p>
число. Если указана опция <b>-p</b>, а маска не задана, результат выдается в виде,
</p><p>
который можно использовать во входной команде. Статус выхода - 0, если маска была
</p><p>
успешно изменена или не указана, и 1 в противном случае.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>unalias [-a] [имя ...]</b></dt><dd>
<p>
Удаляет <b>имена</b> из списка определенных псевдонимов. Если указана опция <b>-a</b>, удаляются
</p><p>
все определения. Возвращается значение 0, за исключением случаев, когда переданное
</p><p>
имя не является псевдонимом.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>unset [-fv] [имя ...]</b></dt><dd>
<p>
Для каждого <b>имени</b> удаляет (сбрасывает) соответствующую переменную или функцию. 
</p><p>
Если опции не указаны или задана опция <b>-v</b>, удаляются только переменные. 
</p><p>
Переменные только для чтения удалять нельзя. Если указана опция <b>-f</b>,
</p><p>
удаляются только определения соответствующих функций. Удаляемая переменная
</p><p>
или функция удаляется из среды, передаваемой последующим командам. Если 
</p><p>
сбрасывается одна из переменных <b>RANDOM</b>, <b>SECONDS</b>, <b>LINENO</b>, 
</p><p>
<b>HISTCMD</b> или <b>DIRSTACK</b>,
</p><p>
эти переменные теряют специальные свойства, даже если они в дальнейшем
</p><p>
снова устанавливаются. Статус выхода - 0, за исключеним случаев, когда <b>имя</b> не
</p><p>
существует или доступно только для чтения.
</p><p>
</p><p>
</p><p>
</p></dd><dt><b>wait [n]</b></dt><dd>
<p>
Ждет завершения указанного процесса и возвращает статус его завершения. <b>n</b> может
</p><p>
быть идентификатором процесса или спецификацией задания; если указана спецификация
</p><p>
задания, ждет завершения всех процессов в конвейере соответствующего задания. Если
</p><p>
<b>n</b> не указано, ожидается завершение всех текущих активных порожденных процессов, и
</p><p>
возвращается статус ноль. Если <b>n</b> задает идентификатор несуществующего процесса или
</p><p>
задания, статус выхода - 127. В противном случае, статусом выхода является
</p><p>
статус завершения последнего процесса или задания, завершение которого ждали.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCT">&nbsp;</a>
<h2>ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</h2>

<p>

Если <b>bash</b> запущен по имени <b>rbash</b> или с опцией <b>-r</b> при вызове, 
</p><p>
командный интерпретатор становится ограниченным. <i>Ограниченный командный 
</i></p><p><i>
интерпретатор</i> используется для создания более управляемой стреды по сравнению с 
</p><p>
обычным интерпретатором. Он ведет себя аналогично <b>bash</b>, но следующие действия 
</p><p>
не разрешены или не выполняются:
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt>*</dt><dd>
изменение текущего каталога с помощью <b>cd</b>
<p>
</p></dd><dt>*</dt><dd>
установка или сброс значений переменных <b>SHELL</b>, <b>PATH</b>, <b>ENV</b> или 
<p>
<b>BASH_ENV</b>
</p><p>
</p></dd><dt>*</dt><dd>
указание <b>/</b> в именах команд
<p>
</p></dd><dt>*</dt><dd>
указание имени файла, содержащего <b>/</b>, в качестве аргумента для встроенной команды <b>.</b>
<p>
</p></dd><dt>*</dt><dd>
импортирование определений функций из среды командного интерпретатора при запуске
<p>
</p></dd><dt>*</dt><dd>
разбор значения переменной <b>SHELLOPTS</b> из среды командного интерпретатора при
<p>
запуске
</p><p>
</p></dd><dt>*</dt><dd>
перенаправление вывода с помощью операторов <b>&gt;</b>, <b>&gt;|</b>, <b>&lt;&gt;</b>, <b>&gt;&amp;</b>, <b>&amp;&gt;</b>
<p>
и <b>&gt;&gt;</b>
</p><p>
</p></dd><dt>*</dt><dd>
использование встроенной команды <b>exec</b> 
<p>
для замены командного интерпретатора другой командой
</p><p>
</p></dd><dt>*</dt><dd>
добавление или удаление встроенных команд с помощью опций <b>-f</b> и <b>-d</b>
<p>
встроенной команды <b>enable</b>
</p><p>
</p></dd><dt>*</dt><dd>
указание опции <b>-p</b> для встроенной команды <b>command</b>
<p>
</p></dd><dt>*</dt><dd>
отключение режима ограниченного командного интерпретатора с помощью опций 
<p>
<b>set +r</b> или <b>set +o  restricted</b>.
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Эти ограничения применяются после чтения файлов начального запуска.
</p><p>
</p><p>
</p><p>
</p><p>

При выполнении команды, которая оказалась сценарием командного интерпретатора
</p><p>
(см. раздел "<b>ВЫПОЛНЕНИЕ КОМАНД</b>" ранее), 
</p><p>
<b>rbash</b> отключает любые ограничения в 
</p><p>
командном интерпретаторе, порожденном для выполнения сценария.
</p><p>
</p><p>
</p><p>
<a name="lbCU">&nbsp;</a>
</p><h2>ССЫЛКИ</h2>

<dl compact="">
<dt></dt><dd>
<p>
Bash Features, Brian Fox and Chet Ramey
</p><p>
The Gnu Readline Library, Brian Fox and Chet Ramey
</p><p>
The Gnu History Library, Brian Fox and Chet Ramey
</p><p>
Utilities, IEEE Portable Operating System Interface (POSIX) Part  2:  Shell
</p><p>
и
</p><p>
<b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=sh&amp;category=1">sh</a>(1)</b>, 
</p><p>
<b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=ksh&amp;category=1">ksh</a>(1)</b>, 
</p><p>
<b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=csh&amp;category=1">csh</a>(1)</b>,
</p><p>
<b><a href="https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=vi&amp;category=1">vi</a>(1)</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCV">&nbsp;</a>
<h2>ФАЙЛЫ</h2>

<dl compact="">
<dt><b>/bin/bash</b></dt><dd>
<p>
Выполняемый файл <b>bash</b>
</p><p>
</p></dd><dt><b>/etc/profile</b></dt><dd>
<p>
Общесистемный файл инициализации, выполняется начальными командными интерпретаторами
</p><p>
</p></dd><dt><b>~/.bash_profile</b></dt><dd>
<p>
Личный файл инициализации, выполняется начальными командными интерпретаторами
</p><p>
</p></dd><dt><b>~/.bashrc</b></dt><dd>
<p>
Отдельный файл начального запуска для интерактивных командных интерпретаторов
</p><p>
</p></dd><dt><b>~/.bash_logout</b></dt><dd>
<p>
Отдельный файл очистки для начального командного интерпретатора, выполняемый при
</p><p>
завершении его работы
</p><p>
</p></dd><dt><b>~/.inputrc</b></dt><dd>
<p>
Отдельный файл инициализации библиотеки <b>readline</b>
</p><p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<a name="lbCW">&nbsp;</a>
<h2>АВТОРЫ</h2>

<p>

Брайан Фокс (Brian Fox), Free Software Foundation
</p><p>
&lt;<b><a href="mailto:bfox@gnu.ai.MIT.Edu">bfox@gnu.ai.MIT.Edu</a></b>&gt;
</p><p>
</p><p>
</p><p>
</p><p>

Чет Реми (Chet Ramey), Case Western Reserve University
</p><p>
&lt;<b><a href="mailto:chet@ins.CWRU.Edu">chet@ins.CWRU.Edu</a></b>&gt;
</p><p>
</p><p>
</p><p>
<a name="lbCX">&nbsp;</a>
</p><h2>ИНФОРМАЦИЯ ОБ ОШИБКАХ</h2>

<p>

Если вы обнаружили ошибку в <b>bash</b>, сообщите о ней. Но сначала убедитесь, что
</p><p>
это действительно ошибка, и что она проявляется в последней имеющейся у вас версии
</p><p>
<b>bash</b>.
</p><p>
</p><p>
</p><p>
</p><p>

После того, как определено, что ошибка действительно существует, используйте команду <b>bashbug</b> для посылки сообщения об ошибке. Если вы знаете, как ошибку исправить,пришлите и исправление! Предложения и "философские" сообщения об ошибках
</p><p>
можете отправлять по электронной почте по адресу 
</p><p>
&lt;<b><a href="mailto:bug-bash@gnu.org">bug-bash@gnu.org</a></b>&gt; или в дискуссионную
</p><p>
группу Usenet <b>gnu.bash.bug</b>.
</p><p>
</p><p>
</p><p>
</p><p>

ВСЕ сообщения об ошибках должны включать:
</p><p>
</p><p>
</p><p>
</p><dl compact="">
<dt>*</dt><dd>
номер версии <b>bash</b>
<p>
</p></dd><dt>*</dt><dd>
информацию об аппаратной платформе и операционной системе
<p>
</p></dd><dt>*</dt><dd>
компилятор, использовавшийся для компиляции
<p>
</p></dd><dt>*</dt><dd>
описание ошибочного поведения
<p>
</p></dd><dt>*</dt><dd>
короткий сценарий или "рецепт", позволяющий воспроизвести проблему
<p>
</p><p>
</p><p>
</p><p>
</p><p>
</p></dd></dl>
<p>

Команда <b>bashbug</b> вставляет первые три компонента в предлагаемый шаблон сообщения 
</p><p>
об ошибке автоматически.
</p><p>
</p><p>
</p><p>
</p><p>

</p><p>
Комментарии и сообщения об ошибках на этой странице справочного руководства
</p><p>
отправляйте по адресу &lt;<b><a href="mailto:chet@ins.CWRU.Edu">chet@ins.CWRU.Edu</a></b>&gt;.
</p><p>
</p><p>
</p><p>
</p><p>

</p><p>
Комментарии и сообщения об ошибках в переводе этой страницы справочного руководства
</p><p>
на русский язык отправляйте по адресу &lt;<b><a href="mailto:valera@openxs.kiev.ua">valera@openxs.kiev.ua</a></b>&gt;.
</p><p>
</p><p>
</p><p>
<a name="lbCY">&nbsp;</a>
</p><h2>ОШИБКИ</h2>

<p>

Слишком большой и слишком медленный.
</p><p>
</p><p>
</p><p>
</p><p>

Есть ряд небольших отличий между <b>bash</b> и традационными версиями <b>sh</b>, в основном,
</p><p>
связанные с поддержкой спецификации POSIX.
</p><p>
</p><p>
</p><p>
</p><p>

Псевдонимы иногда могут сбивать с толку.
</p><p>
</p><p>
</p><p>
</p><p>

Встроенные команды и функции интерпретатора нельзя остановить/перезапустить.
</p><p>
</p><p>
</p><p>
</p><p>

Составные команды и последовательности команд вида <b>'a ; b ; c'</b> обрабатываются
</p><p>
некорректно при попытке приостановки процесса. Когда процесс останавливается,
</p><p>
командный интерпретатор немедленно выполняет следующую команду в последовательности.
</p><p>
Для выполнения последовательности команд в порожденном командном интерпретаторе, что
</p><p>
позволяет останавливать их, как единое целое, достаточно взять ее в скобки.
</p><p>
</p><p>
</p><p>
</p><p>

Команды в операторе подстановки результатов выполнения команды <b>$(...)</b> не
</p><p>
разбираются, пока не будет выполнена попытка подстановки. Это откладывает
</p><p>
выдачу сообщения об ошибке на определенное время при вводе команды.
</p><p>
</p><p>
</p><p>
</p><p>

Нельзя (пока) экспортировать массивы.
</p><p>
</p><p>
</p><p>
<a name="lbCZ">&nbsp;</a>
</p><h2>ПРИМЕЧАНИЯ</h2>

<p>

Исходный код <b>bash</b> доступен в пакете <b>SUNWbashS</b>.
</p><p>
</p><p>

</p><hr>
<a name="index">&nbsp;</a><h2>Index</h2>
<dl>
<dt><a href="#lbAB">НАЗВАНИЕ</a></dt><dd>
</dd><dt><a href="#lbAC">СИНТАКСИС</a></dt><dd>
</dd><dt><a href="#lbAD">АВТОРСКИЕ ПРАВА</a></dt><dd>
</dd><dt><a href="#lbAE">ОПИСАНИЕ</a></dt><dd>
</dd><dt><a href="#lbAF">ОПЦИИ</a></dt><dd>
</dd><dt><a href="#lbAG">АРГУМЕНТЫ</a></dt><dd>
</dd><dt><a href="#lbAH">ВЫЗОВ</a></dt><dd>
</dd><dt><a href="#lbAI">ОПРЕДЕЛЕНИЯ</a></dt><dd>
</dd><dt><a href="#lbAJ">ЗАРЕЗЕРВИРОВАННЫЕ СЛОВА</a></dt><dd>
</dd><dt><a href="#lbAK">СИНТАКСИС КОМАНД</a></dt><dd>
<dl>
<dt><a href="#lbAL">Простые команды</a></dt><dd>
</dd><dt><a href="#lbAM">Конвейеры</a></dt><dd>
</dd><dt><a href="#lbAN">Списки</a></dt><dd>
</dd><dt><a href="#lbAO">Составные команды</a></dt><dd>
</dd></dl>
</dd><dt><a href="#lbAP">КОММЕНТАРИИ</a></dt><dd>
</dd><dt><a href="#lbAQ">МАСКИРОВКА</a></dt><dd>
</dd><dt><a href="#lbAR">ПАРАМЕТРЫ</a></dt><dd>
<dl>
<dt><a href="#lbAS">Позиционные параметры</a></dt><dd>
</dd><dt><a href="#lbAT">Специальные параметры</a></dt><dd>
</dd><dt><a href="#lbAU">Переменные командного интерпретатора</a></dt><dd>
</dd><dt><a href="#lbAV">Массивы</a></dt><dd>
</dd></dl>
</dd><dt><a href="#lbAW">ЗАМЕНЫ</a></dt><dd>
<dl>
<dt><a href="#lbAX">Замена выражений в фигурных скобках</a></dt><dd>
</dd><dt><a href="#lbAY">Замена тильды</a></dt><dd>
</dd><dt><a href="#lbAZ">Подстановка значений параметров</a></dt><dd>
</dd><dt><a href="#lbBA">Подстановка результатов выполнения команд</a></dt><dd>
</dd><dt><a href="#lbBB">Подстановка процессов</a></dt><dd>
</dd><dt><a href="#lbBC">Разбиение на слова</a></dt><dd>
</dd><dt><a href="#lbBD">Подстановка имен файлов</a></dt><dd>
</dd><dt><a href="#lbBE">Удаление кавычек</a></dt><dd>
</dd></dl>
</dd><dt><a href="#lbBF">ПЕРЕНАПРАВЛЕНИЕ</a></dt><dd>
<dl>
<dt><a href="#lbBG">Перенаправление входного потока</a></dt><dd>
</dd><dt><a href="#lbBH">Перенаправление выходного потока</a></dt><dd>
</dd><dt><a href="#lbBI">Добавление перенаправленного вывода</a></dt><dd>
</dd><dt><a href="#lbBJ">Перенаправление стандартного выходного потока и стандартного потока ошибок</a></dt><dd>
</dd><dt><a href="#lbBK">Конструкция документ здесь</a></dt><dd>
</dd><dt><a href="#lbBL">Дублирование дескрипторов файлов</a></dt><dd>
</dd><dt><a href="#lbBM">Открытие дескрипторов файлов для чтения и записи</a></dt><dd>
</dd></dl>
</dd><dt><a href="#lbBN">ПСЕВДОНИМЫ</a></dt><dd>
</dd><dt><a href="#lbBO">ФУНКЦИИ</a></dt><dd>
</dd><dt><a href="#lbBP">ВЫЧИСЛЕНИЕ АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ</a></dt><dd>
</dd><dt><a href="#lbBQ">УСЛОВНЫЕ ВЫРАЖЕНИЯ</a></dt><dd>
</dd><dt><a href="#lbBR">ОБРАБОТКА ПРОСТОЙ КОМАНДЫ</a></dt><dd>
</dd><dt><a href="#lbBS">ВЫПОЛНЕНИЕ КОМАНДЫ</a></dt><dd>
</dd><dt><a href="#lbBT">СРЕДА ВЫПОЛНЕНИЯ КОМАНД</a></dt><dd>
</dd><dt><a href="#lbBU">СРЕДА</a></dt><dd>
</dd><dt><a href="#lbBV">СТАТУС ВЫХОДА</a></dt><dd>
</dd><dt><a href="#lbBW">СИГНАЛЫ</a></dt><dd>
</dd><dt><a href="#lbBX">УПРАВЛЕНИЕ ЗАДАНИЯМИ</a></dt><dd>
</dd><dt><a href="#lbBY">ПРИГЛАШЕНИЯ</a></dt><dd>
</dd><dt><a href="#lbBZ">БИБЛИОТЕКА READLINE</a></dt><dd>
<dl>
<dt><a href="#lbCA">Соглашения по записи команд readline</a></dt><dd>
</dd><dt><a href="#lbCB">Инициализация библиотеки readline</a></dt><dd>
</dd><dt><a href="#lbCC">Горячие клавиши readline</a></dt><dd>
</dd><dt><a href="#lbCD">Переменные readline</a></dt><dd>
</dd><dt><a href="#lbCE">Управляющие конструкции readline</a></dt><dd>
</dd><dt><a href="#lbCF">Поиск</a></dt><dd>
</dd><dt><a href="#lbCG">Команды для перемещения</a></dt><dd>
</dd><dt><a href="#lbCH">Команды для работы со списком истории</a></dt><dd>
</dd><dt><a href="#lbCI">Удаление и вставка</a></dt><dd>
</dd><dt><a href="#lbCJ">Числовые аргументы</a></dt><dd>
</dd><dt><a href="#lbCK">Завершение</a></dt><dd>
</dd><dt><a href="#lbCL">Клавиатурные макросы</a></dt><dd>
</dd><dt><a href="#lbCM">Прочие команды</a></dt><dd>
</dd></dl>
</dd><dt><a href="#lbCN">ИСТОРИЯ ВЫПОЛНЕНИЯ КОМАНД</a></dt><dd>
</dd><dt><a href="#lbCO">ПОДСТАНОВКА КОМАНД ИЗ СПИСКА ИСТОРИИ</a></dt><dd>
<dl>
<dt><a href="#lbCP">Пометки событий</a></dt><dd>
</dd><dt><a href="#lbCQ">Пометки слов</a></dt><dd>
</dd><dt><a href="#lbCR">Модификаторы</a></dt><dd>
</dd></dl>
</dd><dt><a href="#lbCS">ВСТРОЕННЫЕ КОМАНДЫ ИНТЕРПРЕТАТОРА</a></dt><dd>
</dd><dt><a href="#lbCT">ОГРАНИЧЕННЫЙ КОМАНДНЫЙ ИНТЕРПРЕТАТОР</a></dt><dd>
</dd><dt><a href="#lbCU">ССЫЛКИ</a></dt><dd>
</dd><dt><a href="#lbCV">ФАЙЛЫ</a></dt><dd>
</dd><dt><a href="#lbCW">АВТОРЫ</a></dt><dd>
</dd><dt><a href="#lbCX">ИНФОРМАЦИЯ ОБ ОШИБКАХ</a></dt><dd>
</dd><dt><a href="#lbCY">ОШИБКИ</a></dt><dd>
</dd><dt><a href="#lbCZ">ПРИМЕЧАНИЯ</a></dt><dd>
</dd></dl>
<hr>
<br>
<form method="get" action="/search.shtml">
<font size="-1">
<font color="#555555">Поиск по тексту MAN-ов:&nbsp;</font><input size="30" name="words" value="bash" type="text">
<input name="restrict" value="/man" type="hidden">
<input value="Найти" type="submit">
</font>
<input name="method" value="and" type="hidden">
<input name="format" value="builtin-long" type="hidden">
<input name="sort" value="score" type="hidden">
</form>
<br>
<!--htdig_noindex-->
<noindex>
<br>


</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br><br>
<div style="background-color: #E9EAD6; width:100%; height: 61px;">
<div style="margin-right: 20px; float:left; line-height: 61px; vertical-align: middle; margin-left: 10px; font-size: 120%;">
Спонсоры:
</div>
<div style="float:left; height: 60px;  line-height: 60px; margin-left: 20px;">
<a style="align: middle;" target="_blank" href="https://inferno.name/"><img src="/img/inferno2.png" alt="Inferno Solutions" height="57" width="200"></a>
</div>
<div style="float:right; height: 60px;  line-height: 60px;  margin-left: 15px;">
<a style="align: middle;" target="_blank" href="http://hoster.ru/?utm_source=site&amp;utm_medium=banner&amp;utm_campaign=opennet"><img src="/img/dh143x60t.png" alt="Hosting by Hoster.ru" height="60" width="143"></a>
</div>
<div style="float:right;  height: 60px;  line-height: 60px; vertical-align: middle;font-size: 120%;">
Хостинг:
</div>

</div>

<div style="clear: both;"></div>


<br>
<table class="ttxt" style="border-top: 3px solid #C9CaB6;">
<tbody><tr><td width="35%">
<a href="/cgi-bin/opennet/bookmark.cgi">Закладки на сайте</a><br>
<a href="/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить за страницей</a>
</td>
<td align="RIGHT" width="65%">
Created&nbsp;1996-2021&nbsp;by <b><a href="/contact.shtml" title="email maxim.chirkov@gmail.com">Maxim&nbsp;Chirkov</a></b><br>
<a href="https://www.opennet.ru/add.shtml">Добавить</a>, <a href="https://www.opennet.ru/donate.shtml" style="color: #C00000;">Поддержать</a>, <a href="https://www.opennet.ru/banners2.shtml">Вебмастеру</a>
</td>
</tr>
</tbody></table>
<br><br>


<!--/htdig_noindex-->
<!-- end of footer -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>




</body>
<!---------------------------------------------  0  ---------------------------------------------->
