
<!--+++++++++++++++++++++++++++++++++++++++++++  0  +++++++++++++++++++++++++++++++++++++++++++--->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Проект OpenNet: MAN tcsh (1) Команды и прикладные программы пользовательского уровня (FreeBSD и Linux)</title><meta name="KeyWords" content="man, manual, MAN, системное руководство, linux, FreeBSD, OpenBSD, Solaris, ядро, программы, системный вызов, tcsh"><meta name="viewport" content="width=device-width, initial-scale=1"></head>


<body link="#0000FF" vlink="#000080" text="#000000" bgcolor="#E3E4D0" alink="#FF00FF">
<link rel="stylesheet" href="/opennet4.css" type="text/css">
<!--htdig_noindex-->
<form method="get" action="https://www.opennet.ru/search.shtml">
<aside>
<div style="width: 100%; text-align: right; font-size: 70%; background: #E9EAD6; margin-bottom:-10px;">
Профиль: <b><a href="/~" rel="nofollow" title="/~ - сводная страница участника"><u>Аноним</u></a></b> (<a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=login">вход</a> | <a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=user_register">регистрация</a>)</div>

<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody><tr>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" valign="BOTTOM" bgcolor="#E9EAD6" width="300">
<a href="https://www.opennet.ru/"><img src="/opennet2.gif" alt="The OpenNET Project" height="60" width="249" border="0"></a><br>
</td>
<td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left" bgcolor="#E9EAD6" align="CENTER" width="100">

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:10px;" bgcolor="#E9EAD6" align="CENTER" width="50%">
<table width="100%" border="0">
<tbody><tr>
<td width="22%">
 <a href="https://www.opennet.ru/opennews/" class="h"><b>НОВОСТИ</b></a> (<a href="https://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="18%%">
  <a href="https://www.opennet.ru/mp/" class="h"><b>КОНТЕНТ</b></a>
</td><td width="14%">
  <a href="http://wiki.opennet.ru" class="h"><b>WIKI</b></a>
</td><td width="14%">
   <a href="https://www.opennet.ru/man.shtml" class="h"><b>MAN'ы</b></a>
</td><td width="16%">
   <a href="https://www.opennet.ru/forum/" class="h"><b>ФОРУМ</b></a>
</td><td width="16%">
<a href="https://www.opennet.ru/search.shtml" class="h" onmouseover="document.getElementById('form12').style.display='block';">Поиск</a>&nbsp;(<a href="https://www.opennet.ru/keywords/" class="h">теги</a>)
<input id="form12" style="display: none;" size="10" name="words" value="" title="для поиска в google наберите &quot;g фраза&quot;" type="text">
</td></tr>
</tbody></table>

</td><td style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:5px;" bgcolor="#E9EAD6" align="right" width="20%">

<a href="https://www.opennet.ru/opennews/opennews_all_utf.rss"><img src="/img/rss.png" alt="RSS" title="RSS" height="16" width="16" border="0"></a>&nbsp;<a href="https://twitter.com/opennetru"><img src="/twitter.png" alt="twitter" title="Twitter" height="16" width="16" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="/img/vkontakte.gif" title="ВКонтакте" height="16" width="16" border="0"></a>&nbsp;<a href="https://zen.yandex.ru/opennet"><img src="/img/zen.gif" title="Yandex Zen" height="16" width="16" border="0"></a>&nbsp;<a href="https://www.facebook.com/OpenNet.News/"><img src="/img/facebook.gif" title="Facebook" height="16" width="16" border="0"></a>&nbsp;<a href="https://telegram.space/opennet_ru"><img src="/img/telegram2.png" title="Telegram" height="16" width="16" border="0"></a>
</td></tr></tbody></table>
</aside>

<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class="hdr_mobile">
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url('/back.gif') repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<a href="https://www.opennet.ru"><img src="/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" alt="The OpenNET Project / Index page"></a>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="/opennews/">новости</a>&nbsp;/<a href="/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">+++</a> | <a href="/forum/">форум</a> | <a href="http://wiki.opennet.ru">wiki</a> | <a href="/keywords/">теги</a>
| <a href="tg://resolve?domain=opennet_ru"><img src="/img/telegram2.png" title="Telegram" style="margin-bottom: -4px;" height="16" width="16" border="0"></a>
]</small>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id="adv">
</div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id="adv2">
</div>
<div style="width: 279;float: right;" id="adv3">
</div>
<div style="clear: both;"></div>
<br>
</form>
<!--/htdig_noindex-->

<center><h3><font color="#000088">Интерактивная система просмотра системных руководств (man-ов)</font></h3></center>
<form method="GET" action="/man.shtml"> 
<table cellspacing="0" cellpadding="1" bgcolor="#B0B190" align="center" width="600" border="0">
<tbody><tr>
<td valign="TOP">

<table cellspacing="0" cellpadding="0" bgcolor="#E9EAD6" align="center" width="100%" border="0">
<tbody><tr><td>&nbsp;<font color="#555555">Тема</font></td><td><font color="#555555">Набор</font></td><td><font color="#555555">Категория</font></td><td>&nbsp;</td></tr>
<tr><td>

&nbsp;<input size="20" name="topic" value="tcsh" type="text"></td><td><select name="russian">
<option value="4">Solaris man
</option><option value="1">FreeBSD man
</option><option value="3">Разные man
</option><option value="0" selected="">Русские man
</option><option value="2">Linux man
</option><option value="5">POSIX man
</option></select></td>
<td><select size="1" name="category">
	  <option value="" selected="">All
	  </option><option value="1">1
	  </option><option value="2">2
	  </option><option value="3">3
	  </option><option value="4">4
	  </option><option value="5">5
	  </option><option value="6">6
	  </option><option value="7">7
	  </option><option value="8">8
	  </option><option value="9">9
</option></select></td>

<td><input name="submit" value="Показать man" type="submit"></td></tr>
<script async="" src="https://www.google-analytics.com/analytics.js"></script><script language="JavaScript" src="/print.js"></script>
<tr><td colspan="4" align="left">&nbsp;[<a href="/man.shtml">Cписок руководств</a> | <a href="#" onclick="pr('none');">Печать</a>]</td></tr>
</tbody></table>
</td></tr></tbody></table>
</form>
<h3></h3><font size="+2">tcsh (1)</font><hr><li> <a href="/man.shtml?topic=tcsh&amp;category=1&amp;russian=4"><u>tcsh</u></a> (1) <font color="#555555"> ( Solaris man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=tcsh&amp;category=1&amp;russian=1"><u>tcsh</u></a> (1) <font color="#555555"> ( FreeBSD man: Команды и прикладные программы пользовательского уровня )</font></li><li>&gt;&gt; <a href="/man.shtml?topic=tcsh&amp;category=1&amp;russian=0"><u>tcsh</u></a> (1) <font color="#555555"> ( Русские man: Команды и прикладные программы пользовательского уровня )</font></li><li> <a href="/man.shtml?topic=tcsh&amp;category=1&amp;russian=2"><u>tcsh</u></a> (1) <font color="#555555"> ( Linux man: Команды и прикладные программы пользовательского уровня )</font></li>
ИМЯ<br><br>tcsh - оболочка C с завершением имени файла и редактированием командной строки<br> <br><br>СИНТАКСИС<br>tcsh [-bcdefFimnqstvVxX] [-Dname [= значение]] [arg ...]<br>tcsh -l<br>ОПИСАНИЕ<br>tcsh - улучшенная, но полностью совместимая версия оболочки Berkeley UNIX C, csh (1). Это интерпретатор командного языка, который можно использовать как интерактивную оболочку входа, так и командный процессор сценария оболочки. Он включает редактор командной строки (см. Редактор командной строки), программируемое завершение слова (см. Завершение и листинг), исправление орфографии (см. Коррекция орфографии), механизм истории (см. Замена истории), контроль заданий (см. C-подобный синтаксис. Раздел NEW FEATURES описывает основные улучшения tcsh по csh (1). В этом руководстве функции tcsh, не найденные в большинстве реализаций csh (1) (в частности, 4.4shd csh), помечены знаком `(+) ', а функции, которые присутствуют в csh (1), но обычно не документируются, помечены как `(и).<br>Обработка списка аргументов<br>Если первый аргумент (аргумент 0) для оболочки равен `- ', то это оболочка входа. Оболочку входа можно также указать, вызвав оболочку с флагом -l в качестве единственного аргумента.<br><br>Остальные аргументы флага интерпретируются следующим образом:<br><br>-b<br>    Заставляет перерыв из обработки параметров, в результате чего любые дополнительные аргументы оболочки рассматриваются как аргументы без опционов. Остальные аргументы не будут интерпретироваться как параметры оболочки. Это можно использовать для передачи параметров сценарию оболочки без путаницы или возможного уловки. Оболочка не будет запускать сценарий идентификатора набора пользователей без этой опции.<br>-с<br>    Команды считываются из следующего аргумента (который должен присутствовать и должен быть единственным аргументом), который хранится в переменной командной оболочки для ссылки и выполняется. Все остальные аргументы помещаются в переменную оболочки argv.<br>-d<br>    Оболочка загружает стек каталога из ~ / .cshdirs, как описано в разделе Запуск и завершение работы, независимо от того, является ли он оболочкой входа. (+)<br>-dNAME [= значение]<br>    Устанавливает значение переменной среды. (Только для домена / ОС) (+)<br>-e<br>    Оболочка выходит, если какая-либо вызванная команда заканчивается ненормально или дает ненулевой статус выхода.<br>-f<br>    Оболочка игнорирует ~ / .tcshrc и, таким образом, запускается быстрее.<br>-F<br>    Оболочка использует fork (2) вместо vfork (2) для запуска процессов. (Только выпуклый / OS) (+)<br>-я<br>    Оболочка интерактивна и запрашивает вход на верхнем уровне, даже если он не является терминалом. Оболочки интерактивны без этой опции, если их входы и выходы являются терминалами.<br>-l<br>    Оболочка - это оболочка входа. Применимо, только если -l - единственный флаг.<br>-m<br>    Оболочка загружает ~ / .tcshrc, даже если она не принадлежит эффективному пользователю. Более новые версии su (1) могут передать -m в оболочку. (+)<br>-n<br>    Оболочка анализирует команды, но не выполняет их. Это помогает отлаживать сценарии оболочки.<br>-q<br>    Оболочка принимает SIGQUIT (см. Обработка сигналов) и ведет себя, когда используется в отладчике. Управление заданиями отключено. (И)<br>-s<br>    Вход команды берется из стандартного ввода.<br>-t<br>    Оболочка считывает и выполняет одну строку ввода. \ Можно использовать для выхода из новой строки в конце этой строки и перехода на другую строку.<br>-v<br>    Устанавливает вербальную переменную оболочки, поэтому ввод команды повторяется после замены истории.<br>-Икс<br>    Устанавливает переменную оболочки echo, чтобы команды были эхом переданы непосредственно перед выполнением.<br>-V<br>    Устанавливает вербальную переменную оболочки даже до выполнения ~ / .tcshrc.<br>-ИКС<br>    Является ли -x как -V равным -v.<br><br>    --Помогите<br>    Распечатайте справочное сообщение на стандартном выходе и выходе. (+)<br>--версия<br>    Распечатайте параметры версии / платформы / компиляции на стандартном выходе и выходе. Эта информация также содержится в переменной оболочки версии. (+)<br><br>После обработки аргументов флага, если аргументы остаются, но не указаны параметры -c, -i, -s или -t, первый аргумент принимается за имя файла команд или `` script '', для выполнения. Оболочка открывает этот файл и сохраняет его имя для возможной повторной регистрации на `$ 0 '. Поскольку многие системы используют либо стандартные оболочки версии 6, либо версии 7, оболочки которых не совместимы с этой оболочкой, оболочка использует такую стандартную оболочку для выполнения сценария, чей первый символ не является #, т. Е. не начинайте с комментария.<br><br>Остальные аргументы помещаются в переменную оболочки argv.<br>Запуск и завершение работы<br>Оболочка для входа начинается с выполнения команд из системных файлов /etc/csh.cshrc и /etc/csh.login. Затем он выполняет команды из файлов в домашнем каталоге пользователя: сначала ~ / .tcshrc (+) или, если ~ / .tcshrc не найден, ~ / .cshrc, а затем ~ / .history (или значение переменной оболочки файла histfile ), затем ~ / .login и, наконец, ~ / .cshdirs (или значение переменной оболочки dirsfile) (+). Оболочка может читать /etc/csh.login раньше, чем после /etc/csh.cshrc и ~ / .login раньше, чем после ~ / .tcshrc или ~ / .cshrc и ~ / .history, если это скомпилировано; см. переменную оболочки версии. (+)<br><br>Недействительные оболочки читают только /etc/csh.cshrc и ~ / .tcshrc или ~ / .cshrc при запуске.<br><br>Примеры файлов запуска см. На странице http://tcshrc.sourceforge.net.<br><br>Команды, такие как stty (1) и tset (1), которые нужно запускать только один раз для входа, обычно идут в файл ~ / .login. Пользователи, которым необходимо использовать один и тот же набор файлов с csh (1) и tcsh, могут иметь только ~ / .cshrc, который проверяет наличие переменной оболочки tcsh (qv) перед использованием команд, специфичных для tcsh, или может иметь как a ~ / .cshrc и a ~ / .tcshrc, которые являются источниками (см. встроенную команду) ~ / .cshrc. Остальная часть этого руководства использует `~ / .tcshrc 'для обозначения` ~ / .tcshrc или, если ~ / .tcshrc не найден, ~ / .cshrc'.<br><br>В нормальном случае оболочка начинает считывать команды с терминала, запрашивая с помощью `&gt; '. (Обработка аргументов и использование оболочки для обработки файлов, содержащих командные сценарии, описаны ниже.) Оболочка неоднократно читает строку ввода команды, разбивает ее на слова, помещает в список истории команд, анализирует и выполняет каждую команду в линии.<br><br>Вы можете выйти из строя, набрав `^ D 'на пустой строке,` logout' или `login 'или через механизм autologout оболочки (см. Переменную оболочки autologout). Когда оболочка входа завершается, он устанавливает переменную оболочки вывода в нормальный или автоматический, а затем выполняет команды из файлов /etc/csh.logout и ~ / .logout. Оболочка может отбросить DTR при выходе из системы, если она скомпилирована; см. переменную оболочки версии.<br><br>Имена файлов входа в систему и выхода из системы варьируются от системы к системе для совместимости с различными вариантами csh (1); см. ФАЙЛЫ.<br>редактирование<br>Сначала мы опишем редактор командной строки. В разделах Завершение и Листинг и Правописание описываются два набора функциональных возможностей, которые реализуются как команды редактора, но которые заслуживают собственного лечения. Наконец, команды Editor перечисляют и описывают команды редактора, специфичные для оболочки, и их привязки по умолчанию.<br>Редактор командной строки (+)<br>Ввод в командной строке можно редактировать с помощью последовательностей клавиш, подобных тем, которые используются в GNU Emacs или vi (1). Редактор активен только тогда, когда задана переменная оболочки редактирования, которая по умолчанию используется в интерактивных оболочках. Встроенный bindkey может отображать и изменять привязки клавиш. По умолчанию привязки клавиш в стиле Emacs используются (если оболочка не была скомпилирована иначе, см. Переменную оболочки оболочки), но bindkey может изменить привязки ключей к привязкам стиля vi в маске.<br><br>Оболочка всегда связывает клавиши со стрелками (как определено в переменной среды TERMCAP), чтобы<br><br>    вниз<br>        вниз истории<br>    вверх<br>        до-истории<br>    оставил<br>        назад-символ<br>    правильно<br>        вперед-символ<br><br>если только это не изменит другую привязку с одним символом. Можно установить escape-последовательности клавиш стрелки в пустую строку с помощью setc, чтобы предотвратить эти привязки. Последовательности ANSI / VT100 для клавиш со стрелками всегда связаны.<br><br>Другие привязки клавиш - это, по большей части, то, что ожидали бы пользователи Emacs и vi (1) и могут быть легко отображены bindkey, поэтому нет необходимости перечислять их здесь. Аналогично, bindkey может перечислять команды редактора с кратким описанием каждого из них.<br><br>Обратите внимание, что команды редактора не имеют того же понятия слово, что и оболочка. Редактор ограничивает слова любыми не-алфавитно-цифровыми символами, не входящими в переменную wordchars оболочки, тогда как оболочка распознает только пробелы и некоторые символы со специальными значениями для нее, перечисленные в лексической структуре.<br><br>Завершение и листинг (+)<br>Оболочка часто может заполнять слова, когда им присваивается уникальная аббревиатура. Введите часть слова (например, `ls / usr / lost ') и нажмите клавишу табуляции, чтобы запустить команду редактора полного слова. Оболочка завершает имя файла `/ usr / lost 'на` / usr / lost + found /', заменяя неполное слово на полное слово во входном буфере. (Обратите внимание на терминал `/ '; завершение добавляет` /' в конец завершенных каталогов и пробел до конца других завершенных слов, чтобы быстро набирать текст и предоставлять визуальный индикатор успешного завершения. Переменная оболочки adduffix может быть отменена для предотвращения этого.) Если совпадение не найдено (возможно, `/ usr / lost + found 'не существует), звонит колокол терминала. Если слово уже завершено (возможно, в вашей системе есть `/ usr / lost ', или, может быть, вы слишком далеко задумались и набрали все это), к концу добавляется` /' или пространство, если оно не является " t уже есть.<br><br>Завершение работ в любом месте линии, а не только в конце; завершенный текст подталкивает остальную часть строки вправо. Завершение в середине слова часто приводит к оставленным символам справа от курсора, который необходимо удалить.<br><br>Команды и переменные могут быть выполнены почти таким же образом. Например, ввод `em [tab] 'завершил бы` em' на `emacs ', если emacs были единственной командой в вашей системе, начинающейся с` em'. Завершение может найти команду в любом каталоге по пути или если задано полное имя пути. Ввод `echo $ ar [tab] 'завершил бы` $ ar' на `$ argv ', если бы другая переменная не начиналась с` ar'.<br><br>Оболочка анализирует входной буфер, чтобы определить, должно ли слово, которое вы хотите завершить, заполнять как имя файла, команду или переменную. Первое слово в буфере и первое слово, следующее за символами `; ',` |', `| &amp; ',` &amp;&amp;' или `|| ' считается командой. Слово, начинающееся с `$ ', считается переменной. Все остальное - имя файла. Пустая строка `завершена 'как имя файла.<br><br>Вы можете в любой момент перечислить возможные завершения слова, набрав `^ D 'для запуска команды delete-char-or-list-or-eof. В оболочке перечислены возможные доработки с использованием встроенного ls-F (q.v.) и переиздается приглашение и незавершенная командная строка, например:<br><br>    &gt; ls / usr / l [^ D]<br>    lbin / lib / local / lost + found /<br>    &gt; ls / usr / l<br><br>Если задана переменная оболочки автолиста, оболочка перечисляет оставшиеся варианты (если они есть) при завершении завершения:<br><br>    &gt; установить автолист<br>    &gt; nm / usr / lib / libt [tab]<br>    libtermcap.a @ libtermlib.a @<br>    &gt; nm / usr / lib / libterm<br><br>Если для автолиста установлено значение неоднозначное, выбор указывается только в случае неудачи завершения и не добавляет новых символов в слово, которое будет завершено.<br><br>Имя файла, которое должно быть заполнено, может содержать переменные, собственные или другие домашние каталоги, сокращенные с помощью `~ '(см. Подстановку имен файлов) и записи стека в каталоге, сокращенно с помощью` =' (см. Замену стека каталога). Например,<br><br>    &gt; ls ~ k [^ D]<br>    kahn kas kellogg<br>    &gt; ls ~ ke [tab]<br>    &gt; ls ~ kellogg /<br><br>или<br><br>    &gt; set local = / usr / local<br>    &gt; ls $ lo [tab]<br>    &gt; ls $ local / [^ D]<br>    bin / etc / lib / man / src /<br>    &gt; ls $ local /<br><br>Обратите внимание, что переменные также могут быть явно расширены с помощью команды редактора переменных-переменных.<br><br>delete-char-or-list-or-eof только в конце строки; в середине строки он удаляет символ под курсором, а на пустой строке он записывает один из них или, если параметр ignoreeof установлен, ничего не делает. `M- ^ D ', привязанный к списку команд редактора, список возможностей завершения в любой точке строки и список-выбор (или любая из соответствующих команд редактора, которые делают или не удаляют, перечисляют и / или записывают out, перечисленные в файле delete-char-or-list-or-eof) могут быть привязаны к `^ D 'с помощью встроенной команды bindkey, если это необходимо.<br><br>Команды полного слова-fwd и полного слова-назад (не привязанные к каким-либо клавишам по умолчанию) могут использоваться для циклического перехода вверх и вниз по списку возможных завершений, заменяя текущее слово следующим или предыдущим словом в список.<br><br>Переменная fignore оболочки может быть установлена в список суффиксов, которые будут проигнорированы путем завершения. Рассмотрим следующее:<br><br>    &gt; ls<br>    Makefile condiments.h ~ main.o side.c<br>    README main.c еда сторона.o<br>    condiments.h main.c ~<br>    &gt; set fignore = (.o \ ~)<br>    &gt; emacs ma [^ D]<br>    main.c main.c ~ main.o<br>    &gt; emacs ma [tab]<br>    &gt; Разное<br><br>`main.c ~ 'и` main.o' игнорируются завершением (но не перечислением), потому что они заканчиваются суффиксами в fignore. Обратите внимание, что перед `~ 'необходимо было` \', чтобы предотвратить его расширение до дома, как описано в подменю Имя файла. fignore игнорируется, если возможно только одно завершение.<br><br>Если полная переменная оболочки установлена в `усиление ', то завершение 1) игнорирует регистр и 2) рассматривает периоды, дефисы и символы подчеркивания (`.', `- 'и` _') как разделители слов, а дефисы и подчеркивания эквивалентны , Если у вас есть следующие файлы<br><br>    comp.lang.c comp.lang.perl comp.std.c ++<br>    comp.lang.c ++ comp.std.c<br><br>    и набрал mail -f c.l.c [tab], он будет заполнен mail -f comp.lang.c, а ^ D будет содержать список comp.lang.c и comp.lang.c ++. `mail -f c..c ++ [^ D] 'будет содержать список` comp.lang.c ++' и `comp.std.c ++ '. Ввод `rm a - file [^ D] 'в следующем каталоге<br><br>    A_silly_file a-hyphenated-file another_silly_file<br><br>будет перечислять все три файла, потому что случай игнорируется, а дефисы и подчеркивания эквивалентны. Однако периоды не эквивалентны дефисам или символам подчеркивания.<br><br>Завершение и листинг затронуты несколькими другими переменными оболочки: Recexact может быть установлен для завершения в кратчайшем возможном уникальном совпадении, даже если более типизация может привести к более длинному совпадению:<br><br>    &gt; ls<br>    фуд foo food foonly<br>    &gt; set recexact<br>    &gt; rm fo [tab]<br><br>просто звучит, потому что `fo 'может расширяться до` fod' или `foo ', но если мы наберем другое` o'<br><br>    &gt; rm foo [tab]<br>    &gt; rm foo<br><br>завершение завершается на `foo ', даже если еда и foonly также совпадают. autoexpand может быть настроен для запуска команды редактора истории расширений перед каждой попыткой завершения, автокоррекция может быть настроена на орфографическое исправление слова, которое должно быть завершено (см. исправление орфографии) перед каждой попыткой завершения, и исправление может быть установлено для завершения команд автоматически после одного хиты `return '. matchbeep может быть настроен на то, чтобы сделать звуковой сигнал завершения или не подавать звуковой сигнал в различных ситуациях, а nobeep может быть настроен так, чтобы никогда не издавать звуковой сигнал. nostat может быть настроен на список каталогов и / или шаблонов, которые соответствуют каталогам, чтобы предотвратить механизм завершения из stat (2) в этих каталогах. listmax и listmaxrows могут быть установлены для ограничения количества элементов и строк (соответственно), которые перечислены без предварительного запроса. Функция распознавания_определения может быть настроена на то, чтобы сделать список команд только для исполняемых файлов при перечислении команд, но он довольно медленный.<br><br>Наконец, полная встроенная команда может использоваться, чтобы сообщить оболочке, как заполнять слова, отличные от имен файлов, команд и переменных. Завершение и листинг не работают над glob-образцами (см. Подменю Имя файла), но команды редактора list-glob и expand-glob выполняют эквивалентные функции для шаблонов glob.<br>Коррекция орфографии (+)<br>Оболочка может иногда корректировать написание имен файлов, команд и имен переменных, а также заполнять их и перечислять.<br><br>Отдельные слова могут быть исправлены с помощью команды редактора заклинаний (обычно привязаны к M-s и M-S) и всего входного буфера с заклинанием (обычно привязанным к M- $). Правильная переменная оболочки может быть установлена в `cmd ', чтобы исправить имя команды или` all', чтобы исправить всю строку каждый раз, когда набирается возврат, и автокоррекция может быть настроена на исправление слова, которое должно быть выполнено до каждой попытки завершения.<br><br>Когда исправление орфографии вызывается любым из этих способов, и оболочка считает, что любая часть командной строки написана с ошибкой, она запрашивает исправленную строку:<br><br>    &gt; set correct = cmd<br>    &gt; lz / usr / bin<br>    CORRECT&gt; ls / usr / bin (y | n | e | a)?<br><br>Можно ответить y или пробел, чтобы выполнить исправленную строку e, чтобы оставить неуправляемую команду во входном буфере a, чтобы прервать команду, как если бы ^ C был поражен, и что-нибудь еще для выполнения оригинальная линия без изменений.<br><br>Орфографическая коррекция распознает пользовательские доработки (см. Полную встроенную команду). Если входное слово в позиции, для которой определено завершение, похоже на слово в списке завершения, орфографическая коррекция регистрирует орфографическую ошибку и предлагает последнее слово в качестве коррекции. Однако, если входное слово не соответствует ни одному из возможных завершений для этой позиции, исправление орфографии не регистрирует орфографическую ошибку.<br><br>Подобно завершению, орфографическая коррекция работает в любом месте линии, нажимая остальную часть строки вправо и, возможно, оставляя лишние символы справа от курсора.<br><br>Опасайтесь: исправление орфографии не гарантируется, чтобы работать так, как вы планируете, и предоставляется в основном как экспериментальная функция. Предложения и улучшения приветствуются.<br><br>Команды редактора (+)<br>`bindkey 'перечисляет привязки клавиш и списки` bindkey -l' и вкратце описывает команды редактора. Здесь описаны только новые или особенно интересные команды редактора. См. Emacs (1) и vi (1) для описания привязок клавиш каждого редактора.<br><br>Символ или символы, к которым каждая команда привязана по умолчанию, указаны в круглых скобках. Символ `^ 'означает управляющий символ, а символ М-символ - метасимвол, введенный как символ эвакуации на терминалах без мета-ключа. Счетчик событий, но команды, привязанные к буквам по умолчанию, привязаны как к нижним, так и к прописным буквам для удобства.<br><br>полное слово (вкладка)<br>    Завершает слово, как описано в разделе Завершение и листинг.<br>полное слово-назад (не связанное)<br>    Подобно full-word-fwd, но подходит к концу списка.<br>full-word-fwd (не связан)<br>    Заменяет текущее слово первым словом в списке возможных завершений. Может повторяться для перехода вниз по списку. В конце списка раздастся звуковой сигнал и вернется к неполному слову.<br>full-word-raw (^ X-tab)<br>    Как полное слово, но игнорирует пользовательские доработки.<br>copy-prev-word (M - ^ _)<br>    Копирует предыдущее слово в текущей строке во входной буфер. См. Также insert-last-word.<br>dabbrev-expand (M- /)<br>    Расширяет текущее слово до последнего предыдущего, для которого текущий является ведущей подстрокой, при необходимости обертывая список истории (один раз). Повторение dabbrev-expand без каких-либо вмешательств при вводе текста меняется на следующее предыдущее слово и т. Д., Пропуская одинаковые совпадения, похожие на историю-поиск-назад.<br>delete-char (не связан)<br>    Удаляет символ под курсором. См. Также delete-char-or-list-or-eof.<br>delete-char-or-eof (не связан)<br>    Does delete-char, если есть символ под курсором или конец файла на пустой строке. См. Также delete-char-or-list-or-eof.<br>delete-char-or-list (не связан)<br>    Does delete-char, если в конце строки есть символ под курсором или список-выбор. См. Также delete-char-or-list-or-eof.<br>delete-char-or-list-or-eof (^ D)<br>    Does delete-char, если есть символ под курсором, список-выбор в конце строки или конец файла на пустой строке. См. Также эти три команды, каждая из которых выполняет только одно действие, а также delete-char-or-eof, delete-char или-list и list-or-eof, каждый из которых выполняет разные два из трех.<br>вниз-история (стрелка вниз, ^ N)<br>    Как up-history, но уходит в отставку, останавливаясь на исходной строке ввода.<br>конец файла (не связанный)<br>    Сигналы завершают файл, заставляя оболочку завершаться, если для параметра оболочки ignoreeof (q.v.) не установлено это предупреждение. См. Также delete-char-or-list-or-eof.<br>expand-history (M-space)<br>    Расширяет замены истории в текущем слове. См. Замена истории. См. Также magic-space, toggle-literal-history и переменную оболочки autoexpand.<br>expand-glob (^ X- *)<br>    Расширяет шаблон glob слева от курсора. См. Замена имени файла.<br>expand-line (не связанный)<br>    Подобно expand-history, но расширяет подстановки истории в каждом слове во входном буфере,<br>expand-variables (^ X- $)<br>    Расширяет переменную слева от курсора. См. Замена переменных.<br>history-search-backward (M-p, M-P)<br>    Ищет назад по списку истории для команды, начинающейся с текущего содержимого входного буфера до курсора, и копирует его во входной буфер. Строка поиска может быть шаблоном glob (см. Подстановку имен файлов), содержащим `* ',`?', `[] 'Или` {}'. история и история вниз будут исходить из соответствующей точки в списке истории. Только режим Emacs. Смотрите также историю поиска и i-search-back.<br>history-search-forward (M-n, M-N)<br>    Как и история-поиск-назад, но ищет вперед.<br>i-search-back (не связанный)<br>    Ищет назад, как история-поиск-назад, копирует первое совпадение во входной буфер с курсором, расположенным в конце шаблона, и запрашивает `bck: 'и первое совпадение. Для продолжения поиска могут быть введены дополнительные символы, а для повторного поиска i-search-back можно продолжить поиск с использованием того же шаблона, если необходимо, обернуть вокруг списка истории (i-search-back должен быть привязан к одному символу для этого, чтобы работа) или один из следующих специальных символов может быть напечатан:<br><br>        ^ W<br>            Добавляет остальную часть слова под курсором к шаблону поиска.<br>        delete (или любой символ, привязанный к обратному-удалению-char)<br>            Отменяет действие последнего символа и удаляет символ из шаблона поиска, если это необходимо.<br>        ^ G<br>            Если предыдущий поиск был успешным, прервите весь поиск. Если нет, возвращается к последнему успешному поиску.<br>        побег<br>            Завершает поиск, оставив текущую строку во входном буфере.<br><br>            Любой другой символ, не связанный с командой self-insert-command, завершает поиск, оставляя текущую строку во входном буфере и затем интерпретируется как обычный ввод. В частности, возврат каретки вызывает выполнение текущей строки. Только режим Emacs. См. Также i-search-fwd и history-search-backward.<br><br>i-search-fwd (не связан)<br>    Как и i-search-back, но ищет вперед.<br>insert-last-word (M-_)<br>    Вставляет последнее слово предыдущей строки ввода (`! $ ') Во входной буфер. См. Также предисловие к копированию.<br>список-выбор (M- ^ D)<br>    Перечисляет возможности завершения, как описано в разделе Завершение и листинг. См. Также delete-char-or-list-or-eof и list-choice-raw.<br>list-choice-raw (^ X- ^ D)<br>    Подобно спискам, но игнорирует пользовательские доработки.<br>list-glob (^ X-g, ^ X-G)<br>    Списки (через встроенный ls-F) соответствуют шаблону glob (см. Подстановку имен файлов) слева от курсора.<br>list-or-eof (не связан)<br>    Отображает ли список или конец файла на пустой строке. См. Также delete-char-or-list-or-eof.<br>магическое пространство (не связанное)<br>    Расширяет подстановки истории в текущей строке, такие как expand-history, и вставляет пробел. magic-space предназначен для привязки к пробелу, но не связан по умолчанию.<br>normalize-command (^ X-?)<br>    Ищет текущее слово в PATH и, если он найден, заменяет его полным путем к исполняемому файлу. Цитируются специальные символы. Псевдонимы расширены и цитируются, но команды внутри псевдонимов не являются. Эта команда полезна для команд, которые принимают команды в качестве аргументов, например, `dbx 'и` sh -x'.<br>normalize-path (^ X-n, ^ X-N)<br>    Расширяет текущее слово, как описано в параметре `expand 'переменной оболочки symlinks.<br>перезаписывать-режим (несвязанный)<br>    Переключение между режимами ввода и перезаписывания.<br>run-fg-editor (M- ^ Z)<br>    Сохраняет текущую строку ввода и ищет остановленное задание с именем, равным последнему компоненту части имени файла переменных среды EDITOR или VISUAL, или, если они не установлены, `ed 'или` vi'. Если такое задание найдено, оно перезапускается, как если бы была введена команда fg% job. Это позволяет легко и быстро переключаться между редактором и оболочкой. Некоторые люди связывают эту команду с ^ Z, поэтому они могут сделать это еще проще.<br>run-help (M-h, M-H)<br>    Ищет документацию по текущей команде, используя те же понятия текущая команда, что и процедуры завершения, и печатает ее. Невозможно использовать пейджер; run-help предназначен для коротких файлов справки. Если определен специальный псевдоним helpcommand, он запускается с именем команды в качестве единственного аргумента. В противном случае документация должна быть в файле с именем command.help, command.1, command.6, command.8 или command, который должен находиться в одном из каталогов, перечисленных в переменной среды HPATH. Если имеется более одного файла справки, печатается только первое.<br>self-insert-command (текстовые символы)<br>    В режиме вставки (по умолчанию) вставляет введенный символ в строку ввода после символа под курсором. В режиме перезаписи заменяет символ под курсором набранным символом. Режим ввода обычно сохраняется между строками, но переменная оболочки inputmode может быть установлена в insert или overwrite, чтобы поместить редактор в этот режим в начале каждой строки. См. Также режим перезаписи.<br>последовательность-ввод (префикс стрелки, мета-префикс, ^ X)<br>    Указывает, что следующие символы являются частью последовательности с несколькими ключами. Привязка команды к последовательности с несколькими ключами действительно создает две привязки: первый символ для ввода последовательности и всю последовательность команды. Все последовательности, начинающиеся с символа, связанного с вводом последовательности, эффективно связаны с неопределенным ключом, если не связаны с другой командой.<br>spell-line (M- $)<br>    Попытка исправить написание каждого слова во входном буфере, например, слово заклинания, но игнорирует слова, первый символ которых является одним из `- ',`!', `^ 'Или`%' или которые содержат `\ ', `* 'или`?', чтобы избежать проблем с коммутаторами, подстановками и т. п. См. Исправление орфографии.<br>заклинание (M-s, M-S)<br>    Попытки исправить написание текущего слова, как описано в исправлении орфографии. Проверяет каждый компонент слова, который является именем пути.<br>toggle-literal-history (M-r, M-R)<br>    Расширяет или заменяет историю изменений в исходном буфере. См. Также expand-history и переменную оболочки autoexpand.<br>undefined-key (любой несвязанный ключ)<br>    Beeps.<br><br>    up-history (стрелка вверх, ^ P)<br>    Копирует предыдущую запись в списке истории во входной буфер. Если задано значение histlit, используется литеральная форма записи. Можно повторить, чтобы перейти в список истории, остановив верхнюю часть.<br>vi-search-back (?)<br>    Запросы с `? ' для строки поиска (которая может быть шаблоном glob, как и для истории-поиска-назад), ищет его и копирует в входной буфер. Колокол звонит, если совпадение не найдено. Возврат завершает поиск и оставляет последнее совпадение во входном буфере. При ударе заканчивается поиск и выполняется совпадение. vi только.<br>vi-search-fwd (/)<br>    Как vi-search-back, но ищет вперед.<br>которая-команда (M-?)<br>    Есть ли какое (см. Описание встроенной команды) в первом слове входного буфера.<br>yank-pop (M-y)<br>    Когда выполняется сразу после yank или другого yank-pop, заменяет yanked строку следующей предыдущей строкой из killring. Это также приводит к повороту killring, так что эта строка будет считаться последней, убитой более поздней командой yank. Повторение yank-pop будет циклически проходить через killing любое количество раз.<br><br> <br>Лексическая структура<br>Оболочка разбивает входные строки на слова в пробелах и вкладках. Специальные символы `&amp; ',` |', `; ',` &lt;', `&gt; ',` (' и `) 'и удвоенные символы` &amp;&amp;', `|| ',` &lt;&lt;' и ` &gt;&gt; 'всегда являются отдельными словами, независимо от того, окружены ли они пробелами.<br><br>Когда вход оболочки не является терминалом, символ `# 'принимается для начала комментария. Каждый `# 'и остальная часть строки ввода, на которой он появляется, отбрасываются перед дальнейшим разбором.<br><br>Специальный символ (включая пробел или табуляцию) может быть лишен своего особого значения и, возможно, сделан частью другого слова, предшествуя ему обратным слэшем (`\ ') или заключая его в одиночный (`' '), двойной (`` ') или назад (``'). Если не указано иначе, новая строка с символом `\ 'эквивалентна пробелу, но внутри кавычек эта последовательность приводит к новой строке.<br><br>Кроме того, все замещения (см. Ниже), за исключением замены истории, могут быть предотвращены путем включения строк (или частей строк), в которых они отображаются с одинарными кавычками или путем цитирования критического символа (ов) (например, `$ 'или` `' для замены переменных или подстановки команд соответственно) с помощью `\ '. (Подстановка псевдонимов не является исключением: цитирование каким-либо образом любого символа слова, для которого было определено псевдоним, предотвращает замену псевдонима. Обычный способ цитирования псевдонима должен предшествовать ему обратным слэшем.) Подстановка истории предотвращается обратную косую черту, а не одиночные кавычки. Строки, цитируемые двойными или обратными кавычками, подвергаются замене переменных и замене команд, но другие замены не допускаются.<br><br>Текст внутри одиночных или двойных кавычек становится одним словом (или частью одного). Метасимволы в этих строках, включая пробелы и вкладки, не образуют отдельных слов. Только в одном специальном случае (см. Подстановку команд ниже) может быть строка с двумя кавычками, дающая части более одного слова; одиночные кавычки никогда не делают. Обратные кавычки являются особыми: они сигнализируют замену команды (q.v.), что может привести к нескольким словам.<br><br>Цитирование сложных строк, в частности строк, которые сами содержат цитирующие символы, может сбивать с толку. Помните, что цитаты не должны использоваться так, как они написаны человеком! Может быть проще процитировать не целую строку, а только те части строки, которые нуждаются в цитировании, используя различные типы цитирования, чтобы сделать это, если это необходимо.<br><br>Переменная оболочки backslash_quote (qv) может быть установлена так, чтобы обратная косая черта всегда указывала `\ ',`' 'и `"'. (+) Это может облегчить выполнение сложных задач кавычек, но это может привести к синтаксическим ошибкам в csh (1) скрипты.<br><br>Замены<br>Теперь мы описываем различные преобразования, выполняемые оболочкой на входе в том порядке, в котором они происходят. Мы отмечаем мимоходом связанные структуры данных и команды и переменные, которые влияют на них. Помните, что замена может быть предотвращена путем цитирования, как описано в лексической структуре.<br>Замена истории<br>Каждая команда или `` событие '', ввод с терминала сохраняется в списке истории. Предыдущая команда всегда сохраняется, а переменная оболочки истории может быть установлена в число, чтобы сохранить это множество команд. Переменная оболочки histdup может быть настроена так, чтобы не сохранять повторяющиеся события или последовательные повторяющиеся события.<br><br>Сохраненные команды нумеруются последовательно от 1 и отмечены временем. Обычно нет необходимости использовать номера событий, но текущий номер события можно сделать частью подсказки, поместив `! ' в командной строке приглашения.<br><br>Оболочка фактически сохраняет историю в расширенных и буквальных (нерасширенных) формах. Если задана переменная оболочки histlit, команды, отображающие и хранящие историю, используют литеральную форму.<br><br>Команда built-in истории может печатать, хранить в файле, восстанавливать и очищать список истории в любое время, а переменные оболочки savehist и histfile могут быть установлены для автоматического сохранения списка истории при выходе из системы и восстановления его при входе в систему.<br><br>Замены истории вводят слова из списка истории во входной поток, упрощая повторение команд, повторение аргументов предыдущей команды в текущей команде или исправление орфографических ошибок в предыдущей команде с небольшой типизацией и высокой степенью уверенности.<br><br>Замены истории начинаются с символа `! '. Они могут начинаться где угодно во входном потоке, но они не гнездятся. `! ' может предшествовать \, чтобы предотвратить его особый смысл; для удобства, `! ' передается без изменений, когда за ним следуют пробел, табуляция, новая строка, `= 'или` ('. Замены истории также возникают, когда строка ввода начинается с символа `^ '. Это специальное сокращение будет описано ниже. замена истории (`! 'и` ^') может быть изменена путем установки переменной оболочки histchars. Любая строка ввода, которая содержит замену истории, печатается перед ее выполнением.<br><br>Подстановка истории может иметь спецификацию события, которая указывает событие, из которого должны быть сделаны слова, определитель слов, который выбирает определенные слова из выбранного события и / или модификатор, ', который манипулирует выбранными словами.<br><br>Спецификация события может быть<br><br>    N<br>        Число, относящееся к определенному событию<br>    -n<br>        Смещение, относящееся к событию n перед текущим событием<br>    #<br>        Текущее событие. Это следует тщательно использовать в csh (1), где нет проверки на рекурсию. tcsh позволяет 10 уровней рекурсии. (+)<br>    !<br>        Предыдущее событие (эквивалентное `-1 ')<br>    s<br>        Самое последнее событие, первое слово которого начинается с строки s<br>    ? S?<br>        Самое последнее событие, которое содержит строку s. Второй `? ' может быть опущен, если сразу же следует новая строка.<br><br>Например, рассмотрим этот бит списка истории человека:<br><br>     9 8:30 nroff -man wumpus.man<br>    10 8:31 cp wumpus.man wumpus.man.old<br>    11 8:36 vi wumpus.man<br>    12 8:37 diff wumpus.man.old wumpus.man<br><br>    Команды отображаются с номерами событий и отметками времени. Текущее событие, которое мы еще не ввели, - это событие 13. `! 11 'и`! -2' относятся к событию 11. `!! ' относится к предыдущему событию, 12. `!! ' может быть сокращено `! ' если за ним следует `: '(`:' описывается ниже). `! n 'относится к событию 9, которое начинается с` n'. `!? Старый? также относится к событию 12, которое содержит старый. Без указателей слов или модификаторов ссылки истории просто расширяются до всего события, поэтому мы можем набрать `! Cp 'для повторной команды копирования или` !! | more', если выход `diff 'прокручивается в верхней части экрана.<br><br>В случае необходимости ссылки на источники могут быть изолированы от окружающего текста скобками. Например, `! Vdoc 'будет искать команду, начинающуюся с` vdoc', и в этом примере не найти ее, но `! {V} doc 'будет однозначно расширяться до` vi wumpus.mandoc'. Даже в фигурных скобках, замены истории не гнездятся.<br><br>(+) Пока csh (1) расширяет, например, `! 3d 'до события 3 с добавленной к нему буквой` d', tcsh расширяет его до последнего события, начинающегося с `3d '; только полностью числовые аргументы рассматриваются как номера событий. Это позволяет вспомнить события, начинающиеся с чисел. Чтобы развернуть `! 3d ', как в csh (1), скажем`! \ 3d'.<br><br>Чтобы выбрать слова из события, мы можем следить за спецификацией события с помощью символа `: 'и указателя для желаемых слов. Слова входной строки нумеруются от 0, первое (обычно командное) слово равно 0, второе слово (первый аргумент) - 1 и т. Д. Основные обозначения слов:<br><br>    0<br>        Первое (командное) слово<br>    N<br>        N-й аргумент<br>    ^<br>        Первый аргумент, эквивалентный `1 '<br>    $<br>        Последний аргумент<br>    %<br>        Слово соответствует? поиск<br>    х-у<br>        Ряд слов<br>    -y<br>        Эквивалент `0-y '<br>    *<br>        Эквивалентно `^ - $ ', но ничего не возвращает, если событие содержит только одно слово<br>    Икс*<br>        Эквивалент `x- $ '<br>    Икс-<br>        Эквивалент `x * ', но опускающий последнее слово (` $')<br><br>Выбранные слова вставляются в командную строку, разделенную одиночными пробелами. Например, команда `diff 'в предыдущем примере могла быть введена как` diff !!: 1.old !!: 1' (используя `: 1 ', чтобы выбрать первый аргумент из предыдущего события) или` diff! -2: 2! -2: 1 'для выбора и замены аргументов из команды `cp'. Если бы нас не интересовал порядок diff, мы могли бы сказать diff! -2: 1-2 или просто diff! -2: *. Команда `cp 'могла быть написана` cp wumpus.man! #: 1.old', используя `# 'для обозначения текущего события. `! n: - hurkle.man 'будет повторно использовать первые два слова из команды` nroff', чтобы сказать `nroff -man hurkle.man '.<br><br>Параметр `: ', отделяющий спецификацию события от указателя слова, может быть опущен, если селектор аргументов начинается с` ^', `$ ',` *', `% 'или` -'. Например, наша команда `diff 'могла бы быть` diff !! ^. Old !! ^' или, эквивалентно, `diff !! $. Old !! $ '. Однако, если `!! ' сокращенно `! ', селектор аргументов, начинающийся с` -', будет интерпретироваться как спецификация события.<br><br>Ссылка на историю может иметь указатель на слово, но не спецификация события. Затем он ссылается на предыдущую команду. Продолжая наш пример diff, мы могли бы просто сказать diff! ^. Old! ^ Или, чтобы получить аргументы в обратном порядке, просто diff! *.<br><br>Слово или слова в справочнике истории можно редактировать или изменять, следуя за ним одним или несколькими модификаторами, каждому из которых предшествует символ `:':<br><br>час<br>        Удалите компонент конечного пути, оставив голову.<br>    T<br>        Удалите все ведущие компоненты пути, оставив хвост.<br>    р<br>        Удалите расширение файла .xxx ', оставив имя корня.<br>    е<br>        Удалите все, кроме расширения.<br>    U<br>        Прописьте первую строчную букву.<br>    L<br>        Опишите первую букву верхнего регистра.<br>    с / л / г /<br>        Заменим l на r. l - это просто строка типа r, а не регулярное выражение, как в команде eponymous ed (1). Любой символ может использоваться как разделитель вместо `/ '; a `\ 'может использоваться для указания разделителя внутри l и r. Символ `&amp; 'в r заменяется на l; `\ 'также цитирует` &amp;'. Если l пуст (`` ''), l из предыдущей подстановки или s из предыдущего `? S? ' используется спецификация события. Конечный разделитель может быть опущен, если сразу же следует новая строка.<br>    &amp;<br>        Повторите предыдущую замену.<br>    г<br>        Применяйте следующий модификатор один раз к каждому слову.<br>    a (+)<br>        Применяйте следующий модификатор столько раз, сколько возможно до одного слова. `a 'и` g' могут использоваться вместе для применения модификатора глобально. В текущей реализации использование модификаторов `a 'и` s' вместе может привести к бесконечному циклу. Например, `: as / f / ff / 'никогда не завершится. Такое поведение может измениться в будущем.<br>    п<br>        Распечатайте новую командную строку, но не выполняйте ее.<br>    Q<br>        Процитировать замещенные слова, предотвращая дальнейшие замены.<br>    Икс<br>        Как и q, но разрывайте слова в пробелах, вкладках и символах новой строки.<br><br>Модификаторы применяются только к первому модифицируемому слову (если не используется `g '). Это ошибка, поскольку никакое слово не может быть изменено.<br><br>Например, команда `diff 'могла быть написана как` diff wumpus.man.old! # ^: R', используя `: r 'для удаления` .old' из первого аргумента в той же строке (`! # ^ '). Мы могли бы сказать echo hello there there, затем echo! *: U, чтобы использовать hello, echo! *: Au, чтобы сказать это вслух, или echo! *: Agu, чтобы действительно кричать. Мы могли бы следовать mail -s. Я забыл пароль rot с `!: S / rot / root ', чтобы исправить написание root (но см. Исправление орфографии для другого подхода).<br><br>Существует специальная аббревиатура для замещений. `^ ', когда он является первым символом на входной строке, эквивалентен`!: s ^'. Таким образом, мы могли бы сказать ^ rot ^ root, чтобы сделать орфографическую коррекцию в предыдущем примере. Это единственная замена истории, которая явно не начинается с `! '.<br><br>(+) В csh как таковой, только один модификатор может применяться к каждому расширению истории или переменной. В tcsh может использоваться более одного, например<br><br>    % mv wumpus.man /usr/man/man1/wumpus.1<br>    % man! $: t: r<br>    Мужчина wumpus<br><br>    В csh результатом будет `wumpus.1: r '. Замена, за которой следует толстая кишка, возможно, должна быть изолирована от нее скобками:<br><br>    &gt; mv a.out / usr / games / wumpus<br>    &gt; setenv PATH! $: h: $ PATH<br>    Плохо ! модификатор: $.<br>    &gt; setenv PATH! { - 2 $: h}: $ PATH<br>    setenv PATH / usr / games: / bin: / usr / bin :.<br><br>Первая попытка будет успешной в csh, но сбой в tcsh, потому что tcsh ожидает другого модификатора после второго двоеточия, а не `$ '.<br><br>Наконец, историю можно получить через редактор, а также через описанные ниже замены. Команды up-down-history, history-search-backward и -forward, i-search-back и -fwd, vi-search-back и -fwd, copy-prev-word и insert-last-word выполняют поиск события в списке истории и скопировать их во входной буфер. Команда редактора переключателя-литеральной истории переключается между расширенными и буквальными формами строк истории во входном буфере. expand-history и expand-line расширять исторические подстановки в текущем слове и во всем входном буфере соответственно.<br>Подстановка псевдонимов<br>Оболочка поддерживает список псевдонимов, которые могут быть установлены, отменены и напечатаны командами псевдонимов и неалиасов. После того, как командная строка анализируется на простые команды (см. Команды), первое слово каждой команды слева-направо проверяется на наличие псевдонима. Если это так, первое слово заменяется псевдонимом. Если псевдоним содержит ссылку на историю, он подвергается замене истории (q.v.), как если бы исходной командой была предыдущая строка ввода. Если псевдоним не содержит ссылки на историю, список аргументов остается нетронутым.<br><br>Таким образом, если псевдоним для `ls 'был` ls -l', команда `ls / usr 'стала бы` ls -l / usr', список аргументов здесь невозможен. Если псевдоним для `lookup 'был` grep! ^ / Etc / passwd', тогда `lookup bill 'станет` grep bill / etc / passwd'. Псевдонимы могут использоваться для введения метасинтакса парсера. Например, `alias print 'pr \! * | lpr '' определяет `` command '' (`print '), который pr (1) содержит свои аргументы для линейного принтера.<br><br>Подстановка псевдонима повторяется до тех пор, пока первое слово команды не будет иметь псевдоним. Если подстановка псевдонимов не меняет первое слово (как в предыдущем примере), оно помечено для предотвращения цикла. Обнаружены другие циклы и вызывают ошибку.<br><br>Некоторые псевдонимы упоминаются оболочкой; см. Специальные псевдонимы.<br>Переменная замена<br>Оболочка поддерживает список переменных, каждый из которых имеет в качестве значения список из нуля или более слов. Значения переменных оболочки могут быть отображены и изменены с помощью команд set и unset. Система поддерживает собственный список переменных `` environment ''. Они могут отображаться и изменяться с помощью printenv, setenv и unsetenv.<br><br>(+) Переменные могут быть сделаны только для чтения с помощью `set -r '(q.v.) Переменные только для чтения не могут быть изменены или отменены; попытка сделать это приведет к ошибке. После того, как вы сделали доступным только для чтения, переменная не может быть доступна для записи, поэтому `set -r 'следует использовать с осторожностью. Переменные среды не могут быть доступны только для чтения.<br><br>Некоторые переменные задаются оболочкой или ссылаются на нее. Например, переменная argv представляет собой образ списка аргументов оболочки, а слова значения этой переменной упоминаются особыми способами. Некоторые из переменных, на которые ссылается оболочка, являются переключателями; оболочке все равно, какова их ценность, только если они установлены или нет. Например, переменная verbose является переключателем, который вызывает эхо-сигнал команды. Параметр -v командной строки задает эту переменную. Специальные переменные оболочки перечисляют все переменные, на которые ссылается оболочка.<br><br>Другие операции обрабатывают переменные численно. Команда `@ 'позволяет выполнять числовые вычисления и присваивать результат переменной. Однако переменные значения всегда представляются как (ноль или более) строк. Для целей числовых операций нулевая строка считается нулевой, а второй и последующие слова многословных значений игнорируются.<br><br>После того, как строка ввода будет сглажена и проанализирована, и перед выполнением каждой команды подстановка переменной выполняется с помощью символов `$ '. Это расширение может быть предотвращено предшествующим `$ 'с помощью` \', за исключением внутри `` ', где оно всегда встречается, и внутри ``', где оно никогда не встречается. Строки, цитируемые `` ', интерпретируются позже (см. Команду подстановка ниже), поэтому подстановка `$ 'не встречается там до поздней, если вообще. $ передается без изменений, если за ней следует пробел, табуляция или конец строки.<br><br>Переадресация ввода / вывода распознается до расширения переменной и разнесена по отдельности. В противном случае имя команды и весь список аргументов будут расширены вместе. Таким образом, первое (командное) слово (к этой точке) может генерировать более одного слова, первым из которых становится имя команды, а остальные - аргументы.<br><br>Если не указано в `` 'или задано модификатором `: q', результаты подстановки переменных могут в конечном итоге быть заменены командой и filename. Внутри` "'переменная, значение которой состоит из нескольких слов, расширяется до (части a) одного слова , со словами значения переменной, разделенных пробелами. Когда к подстановке применяется модификатор `: q ', переменная будет расширяться до нескольких слов с каждым словом, разделенным пробелом и цитируемым, чтобы предотвратить замену позже или замену имени файла.<br><br>Для ввода значений переменных в ввод оболочки вводятся следующие metasequences. За исключением случаев, отмеченных, это ошибка для ссылки на переменную, которая не установлена.<br><br>имя $<br><br>$ {Имя}<br>    Заменяет слова значения имени переменной, каждая из которых разделяется пробелом. Брекеты изолируют имя от следующих символов, которые в противном случае были бы частью этого. Переменные Shell имеют имена, состоящие из 20 букв и цифр, начинающихся с буквы. Символ подчеркивания считается буквой. Если имя не является переменной оболочки, но установлено в среде, то это значение возвращается (но модификаторы `: 'и другие формы, приведенные ниже, в этом случае недоступны).<br><br>$ Имя [селектор]<br><br>$ {Имя [селектор]}<br>    Заменяет только выбранные слова из значения имени. Селектор подвергается подстановке `$ 'и может состоять из одного числа или двух чисел, разделенных символом` -'. Первое слово значения переменной имеет номер 1. Если первое число диапазона опущено, по умолчанию используется значение 1. Если последний член диапазона опущен, по умолчанию используется `$ # name '. Селектор `* 'выбирает все слова. Это не ошибка для диапазона, который должен быть пустым, если второй аргумент опущен или находится в диапазоне.<br>$ 0<br>    Заменяет имя файла, из которого считывается ввод команды. Происходит ошибка, если имя неизвестно.<br><br>$ номер<br><br>$ {Номер}<br>    Эквивалент `$ argv [number] '.<br>$ *<br>    Эквивалент `$ argv ', который эквивалентен` $ argv [*]'.<br><br>Модификаторы `: ', описанные в разделе Замена истории , кроме: p , могут быть применены к приведенным выше замещениям. Можно использовать более одного. (+) Скобки могут понадобиться для изоляции замены переменных из буквального двоеточия, как и при замене истории (q.v.); любые модификаторы должны появляться в фигурных скобках.<br><br>Следующие подстановки не могут быть изменены с помощью модификаторов `: '.<br><br>$? Имя<br><br>$ {?} Имя<br>    Заменяет строку `1 ', если имя установлено,` 0', если это не так.<br>$? 0<br>    Заменяет `1 ', если текущее имя входного файла известно,` 0', если это не так. Всегда `0 'в интерактивных оболочках.<br><br>$ # Имя<br><br>$ {# Имя}<br>    Заменяет количество слов по имени.<br>$ #<br>    Эквивалентен `$ # argv '. (+)<br><br>$ Имя%<br><br>$ {Имя}%<br>    Заменяет количество символов в имени. (+)<br><br>$ Номер%<br><br>$ {% Число}<br>    Заменяет количество символов в $ argv [number]. (+)<br>$?<br>    Эквивалент `$ status '. (+)<br>$$<br>    Заменяет (десятичный) номер процесса (родительской) оболочки.<br>$!<br>    Заменяет (десятичный) номер процесса последнего фонового процесса, запускаемого этой оболочкой. (+)<br>$ _<br>    Заменяет командную строку последней выполненной команды. (+)<br>$ &lt;<br>    Заменяет линию со стандартного ввода, без дальнейшей интерпретации. Его можно использовать для чтения с клавиатуры в сценарии оболочки. (+) Пока csh всегда цитирует $ &lt;, как если бы он был эквивалентен `$ &lt;: q ', tcsh этого не делает. Кроме того, когда tcsh ожидает ввода строки, пользователь может ввести прерывание для прерывания последовательности, в которую должна быть заменена строка, но csh не позволяет этого.<br><br>Команда редактора expand-variables, обычно связанная с `^ X- $ ', может использоваться для интерактивного расширения отдельных переменных.<br>Подстановка команды, имя файла и каталога<br>Остальные подстановки применяются выборочно к аргументам встроенных команд. Это означает, что части выражений, которые не оцениваются, не подвергаются этим разложениям. Для команд, которые не являются внутренними для оболочки, имя команды заменяется отдельно от списка аргументов. Это происходит очень поздно, после выполнения перенаправления ввода-вывода и дочернего элемента основной оболочки.<br><br>Замена команд<br>Подстановка команд указана командой, заключенной в `` '. Результат такой команды разбивается на отдельные слова в пробелах, вкладках и новых строках, а нулевые слова отбрасываются. Вывод является переменным, а команда заменена и помещается вместо исходной строки.<br><br>Замены команд внутри двойных кавычек (`` ') сохраняют пробелы и табуляции, только новые строки заставляют новые слова. Единственная конечная новая строка не заставляет новое слово ни в коем случае. Таким образом, подмена команды может дать только часть слова , даже если команда выводит полную строку.<br><br>По умолчанию оболочка с версии 6.12 заменяет все символы новой строки и символа возврата каретки в команде пробелами. Если это отключено, отключив csubstnonl, новые строки разделяют команды как обычно.<br>Замена имени файла<br>Если слово содержит любые символы `* ',`?', `['Или` {' или начинается с символа `~ ', это кандидат на замену имени файла, также известный как` `globbing' '. Это слово затем рассматривается как шаблон (glob-pattern) и заменяется алфавитно отсортированным списком имен файлов, которые соответствуют шаблону.<br><br>В совпадающих именах файлов символ `. ' в начале имени файла или сразу после символа `/ ', а также символ` /' должен быть явно указан. Символ `* 'соответствует любой строке символов, включая нулевую строку. Символ `? ' соответствует любому одиночному символу. Последовательность `[...] 'соответствует любому из заключенных символов. Внутри [...] 'пара символов, разделенных символом `-', соответствует любому символу лексически между двумя.<br><br>(+) Некоторые шаблоны glob могут быть сведены на нет: последовательность `[^ ...] 'соответствует любому одиночному символу, не указанному символами и / или диапазонами символов в фигурных скобках.<br><br>Весь шаблон glob также можно отменить с помощью `^ ':<br><br>    &gt; echo *<br>    грохот аварии<br>    &gt; echo ^ cr *<br>    ударять<br><br>Шаблоны Glob, которые не используют `? ',` *' Или `[] 'или которые используют` {}' или `~ '(см. Ниже), неправильно сбрасываются.<br><br>Метанотация `a {b, c, d} e 'является сокращением для` abe ace ade'. Порядок слева направо сохраняется: `/usr/source/s1/{oldls,ls}.c 'расширяется до` /usr/source/s1/oldls.c /usr/source/s1/ls.c'. Результаты матчей сортируются отдельно на низком уровне для сохранения этого порядка: `../{memo,*box} 'может расширяться до` ../memo ../box ../mbox'. (Обратите внимание, что `memo 'не сортировалось с результатами сопоставления` * box.) Это не ошибка, когда эта конструкция расширяется до файлов, которые не существуют, но можно получить сообщение об ошибке из команды, расширен список. Эта конструкция может быть вложенной. В качестве специального случая слова `{',`}' и `{} 'передаются без изменений.<br><br>Символ `~ 'в начале имени файла относится к домашним каталогам. Стоя в одиночку, т. Е. `~ ', Он расширяется до домашнего каталога invoker, как это отражено в значении переменной home shell. Когда за ним следует имя, состоящее из букв, цифр и символов `- ', оболочка ищет пользователя с этим именем и заменяет свой домашний каталог; таким образом, `~ ken 'может расширяться до` / usr / ken' и `~ ken / chmach 'до` / usr / ken / chmach'. Если за символом `~ 'следует символ, отличный от буквы или` /', или появляется в другом месте, кроме как в начале слова, он остается невозмущенным. Команда, подобная `setenv MANPATH / usr / man: / usr / local / man: ~ / lib / man ', поэтому не делает замену домашней директории, как можно было бы надеяться.<br><br>Это ошибка для шаблона glob, содержащего `* ',`?', `['Или` ~', с или без `^ ', чтобы не соответствовать никаким файлам. Тем не менее, только один шаблон в списке glob-шаблонов должен соответствовать файлу (так что, например, `rm * .a * .c * .o 'потерпит неудачу, только если в текущем каталоге, заканчивающемся на` `, не было файлов. a ', `.c' или` .o '), и если установлена переменная оболочки nonomatch, шаблон (или список шаблонов), который не соответствует ни одному, не остается неизменным, а не вызывает ошибку.<br><br>Переменная оболочки noglob может быть установлена для предотвращения подстановки имени файла, а команда редактора расширения-glob, обычно связанная с `^ X- * ', может использоваться для интерактивного расширения отдельных подстановок имен файлов.<br><br>Подстановка стека каталога (+)<br>Стек каталога представляет собой список каталогов, нумерованных от нуля, используемых командами pushd, popd и dirs (q.v.). dirs могут печатать, хранить в файле, восстанавливать и очищать стек каталога в любое время, а переменные оболочки savedirs и dirsfile могут быть установлены для автоматического хранения стека каталога при выходе из системы и восстановления его при входе в систему. Переменная оболочки dirstack может быть проверена, чтобы увидеть стек каталога и установить для размещения произвольных каталогов в стек каталога.<br><br>Символ `= ', за которым следует одна или несколько цифр, расширяется до записи в стеке каталога. Специальный случай `= - 'расширяется до последнего каталога в стеке. Например,<br><br>    &gt; dirs -v<br>    0 / usr / bin<br>    1 / usr / spool / uucp<br>    2 / usr / accts / sys<br>    &gt; echo = 1<br>    / USR / катушка / UUCP<br>    &gt; echo = 0 / calendar<br>    / USR / бен / календарь<br>    &gt; echo = -<br>    / USR / ACCTS / SYS<br><br>Переменные оболочки noglob и nonomatch и команда редактора expand-glob применяются к стеку каталогов, а также заменам имен файлов.<br>


Другие подстановки (+)<br>Существует еще несколько преобразований с именами файлов, не строго связанных с вышеупомянутым, но упомянутых здесь для полноты. Любое имя файла может быть расширено до полного пути, когда переменная symlinks (q.v.) установлена в `expand '. Quoting предотвращает это расширение, и команда редактора normalize-path делает это по требованию. Команда редактора normalize-command расширяет команды в PATH на полные пути по требованию. Наконец, cd и pushd интерпретируют `- 'как старую рабочую директорию (эквивалентную переменной оболочки owd). Это не подстановка вообще, а аббревиатура, распознаваемая только этими командами. Тем не менее, это тоже может быть предотвращено путем цитирования.<br>команды<br>В следующих трех разделах описывается, как оболочка выполняет команды и обрабатывает их вход и выход.<br>Простые команды, конвейеры и последовательности<br>Простая команда - это последовательность слов, первая из которых указывает исполняемую команду. Ряд простых команд, соединенных `| ' символы образуют конвейер. Выход каждой команды в конвейере подключается к входу следующего.<br><br>Простые команды и конвейеры могут быть объединены в последовательности с символом `; 'и будут выполняться последовательно. Команды и конвейеры также могут быть объединены в последовательности с `|| ' или `&amp;&amp; ', указывая, как на языке C, что второй должен быть выполнен только в том случае, если первый сбой или успешный результат соответственно.<br><br>Простую команду, конвейер или последовательность можно помещать в круглые скобки `() ', чтобы сформировать простую команду, которая, в свою очередь, может быть компонентом конвейера или последовательности. Команду, конвейер или последовательность можно выполнить, не дожидаясь завершения операции, следуя за ней с помощью `&amp; '.<br>Исполнение встроенной и не встроенной команды<br>Встроенные команды выполняются внутри оболочки. Если какой-либо компонент конвейера, кроме последнего, является встроенной командой, конвейер выполняется в подоболочке.<br><br>Команды в скобках всегда выполняются в подоболочке.<br><br>    (cd; pwd); PWD<br><br>таким образом печатает домашний каталог, оставляя вас там, где вы были (печатайте это после домашнего каталога), в то время как<br><br>    CD; PWD<br><br>оставляет вас в домашнем каталоге. Скоринговые команды чаще всего используются для предотвращения влияния cd на текущую оболочку.<br><br>Когда команда, которая будет выполнена, не будет встроенной командой, оболочка пытается выполнить команду через execve (2). Каждое слово в пути переменной определяет каталог, в котором оболочка будет искать команду. Если ему не задана опция a -c или a -t, оболочка хэширует имена в этих каталогах во внутреннюю таблицу, чтобы попытаться выполнить execve (2) только в каталоге, где есть вероятность, что команда находится там , Это значительно ускоряет расположение команд, когда в пути поиска присутствует большое количество каталогов. Если этот механизм был отключен (через unhash), если оболочке был задан аргумент -c или -t или в любом случае для каждого компонента каталога пути, который не начинается с `/ ', оболочка объединяет текущую рабочую каталог с заданным именем команды, чтобы сформировать путь к файлу, который затем пытается выполнить.<br><br>Если файл имеет разрешения на выполнение, но не является исполняемым для системы (т. Е. Он не является исполняемым двоичным файлом или сценарием, который указывает его интерпретатор), то предполагается, что он является файлом, содержащим команды оболочки, и новая оболочка порождается прочитайте его. Специальный псевдоним оболочки может быть установлен для указания интерпретатора, отличного от самой оболочки.<br><br>В системах, которые не понимают `#! ' сценарий интерпретатора интерпретатора shell может быть скомпилирован для его эмулирования; см. переменную оболочки версии. Если это так, оболочка проверяет первую строку файла, чтобы увидеть, имеет ли он форму `#! Interpreter arg ... '. Если это так, оболочка запускает интерпретатор с данными аргументами и подает файл на него на стандартный ввод.<br>Ввод, вывод<br>Стандартный ввод и стандартный вывод команды могут быть перенаправлены со следующим синтаксисом:<br><br>&lt;имя<br>    В качестве стандартного ввода вы можете открыть имя файла (которое является первой переменной, командой и именем файла).<br>&lt;&lt; слово<br>    Прочитайте ввод оболочки до строки, которая идентична слову. слово не подвергается переменной, имени файла или подстановке команд, и каждая строка ввода сравнивается со словом до того, как в этой строке ввода будут сделаны какие-либо подстановки. Если в переменных слова не отображается цитирование `\ ',` "',` 'или ``', а подстановка команд выполняется на промежуточных строках, что позволяет `\ 'указывать` $', `\ 'и` `'. Команды которые заменяются, сохраняются все пробелы, табуляции и новые строки, за исключением окончательной новой строки, которая отбрасывается. Полученный текст помещается в анонимный временный файл, который присваивается команде в качестве стандартного ввода.<br><br>&gt; имя<br>&gt;! имя<br>&gt; &amp; name<br><br>&gt; &amp;! имя<br>    Имя файла используется как стандартный вывод. Если файл не существует, он создается; если файл существует, он усекается, его предыдущее содержимое теряется.<br><br>        Если задана переменная оболочки noclobber, то файл не должен существовать или быть специальным файлом символа (например, терминалом или `/ dev / null ') или результатом ошибки. Это помогает предотвратить случайное уничтожение файлов. В этом случае `! ' формы могут быть использованы для подавления этой проверки.<br><br>        Формы, содержащие `&amp; ', маршрутизируют диагностический вывод в указанный файл, а также стандартный вывод. имя расширяется так же, как и входные имена `&lt;'.<br><br>&gt;&gt; имя<br>&gt;&gt; &amp; name<br>&gt;&gt;! имя<br><br>&gt;&gt; &amp;! имя<br>    Как `&gt; ', но добавляет вывод в конец имени. Если задана переменная оболочки noclobber, то это ошибка для того, чтобы файл не существовал, если только один из `! ' формы.<br><br>Команда получает среду, в которой оболочка была вызвана с изменением параметров ввода-вывода и наличием команды в конвейере. Таким образом, в отличие от некоторых предыдущих оболочек, команды, запускаемые из файла команд оболочки, не имеют доступа к тексту команд по умолчанию; скорее они получают исходный стандартный ввод оболочки. Для представления встроенных данных следует использовать механизм &lt;&lt;. Это позволяет командам командной оболочки работать в качестве компонентов конвейеров и позволяет оболочке блокировать чтение своего ввода. Обратите внимание, что стандартный стандартный ввод для отладки команды не является пустым файлом / dev / null, а исходным стандартным вводом оболочки. Если это терминал, и если процесс пытается прочитать с терминала, процесс блокируется, и пользователь будет уведомлен (см. Работы).<br><br>Диагностический выход может быть направлен через трубу со стандартным выходом. Просто используйте форму `| &amp; ', а не просто` |'.<br><br>Оболочка не может в настоящее время перенаправлять диагностический вывод, не перенаправляя также стандартный вывод, но `(command&gt; output-file)&gt; &amp; error-file 'часто является приемлемым обходным решением. Любой выходной файл или файл ошибок может быть `/ dev / tty 'для отправки вывода на терминал.<br><br>Особенности<br>Описав, как оболочка принимает, анализирует и выполняет командные строки, мы теперь переходим к множеству полезных функций.<br>Управляющий поток<br>Оболочка содержит ряд команд, которые могут использоваться для регулирования потока управления в командных файлах (сценариях оболочки) и (ограниченными, но полезными способами) с терминала. Все эти команды работают, заставляя оболочку перечитывать или пропускать на своем входе и из-за реализации ограничивают размещение некоторых команд.<br><br>Операторы foreach, switch и while, а также форма if-then-else оператора if требуют, чтобы основные ключевые слова отображались в одной простой команде на входной строке, как показано ниже.<br><br>Если вход оболочки не доступен для поиска, оболочка буферизует входной сигнал всякий раз, когда цикл считывается и выполняет поиск в этом внутреннем буфере, чтобы выполнить перечитывание, указанное в цикле. (В той степени, в которой это позволяет, обратные gotos преуспеют в недоступных для входа входах).<br>Выражения<br>Команды if, while и exit встроены в выражения с общим синтаксисом. Выражения могут включать любой из операторов, описанных в следующих трех разделах. Обратите внимание, что команда @ builtin (q.v.) имеет свой отдельный синтаксис.<br>Логические, арифметические и сравнительные операторы<br>Эти операторы аналогичны тем, которые имеют С и имеют одинаковый приоритет. Они включают<br><br>    || &amp;&amp; | ^ &amp; ==! = = ~! ~ &lt;=&gt; =<br>    &lt;&gt; &lt;&lt; &gt;&gt; + - * /%! ~ ()<br><br>Здесь приоритет увеличивается вправо, `== '`! =' `= ~ 'И`! ~', `&lt;= '`&gt;' '&lt;' И `&gt; ',` &lt;&lt;' и `&gt;&gt; ',' + 'и `-',` * '`/' и`% 'в группах на одном уровне. Операторы `== '`! =' `= ~ И`! ~ 'Сравнивают свои аргументы как строки; все остальные работают по номерам. Операторы `= ~ 'и`! ~' Похожи на `! = 'И` ==', за исключением того, что правая часть является шаблоном glob (см. Подстановку имен файлов), с которым сопоставляется левый операнд. Это уменьшает необходимость использования встроенной команды switch в сценариях оболочки, когда все, что действительно необходимо, - это сопоставление шаблонов.<br><br>Строки, начинающиеся с 0, считаются восьмеричными числами. Нулевые или отсутствующие аргументы считаются 0. Результатами всех выражений являются строки, которые представляют десятичные числа. Важно отметить, что никакие две составляющие выражения не могут появляться в одном и том же слове; кроме случаев, когда они смежны с компонентами выражений, синтаксически значимыми для синтаксического анализатора (`&amp; '` |' `&lt;'`&gt;' `('`)'), они должны быть окружены пробелами.<br>Статус выхода команды<br>Команды могут выполняться в выражениях, и их статус выхода возвращается, заключая их в фигурные скобки (`{} '). Помните, что скобки должны быть отделены от слов команды пробелами. Выполнение команд выполняется успешно, возвращая true, то есть 1, если команда завершает работу со статусом 0, иначе они терпят неудачу, возвращая false, то есть 0. Если требуется более подробная информация о статусе, команда должна выполняться вне выражения и проверяется переменная оболочки состояния.<br>Операторы запросов к файлам<br>Некоторые из этих операторов выполняют истинные / ложные тесты на файлы и связанные объекты. Они имеют форму -op-файл, где op является одним из<br><br>    р<br>        Доступ для чтения<br>    вес<br>        Доступ к записи<br>    Икс<br>        Выполнять доступ<br>    Икс<br>        Исполняемые в построении пути или оболочки, например, `-X ls 'и` -X ls-F', как правило, истинны, но `-X / bin / ls 'не является (+)<br>    е<br>        существование<br>    о<br>        Владение<br>    Z<br>        Нулевой размер<br>    s<br>        Необязательный размер (+)<br>    е<br>        Обычный файл<br>    d<br>        каталог<br>    L<br>        Символическая ссылка (+) *<br>    б<br>        Блокировать специальный файл (+)<br>    с<br>        Специальный файл символов (+)<br>    п<br>        Именованная труба (fifo) (+) *<br>    S<br>        Специальный файл сокета (+) *<br>    U<br>        Установленный бит идентификатора пользователя установлен (+)<br>    г<br>        Установленный бит группы Set (+)<br>    К<br>        Установлен липкий бит (+)<br>    T<br>        файл (который должен быть цифрой) является открытым файловым дескриптором для терминального устройства (+)<br>    р<br>        Был перенесен (только выпуклый) (+)<br>    L<br>        Применяет последующие операторы в тесте с несколькими операторами к символической ссылке, а не к файлу, к которому относится ссылка (+) *<br><br>        файл - это команда и имя файла, расширенные, а затем протестированы, чтобы узнать, имеет ли он определенную связь с реальным пользователем. Если файл не существует или недоступен, или для операторов, обозначенных символом `* ', если указанный тип файла не существует в текущей системе, то все запросы возвращают false, т. Е.` 0'.<br><br>Эти операторы могут быть объединены для краткости: -xy-файл эквивалентен -x file &amp;&amp; -y file. (+) Например, `-fx 'является истинным (возвращает` 1') для простых исполняемых файлов, но не для каталогов.<br><br>L может использоваться в тесте с несколькими операторами для применения последующих операторов к символической ссылке, а не к файлу, на который указывает ссылка. Например, `-lLo 'истинно для ссылок, принадлежащих вызывающему пользователю. Lr, Lw и Lx всегда верны для ссылок и false для не-ссылок. L имеет другое значение, когда он является последним оператором в тесте с несколькими операторами; Смотри ниже.<br><br>Возможно, но не полезно, а иногда и вводить в заблуждение, комбинировать операторов, которые ожидают, что файл будет файлом с операторами, которые этого не делают (например, X и t). После L с помощью не-файла оператор может привести к особенно странным результатам.<br><br>Другие операторы возвращают другую информацию, то есть не только 0 или 1. (+) Они имеют тот же формат, что и раньше; op может быть одним из<br><br>    <br>        Время последнего доступа к файлу, так как количество секунд с момента<br>    A:<br>        Как и A, но в формате timestamp, например, Fri May 14 16:36:10 1993,<br>    M<br>        Время последнего изменения файла<br>    М:<br>        Как и M, но в формате timestamp<br>    С<br>        Время последней модификации inode<br>    C:<br>        Как и C, но в формате timestamp<br>    D<br>        Номер устройства<br>    я<br>        Номер Inode<br>    F<br>        Идентификатор композитного файла в устройстве формы: inode<br>    L<br>        Имя файла, на которое указывает символическая ссылка<br>    N<br>        Количество (жестких) ссылок<br>    п<br>        Разрешения, в восьмеричном, без начального нуля<br>    П:<br>        Подобно P, с начальным нулем<br>    PMODE<br>        Эквивалент `-P file &amp; mode ', например,` -P22 file' возвращает `22 ', если файл доступен для записи группой и другими,` 20', если только по группе, и `0 ', если ни один из них<br>    PMODE:<br>        Подобно Pmode :, с начальным нулем<br>    U<br>        Числовой идентификатор пользователя<br>    U:<br>        Имя пользователя или числовой идентификатор пользователя, если имя пользователя неизвестно<br>    г<br>        Числовая группа<br>    Г:<br>        Имя группы или числовая группа, если имя группы неизвестно<br>    Z<br>        Размер, в байтах<br><br>Только один из этих операторов может появиться в тесте с несколькими операторами, и он должен быть последним. Обратите внимание, что L имеет другое значение в конце и в другом месте в тесте с несколькими операторами. Поскольку `0 'является допустимым возвращаемым значением для многих из этих операторов, они не возвращают` 0', когда они терпят неудачу: большинство возвращает `-1 ', а F возвращает`:'.<br><br>Если оболочка скомпилирована с установленным POSIX (см. Переменную оболочки версии), результат запроса файла основан на битах разрешения файла, а не на результате системного вызова доступа (2). Например, если вы тестируете файл с ключом -w, разрешения которого обычно позволяют записывать, но который находится в файловой системе, смонтированной только для чтения, тест будет успешным в оболочке POSIX, но не будет работать в оболочке, отличной от POSIX.<br><br>Операторы запроса файла также могут быть оценены с помощью встроенной команды filetest (q.v.) (+).<br><br>работы<br>Оболочка связывает задание с каждым конвейером. Он хранит таблицу текущих заданий, напечатанную командой jobs, и присваивает им небольшие целые числа. Когда задание запускается асинхронно с `&amp; ', оболочка печатает строку, которая выглядит как<br><br>    [1] 1234<br><br>что работа, которая была запущена асинхронно, была номером 1 работы и имела один (верхний уровень) процесс, чей идентификатор процесса был 1234.<br><br>Если вы выполняете задание и хотите сделать что-то еще, вы можете нажать клавишу приостановки (обычно `^ Z '), которая отправляет сигнал STOP на текущее задание. Затем оболочка обычно указывает, что задание было приостановлено и распечатало другое приглашение. Если задана переменная оболочки listjobs, все задания будут перечислены как команда builtins; если он настроен на `long ', список будет в длинном формате, например` jobs -l'. Затем вы можете управлять состоянием приостановленной работы. Вы можете поместить его в фон с помощью команды bg или запустить некоторые другие команды и в конечном итоге вернуть задание в передний план с помощью fg. (См. Также команду редактора редактора run-fg-editor.) ^ Z вступает в силу немедленно и как прерывание в том, что ожидающий вывод и непрочитанный ввод отбрасываются при его вводе. Команда wait builtin заставляет оболочку ждать завершения всех фоновых заданий.<br><br>Клавиша `^ 'отправляет задержанный сигнал приостановки, который не генерирует сигнал STOP до тех пор, пока программа не попытается прочитать (2) это текущее задание. Это может быть полезно напечатать заранее, когда вы подготовили некоторые команды для задания, которое вы хотите остановить, после того, как прочитали их. Клавиша `^ Y 'выполняет эту функцию в csh (1); в tcsh, `^ Y '- команда редактирования. (+)<br><br>Работа, выполняемая в фоновом режиме, останавливается, если она пытается прочитать с терминала. Фоновым заданиям обычно разрешено создавать выходные данные, но это можно отключить, указав команду `stty tostop '. Если вы установите эту опцию tty, фоновые задания прекратятся, когда они попытаются произвести вывод, как они делают, когда они попытаются прочитать ввод.<br><br>Существует несколько способов ссылаться на задания в оболочке. Символ `% 'вводит имя задания. Если вы хотите сослаться на номер задания 1, вы можете назвать его как % 1. Простое назначение задания выводит его на передний план; поэтому % 1 является синонимом fg% 1, возвращая работу 1 на передний план. Аналогично, выражение `% 1 &amp; 'возобновляет работу 1 в фоновом режиме, как и` bg% 1'. Задание также может быть названо однозначным префиксом строки, введенной для ее начала: `% ex 'обычно перезапускает приостановленное ex (1) задание, если было только одно приостановленное задание, имя которого начиналось со строки` ex' , Также можно указать `%? String 'для задания задания, текст которого содержит строку, если есть только одно такое задание.<br><br>Оболочка поддерживает понятие текущих и предыдущих заданий. В выходном файле, относящемся к заданию, текущее задание помечено символом `+ 'и предыдущим заданием с символом` -'. Аббревиатуры `% + ',`%' и (по аналогии с синтаксисом механизма истории) `%% 'все относятся к текущему заданию, а`% -' относится к предыдущему заданию.<br><br>Механизм управления заданиями требует, чтобы параметр stty (1) `new 'устанавливался в некоторых системах. Это артефакт из новой реализации драйвера tty, который позволяет генерировать символы прерываний с клавиатуры, чтобы остановить выполнение заданий. Подробнее о настройке параметров в новом tty-драйвере см. В файле stty (1) и команде setty builtin.<br><br>Отчет о состоянии<br>Оболочка сразу узнает, когда процесс изменяется. Он обычно информирует вас всякий раз, когда задание блокируется, так что дальнейший прогресс возможен, но только до того, как он распечатает приглашение. Это делается так, чтобы это не нарушало вашу работу. Если, однако, вы установите уведомление оболочки, оболочка немедленно сообщит вам об изменениях статуса в фоновых заданиях. Также есть команда оболочки, которая уведомляет о том, что отмечает один процесс, чтобы немедленно сообщать о его изменениях. По умолчанию уведомляет отметки текущего процесса; просто скажите уведомить после запуска фоновой работы, чтобы пометить его.<br><br>Когда вы пытаетесь оставить оболочку во время остановки работы, вы будете предупреждены, что вы остановили работу. Вы можете использовать команду jobs, чтобы узнать, что это такое. Если вы сделаете это или сразу попытаетесь выйти снова, оболочка не будет предупреждать вас во второй раз, и приостановленные задания будут прекращены.<br>Автоматические, периодические и синхронизированные события (+)<br>Существуют различные способы запуска команд и выполнения других действий автоматически в разное время в жизненном цикле оболочки. Они суммируются здесь и подробно описаны в соответствующих командах Builtin, специальных переменных оболочки и специальных псевдонимов.<br><br>Команда schedinedin ставит команды в список запланированных событий, которые должны выполняться оболочкой в данный момент времени.<br><br>Beepcmd, cwdcmd, периодический, precmd, postcmd и jobcmd. Специальные псевдонимы могут быть установлены, соответственно, для выполнения команд, когда оболочка хочет позвонить в колокол, когда рабочий каталог изменяется, каждые минуты в течение каждого запроса перед каждой командой запускается, после выполнения каждой команды, и когда задание запускается или выводится на передний план.<br><br>Переменная оболочки autologout может быть установлена для выхода из системы или блокировки оболочки после заданного количества минут бездействия.<br><br>Переменная почтовой оболочки может быть настроена для периодической проверки новой почты.<br><br>Переменная оболочки printexitvalue может быть настроена так, чтобы печатать статус выхода команд, которые выходят со статусом, отличным от нуля.<br><br>Переменная оболочки rmstar может быть настроена на то, чтобы спросить пользователя, когда вводится rm *, если это действительно то, что означало.<br><br>Переменная временной шкалы может быть настроена на выполнение команды time builtin после завершения любого процесса, который занимает больше заданного количества секунд процессора.<br><br>Параметры часов и переменные оболочки могут быть настроены так, чтобы сообщать, когда выбранные пользователи входят в систему или выходят, а команда встроенного журнала регистрирует эти пользователи в любое время.<br>Поддержка языковой системы (+)<br>Оболочка имеет восемь бит (если она скомпилирована, см. Переменную оболочки версии) и, таким образом, поддерживает наборы символов, требующие этой возможности. Поддержка NLS различается в зависимости от того, была ли скомпилирована оболочка для использования NLS системы (опять же, см. Версию). В любом случае 7-разрядный ASCII - это код символа по умолчанию (например, классификация символов, подлежащих печати) и сортировка, а также изменение переменных среды LANG или LC_CTYPE приводит к проверке возможных изменений в этих отношениях.<br><br>При использовании NLS системы функция setlocale (3) вызывается для определения соответствующего символьного кода / классификации и сортировки (например, en_CA.UTF-8 дает код UTF-8 в качестве символьного кода). Эта функция обычно анализирует переменные среды LANG и LC_CTYPE; более подробную информацию см. в документации по системе. Если не использовать NLS системы, оболочка имитирует его, предполагая, что набор символов ISO 8859-1 используется всякий раз, когда заданы переменные LANG и LC_CTYPE независимо от их значений. Сортировка не влияет на моделируемую NLS.<br><br>Кроме того, как с реальными, так и с имитируемыми NLS, все печатные символы в диапазоне \ 200- \ 377, т. Е. Те, у которых есть привязки M-char, автоматически восстанавливаются до self-insert-command. Соответствующая привязка для последовательности escape-char, если таковая имеется, остается одной. Эти символы не восстанавливаются, если установлена переменная среды NOREBIND. Это может быть полезно для моделируемой NLS или примитивной реальной NLS, которая предполагает полный ISO 8859-1. В противном случае все привязки M-char в диапазоне \ 240- \ 377 эффективно отменены. Очевидно, что повторное связывание соответствующих ключей с bindkey, конечно, возможно.<br><br>Неизвестные символы (т. Е. Те, которые не являются ни печатными, ни управляющими символами) печатаются в формате \ nnn. Если tty не находится в 8-битном режиме, другие 8-битные символы печатаются путем преобразования их в ASCII и использования режима standout. Оболочка никогда не изменяет режим 7/8 бит tty и не отслеживает инициированные пользователем изменения режима 7/8 бит. Пользователям NLS (или, если на то пошло, тем, кто хочет использовать мета-ключ), возможно, необходимо явно установить tty в 8-битном режиме с помощью соответствующей команды stty (1), например, в файле ~ / .login.<br><br>Поддержка варианта ОС (+)<br>Для поддержки функций в конкретных операционных системах предусмотрен ряд новых встроенных команд. Все они подробно описаны в разделе Встроенные команды.<br><br>В системах, поддерживающих TCF (aix-ibm370, aix-ps2), getpath и setspath получают и устанавливают путь выполнения системы, getxvers и setxvers получают и устанавливают префикс экспериментальной версии и переносят процессы миграции между сайтами. Созданные задания печатают сайт, на котором выполняется каждое задание.<br><br>В BS2000 команда bs2cmd выполняет команды базовой операционной системы BS2000 / OSD.<br><br>В разделе Домен / ОС inlib добавляет общие библиотеки в текущую среду, rootnode изменяет корневой каталог, а ver изменяет systype.<br><br>Под Махом путь setpath эквивалентен pathpath (1) Маха.<br><br>В Masscomp / RTU и Harris CX / UX юниверс устанавливает юниверс.<br><br>Под Harris CX / UX ucb или att запускает команду под указанным юниверсом.<br><br>В Convex / OS warp печатает или устанавливает юниверс.<br><br>Переменные окружения VENDOR, OSTYPE и MACHTYPE указывают, соответственно, поставщика, операционную систему и тип машины (класс микропроцессора или модель машины) системы, на которой оболочка считает, что она работает. Они особенно полезны при обмене домашним каталогом между несколькими типами машин; можно, например,<br><br>    set path = (~ / bin. $ MACHTYPE / usr / ucb / bin / usr / bin.)<br><br>в своем ~ / .login и поместить исполняемые файлы, скомпилированные для каждой машины в соответствующий каталог.<br><br>Переменная оболочки версии указывает, какие параметры были выбраны при компиляции оболочки.<br><br>Также обратите внимание на переменные оболочки newgrp builtin, afsuser и echo_style и зависящие от системы расположения входных файлов оболочки (см. ФАЙЛЫ).<br>Обработка сигналов<br>При просмотре файла ~ / .logout блокировки входа игнорируют прерывания. Оболочка игнорирует сигналы выхода, если только не запускается с -q. Локальные оболочки улавливают сигнал завершения, но оболочки, не входящие в систему, наследуют поведение от своих родителей. Другие сигналы имеют значения, которые оболочка унаследовала от своего родителя.<br><br>В сценариях оболочки обработка командами сигналов прерывания и завершения работы оболочки может контролироваться с помощью onintr, а ее обработка зависаний может контролироваться с помощью hup и nohup.<br><br>Оболочка выходит из зависания (см. Также переменную оболочки выхода). По умолчанию дети с оболочкой тоже, но оболочка не отправляет им зависание при выходе. hup устраивает оболочку для отправки зависания ребенку, когда он выходит, а nohup устанавливает дочерний элемент для игнорирования зависаний.<br>Управление терминалом (+)<br>Оболочка использует три разных набора терминальных (`` tty '') режимов: `edit ', используемые при редактировании,` quote', используемые при цитировании буквенных символов и `execute ', используемые при выполнении команд. Оболочка содержит некоторые настройки в каждой константе режима, поэтому команды, которые оставляют tty в запутанном состоянии, не мешают оболочке. Оболочка также соответствует изменениям скорости и отступов tty. Список режимов tty, которые поддерживаются постоянными, может быть проверен и изменен с помощью встроенного setty. Обратите внимание, что хотя редактор использует режим CBREAK (или его эквивалент), он все равно принимает символы с набросками.<br><br>Команды echotc, settc и telltc могут использоваться для управления и отладки функций терминала из командной строки.<br><br>В системах, поддерживающих SIGWINCH или SIGWINDOW, оболочка автоматически адаптируется к размеру окна и настраивает переменные среды LINES и COLUMNS, если они установлены. Если переменная окружения TERMCAP содержит поля li # и co #, оболочка настраивает их, чтобы отобразить новый размер окна.<br>СПРАВКА<br>В следующих разделах этого руководства описываются все доступные команды Builtin, специальные псевдонимы и специальные переменные оболочки.<br><br>Встроенные команды<br><br>% работа<br>    Синоним команды fg builtin.<br>% job &amp;<br>    Синоним команды bg builtin.<br>:<br>    Ничего не делает, успешно.<br><br>@<br>@ name = expr<br>@ name [index] = expr<br>@ name ++ | -<br><br>@ name [index] ++ | -<br>    Первая форма печатает значения всех переменных оболочки.<br><br>        Вторая форма присваивает значение expr для имени. Третья форма присваивает значение expr индексовому компоненту имени; как имя, так и его индексный компонент уже должны существовать.<br><br>        expr может содержать операторы `* ',` +' и т. д., как в C. Если expr содержит `&lt;',`&gt;', `&amp; 'или`', то по крайней мере часть expr должна быть помещена в `( ). Обратите внимание, что синтаксис выражения expr не имеет ничего общего с описанным в разделе Выражения.<br><br>        Четвертое и пятое число приращений (`++ ') или декремент (` -') или его индексный компонент.<br><br>        Требуется пространство между `@ 'и именем. Пространства между именем и `= 'и между` =' и expr являются необязательными. Компоненты expr должны быть разделены пробелами.<br><br>псевдоним [name [wordlist]]<br>    Без аргументов печатает все псевдонимы. С именем печатает псевдоним для имени. С именем и списком слов назначает wordlist как псевдоним имени. wordlist - это команда и имя файла. имя не может быть alias или unalias. См. Также встроенную команду unalias.<br>Alloc<br>    Показывает объем приобретенной динамической памяти, разбитый на использованную и свободную память. В аргументе показано количество свободных и используемых блоков в каждой категории размеров. Категории начинаются с размера 8 и удваиваются на каждом шаге. Выход этой команды может различаться для разных типов систем, поскольку в системах, отличных от VAX, может использоваться другой распределитель памяти.<br>bg [% job ...]<br>    Помещает заданные задания (или, без аргументов, текущее задание) в фоновый режим, продолжая каждый, если он остановлен. job может быть числом, строкой, ``, `% ',` +' или `- ', как описано в разделе Рабочие места .<br><br>bindkey [-l | -d | -e | -v | -u] (+)<br>bindkey [-a] [-b] [-k] [-r] [-] (+)<br><br>bindkey [-a] [-b] [-k] [-c | -s] [-] команда клавиш (+)<br>    Без параметров первая форма перечисляет все связанные ключи и команду редактора, к которой привязана каждая, вторая форма перечисляет команду редактора, к которой привязан ключ, и третья форма связывает команду команды редактора с ключом. Варианты включают:<br><br>    -l<br>        Перечисляет все команды редактора и краткое описание каждого из них.<br>    -d<br>        Привязывает все ключи к стандартным связям для редактора по умолчанию.<br>    -e<br>        Привязывает все ключи к стандартным связям с GNU Emacs.<br>    -v<br>        Привязывает все ключи к стандартным связям vi (1).<br>    -a<br>        Перечисляет или меняет привязки клавиш на альтернативной карте ключей. Это ключевая карта, используемая в режиме командной строки vi.<br>    -b<br>        (например, `^ A ') или C-символ (например,` C-A'), метасимвольный символ M-символов (например, `M-A '), a функциональная клавиша, записанная F-строка (например, F-строка), или расширенный ключ префикса, написанный символом X (например, X-A).<br>    -k<br>        ключ интерпретируется как символическое имя клавиши стрелки, которое может быть одним из вниз, вверх, слева или справа.<br>    -р<br>        Удаляет привязку ключа. Будьте осторожны: `bindkey -r 'не связывает ключ с self-insert-command (q.v.), он полностью отключает ключ.<br>    -с<br>        команда интерпретируется как встроенная или внешняя команда вместо команды редактора.<br>    -s<br>        команда берется как буквальная строка и обрабатывается как вход терминала при вводе ключа. Связанные ключи в команде сами интерпретируются, и это продолжается для десяти уровней интерпретации.<br>    -<br>        Вызывает перерыв в обработке параметров, поэтому следующее слово считается ключевым, даже если оно начинается с -.<br>    -u (или любой недопустимый вариант)<br>        Распечатывает сообщение об использовании.<br><br>    ключ может быть одним символом или строкой. Если команда привязана к строке, первый символ строки привязан к вводу последовательности, и вся строка привязана к команде.<br><br>    Управляющие символы в ключе могут быть буквальными (их можно ввести, указав перед ними команду редактора quote quoted-insert, обычно привязанную к `^ V ') или написанный стиль символа каретки, например,` ^ A'. Удалить написано `^? ' (знак-вопросительный знак). ключ и команда могут содержать обратные слэш-последовательности (в стиле System V echo (1)) следующим образом:<br><br>    \колокольчик<br>        \ б<br>            возврат на одну позицию<br>        \ е<br>            Побег<br>        \ е<br>            Подача формы<br>        \ п<br>            Новая линия<br>        \р<br>            Возврат каретки<br>        \ т<br>            Горизонтальная вкладка<br>        \ v<br>            Вертикальная вкладка<br>        \ NNN<br>            Символ ASCII, соответствующий восьмеричному номеру nnn<br><br>    `\ 'аннулирует особый смысл следующего символа, если он имеет какие-либо, особенно` \' и `^ '.<br><br>bs2cmd bs2000-команда (+)<br>    Передает команду bs2000 команде интерпретатора команд BS2000 для выполнения. Могут выполняться только неинтерактивные команды, и невозможно выполнить любую команду, которая накладывает изображение текущего процесса, например / EXECUTE или / CALL-PROCEDURE. (Только для BS2000)<br>ломать<br>    Запускает выполнение для возобновления после окончания ближайшего окружения foreach или while. Остальные команды в текущей строке выполняются. Таким образом, возможны многоуровневые разрывы, записывая их на одной строке.<br>breaksw<br>    Вызывает перерыв от переключателя, возобновляющийся после окончания.<br>встроенные (+)<br>    Распечатывает имена всех встроенных команд.<br>bye (+)<br>    Синоним встроенной команды выхода из системы. Доступно только в том случае, если оболочка была скомпилирована; см. переменную оболочки версии.<br>метка корпуса:<br>    Метка в инструкции коммутатора, как описано ниже.<br>cd [-p] [-l] [-n | -v] [имя]<br>    Если задано имя каталога, изменяется имя рабочего каталога оболочки. Если нет, изменения в доме. Если имя `- ', оно интерпретируется как предыдущий рабочий каталог (см. Другие подстановки). (+) Если имя не является подкаталогом текущего каталога (и не начинается с `/ ',` ./' или `../ '), каждый компонент переменной cdpath проверяется, есть ли у него подкаталог имя. Наконец, если все остальное не удается, но имя - это переменная оболочки, значение которой начинается с `/ ', тогда это пытается увидеть, является ли это каталогом.<br><br>        С -p выводит окончательный стек каталогов, как и у dirs. Флаги -l, -n и -v оказывают такое же влияние на cd, что и на dirs, и они подразумевают -p. (+)<br><br>        См. Также переменную оболочки implicitcd.<br><br>ChDir<br>    Синоним для встроенной команды cd.<br>complete [command [word / pattern / list [: select] / [[suffix] /] ...]] (+)<br>    Без аргументов перечислены все доработки. С помощью команды, списки завершения для команды. С помощью команды и слова и т. Д. Определяет доработки.<br><br>        команда может быть полным именем команды или шаблоном glob (см. замену имен файлов). Он может начинаться с символа `- ', чтобы указать, что завершение должно использоваться только тогда, когда команда неоднозначна.<br><br>        слово определяет, какое слово относительно текущего слова должно быть завершено, и может быть одним из следующих:<br><br>            с<br>                Выполнение текущего слова. pattern - это шаблон glob, который должен соответствовать началу текущего слова в командной строке. шаблон игнорируется при заполнении текущего слова.<br>            С<br>                Как и c, но включает шаблон при заполнении текущего слова.<br>            N<br>                Завершение следующего слова. pattern - это шаблон glob, который должен соответствовать началу предыдущего слова в командной строке.<br>            N<br>                Как и n, но должно совпадать с началом слова два перед текущим словом.<br>            п<br>                Завершение позиции. pattern - это числовой диапазон, с тем же синтаксисом, который используется для индексации переменных оболочки, который должен включать текущее слово.<br><br>        список, список возможных завершений может быть одним из следующих:<br><br>            <br>                Псевдонимы<br>            б<br>                Привязки (команды редактора)<br>            с<br>                Команды (встроенные или внешние команды)<br>            С<br>                Внешние команды, начинающиеся с заданного префикса пути<br>            d<br>                Справочники<br>            D<br>                Каталоги, которые начинаются с поставленного префикса пути<br>            е<br>                Переменные среды<br>            е<br>                Имена файлов<br>            F<br>                Имена файлов, начинающиеся с заданного префикса пути<br>            г<br>                названия групп<br>            J<br>                работы<br>            L<br>                рамки<br>            N<br>                Ничего<br>            s<br>                Обозначения оболочки<br>            S<br>                сигналы<br>            T<br>                Обычные (`` text '') файлы<br>            T<br>                Обычные (`` text '') файлы, которые начинаются с указанного префикса пути<br>            v<br>                Любые переменные<br>            U<br>                Usernames<br>            Икс<br>                Как и n, но отпечатки выбирают, когда используются списки.<br>            Икс<br>                Пополнения<br>            $ вар<br>                Слова из переменной var<br>            (...)<br>                Слова из данного списка<br>            `...`<br>                Слова с вывода команды<br><br>                select - необязательный шаблон glob. Если дано, учитываются слова только из списка, которые соответствуют выбору, и переменная оболочки fignore игнорируется. Последние три типа завершения могут не иметь шаблона выбора, а х использует select в качестве пояснительного сообщения, когда используется команда редактора списка.<br><br>Суффикс - это один символ, который добавляется к успешному завершению. Если значение null, символ не добавляется. Если опустить (в этом случае четвертый разделитель также можно опустить), косая черта добавляется к каталогам и пробелу к другим словам.<br><br>Теперь для некоторых примеров. Некоторые команды принимают только каталоги в качестве аргументов, поэтому нет смысла заполнять простые файлы.<br><br>    &gt; полный cd 'p / 1 / d /'<br><br>завершает только первое слово, следующее за `cd '(` p / 1') с каталогом. Выполнение p-type также может использоваться для сужения завершения команды:<br><br>    &gt; co [^ D]<br>    полный компресс<br>    &gt; complete -co * 'p / 0 / (compress) /'<br>    &gt; co [^ D]<br>    &gt; сжать<br><br>Это завершение завершает команды (слова в позиции 0, `p / 0 '), которые начинаются с` co' (таким образом, сопоставляя `co * ') с` compress' (единственное слово в списке). Ведущий `- 'указывает, что это завершение должно использоваться только с двусмысленными командами.<br><br>    &gt; complete find 'n / -user / u /'<br><br>является примером завершения n-типа. Любое слово find и сразу после -user завершено из списка пользователей.<br><br>    &gt; полный cc 'c / -I / d /'<br><br>демонстрирует завершение c-типа. Любое слово, следующее за `cc 'и начинающееся с` -I', завершается как каталог. `-I 'не принимается как часть каталога, потому что мы использовали строчный код c.<br><br>Различные списки полезны для разных команд.<br><br>    &gt; полный псевдоним 'p / 1 / a /'<br>    &gt; полный человек 'p / * / c /'<br>    &gt; полный набор 'p / 1 / s /'<br>    &gt; complete true 'p / 1 / x: У правды нет вариантов. /'<br><br>Эти полные слова, следующие за псевдонимами с псевдонимами, человек с командами и набор с переменными оболочки. `true 'не имеет никаких параметров, поэтому x ничего не делает при попытке завершения и печатает` Truth не имеет параметров.' когда перечислены варианты завершения.<br><br>Обратите внимание, что пример человека и несколько других примеров ниже могли бы также использовать c / * или n / * как p / *.<br><br>Слова могут быть заполнены из переменной, оцененной во время завершения,<br><br>    &gt; complete ftp 'p / 1 / $ hostnames /'<br>    &gt; set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu)<br>    &gt; ftp [^ D]<br>    rtfm.mit.edu tesla.ee.cornell.edu<br>    &gt; ftp [^ C]<br>    &gt; set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net)<br>    &gt; ftp [^ D]<br>    rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net<br><br>или из командной строки во время завершения:<br><br>    &gt; complete kill 'p / * / `ps | awk \ {print \ \ $ 1 \} `/ '<br>    &gt; kill -9 [^ D]<br>    23113 23377 23380 23406 23429 23529 23530 PID<br><br>Обратите внимание, что полная команда сама не цитирует свои аргументы, поэтому скобки, пробел и `$ 'в` {print $ 1}' должны быть указаны явно.<br><br>Одна команда может иметь несколько завершений:<br><br>    &gt; полный dbx 'p / 2 / (core) /' 'p / * / c /'<br><br>завершает второй аргумент `dbx 'словом core и всеми другими аргументами с командами. Обратите внимание, что позиционное завершение задается до завершения следующего слова. Поскольку доработки оцениваются слева направо, если сначала было задано завершение следующего слова, оно всегда будет соответствовать, и позиционное завершение никогда не будет выполнено. Это обычная ошибка при определении завершения.<br><br>Шаблон выбора полезен, когда команда принимает файлы только с определенными формами в качестве аргументов. Например,<br><br>            &gt; complete cc 'p / * / f: *. [cao] /'<br><br>        завершает аргументы `cc 'для файлов, заканчивающихся только` .c', `.a 'или` .o'. select также может исключать файлы, используя отрицание шаблона glob, как описано в подмене Fileename. Можно было бы использовать<br><br>            &gt; полный rm 'p / * / f: ^ *. {c, h, cc, C, tex, 1, man, l, y} /'<br><br>        чтобы исключить ценный исходный код из rm. Конечно, все же можно было бы ввести исключенные имена вручную или переопределить механизм завершения, используя команды полного слова-raw или list-choice-raw editor (q.v.).<br><br>        Списки `C ',` D', `F 'и` T' похожи на `c ',` d', `f 'и` t' соответственно, но они используют аргумент select по-другому: для ограничения завершения к файлам, начинающимся с определенного префикса пути. Например, почтовая программа Elm использует `= 'в качестве аббревиатуры для своего почтового каталога. Можно было бы использовать<br><br>            &gt; полный elm c @ = @ F: $ HOME / Mail / @<br><br>        для завершения `elm -f = ', как если бы это было` elm -f ~ / Mail /'. Обратите внимание, что мы использовали `@ 'вместо` /', чтобы избежать путаницы с аргументом select, и мы использовали `$ HOME 'вместо` ~', потому что замена в домашнем каталоге работает только с началом слова.<br><br>        суффикс используется для добавления нестандартного суффикса (не пробела или `/ 'для каталогов) к завершенным словам.<br><br>            &gt; полный палец 'c / * @ / $ hostnames /' 'p / 1 / u / @'<br><br>        завершает аргументы finger из списка пользователей, добавляет @, а затем завершается после @ из переменной hostnames. Еще раз обратите внимание на порядок, в котором указаны пополнения.<br><br>        Наконец, вот сложный пример для вдохновения:<br><br>            &gt; полный поиск \<br>            'n / -name / f /' 'n / -newer / f /' 'n / - {, n} cpio / f /' \<br>            'n / -exec / c /' 'n / -ok / c /' 'n / -user / u /' \<br>            'n / -группа / g /' 'n / -fstype / (nfs 4.2) /' \<br>            'n / -тип / (b c d f l p s) /' \<br>            'c / - / (name newer cpio ncpio exec ok user \<br>            группа fstype type atime ctime depth inum \<br>            ls mtime nogroup nouser perm print prune \<br>            размер xdev) / '\<br>            'Р / * / д /'<br><br>        Это завершает слова, следующие за следующими словами: -name, -newer, -cpio или ncpio (обратите внимание на шаблон, который соответствует обоим), на файлы, слова, следующие за командами -exec или -ok, user 'и `group' для пользователей и групп соответственно и слов, следующих за` -fstype 'или `-type' членам этих списков. Он также завершает сами переключатели из данного списка (обратите внимание на использование слияния типа c) и завершает все, что не завершено в каталог. Уф.<br><br>        Помните, что запрограммированные завершения игнорируются, если заполняемое слово является подстановкой тильды (начиная с `~ ') или переменной (начиная с` $'). complete - экспериментальная функция, и синтаксис может измениться в будущих версиях оболочки. См. Также незавершенную встроенную команду.<br><br>Продолжать<br>    Продолжает выполнение ближайшего приложения while или foreach. Остальные команды в текущей строке выполняются.<br>по умолчанию:<br>    Обозначает случай по умолчанию в инструкции switch. Он должен появиться после всех ярлыков.<br><br>dirs [-l] [-n | -v]<br>dirs -S | -L [имя_файла] (+)<br><br>dirs -c (+)<br>    Первая форма печатает стек каталога. Верх стека находится слева, а первый каталог в стеке - это текущий каталог. При использовании -l, `~ 'или` ~ name' в выводе явно указывается на дом или путь к домашнему каталогу для имени пользователя. (+) С -n записи завертываются до того, как они достигают края экрана. (+) С -v, записи печатаются по одному на строку, перед которыми расположены позиции стека. (+) Если задано более одного -n или -v, -v имеет приоритет. -p принимается, но ничего не делает.<br><br>        С -S вторая форма сохраняет стек каталога в filename как последовательность команд cd и pushd. С -L - имя файла shell, имя которого, по-видимому, является файлом стека каталога, сохраненным параметром -S или механизмом savedirs. В любом случае dirsfile используется, если имя файла не указано, а ~ / .cshdirs используется, если dirsfile не установлен.<br><br>        Обратите внимание, что при запуске в качестве входных оболочек выполняются эквиваленты `dirs -L ', и, если для них выбрано savedirs,` dirs -S' перед выходом. Поскольку обычно ~ / .tcshrc обычно используется до ~ / .cshdirs, dirsfile должен быть установлен в ~ / .tcshrc, а не ~ / .login.<br><br>        Последняя форма очищает стек каталога.<br><br>echo [-n] word ...<br>    Записывает каждое слово в стандартный вывод оболочки, разделяя пробелы и заканчивая новой строкой. Переменная оболочки echo_style может быть настроена на эмулирование (или нет) флагов и escape-последовательностей версий эхо-сигнала BSD и / или System V; см. эхо (1).<br>echotc [-sv] arg ... (+)<br>    Управляет возможностями терминала (см. Termcap (5)) в args. Например, echotc home отправляет курсор в исходное положение, echotc cm 3 10 отправляет его в столбец 3 и строку 10 и echotc ts 0; echo "Это тест."; echotc fs 'prints "Это тест". в строке состояния.<br><br>        Если arg - бод, кол, линии, мета или вкладки, печатает значение этой возможности (да или нет, указывающее, что терминал имеет или не имеет этой возможности). Можно использовать это, чтобы сделать вывод из сценария оболочки менее подробным на медленных терминалах или вывести команду ограничения на количество строк на экране:<br><br>            &gt; set history = `echotc lines`<br>            &gt; @ history--<br><br>        Строки termcap могут содержать подстановочные знаки, которые не будут правильно отображаться. При установке переменной оболочки в строку возможностей терминала следует использовать двойные кавычки, как в следующем примере, который помещает дату в строку состояния:<br><br>            &gt; set tosl = "` echotc ts 0` "<br>            &gt; set frsl = "` echotc fs` "<br>            &gt; echo -n "$ tosl"; date; echo -n "$ frsl"<br><br>        С -s, несуществующие возможности возвращают пустую строку, а не вызывают ошибку. С -v сообщения являются подробными.<br><br>еще<br>конец<br>ENDIF<br><br>endsw<br>    См. Описание инструкций foreach, if, switch и while ниже.<br>eval arg ...<br>    Рассматривает аргументы как ввод в оболочку и выполняет результирующие команды в контексте текущей оболочки. Обычно это используется для выполнения команд, сгенерированных в результате замены команды или переменной, поскольку синтаксический анализ происходит до этих подстановок. См. Tset (1) для выборочного использования eval.<br>команда exec<br>    Выполняет указанную команду вместо текущей оболочки.<br>exit [expr]<br>    Оболочка выходит либо со значением указанного выражения expr (выражение, как описано в разделе Выражения), либо без выражения expr со значением переменной состояния.<br>fg [% job ...]<br>    Приводит заданные задания (или, без аргументов, текущее задание) на передний план, продолжая каждый, если он остановлен. job может быть числом, строкой, ``, `% ',` +' или `- ', как описано в разделе Рабочие места . См. Также команду редактора run-fg-editor.<br>filetest -op file ... (+)<br>    Применяет op (который является оператором запроса файла, как описано в Операторах поиска файлов) для каждого файла и возвращает результаты в виде списка, разделенного пробелом.<br><br>имя foreach (список слов)<br>...<br><br>конец<br>    Последовательно присваивает имя переменной каждому члену списка слов и выполняет последовательность команд между этой командой и совпадающим концом. (Оба типа foreach и end должны появляться отдельно на отдельных строках.) Встроенная команда continue может использоваться для продолжения цикла преждевременно, а встроенная команда прерывается, чтобы прервать ее преждевременно. Когда эта команда считывается с терминала, цикл читается после запроса с помощью `foreach? '(или prompt2) перед выполнением любых операторов цикла. Если вы допустили ошибку, набрав в цикле на терминале, вы можете вытереть ее.<br>getpath (+)<br>    Распечатывает путь выполнения системы. (Только TCF)<br>getxvers (+)<br>    Распечатывает префикс экспериментальной версии. (Только TCF)<br>glob wordlist<br>    Подобно echo, но никаких escape-символов `\ 'не распознаются, а слова ограничены нулевыми символами на выходе. Полезно для программ, которые хотят использовать оболочку для имени файла, расширить список слов.<br>goto word<br>    word - имя файла и команда - подставляются, чтобы получить строку формы `label '. Оболочка перематывает свой вход как можно больше, ищет строку формы label:, возможно, которой предшествуют пробелы или вкладки, и продолжает выполнение после этой строки.<br><br>    hashstat<br>    Распечатывает строку статистики, указывающую, насколько эффективна внутренняя таблица хеш-файла при определении команд (и исключение exec). Выполняется попытка exec для каждого компонента пути, где хеш-функция указывает на возможный удар, и в каждом компоненте, который не начинается с `/ '.<br>    На машинах без vfork (2) выводится только количество и размер хэш-ковшей.<br><br>история [-hTr] [n]<br>история -S | -L | -M [имя_файла] (+)<br><br>history -c (+)<br>    Первая форма печатает список событий истории. Если n задано, выводится или сохраняется только n самых последних событий. С -h список истории печатается без ведущих номеров. Если указано -T, отметки времени печатаются также в форме комментариев. (Это можно использовать для создания файлов, подходящих для загрузки с помощью history -L или source -h.) С -r порядок печати сначала является первым, а не самым старым.<br><br>        С -S вторая форма сохраняет список истории в имени файла. Если в первом слове переменной оболочки savehist задано число, самое большее, что многие строки сохраняются. Если для второго слова savehist установлено значение merge, список истории объединяется с существующим файлом истории вместо его замены (если есть) и сортируется по метке времени. (+) Слияние предназначено для такой среды, как X Window System, с несколькими ракетами при одновременном использовании. В настоящее время он преуспевает только тогда, когда оболочки прекрасны друг за другом.<br><br>        С -L оболочка добавляет имя файла, которое, по-видимому, является списком истории, сохраненным параметром -S или механизмом savehist, в список истории. -M похож на -L, но содержимое имени файла сливается в список истории и сортируется по метке времени. В любом случае файл histfile используется, если имя файла не задано, а ~ / .history используется, если файл histfile не установлен. `history -L 'в точности похож на' source -h ', за исключением того, что для него не требуется имя файла.<br><br>        Обратите внимание, что при запуске в качестве входных оболочек выполняются эквиваленты `history -L ', и, если savehist установлен,` history -S' перед выходом. Поскольку только ~ / .tcshrc обычно используется до ~ / .history, файл hist должен быть установлен в ~ / .tcshrc, а не ~ / .login.<br><br>        Если задано значение histlit, первая и вторая формы печатают и сохраняют литеральную (нерасширенную) форму списка истории.<br><br>        Последняя форма очищает список истории.<br><br>hup [команда] (+)<br>    С командой запускает команду, чтобы она выходила из сигнала зависания и устраивала для оболочки отправку сигнала зависания при выходе оболочки. Обратите внимание, что команды могут устанавливать свой собственный ответ на зависания, переопределяя hup. Без аргумента (разрешено только в сценарии оболочки), заставляет оболочку выйти из зависания для остальной части скрипта. См. Также Обработка сигналов и команда nohup builtin.<br>if (expr) команда<br>    Если выражение (выражение, как описано в разделе Выражения) оценивает значение Истина, выполняется команда. Перестановка переменных в команде происходит раньше, в то же время она выполняется для остальной команды if. команда должна быть простой командой, а не псевдонимом, конвейером, списком команд или списком команд в скобках, но может иметь аргументы. Перенаправление ввода / вывода происходит, даже если expr имеет значение false, и команда, таким образом, не выполняется; это ошибка.<br><br>if (expr), тогда<br>...<br>else if (expr2) then<br>...<br>еще<br>...<br><br>ENDIF<br>    Если указанное выражение истинно, тогда выполняются команды для первого else; в противном случае, если expr2 истинно, тогда выполняются команды ко второму другому и т. д. Возможны любые пары else-if; требуется только один endif. Другая часть также необязательна. (Слова else и endif должны появляться в начале строк ввода, а если они должны появляться отдельно в строке ввода или после else.)<br>inlib shared-library ... (+)<br>    Добавляет каждую общую библиотеку в текущую среду. Невозможно удалить общую библиотеку. (Только для домена / ОС)<br>рабочие места [-l]<br>    Перечисляет активные задания. С -l перечисляет идентификаторы процессов в дополнение к обычной информации. В TCF-системах печатает сайт, на котором выполняется каждое задание.<br><br>kill [-s signal]% job | pid ...<br>kill -l<br>    Первая и вторая формы отправляют указанный сигнал (или, если ни один не указан, сигнал TERM (завершение)) к указанным заданиям или процессам. job может быть числом, строкой, ``, `% ',` +' или `- ', как описано в разделе Рабочие места . Сигналы либо задаются по числу, либо по имени (как указано в /usr/include/signal.h, лишен префикса `SIG '). Работа по умолчанию отсутствует; говоря, что kill не посылает сигнал текущему заданию. Если посылаемый сигнал - TERM (завершение) или HUP (зависание), то задание или процесс отправляется также сигнал CONT (продолжение). В третьей форме перечислены имена сигналов.<br><br>    limit [-h] [ресурс [максимальное использование]]<br>    Ограничивает потребление текущим процессом и каждым процессом, который он создает, чтобы индивидуально не превышать максимальное использование на указанном ресурсе. Если максимальное использование не указано, тогда печатается текущий предел; если ресурс не задан, тогда даются все ограничения. Если задан флаг -h, вместо текущих ограничений используются жесткие лимиты. Жесткие лимиты налагают потолок на значения текущих пределов. Только суперпользователь может поднять жесткие ограничения, но пользователь может снизить или увеличить текущие пределы в пределах правового диапазона.<br><br>        Контролируемые ресурсы в настоящее время включают (если поддерживается ОС):<br><br>        cputime<br>            максимальное количество процессорных секунд, которое будет использоваться каждым процессом<br>        размер файла<br>            самый большой один файл, который можно создать<br>        DataSize<br>            максимальный рост области данных + стек через sbrk (2) за пределами текста программы<br>        STACKSIZE<br>            максимальный размер области с расширенным стеком автоматически<br>        coredumpsize<br>            размер самого большого дампа ядра, который будет создан<br>        memoryuse<br>            максимальный объем физической памяти, который может быть выделен ему процессом в данный момент времени<br>        heapsize<br>            максимальный объем памяти, который может распределить процесс на каждый вызов brk ()<br>        дескрипторы или открытые файлы<br>            максимальное количество открытых файлов для этого процесса<br>        совпадение<br>            максимальное количество потоков для этого процесса<br>        memorylocked<br>            максимальный размер, который процесс может блокировать в памяти с помощью mlock (2)<br>        maxproc<br>            максимальное количество одновременных процессов для этого идентификатора пользователя<br><br>

sbsize<br>            максимальный размер использования буфера сокета для этого пользователя<br><br>        максимальное использование может быть задано как число с плавающей точкой или целое число, за которым следует масштабный коэффициент. Для всех ограничений, отличных от cputime, по умолчанию используется значение k или килобайт (1024 байта); может также использоваться масштабный коэффициент m или мегабайт. Для cputime масштабирование по умолчанию - `секунды ', в то время как` m' в минутах или `h 'в течение нескольких часов, или время формы` mm: ss', указывающее минуты и секунды.<br><br>        Для имен ресурсов и масштабных коэффициентов достаточно однозначных префиксов имен.<br><br>log (+)<br>    Распечатывает переменную оболочки часового механизма и сообщает каждому пользователю, указанному в часах, кто вошел в систему, независимо от того, когда они в последний раз вошли в систему. См. Также watchlog.<br>авторизоваться<br>    Завершает оболочку входа, заменяя ее экземпляром / bin / login. Это один из способов выйти из системы, включенный для совместимости с sh (1).<br>выйти<br>    Завершает оболочку входа. Особенно полезно, если ignoreeof установлен.<br>ls-F [-switch ...] [файл ...] (+)<br>    Списки файлов, такие как `ls -F ', но намного быстрее. Он идентифицирует каждый тип специального файла в списке со специальным символом:<br><br>    /<br>        каталог<br>    *<br>        исполнимый<br>    #<br>        Блочное устройство<br>    %<br>        Символьное устройство<br>    |<br>        Именованная труба (только с именованными трубами)<br>    знак равно<br>        Розетка (только с разъемами)<br>    @<br>        Символическая ссылка (системы с символическими ссылками)<br>    +<br>        Скрытый каталог (только для AIX) или контекстно-зависимый (только для HP / UX)<br>    :<br>        Специальная сеть (только для HP / UX)<br><br>    Если задана переменная оболочки listlinks, символические ссылки идентифицируются более подробно (только для систем, которые имеют их, конечно):<br><br>    @<br>        Символическая ссылка на некаталог<br>    &gt;<br>        Символическая ссылка на каталог<br>    &amp;<br>        Символическая ссылка в никуда<br><br>    listlinks также замедляет ls-F и вызывает разделы, содержащие файлы, на которые указывают символические ссылки для монтирования.<br><br>    Если переменная оболочки listflags установлена в `x ',` a' или `A 'или любая их комбинация (например,` xA'), они используются как флаги для ls-F, заставляя ее действовать как `ls -xF ', `ls -Fa',` ls -FA 'или комбинацию (например, `ls -FxA'). На машинах, где `ls -C 'не является значением по умолчанию, ls-F действует как` ls -CF', если listflags не содержит `x ', и в этом случае он действует как` ls -xF'. ls-F передает свои аргументы в ls (1), если ему заданы какие-либо переключатели, поэтому alias ls ls-F обычно делает правильные вещи.<br><br>    Встроенный ls-F может отображать файлы с использованием разных цветов в зависимости от типа файла или расширения. См. Переменную цвета tcsh и переменную среды LS_COLORS.<br><br>migrate [-site] pid |% jobid ... (+)<br><br>migrate -site (+)<br>    Первая форма переносит процесс или задание на указанный сайт или сайт по умолчанию, определяемый системным путем. Вторая форма эквивалентна `migrate -site $$ ': она переносит текущий процесс на указанный сайт. Миграция оболочки сама по себе может привести к неожиданному поведению, потому что оболочка не любит терять ее. (Только TCF)<br>newgrp [-] группа (+)<br>    Эквивалент `exec newgrp '; см. newgrp (1). Доступно только в том случае, если оболочка была скомпилирована; см. переменную оболочки версии.<br>nice [+ number] [команда]<br>    Устанавливает приоритет диспетчеризации для номера оболочки или, без номера, 4. С командой запускает команду с соответствующим приоритетом. Чем больше число, тем меньше процессор получает процесс. Суперпользователь может указать отрицательный приоритет, используя `nice -number ... '. Команда всегда выполняется в под-оболочке, и применяются ограничения на команды в простых операциях if.<br>nohup [команда]<br>    С помощью команды запускается команда, так что она будет игнорировать сигналы зависания. Обратите внимание, что команды могут устанавливать свой собственный ответ на зависания, переопределяя nohup. Без аргумента (допускается только сценарий оболочки), заставляет оболочку игнорировать зависания для остальной части скрипта. См. Также Обработка сигналов и команда hup builtin.<br>уведомлять [% job ...]<br>    Заставляет оболочку уведомлять пользователя асинхронно, когда изменяется состояние любого из заданных заданий (или, без задания%, текущего задания), вместо ожидания до следующего приглашения, как обычно. job может быть числом, строкой, ``, `% ',` +' или `- ', как описано в разделе Рабочие места . См. Также переменную оболочки уведомления.<br>onintr [- | label]<br>    Управляет действием оболочки на прерываниях. Без аргументов восстанавливает действие оболочки по умолчанию на прерываниях, что означает прекращение сценариев оболочки или возврат к входному уровню команды терминала. С `- ', все прерывания игнорируются. С меткой вызывает оболочку для выполнения goto label при получении прерывания или завершение дочернего процесса, поскольку он был прерван.<br>    onintr игнорируется, если оболочка работает отдельно и в файлах запуска системы (см. ФАЙЛЫ), где прерывания в любом случае отключены.<br>popd [-p] [-l] [-n | -v] [+ n]<br>    Без аргументов выталкивает стек каталога и возвращается в новый верхний каталог. С номером `+ n 'отбрасывает n-й элемент в стеке.<br>    Наконец, все формы popd печатают финальный стек каталога, как и dirs. Передвинутую переменную оболочки можно установить для предотвращения этого, и флаг -p может быть задан для переопределения pushdsilent. Флаги -l, -n и -v оказывают такое же влияние на popd, что и на dirs. (+)<br>printenv [имя] (+)<br>    Распечатывает имена и значения всех переменных среды или, с именем, значение имени переменной среды.<br>pushd [-p] [-l] [-n | -v] [имя | + n]<br>    Без аргументов обменивается двумя верхними элементами стека каталога. Если pushdtohome установлен, pushd без аргументов `pushd ~ ', как cd. (+) С именем, толкает текущий рабочий каталог в стек каталога и изменяется на имя. Если имя `- ', оно интерпретируется как предыдущий рабочий каталог (см. Замену имен файлов). (+) Если dunique установлен, pushd удаляет все экземпляры имени из стека, прежде чем нажимать его на стек. (+) С номером `+ n 'вращает n-й элемент стека каталога вокруг, чтобы быть верхним элементом и изменяется на него. Однако если dextract установлен, `pushd + n 'извлекает n-й каталог, толкает его в верхнюю часть стека и изменяет на него. (+)<br>    Наконец, все формы pushd выводят окончательный стек директории, как и dirs. Передвинутую переменную оболочки можно установить для предотвращения этого, и флаг -p может быть задан для переопределения pushdsilent. Флаги -l, -n и -v оказывают одинаковое влияние на pushd как на dirs. (+)<br>перепев<br>    Заставляет внутреннюю хеш-таблицу содержимого каталогов переменной пути перечитать. Это необходимо, если новые команды добавляются в каталоги в пути во время входа в систему. Это необходимо, только если вы добавляете команды в один из ваших собственных каталогов или системный программист меняет содержимое одного из системных каталогов. Также очищает кеш домашних каталогов, созданных расширением тильды.<br><br>    команда повторного подсчета<br>    Указанная команда, которая подчинена тем же ограничениям, что и команда в одной строке, если указано выше, выполняется как раз счетчик. Переадресация ввода-вывода происходит ровно один раз, даже если счетчик равен 0.<br>rootnode // nodename (+)<br>    Изменяет rootnode на // nodename, так что `/ 'будет интерпретироваться как` // nodename'. (Только для домена / ОС)<br><br>расписание (+)<br>sched [+] hh: mm command (+)<br><br>sched -n (+)<br>    Первая форма печатает список запланированных событий. Переменная оболочки плаката может быть задана так, чтобы определять формат, в котором печатается список запланированных событий. Вторая форма добавляет команду в список запланированных событий. Например,<br><br>            &gt; sched 11:00 echo Это одиннадцать часов.<br><br>        заставляет оболочку эхо Это одиннадцать часов. в 11:00. Время может быть в 12-часовом формате AM / PM<br><br>            &gt; sched 5pm set prompt = '[% h] После 5; вернуться домой:&gt; '<br><br>        или может относиться к текущему времени:<br><br>            &gt; sched +2: 15 / usr / lib / uucp / uucico -r1 -sother<br><br>        Относительная спецификация времени может не использовать формат AM / PM. Третья форма удаляет элемент n из списка событий:<br><br>            &gt; расписание<br><br>                 1 Ср Апр 4 15:42 / usr / lib / uucp / uucico -r1 -sother<br><br>                 2 ср. Apr 4 17:00 set prompt = [% h] После 5; вернуться домой:&gt;<br>            &gt; sched -2<br>            &gt; расписание<br><br>                 1 Ср Апр 4 15:42 / usr / lib / uucp / uucico -r1 -sother<br><br>        Команда в списке запланированных событий выполняется до того, как первое приглашение будет напечатано после того, как будет запланирована команда. Можно пропустить точное время выполнения команды, но просроченная команда будет выполнена в следующем запросе. Команда, которая приходит, когда оболочка ждет ввода пользователя, выполняется немедленно. Однако нормальная работа уже запущенной команды не прерывается, так что может быть запущен элемент списка запланированного события.<br><br>        Этот механизм похож на, но не совпадает с командой at (1) на некоторых Unix-системах. Его основным недостатком является то, что он может не выполнять команду точно в указанное время. Его главным преимуществом является то, что поскольку sched запускается непосредственно из оболочки, у него есть доступ к переменным оболочки и другим структурам. Это обеспечивает механизм изменения рабочей среды в зависимости от времени суток.<br><br>задавать<br>Имя набора ...<br>set name = word ...<br>set [-r] [-f | -l] name = (wordlist) ... (+)<br>set name [index] = word ...<br>set -r (+)<br>set -r name ... (+)<br><br>set -r name = word ... (+)<br>    Первая форма команды печатает значение всех переменных оболочки. Переменные, содержащие более одного слова, печатаются в виде списка слов в скобках. Вторая форма задает имя нулевой строке. Третья форма устанавливает имя для одного слова. Четвертая форма устанавливает имя для списка слов в списке слов. Во всех случаях значение - это команда и имя файла. Если указано значение -r, значение устанавливается только для чтения. Если заданы -f или -l, задайте только уникальные слова, сохраняющие их порядок. -f предпочитает первое вхождение слова, а -l последнее. Пятая форма устанавливает компонент index'th от имени к слову; этот компонент уже должен существовать. В шестой форме перечислены только имена всех переменных оболочки, которые доступны только для чтения. Седьмая форма делает имя только для чтения, независимо от того, имеет ли оно значение. Вторая форма задает имя нулевой строке. Восьмая форма такая же, как и третья форма, но одновременно делает имя только для чтения.<br>    Эти аргументы можно повторить, чтобы установить и / или сделать только переменные только для чтения в одной команде набора. Обратите внимание, однако, что расширение переменной происходит для всех аргументов до того, как возникнет какая-либо настройка. Также обратите внимание, что `= 'может быть смежным с именем и словом или отделенным от обоих пробелом, но не может быть смежным только с одним или другим. См. Также команду unset builtin.<br><br>    setenv [имя [значение]]<br>    Без аргументов печатает имена и значения всех переменных среды. Данное имя задает имя переменной среды для значения или, без значения, для нулевой строки.<br>путь setpath (+)<br>    Эквивалент setpath (1). (Только для Маха)<br>setpath LOCAL | сайт | cpu ... (+)<br>    Устанавливает путь выполнения системы. (Только TCF)<br>значение уставки (+)<br>    Сообщает оболочке полагать, что ограничение возможности терминала (как определено в termcap (5)) имеет значение. Проверка работоспособности не производится. Пользователям терминалов терминалов может потребоваться `settc xn no 'для правильной упаковки в крайнем правом столбце.<br>setty [-d | -q | -x] [-a] [[+ | -] mode] (+)<br>    Контролирует, какие режимы tty (см. Управление терминалом) оболочка не позволяет изменять. -d, -q или -x указывает setty действовать на набор edit, quote или execute tty соответственно; без -d, -q или -x, `execute '.<br>    Без других аргументов setty перечисляет режимы в выбранном наборе, которые фиксируются (`+ mode ') или off (` -mode'). Доступные режимы и, следовательно, дисплей, варьируются от системы к системе. С -a перечисляет все tty-режимы в выбранном наборе независимо от того, фиксированы они или нет. В режиме +, режиме или режиме фиксируется или выключается режим или удаляется из режима в выбранном наборе. Например, setty + echok echoe фиксирует режим echok и позволяет командам включать или выключать режим echoe, как при выполнении команд.<br>setxvers [string] (+)<br>    Установите префикс экспериментальной версии в строку или удалите его, если строка опущена. (Только TCF)<br>shift [переменная]<br>    Без аргументов отбрасывает argv [1] и сдвигает элементы argv влево. Это ошибка для argv, которая не должна быть установлена или иметь меньше одного слова в качестве значения. С переменной выполняет ту же функцию для переменной.<br>источник [-h] name [args ...]<br>    Оболочка читает и выполняет команды от имени. Команды не помещаются в список истории. Если заданы какие-либо аргументы, они помещаются в argv. (+) исходные команды могут быть вложенными; если они слишком глубоко вложены, оболочка может закончиться файловыми дескрипторами. Ошибка в источнике на любом уровне завершает все вложенные исходные команды. С -h команды помещаются в список истории, а не выполняются, как `history -L '.<br>stop% job | pid ...<br>    Остановка заданий или процессов, выполняемых в фоновом режиме. job может быть числом, строкой, ``, `% ',` +' или `- ', как описано в разделе Рабочие места . Работа по умолчанию отсутствует; говоря, что остановка не останавливает текущую работу.<br>приостановить<br>    Заставляет оболочку останавливаться на своих дорожках, как если бы она была отправлена сигналом остановки с помощью ^ Z. Это чаще всего используется для остановки оболочек, начинающихся с su (1).<br><br>переключатель (строка)<br>case str1:<br><br>    ...<br>    breaksw<br><br>...<br><br>по умолчанию:<br><br>    ...<br>    breaksw<br>endsw<br>    Каждая метка случая последовательно сопоставляется с указанной строкой, которая является первой командой и расширением имени файла. Метасимволы файла `* ',`?' и `[...] 'могут использоваться в ярлыках case, которые изменяются по переменной. Если ни одна из ярлыков не совпадала до того, как была найдена метка default, выполнение начинается после метки по умолчанию. Каждая метка случая и метка по умолчанию должны появляться в начале строки. Командный breaksw заставляет выполнение продолжить работу после endsw. В противном случае управление может проходить через метки меток и метки по умолчанию, как в C. Если ни одна метка не соответствует, и по умолчанию не выполняется, выполнение продолжается после окончания.<br>telltc (+)<br>    Перечисляет значения всех возможностей терминала (см. Termcap (5)).<br>termname [тип терминала] (+)<br>    Тесты, если тип терминала (или текущее значение TERM, если нет типа терминала), имеет запись в базе данных termcap (5) или terminfo (5). Распечатывает тип терминала в stdout и возвращает 0, если запись присутствует в противном случае возвращает 1.<br>время [команда]<br>    Выполняет команду (которая должна быть простой командой, а не псевдонимом, конвейером, списком команд или списком команд в скобках) и выводит сводку времени, как описано в переменной времени. При необходимости создается дополнительная оболочка для печати статистики времени, когда команда завершается. Без команды печатает сводку времени для текущей оболочки и ее дочерних элементов.<br>umask [значение]<br>    Устанавливает маску создания файла для значения, которое дается в восьмеричном. Общие значения для маски - 002, предоставляя весь доступ к группе, а также чтение и выполнение доступа к другим, и 022, предоставляя доступ к группе и другим пользователям доступ к чтению и выполнению. Без значения печатает текущую маску создания файла.<br>шаблон unalias<br><br>Удаляет все псевдонимы, имена которых соответствуют шаблону. `unalias * 'таким образом удаляет все псевдонимы. Это не ошибка, потому что ничто не может быть безуспешным.<br>незавершенный рисунок (+)<br>    Удаляет все пополнения, чьи имена соответствуют шаблону. `uncomplete * 'таким образом удаляет все пополнения. Это не ошибка, потому что ничего не должно быть незавершенным.<br>unhash<br>    Отключает использование внутренней хэш-таблицы для ускорения размещения исполняемых программ.<br>Вселенная Вселенная (+)<br>    Устанавливает юниверс для юниверса. (Только для Masscomp / RTU)<br>unlimit [-h] [ресурс]<br>    Удаляет ограничение ресурса или, если ресурс не указан, все ограничения ресурсов. С -h соответствующие жесткие пределы удаляются. Только суперпользователь может это сделать. Обратите внимание, что unlimit не может завершиться успешно, так как большинство систем не допускают, чтобы дескрипторы были неограниченными.<br>unset pattern<br>    Удаляет все переменные, имена которых соответствуют шаблону, если только они не доступны только для чтения. `unset * ', таким образом, удаляет все переменные, если только они не доступны только для чтения; Это плохая идея. Это не ошибка, потому что ничего не должно быть отменено.<br>unsetenv pattern<br>    Удаляет все переменные среды, чьи имена соответствуют шаблону. `unsetenv * 'таким образом удаляет все переменные среды; Это плохая идея. Это не ошибка, потому что ничего не происходит.<br>ver [systype [команда]] (+)<br>    Без аргументов печатает SYSTYPE. С помощью systype задает SYSTYPE для systype. С помощью systype и команды выполняется команда под systype. systype может быть `bsd4.3 'или` sys5.3'. (Только для домена / ОС)<br>Подождите<br>    Оболочка ждет всех фоновых заданий. Если оболочка является интерактивной, прерывание прерывает ожидание и заставляет оболочку печатать имена и номера заданий всех выдающихся заданий.<br>warp universe (+)<br>    Устанавливает юниверс для юниверса. (Только выпуклый / OS)<br>watchlog (+)<br>    Альтернативное имя для встроенной команды log (q.v.). Доступно только в том случае, если оболочка была скомпилирована; см. переменную оболочки версии.<br>где команда (+)<br>    Сообщает обо всех известных экземплярах команды, включая псевдонимы, встроенные и исполняемые файлы в пути.<br>какая команда (+)<br>    Отображает команду, которая будет выполняться оболочкой после замещений, поиск путей и т. Д. Встроенная команда похожа на то, что (1), но она корректно сообщает псевдонимы и встроенные значения tcsh и в 10-100 раз быстрее. См. Также команду редактора команды.<br><br>while (expr)<br>...<br><br>конец<br>    Выполняет команды между временем и совпадающим концом, в то время как expr (выражение, как описано в разделе Выражения) оценивает ненулевое значение. while и end должны появляться только на своих входных строках. break и continue могут использоваться для прекращения или продолжения цикла преждевременно. Если вход является терминалом, пользователю предлагается первый раз через цикл, как и для foreach.<br><br> <br>Специальные псевдонимы (+)<br>Если установлено, каждая из этих псевдонимов выполняется автоматически в указанное время. Все они изначально не определены.<br><br>beepcmd<br>    Выполняется, когда оболочка хочет позвонить в колокол терминала.<br><br>    cwdcmd<br>    Запускается после каждого изменения рабочего каталога. Например, если пользователь работает над системой окон X с использованием xterm (1) и диспетчера окон восходящего родителя, который поддерживает заголовки, такие как twm (1) и делает<br><br>            &gt; alias cwdcmd 'echo -n "^ [] 2; $ {HOST}: $ cwd ^ G"'<br><br>        то оболочка изменит заголовок работающего xterm (1) как имя хоста, двоеточия и полный рабочий каталог. Более удобный способ сделать это<br><br>            &gt; alias cwdcmd 'echo -n "^ [] 2; $ {HOST}: $ cwd ^ G ^ [] 1; $ {HOST} ^ G"'<br><br>        Это поместит имя хоста и рабочий каталог в строку заголовка, но только имя хоста в меню диспетчера значков.<br><br>        Обратите внимание, что установка cd, pushd или popd в cwdcmd может привести к бесконечному циклу. По мнению автора, любой, кто сделает это, получит то, что заслуживает.<br><br>jobcmd<br>    Выполняется перед выполнением каждой команды или при изменении состояния команды. Это похоже на postcmd, но он не печатает встроенные.<br><br>            &gt; alias jobcmd 'echo -n "^ [] 2 \; \! # ^ G"'<br><br>        то выполнение vi foo.c поместит командную строку в строку заголовка xterm.<br><br>helpcommand<br>    Вызывается командой редактора run-help. Имя команды, для которой запрашивается помощь, передается как единственный аргумент. Например, если вы это сделаете<br><br>            &gt; alias helpcommand '\ !: 1 --help'<br><br>        то будет вызываться отображение справки самой команды, используя соглашение о вызове GNU. В настоящее время нет простого способа учета различных соглашений вызова (например, обычного Unix -h), за исключением использования таблицы из множества команд.<br><br>периодический<br>    Запускает каждую минуту. Это обеспечивает удобное средство для проверки обычных, но редких изменений, таких как новая почта. Например, если вы это сделаете<br><br>            &gt; set tperiod = 30<br>            &gt; псевдоним периодические проверки<br><br>        то программа checknews (1) запускается каждые 30 минут. Если периодический задан, но tpeiod не установлен или установлен в 0, периодический ведет себя как precmd.<br><br>precmd<br>    Выполняется непосредственно перед печатью каждого приглашения. Например, если вы это сделаете<br><br>            &gt; псевдоним<br><br>        то date (1) запускается непосредственно перед запросом оболочки для каждой команды. Нет никаких ограничений на то, что может быть сделано, но следует соблюдать осторожность.<br><br>postcmd<br>    Выполняется до запуска каждой команды.<br><br>            &gt; alias postcmd 'echo -n "^ [] 2 \; \! # ^ G"'<br><br>        то выполнение vi foo.c поместит командную строку в строку заголовка xterm.<br><br>оболочка<br>    Указывает интерпретатор исполняемых скриптов, которые сами не указывают интерпретатор. Первым словом должно быть полное имя пути к требуемому интерпретатору (например, `/ bin / csh 'или` / usr / local / bin / tcsh').<br><br> <br>Специальные переменные оболочки<br>Переменные, описанные в этом разделе, имеют особое значение для оболочки.<br><br>Набор оболочек adduffix, argv, autologout, csubstnonl, command, echo_style, edit, gid, group, home, loginsh, oid, path, prompt, prompt2, prompt3, shell, shlvl, tcsh, term, tty, uid, user и version при запуске; они не меняются после этого, если они не изменены пользователем. Оболочка обновляет cwd, dirstack, owd и статус при необходимости и устанавливает выход из системы при выходе из системы.<br><br>Оболочка синхронизирует afsuser, group, home, path, shlvl, term и user с переменными среды с одинаковыми именами: всякий раз, когда изменяется переменная среды, оболочка меняет соответствующую переменную оболочки для соответствия (если только переменная оболочки не доступна только для чтения) и наоборот. Обратите внимание, что хотя cwd и PWD имеют одинаковые значения, они не синхронизируются таким образом и что оболочка автоматически преобразует разные форматы пути и PATH.<br><br>adduffix (+)<br>    Если установлено, завершение имени файла добавляет `/ 'в конец каталогов и пространство до конца обычных файлов, когда они точно совпадают. Установите по умолчанию.<br>afsuser (+)<br>    Если установлено, функция autolock autologout использует свое значение вместо локального имени пользователя для аутентификации Kerberos.<br>ampm (+)<br>    Если установлено, все времена отображаются в 12-часовом формате AM / PM.<br>ARGV<br>    Аргументы к оболочке. Позиционные параметры берутся из argv, то есть `$ 1 'заменяется на` $ argv [1]' и т. Д. Устанавливается по умолчанию, но обычно пуст в интерактивных оболочках.<br>автокоррекция (+)<br>    Если установлено, команда редактора заклинаний запускается автоматически перед каждой попыткой завершения.<br>autoexpand (+)<br>    Если установлено, команда редактора истории расширений автоматически запускается перед каждой попыткой завершения.<br>автолист (+)<br>    Если установлено, возможности перечислены после неоднозначного завершения. Если установлено значение неоднозначно, возможности перечисляются только тогда, когда новые символы не добавляются по завершению.<br>autologout (+)<br>    Первое слово - это количество минут бездействия перед автоматическим выходом из системы. Дополнительным вторым словом является количество минут бездействия перед автоматической блокировкой. Когда оболочка автоматически выходит из системы, она печатает `auto-logout ', устанавливает автоматический выход из системы в` automatic' и завершает работу. Когда оболочка автоматически блокируется, пользователь должен ввести свой пароль для продолжения работы. Пять неправильных попыток приводят к автоматическому выходу из системы. Установите значение 60 (автоматический выход из системы через 60 минут и отсутствие блокировки) по умолчанию в оболочках login и superuser, но если оболочка не считает, что она запущена под оконной системой (т. Е. Установлена переменная среды DISPLAY), tty является псевдо-tty (pty) или оболочка не была скомпилирована (см. переменную оболочки версии). См. Также переменные оболочки afsuser и logout.<br>backslash_quote (+)<br>    Если установлено, обратная косая черта (`\ ') всегда цитирует` \', `'' и` `'. Это может облегчить выполнение сложных заданий кавычек, но это может привести к синтаксическим ошибкам в сценариях csh (1).<br>каталог<br>    Имя файла каталога сообщений. Если установлено, tcsh использует `tcsh. $ {Catalog} 'в качестве каталога сообщений вместо стандартного` tcsh'.<br>CDPATH<br>    Список каталогов, в которых cd должен искать подкаталоги, если они не найдены в текущем каталоге.<br>цвет<br>    Если он установлен, он включает цветной дисплей для встроенного ls-F и передает --color = auto в ls. Кроме того, его можно установить только ls-F или только ls, чтобы включить цвет только для одной команды. Установка его ничем не эквивалентна установке его на (ls-F ls).<br>colorcat<br>    Если установлено, он позволяет выполнить последовательность выбора цвета для файлов сообщений NLS. И отображать красочные сообщения NLS.<br>команда (+)<br>    Если установлено, команда, которая была передана оболочке с флагом -c (q.v.).<br>полный (+)<br>    Если установлено усиление, завершение 1) игнорирует регистр и 2) рассматривает периоды, дефисы и подчеркивания (`. ',` -' и `_ ') как разделители слов, дефисы и подчеркивания эквивалентны. Если установлено значение igncase, завершение становится нечувствительным к регистру.<br>продолжить (+)<br>    Если задано список команд, оболочка будет продолжать перечисленные команды, а не запускать новую.<br>continue_args (+)<br>    То же, что и continue, но оболочка будет выполнена:<br><br>            echo `pwd` $ argv&gt; ~ /. <cmd> _pause; % &lt;Команда&gt;<br><br>правильный (+)<br>    Если установлено значение `cmd ', команды автоматически исправляются. Если установлено complete, команды автоматически завершаются. Если установлено значение все, вся командная строка исправлена.<br>csubstnonl (+)<br>    Если установлено, новые строки и возврат каретки в подстановке команд заменяются пробелами. Установите по умолчанию.<br>УХО<br>    Полный путь к текущему каталогу. См. Также dirstack и старые переменные оболочки.<br>dextract (+)<br>    Если установлено, `pushd + n 'извлекает n-й каталог из стека каталога, а не поворачивает его вверх.<br>dirsfile (+)<br>    Место по умолчанию, в котором `dirs -S 'и` dirs -L' ищут файл истории. Если unset, используется ~ / .cshdirs. Поскольку обычно ~ / .tcshrc обычно используется до ~ / .cshdirs, dirsfile должен быть установлен в ~ / .tcshrc, а не ~ / .login.<br>dirstack (+)<br>    Массив всех каталогов в стеке директорий. `$ dirstack [1] '- текущий рабочий каталог,` $ dirstack [2]' первый каталог в стеке и т. д. Обратите внимание, что текущий рабочий каталог - `$ dirstack [1] 'but` = 0' в каталоге замены стека и т. д. Можно произвольно изменить стек, установив dirstack, но первый элемент (текущий рабочий каталог) всегда корректен. См. Также переменные cwd и owd.<br><br>    dspmbyte (+)<br>    Имеет значение iff 'dspm', указанный как часть переменной оболочки версии. Если установлено значение `euc ', оно позволяет отображать и редактировать код EUC-kanji (Japanese). Если установлено значение `sjis ', он позволяет отображать и редактировать Shift-JIS (японский) код. Если установлено значение `big5 ', оно позволяет отображать и редактировать код Big5 (китайский). Если установлено значение `utf8 ', оно позволяет отображать и редактировать код Utf8 (Unicode). Если установлен в следующем формате, он позволяет отображать и редактировать исходный формат многобайтового кода:<br><br>            &gt; set dspmbyte = 0000 .... (256 байт) .... 0000<br><br>        Для таблицы требуется всего 256 байт. Каждый символ из 256 символов соответствует (слева направо) кодам ASCII 0x00, 0x01, ... 0xff. Каждому символу присваивается число 0,1,2 и 3. Каждый номер имеет следующее значение:<br><br>          0 ... не используется для многобайтовых символов.<br><br>          1 ... используется для первого байта многобайтового символа.<br><br>          2 ... используется для второго байта многобайтового символа.<br><br>          3 ... используется как для первого байта, так и для второго байта многобайтового символа.<br>              <br><br>          Пример:<br>        Если установлено значение 001322, первый символ (означает 0x00 кода ASCII) и второй символ (означает 0x01 кода ASCII) установлены в 0. Затем он не используется для многобайтовых символов. Третий символ (0x02) установлен в '1', указывая, что он используется для первого байта многобайтового символа. Четвёртый символ (0x03) установлен на 3. Он используется как для первого байта, так и для второго байта многобайтового символа. 5-й и 6-й символы (0x04,0x05) установлены на 2, указывая, что они используются для второго байта многобайтового символа.<br><br>        Версия файла ls GNU fileutils не может отображать многобайтовые имена файлов без опции -N (--literal). Если вы используете эту версию, установите второе слово dspmbyte в ls. Если нет, например, ls-F -l не может отображать многобайтовые имена файлов.<br><br><br>          Заметка:<br>        Эта переменная может использоваться только в том случае, если во время компиляции определены KANJI и DSPMBYTE.<br><br>dunique (+)<br>    Если установлено, pushd удаляет все экземпляры имени из стека, прежде чем нажимать его на стек.<br>эхо<br>    Если установлено, каждая команда с ее аргументами будет эхом, прежде чем она будет выполнена. Для не встроенных команд все расширения происходят перед эхом. Встроенные команды повторяются перед заменой команды и имени файла, потому что эти замены затем выполняются выборочно. Задано параметром командной строки -x.<br>echo_style (+)<br>    Стиль встроенного эха. Может быть установлено значение<br><br>    BSD<br>        Не эхо-символ новой строки, если первый аргумент -n.<br>    SysV<br>        Распознавайте обратные последовательности escape-последовательности в эхо-строках.<br>    и то и другое<br>        Признать флаг -n и escape-последовательности обратной косой черты; по умолчанию.<br>    никто<br>        Не признавайте ни того, ни другого.<br><br>    Установите по умолчанию локальную систему по умолчанию. Параметры BSD и System V описаны в справочных страницах echo (1) в соответствующих системах.<br><br>редактировать (+)<br>    Если установлено, используется редактор командной строки. Установить по умолчанию в интерактивных оболочках.<br>эллипсис (+)<br>    Если установлено, `% c '/`%.' и `% C '(см. переменную командной строки) указывают пропущенные каталоги с эллипсисом (` ...') вместо `/ <skipped> '.<br>fignore (+)<br>    Перечисляет суффиксы имени файла, которые будут проигнорированы по завершению.<br>filec<br>    В tcsh значение всегда используется, и по умолчанию эта переменная игнорируется. Если редактирование отменено, то используется традиционное выполнение csh. Если установлено в csh, используется завершение имени файла.<br>gid (+)<br>    Идентификатор реальной группы пользователей.<br>группа (+)<br>    Имя группы пользователя.<br>histchars<br>    Строковое значение, определяющее символы, используемые в подстановке истории (q.v.). Первый символ его значения используется в качестве символа замены истории, заменяя символ по умолчанию `! '. Второй символ его значения заменяет символ `^ 'в быстрых подстановках.<br><br>    histdup (+)<br>    Управляет обработкой дубликатов записей в списке истории. Если установлено значение все, в списке истории вводятся только уникальные события истории. Если установлено значение prev, а последнее событие истории совпадает с текущей командой, текущая команда не вводится в историю. Если установлено erase, и в списке истории найдено одно и то же событие, это старое событие стирается и текущий вставлен. Обратите внимание, что опции prev и all переопределяют историю событий, поэтому пробелов нет.<br>histfile (+)<br>    Место по умолчанию, в котором `history -S 'и` history -L' ищут файл истории. Если unset, используется ~ / .history. histfile полезен при совместном использовании одного и того же домашнего каталога между разными машинами или при сохранении отдельных историй на разных терминалах. Поскольку только ~ / .tcshrc обычно используется до ~ / .history, файл hist должен быть установлен в ~ / .tcshrc, а не ~ / .login.<br>histlit (+)<br>    Если команды set, builtin и editor и механизм savehist используют литеральную (нерасширенную) форму строк в списке истории. См. Также команду редактора переключателя-литеральной истории.<br>история<br>    Первое слово указывает количество исторических событий для сохранения. Дополнительное второе слово (+) указывает формат, в котором печатается история; если не указано, используется `% h \ t% T \ t% R \ n '. Последовательность форматирования описывается ниже под подсказкой; обратите внимание на переменное значение `% R '. Установите значение 100 по умолчанию.<br>Главная<br>    Инициализирован в домашний каталог вызывающего. Расширение имени `~ 'имени файла относится к этой переменной.<br>IGNOREEOF<br>    Если установлено пустая строка или `0 ', а устройство ввода - это терминал, команда конца файла (обычно генерируемая пользователем путем ввода` ^ D' в пустой строке) заставляет оболочку печатать `Use ' exit ", чтобы оставить tcsh. ' вместо выхода. Это предотвращает случайное убийство оболочки. Исторически этот параметр вышел после 26 последовательных EOF, чтобы избежать бесконечных циклов. Если установлено число n, оболочка игнорирует n - 1 последовательные конечные файлы и выходит на n-ом. (+) Если не установлено, используется `1 ', т. Е. Оболочка выходит из одного` ^ D'.<br>implicitcd (+)<br>    Если установлено, оболочка обрабатывает имя каталога, введенное в качестве команды, как если бы это был запрос на изменение в этот каталог. Если установлено значение verbose, изменение каталога отражается на стандартном выходе. Это поведение запрещено в неинтерактивных сценариях оболочки или для командных строк с несколькими словами. Изменение каталога имеет приоритет над выполнением команды с похожими именами, но это делается после подстановок псевдонимов. Тильда и переменные расширения работают, как ожидалось.<br>inputmode (+)<br>    Если установлено insert или overwrite, помещает редактор в этот режим ввода в начале каждой строки.<br>killdup (+)<br>    Управляет обработкой дубликатов записей в кольце уничтожения. Если установлено все, в кольцо уничтожения вводятся только уникальные строки. Если установлено значение prev, а последняя убитая строка совпадает с текущей убитой строкой, то текущая строка не вводится в кольцо. Если установлено erase, и одна и та же строка находится в кольце kill, старая строка стирается, а текущая - вставляется.<br>killring (+)<br>    Указывает количество убитых строк для сохранения в памяти. По умолчанию установлено значение 30. Если значение unset или установлено меньше, чем `2 ', оболочка сохранит только последнюю убитую строку. Строки помещаются в killring командами редактора, которые удаляют (убивают) строки текста, например. back-delete-word, kill-line и т. д., а также команду copy-region-as-kill. Команда редактора yank уничтожит самую последнюю убитую строку в командной строке, а yank-pop (см. Команды редактора) можно использовать для захвата ранее убитых строк.<br>listflags (+)<br>    Если установлено x, a или A или любая их комбинация (например, xA), они используются в качестве флагов для ls-F, заставляя его действовать как `ls -xF ',` ls - Fa ', `ls -FA' или комбинация (например,` ls -FxA '): `a' показывает все файлы (даже если они начинаются с`. '), `A' показывает все файлы, кроме`. ' и `.. ', а` x' сортируется попеременно, а не вниз. Если установлено второе слово listflags, оно используется как путь к `ls (1) '.<br>listjobs (+)<br>    Если установлено, все задания указываются при приостановке задания. Если установлено long, список находится в длинном формате.<br>listlinks (+)<br>    Если установлено, команда ls-F builtin показывает тип файла, на который указывает каждая символьная ссылка.<br>listmax (+)<br>    Максимальное количество элементов, список которых будет отображаться командой редактора списка, без предварительного запроса.<br>listmaxrows (+)<br>    Максимальное количество строк элементов, список которых будет отображаться командой редактора списка, без предварительного запроса.<br><br>    loginsh (+)<br>    Устанавливается оболочкой, если она является оболочкой входа. Установка или отключение его в оболочке не влияет. См. Также shlvl.<br>выход из системы (+)<br>    Установите оболочкой нормальный перед обычным выходом из системы, автоматический перед автоматическим выходом из системы и зависанием, если оболочка была убита сигналом зависания (см. Обработка сигналов). См. Также переменную оболочки autologout.<br>почта<br>    Имена файлов или каталогов для проверки входящей почты, разделенные пробелами и необязательно предшествующие числовому слову. Перед каждой подсказкой, если прошло 10 минут с момента последней проверки, оболочка проверяет каждый файл и говорит: У вас новая почта. (или, если почта содержит несколько файлов, У вас есть новая почта по имени), если размер файла больше нуля и имеет время модификации больше, чем время доступа.<br><br>    Если вы находитесь в оболочке входа, то почтовый файл не сообщается, если он не был изменен после запуска оболочки, чтобы предотвратить избыточные уведомления. Большинство программ входа в систему сообщают вам, есть ли у вас почта при входе в систему.<br><br>    Если файл, указанный в почте, является каталогом, оболочка будет считать каждый файл в этом каталоге отдельным сообщением и будет сообщать У вас есть почта. или `У вас есть n писем по имени. ' при необходимости. Эта функциональность предоставляется в основном для тех систем, которые хранят почту таким образом, как, например, Andrew Mail System.<br><br>    Если первое слово почты является числовым, оно принимается за другой интервал проверки почты в секундах.<br><br>    В очень редких случаях оболочка может сообщать У вас есть почта. вместо У вас новая почта.<br><br>matchbeep (+)<br>    Если установлено `never ', завершение не будет звучать. Если задано `nomatch ', он подает звуковой сигнал только тогда, когда нет совпадения. Если установлено значение неоднозначно, оно подает звуковой сигнал, когда имеется несколько совпадений. Если установлено значение notunique, он подает звуковой сигнал, когда есть одно точное и другое более длинные совпадения. Если не задано значение, используется неоднозначный.<br>nobeep (+)<br>    Если установлено, звуковой сигнал полностью отключен. См. Также visiblebell.<br>NoClobber<br>    Если установлено, ограничения перенаправляются на перенаправление вывода, чтобы гарантировать, что файлы не будут случайно уничтожены, а перенаправления `&gt;&gt; 'относятся к существующим файлам, как описано в разделе Ввод / вывод .<br>кивая<br>    Если установлено, отключите печать `DING! ' в подсказках времени при изменении часа.<br>noglob<br>    Если установлено, подстановка имени файла и замена стека каталога (q.v.) запрещены. Это наиболее полезно в сценариях оболочки, которые не обрабатывают имена файлов, или после получения списка имен файлов, и дальнейшие расширения нежелательны.<br>nokanji (+)<br>    Если установлено, и оболочка поддерживает Kanji (см. Переменную оболочки версии), она отключается, поэтому мета-ключ можно использовать.<br>nonomatch<br>    Если установлено, подстановка имени файла или подстановка каталога (q.v.), которая не соответствует существующим файлам, остается нетронутой, а не вызывает ошибку. По-прежнему является ошибкой для искажения, например, `echo ['все еще дает ошибку.<br>nostat (+)<br>    Список каталогов (или шаблонов glob, которые соответствуют каталогам, см. Подстановку имен файлов), которые не должны быть stat (2) ed во время операции завершения. Обычно это используется для исключения каталогов, которые занимают слишком много времени для stat (2), например / afs.<br>поставить в известность<br>    Если установлено, оболочка объявляет о завершении работы асинхронно. По умолчанию задание завершается до того, как вы распечатаете приглашение.<br>oid (+)<br>    Идентификатор реальной организации пользователя. (Только для домена / ОС)<br>owd (+)<br>    Старый рабочий каталог, эквивалентный `- ', используемый cd и pushd. См. Также переменные оболочки cwd и dirstack.<br>дорожка<br>    Список каталогов, в которых нужно искать исполняемые команды. Нулевое слово указывает текущий каталог. Если переменная пути отсутствует, будут выполняться только полные имена путей. path устанавливается оболочкой при запуске из переменной среды PATH или, если PATH не существует, зависит от системы по умолчанию, например `(/ usr / local / bin / usr / bsd / bin / usr / bin.) ' , Оболочка может помещать `. ' первый или последний в пути или полностью опустить его в зависимости от того, как он был скомпилирован; см. переменную оболочки версии. Оболочка, которой не задана опция -c или -t, хэширует содержимое каталогов в пути после чтения ~ / .tcshrc и каждый раз путь сбрасывается. Если добавить новую команду в каталог, находящийся в пути, пока активна оболочка, может потребоваться перефразировать оболочку, чтобы ее найти.<br><br>    printexitvalue (+)<br>    Если установлено, и интерактивная программа выходит с ненулевым статусом, оболочка печатает `Exit status '.<br>незамедлительный<br>    Строка, которая печатается перед чтением каждой команды с терминала. приглашение может включать в себя любую из следующих последовательностей форматирования (+), которые заменяются данной информацией:<br><br>    % /<br>        Текущий рабочий каталог.<br>    % ~<br>        Текущий рабочий каталог, но с домашним каталогом, представленным домашними каталогами `~ 'и других пользователей, представленными` ~ пользователем' в соответствии с подстановкой имен файлов. Замена `~ user 'происходит только в том случае, если оболочка уже использовала` ~ user' в имени пути в текущем сеансе.<br>    % c [[0] n],%. [[0] n]<br>        Заключительный компонент текущего рабочего каталога или n конечных компонентов, если задана цифра n. Если n начинается с `0 ', количество пропущенных компонентов предшествует концевому компоненту (-ам) в формате` / <skipped> trailing'. Если задана переменная оболочки с многоточием, пропущенные компоненты представлены многоточием, поэтому целое становится ... trailing. Подстановка `~ 'выполняется так же, как и в`% ~', но компонент `~ 'игнорируется при подсчете конечных компонентов.<br>    % С<br>        Как% c, но без замены `~ '.<br>    % h,% !,!<br>        Текущий номер события истории.<br>    % M<br>        Полное имя хоста.<br>    % м<br>        Имя хоста до первого `. '.<br>    % S (% s)<br>        Режим ожидания (остановки).<br>    % B (% b)<br>        Пуск (стоп).<br>    % U (% u)<br>        Начать (останавливать) режим подчеркивания.<br>    % t,% @<br>        Время дня в 12-часовом формате AM / PM.<br>    % Т<br>        Как и `% t ', но в 24-часовом формате (но см. Переменную оболочки ampm).<br>    %п<br>        Точное время суток в 12-часовом формате AM / PM с секундами.<br>    %П<br>        Как и `% p ', но в 24-часовом формате (но см. Переменную оболочки ampm).<br>    \ с<br>        c анализируется как в bindkey.<br>    ^ с<br>        c анализируется как в bindkey.<br>    %%<br>        Единый `% '.<br>    % п<br>        Имя пользователя.<br>    % J<br>        Количество рабочих мест.<br>    % d<br>        День недели в формате День.<br>    % D<br>        День в формате `dd '.<br>    % мас<br>        Месяц в формате Mon.<br>    % W<br>        Месяц в формате `mm '.<br>    % г<br>        Год в формате `yy '.<br>    % Y<br>        Год в формате `yyyy '.<br>    % л<br>        Тонкая оболочка.<br>    % L<br>        Очищает от конца подсказки до конца дисплея или конца строки.<br>    % $<br>        Расширяет имя переменной оболочки или среды сразу после `$ '.<br>    % #<br>        `&gt; '(или первый символ переменной оболочки promptchars) для обычных пользователей,` #' (или второй символ promptchars) для суперпользователя.<br>    % {Строка%}<br>        Включает строку как литеральную escape-последовательность. Он должен использоваться только для изменения атрибутов терминала и не должен перемещать местоположение курсора. Это не может быть последней последовательностью в подсказке.<br>    %?<br>        Код возврата команды, выполненный непосредственно перед подсказкой.<br>    %Р<br>        В prompt2 - статус синтаксического анализатора. В строке prompt3 исправлена строка. В истории - строка истории.<br><br>    `% B ',`% S', `% U 'и`% {string%}' доступны только в 8-битных чистых оболочках; см. переменную оболочки версии.<br><br>    Жирные, выдающиеся и подчеркиваемые последовательности часто используются для выделения оболочки суперпользователя. Например,<br><br>        &gt; set prompt = "% m [% h]% B [% @]% b [% /] вы звонили?"<br>        tut [37] [14:54] [/ usr / accts / sys] ты позвонил? _<br><br>    Если используются `% t ',`% @', `% T ',`% p' или `% P ', а noding не задано, напечатайте` DING!' на изменение часа (т. е. `: 00 'минут) вместо фактического времени.<br><br>    Установите по умолчанию `% # 'в интерактивных оболочках.<br><br>prompt2 (+)<br>    Строка, с помощью которой вы можете запрашивать циклы while и foreach и после строк, заканчивающихся на `\ '. Такие же последовательности форматов могут использоваться как в подсказке (q.v.); обратите внимание на переменное значение `% R '. Установите по умолчанию значение `% R? 'в интерактивных оболочках.<br>prompt3 (+)<br>    Строка с подсказкой при подтверждении автоматической коррекции орфографии. Такие же последовательности форматов могут использоваться как в подсказке (q.v.); обратите внимание на переменное значение `% R '. Установите по умолчанию `CORRECT&gt;% R (y | n | e | a)? 'в интерактивных оболочках.<br>promptchars (+)<br>    Если установлено (для двухсимвольной строки), последовательность форматирования `% # 'в командной строке приглашения заменяется первым символом для обычных пользователей и вторым символом для суперпользователя.<br><br>    pushdtohome (+)<br>    Если установлено, pushd без аргументов делает `pushd ~ ', как cd.<br>pushdsilent (+)<br>    Если установлено, pushd и popd не печатают стек каталога.<br>recexact (+)<br>    Если установлено, завершение завершается в точном совпадении, даже если возможно более длинное совпадение.<br>узнавать_одно_программы (+)<br>    Если установлено, список команд отображает только файлы в исполняемом пути. Медленный.<br>rmstar (+)<br>    Если установлено, пользователь запрашивается до выполнения rm *.<br>rprompt (+)<br>    Строка для печати в правой части экрана (после ввода команды), когда приглашение отображается слева. Он распознает те же символы форматирования, что и приглашение. Он будет автоматически исчезать и снова появляться по мере необходимости, чтобы гарантировать, что ввод команд не затенен и появится только в том случае, если подсказка, ввод команды и сама по себе будут совпадать в первой строке. Если редактирование не установлено, то rprompt будет напечатано после подсказки и перед вводом команды.<br>savedirs (+)<br>    Если установлено, оболочка выполняет `dirs -S 'перед выходом. Если первое слово установлено на число, самое большее, что многие записи стека каталога сохраняются.<br>SAVEHIST<br>    Если установлено, оболочка выполняет `history -S 'перед выходом. Если первое слово установлено на число, самое большее, что многие строки сохраняются. (Число должно быть меньше или равно истории). Если для второго слова установлено значение merge, список истории объединяется с существующим файлом истории, а не заменяет его (если он есть), и сортируется по метке времени и последние события сохраняются. (+)<br>расписание (+)<br>    Формат, в котором команда sched builtin печатает запланированные события; если не указано, используется `% h \ t% T \ t% R \ n '. Последовательности форматирования описаны выше под подсказкой; обратите внимание на переменное значение `% R '.<br>оболочка<br>    Файл, в котором находится оболочка. Это используется в forking shells для интерпретации файлов, у которых есть исполняемые биты, но не исполняемые системой. (См. Описание выполнения встроенной и не встроенной команды.) Инициализируется в (зависящем от системы) доме оболочки.<br>shlvl (+)<br>    Количество вложенных оболочек. Сброс до 1 в оболочках входа. См. Также loginsh.<br>положение дел<br>    Статус, возвращаемый последней командой. Если он прерывается ненормально, то к статусу добавляется 0200. Встроенные команды, которые не возвращают статус выхода 1, все остальные встроенные команды возвращают статус 0.<br>символические ссылки (+)<br>    Может быть установлено несколько разных значений для управления разрешением символической ссылки (символьная ссылка):<br><br>        Если установлено `chase ', всякий раз, когда текущий каталог изменяется в каталог, содержащий символическую ссылку, он расширяется до реального имени каталога, на который указывает ссылка. Это не работает для домашнего каталога пользователя; это ошибка.<br><br>        Если установлено значение `ignore ', оболочка пытается построить текущий каталог по отношению к текущему каталогу до пересечения ссылки. Это означает, что cding через символическую ссылку, а затем `cd .. 'ing возвращает один в исходный каталог. Это затрагивает только встроенные команды и завершение имени файла.<br><br>        Если установлено `expand ', оболочка пытается исправить символические ссылки, фактически расширяя аргументы, которые выглядят как имена путей. Это влияет на любую команду, а не только на встроенные. К сожалению, это не работает для трудно распознаваемых имен файлов, таких как встроенные в параметры команды. Расширение может быть предотвращено путем цитирования. Хотя этот параметр обычно наиболее удобен, он иногда вводит в заблуждение и иногда запутывается, когда ему не удается распознать аргумент, который следует расширить. Компромисс заключается в использовании ignore и использовании команды normalize-path редактора (по умолчанию привязана к ^ X-n).<br><br>        Некоторые примеры в порядке. Сначала создадим некоторые игровые каталоги:<br><br>            &gt; cd / tmp<br>            &gt; mkdir из / src в<br>            &gt; ln -s от / src до / dst<br><br>        Ниже приведено поведение с отключенными символическими ссылками,<br><br>            &gt; cd / tmp / to / dst; echo $ cwd<br>            / TMP / к / ДСТ<br>            &gt; cd ..; echo $ cwd<br>            / TMP / с<br><br>        вот поведение с символическими ссылками, установленными на `chase ',<br><br>            &gt; cd / tmp / to / dst; echo $ cwd<br>            / TMP / с / SRC<br>            &gt; cd ..; echo $ cwd<br>            / TMP / с<br><br>        вот поведение с символическими ссылками, установленными на `ignore ',<br><br>            &gt; cd / tmp / to / dst; echo $ cwd<br>            / TMP / к / ДСТ<br>            &gt; cd ..; echo $ cwd<br>            / TMP / к<br><br>            и вот поведение с символическими ссылками, установленными на `expand '.<br><br>            &gt; cd / tmp / to / dst; echo $ cwd<br>            / TMP / к / ДСТ<br>            &gt; cd ..; echo $ cwd<br>            / TMP / к<br>            &gt; cd / tmp / to / dst; echo $ cwd<br>            / TMP / к / ДСТ<br>            &gt; cd ".."; echo $ cwd<br>            / TMP / с<br>            &gt; / bin / echo ..<br>            / TMP / к<br>            &gt; / bin / echo ".."<br>            ..<br><br>        Обратите внимание, что расширение `expand '1) работает так же, как` ignore' для встроенных функций, таких как cd, 2) предотвращается путем цитирования, а 3) происходит до того, как имена файлов передаются не встроенным командам.<br><br>tcsh (+)<br>    Номер версии оболочки в формате `R.VV.PP ', где` R' - основной номер выпуска, `VV '- текущая версия и` PP' - уровень патча.<br>срок<br>    Тип терминала. Обычно устанавливается в ~ / .login, как описано в разделе Запуск и завершение работы.<br>время<br>    Если задано число, то время встроенного (q.v.) выполняется автоматически после каждой команды, которая занимает больше, чем столько секунд процессора. Если есть второе слово, оно используется как строка формата для вывода встроенного времени. (u) В строке формата могут использоваться следующие последовательности:<br><br>    % U<br>        Время, затрачиваемое процессом в пользовательском режиме в секундах процессора.<br>    % S<br>        Время, затрачиваемое процессом в режиме ядра в секундах процессора.<br>    % E<br>        Истекшее (настенное время) время в секундах.<br>    %П<br>        Процент CPU вычисляется как (% U +% S) /% E.<br>    % W<br>        Количество случаев, когда процесс был заменен.<br>    %ИКС<br>        Средняя сумма в (общем) текстовом пространстве, используемом в Кбайтах.<br>    % D<br>        Средняя сумма в (неразделенной) области данных / стека, используемой в Кбайтах.<br>    % K<br>        Общее пространство используется (% X +% D) в килобайтах.<br>    % M<br>        Максимальная память, которую этот процесс использовал в любое время в килобайтах.<br>    % F<br>        Количество основных ошибок страницы (страница должна быть доставлена с диска).<br>    %Р<br>        Количество незначительных ошибок страницы.<br>    %Я<br>        Количество операций ввода.<br>    % O<br>        Количество операций вывода.<br>    %р<br>        Количество полученных сообщений сокета.<br>    % s<br>        Количество отправленных сообщений сокетов.<br>    % к<br>        Количество принятых сигналов.<br>    % мас<br>        Количество добровольных переключателей контекста (ожидания).<br>    % с<br>        Количество непроизвольных переключателей контекста.<br><br>    Только первые четыре последовательности поддерживаются в системах без ограничений по ресурсам BSD. Формат времени по умолчанию: % Uu% Ss% E% P% X +% Dk% I +% Oio% Fpf +% Ww для систем, которые поддерживают отчеты об использовании ресурсов и `% Uu% Ss% E% P 'для систем, которые не ,<br><br>    В разделе DYNIX / ptx от Sequent% X,% D,% K,% r и% s недоступны, но следующие дополнительные последовательности:<br><br>    % Y<br>        Количество выполненных системных вызовов.<br>    % Z<br>        Количество страниц, заполненных нулями по требованию.<br>    %я<br>        Ядро увеличило размер резидентного размера процесса.<br>    % d<br>        Количество ядер, размер резидентного набора которых был уменьшен ядром.<br>    % л<br>        Количество выполненных системных вызовов.<br>    % м<br>        Количество выполненных системных вызовов.<br>    %п<br>        Количество чтений с необработанных дисковых устройств.<br>    % к<br>        Количество записей на необработанные дисковые устройства.<br><br>    и по умолчанию используется формат `% Uu% Ss% E% P% I +% Oio% Fpf +% Ww '. Обратите внимание, что процент процессора может быть выше 100% на нескольких процессорах.<br><br>    тпериод (+)<br>    Период, в минутах, между исполнением периодического специального псевдонима.<br>tty (+)<br>    Имя tty или пустое, если оно не привязано к одному.<br>uid (+)<br>    Идентификатор пользователя.<br>пользователь<br>    Имя пользователя.<br>подробный<br>    Если установлено, заставляет слова каждой команды печататься после замены истории (если есть). Задано параметром командной строки -v.<br>версия (+)<br>    Идентификатор версии. Он содержит номер версии оболочки (см. Tcsh), дату начала, дату выпуска, поставщика, операционную систему и машину (см. VENDOR, OSTYPE и MACHTYPE) и список параметров, разделенных запятыми, которые были установлены во время компиляции. Отмечаются параметры, установленные по умолчанию в дистрибутиве.<br><br>    8б<br>        Оболочка восемь чистая; по умолчанию<br>    7b<br>        Оболочка не восемь чистых<br>    широкий<br>        Оболочка является многобайтовой кодировкой чистой (например, UTF-8)<br>    NLS<br>        Используется система NLS системы; по умолчанию для систем с NLS<br>    Л.Ф.<br>        Войдите в shells запустите /etc/csh.login раньше, чем после /etc/csh.cshrc и ~ / .login, а не после ~ / .tcshrc и ~ / .history.<br>    дл<br>        `. ставится последним в пути для обеспечения безопасности; по умолчанию<br>    й<br>        `. пропущено из пути для обеспечения безопасности<br>    VI<br><br>


Редактирование в стиле vi - это по умолчанию, а не emacs<br>    DTR<br>        При удалении<br>    пока<br>        bye - синоним logout, а log - альтернативное имя для watchlog<br>    аль<br>        autologout включен; по умолчанию<br>    кан<br>        Канджи используется, если это необходимо, в соответствии с настройками локали, если не установлена переменная оболочки ноканджи<br>    см<br>        Используется системный malloc (3)<br>    ро<br>        Соглашение `#! <program> <args> 'эмулируется при выполнении сценариев оболочки<br>    нг<br>        Доступен встроенный newgrp<br>    относительная влажность<br>        Оболочка пытается установить переменную среды REMOTEHOST<br>    АФС<br>        Оболочка проверяет ваш пароль с сервером kerberos, если локальная проверка подлинности не удалась. Переменная оболочки afsuser или переменная окружения AFSUSER переопределяют ваше локальное имя пользователя, если оно установлено.<br><br>    Администратор может ввести дополнительные строки, чтобы указать различия в локальной версии.<br><br>visiblebell (+)<br>    Если установлено, используется экранная вспышка, а не звуковой звонок. См. Также nobeep.<br>смотреть (+)<br>    Список пар пользователей / терминалов для просмотра логинов и выхода из системы. Если любой пользователь является любым, все терминалы просматриваются для данного пользователя и наоборот. Установка часов на `(любой любой) 'наблюдает за всеми пользователями и терминалами. Например,<br><br>            set watch = (george ttyd1 любая консоль $ user any)<br><br>        сообщает активность пользователя `george 'на ttyd1, любого пользователя на консоли и себя (или нарушителя) на любом терминале.<br><br>        Вход и выход из системы проверяется каждые 10 минут по умолчанию, но первое слово часов может быть установлено на число, которое будет проверяться каждые несколько минут. Например,<br><br>            set watch = (1 любой)<br><br>        сообщает каждую регистрацию / выход из системы каждую минуту. Для нетерпеливых, встроенная команда журнала запускает отчет о часах в любое время. Все текущие логины сообщаются (как и при построении журнала), когда часы впервые установлены.<br><br>        Переменная оболочки, управляющая форматом отчетов о часах.<br><br>кто (+)<br>    Строка формата для просмотра сообщений. Следующие последовательности заменяются данной информацией:<br><br>    % п<br>        Имя пользователя, который входил / выходил.<br>    % в<br>        Наблюдаемое действие, то есть вошел в систему, вышло или заменил olduser on.<br>    % л<br>        Терминал (tty), на котором пользователь входил / выходил.<br>    % M<br>        Полное имя хоста удаленного хоста или `local ', если вход / выход из локального узла.<br>    % м<br>        Имя хоста удаленного хоста до первого `. '. Полное имя печатается, если это IP-адрес или дисплей X Window System.<br><br>    % M и% m доступны только в системах, которые хранят имя удаленного хоста в / etc / utmp. Если unset, `% n имеет% a% l из% m. ' , или `% n имеет% a% l. ' на системах, которые не хранят имя удаленного хоста.<br><br>wordchars (+)<br>    Список неалфавитно-цифровых символов, которые считаются частью слова форвард-словами, обратным словом и т. Д., Командами редактора. Если не установлено, используется `*? _-. [] ~ = '.<br><br>    ОКРУЖАЮЩАЯ СРЕДА<br><br>AFSUSER (+)<br>    Эквивалент переменной оболочки afsuser.<br>КОЛОННЫ<br>    Количество столбцов в терминале. См. Раздел Управление терминалом.<br>DISPLAY<br>    Используется системой X Window (см. X (1)). Если установлено, оболочка не устанавливает autologout (q.v.).<br>РЕДАКТОР<br>    Путь к редактору по умолчанию. См. Также переменную среды VISUAL и команду редактора run-fg-editor.<br>ГРУППА (+)<br>    Эквивалент групповой переменной.<br>ГЛАВНАЯ<br>    Эквивалент переменной рабочей оболочки.<br>HOST (+)<br>    Инициализируется имя машины, на которой работает оболочка, как определено системным вызовом gethostname (2).<br>HOSTTYPE (+)<br>    Инициализируется на тип машины, на которой работает оболочка, как определено во время компиляции. Эта переменная устарела и будет удалена в будущей версии.<br>HPATH (+)<br>    Список каталогов, разделенных двоеточиями, в которых команда редактора run-help ищет командную документацию.<br>LANG<br>    Предоставляет предпочтительную среду символов. См. Поддержка системы родного языка.<br>LC_CTYPE<br>    Если установлено, изменяется только обработка символов ctype. См. Поддержка системы родного языка.<br>ЛИНИИ<br>    Количество строк в терминале. См. Раздел Управление терминалом.<br>LS_COLORS<br>    Формат этой переменной напоминает формат файла termcap (5); разделенный двоеточием список выражений формы xx = string, где xx - это двухсимвольное имя переменной. Переменные со связанными по умолчанию значениями:<br><br>        нет 0<br>            Нормальный (нефайловый) текст<br>        fi 0<br>            Обычный файл<br>        di 01; 34<br>            каталог<br>        ln 01; 36<br>            Символическая ссылка<br>        pi 33<br>            Именованная труба (FIFO)<br>        поэтому 01; 35<br>            Разъем<br>        сделать 01; 35<br>            Дверь<br>        bd 01; 33<br>            Блочное устройство<br>        cd 01; 32<br>            Символьное устройство<br>        ex 01; 32<br>            Запускаемый файл<br>        mi (нет)<br>            Отсутствует файл (по умолчанию - fi)<br>        или (нет)<br>            Сиротская символическая ссылка (по умолчанию - ln)<br>        lc ^ [[<br>            Левый код<br>        rc m<br>            Правильный код<br>        ec (нет)<br>            Конец кода (заменяет lc + no + rc)<br><br>    Вам нужно включить только переменные, которые вы хотите изменить по умолчанию.<br><br>    Имена файлов также можно раскрасить на основе расширения имени файла. Это указано в переменной LS_COLORS с использованием синтаксиса * ext = string. Например, используя коды ISO 6429, чтобы окрасить все исходные файлы на языке Си-синего, вы должны указать * .c = 34. Это будет окрашивать все файлы, заканчивающиеся на .c в синем (34) цвете.<br><br>    Управляющие символы могут быть записаны либо в стиле с экранированной записью, либо в stty-like -notation. Обозначение C-стиля добавляет ^ [для Escape, _ для нормального символа пробела и? для удаления. Кроме того, символ ^ [escape-символ может использоваться для переопределения интерпретации по умолчанию ^ [, ^,: и =.<br><br>    Каждый файл будет записан как <lc> <color-code> <rc> <filename> <ec>. Если код <ec> не определен, вместо него будет использоваться последовательность <lc> <no> <rc>. Это, как правило, более удобно использовать, но менее общий. Коды слева, справа и справа предоставляются, поэтому вам не нужно снова и снова вводить общие части и поддерживать странные терминалы; вам вообще не нужно будет изменять их вообще, если ваш терминал не использует цветовые последовательности ISO 6429, а другую систему.<br><br>    Если ваш терминал использует цветовые коды ISO 6429, вы можете составить коды типов (то есть все, кроме кодов lc, rc и ec), из числовых команд, разделенных точками с запятой. Наиболее распространенные команды:<br><br>    0<br>            для восстановления цвета по умолчанию<br>        1<br>            для ярких цветов<br>        4<br>            для подчеркнутого текста<br>        5<br>            для мигания текста<br>        30<br>            для черного переднего плана<br>        31<br>            для красного переднего плана<br>        32<br>            для зеленого переднего плана<br>        33<br>            для желтого (или коричневого) переднего плана<br>        34<br>            для синего переднего плана<br>        35<br>            для фиолетового переднего плана<br>        36<br>            для голубого переднего плана<br>        37<br>            для белого (или серого) переднего плана<br>        40<br>            на черном фоне<br>        41<br>            для красного фона<br>        42<br>            для зеленого фона<br>        43<br>            для желтого (или коричневого) фона<br>        44<br>            для синего фона<br>        45<br>            для фиолетового фона<br>        46<br>            для голубого фона<br>        47<br>            для белого (или серого) фона<br><br>    Не все команды будут работать на всех системах или устройствах отображения.<br><br>    Несколько терминальных программ не распознают конечный код по умолчанию. Если весь текст будет раскрашен после того, как вы сделаете список каталогов, попробуйте изменить коды no и fi с 0 на числовые коды для стандартных цветов переднего и заднего фона.<br><br>MACHTYPE (+)<br>    Тип машины (класс микропроцессора или модель машины), как определено во время компиляции.<br>NOREBIND (+)<br>    Если установлено, печатные символы не отскакивают от команды self-insert-command. См. Поддержка системы родного языка.<br>OSTYPE (+)<br>    Операционная система, определенная во время компиляции.<br>ДОРОЖКА<br>    Список каталогов, разделенных двоеточиями, для поиска исполняемых файлов. Эквивалентен переменной оболочки пути, но в другом формате.<br>PWD (+)<br>    Эквивалентен переменной оболочки cwd, но не синхронизирован с ней; обновляется только после фактического изменения каталога.<br>REMOTEHOST (+)<br>    Хост, с которого пользователь зарегистрировался удаленно, если это так, и оболочка может его определить. Установите только в том случае, если оболочка была скомпилирована; см. переменную оболочки версии.<br>SHLVL (+)<br>    Эквивалент переменной оболочки shlvl.<br>SYSTYPE (+)<br>    Текущий тип системы. (Только для домена / ОС)<br>СРОК<br>    Эквивалентен термину переменная оболочки.<br>TERMCAP<br>    Строка возможностей терминала. См. Раздел Управление терминалом.<br>USER<br>    Эквивалент переменной оболочки пользователя.<br>VENDOR (+)<br>    Поставщик, как определено во время компиляции.<br>VISUAL<br>    Путь к полноэкранному редактору по умолчанию. См. Также переменную окружения EDITOR и команду редактора редактора run-fg-editor.<br><br>    FILES<br><br>/etc/csh.cshrc<br>    Прочитайте сначала каждую оболочку. ConvexOS, Stellix и Intel используют / etc / cshrc, а NeXT используют /etc/cshrc.std. A / UX, AMIX, Cray и IRIX не имеют эквивалента в csh (1), но все равно прочитайте этот файл в tcsh. Solaris 2.x также не имеет этого, но tcsh читает /etc/.cshrc. (+)<br>/etc/csh.login<br>    Чтение с помощью команд входа после /etc/csh.cshrc. ConvexOS, Stellix и Intel используют / etc / login, NeXT используют /etc/login.std, Solaris 2.x использует /etc/.login и A / UX, AMIX, Cray и IRIX, используя / etc / cshrc.<br>~ / .tcshrc (+)<br>    Чтение каждой оболочки после /etc/csh.cshrc или ее эквивалента.<br>~ / .cshrc<br>    Чтение каждой оболочки, если ~ / .tcshrc не существует, после /etc/csh.cshrc или его эквивалента. В этом руководстве используется `~ / .tcshrc 'для обозначения` ~ / .tcshrc или, если ~ / .tcshrc не найден, ~ / .cshrc'.<br>~ / .history<br>    Прочитайте по командам входа в систему после ~ / .tcshrc, если установлен savehist, но посмотрите также файл histfile.<br>~ / .login<br>    Чтение с помощью оболочек входа после ~ / .tcshrc или ~ / .history. Оболочка может быть скомпилирована для чтения ~ / .login раньше, чем после ~ / .tcshrc и ~ / .history; см. переменную оболочки версии.<br>~ / .cshdirs (+)<br>    Чтение с помощью интерфейсов входа в систему после ~ / .login, если установлено savedirs, но см. Также dirsfile.<br>/etc/csh.logout<br>    Чтение с помощью систем входа в систему при выходе из системы. ConvexOS, Stellix и Intel используют / etc / logout, а NeXT используют /etc/logout.std. A / UX, AMIX, Cray и IRIX не имеют эквивалента в csh (1), но все равно прочитайте этот файл в tcsh. Solaris 2.x тоже не имеет этого, но tcsh читает /etc/.logout. (+)<br>~ / .logout<br>    Чтение с помощью логинов при выходе из системы после /etc/csh.logout или его эквивалента.<br>/ Бен / ш<br>    Используется для интерпретации сценариев оболочки, не начиная с `# '.<br>/ TMP / ш *<br>    Временный файл для `&lt;&lt; '.<br>/ И т.д. / пароль<br>    Источник исходных каталогов для подстановок `~ name '.<br><br>Порядок чтения файлов запуска может отличаться, если оболочка была скомпилирована; см. Запуск и завершение работы и переменная оболочки версии.<br>НОВЫЕ ВОЗМОЖНОСТИ (+)<br>В этом руководстве описывается tcsh как единое целое, но опытные пользователи csh (1) захотят обратить особое внимание на новые функции tcsh.<br><br>Редактор командной строки, который поддерживает GNU Emacs или vi (1) -строчные привязки клавиш. См. Редактор командной строки и команды Редактора.<br><br>Программируемое, интерактивное заполнение слов и листинг. См. Завершение и листинг, а также полные и незавершенные встроенные команды.<br><br>Коррекция орфографии (q.v.) имен файлов, команд и переменных.<br><br>Команды редактора (q.v.), которые выполняют другие полезные функции в середине типизированных команд, включая поиск документации (run-help), быстрый перезапуск редактора (run-fg-editor) и разрешение команды (эта команда).<br><br>Усовершенствованный механизм истории. События в списке истории отмечены по времени. См. Также команду history и связанные с ней переменные оболочки, ранее недокументированный спецификатор события # и новые модификаторы в разделе Замена истории, * -история, история-поиск- *, i-search- *, vi-search- * и переключение -literal-history и командную переменную shell.<br><br>Усовершенствованный синтаксический анализ каталогов и обработка стека каталогов. См. Команды cd, pushd, popd и dirs и связанные с ними переменные оболочки, описание подстановки стека каталога, переменные оболочки dirstack, owd и symlinks и команды редактора normalize-command и normalize-path.<br><br>Отрицание в шаблонах glob. См. Замена имени файла.<br><br>Новые операторы поиска файлов (q.v.) и встроенная файловая система, которая их использует.<br><br>Различные автоматические, периодические и синхронизированные события (q.v.), включая запланированные события, специальные псевдонимы, автоматический выход из системы и блокировку терминала, синхронизацию команд и просмотр входа и выхода из системы.<br><br>Поддержка системы родного языка (см. Поддержка системы родного языка), варианты варианта ОС (см. Поддержку вариантов ОС и переменную оболочки echo_style) и зависящие от системы расположения файлов (см. ФАЙЛЫ).<br><br>Обширные возможности управления терминалом. См. Раздел Управление терминалом.<br><br>Новые встроенные команды, включая встроенные, hup, ls-F, newgrp, printenv, которые и где (q.v.).<br><br>Новые переменные, которые делают полезную информацию доступной для оболочки. См. Переменные среды gid, loginsh, oid, shlvl, tcsh, tty, uid и версии оболочки и переменные среды HOST, REMOTEHOST, VENDOR, OSTYPE и MACHTYPE.<br><br>Новый синтаксис для включения полезной информации в строку приглашения (см. Подсказку). и специальные подсказки для циклов и коррекции орфографии (см. подсказку2 и подсказку3).<br><br>Переменные только для чтения. См. Замена переменных.<br>ОШИБКИ<br>Когда приостановленная команда перезапускается, оболочка печатает начатый каталог, если это отличается от текущего каталога. Это может вводить в заблуждение (т. Е. Неверно), поскольку это задание может изменить внутренние каталоги.<br><br>Встроенные функции Shell не останавливаются / перезапускаются. Командные последовательности формы `a; b; c 'также не обрабатываются изящно, когда останавливается попытка. Если вы приостановите `b ', оболочка немедленно выполнит` c'. Это особенно заметно, если это расширение связано с псевдонимом. Достаточно поместить последовательность команд в (), чтобы заставить ее подоболочку, т. Е. `(A; b; c) '.<br><br>Контроль над выходом tty после запуска процессов примитивен; возможно, это вдохновит кого-то работать на хороший виртуальный интерфейс терминала. В виртуальном терминальном интерфейсе с контролем вывода можно было бы сделать гораздо более интересные вещи.<br><br>Подстановка псевдонимов чаще всего используется для неуклюже имитации процедур оболочки; должны быть предоставлены оболочки, а не псевдонимы.<br><br>Команды в циклах не помещаются в список истории. Структуры управления должны анализироваться, а не распознаваться как встроенные команды. Это позволило бы командам управления быть размещенными в любом месте, чтобы они были объединены с `| 'и использоваться с` &amp;' и `; ' metasyntax.<br><br>foreach не игнорирует здесь документы при поиске его конца.<br><br>Должно быть возможно использовать модификаторы `: 'на выходе подстановок команд.<br><br>Обновление экрана для строк, превышающих ширину экрана, очень плохо, если терминал не может перемещать курсор вверх (т. Е. Тип терминала немой).<br><br>HPATH и NOREBIND не должны быть переменными среды.<br><br>Шаблоны Glob, которые не используют `? ',` *' Или `[] 'или которые используют` {}' или `~ ', неправильно сбрасываются.<br><br>Форма одной команды if выполняет перенаправление вывода, даже если выражение false, и команда не выполняется.<br><br>ls-F включает идентификаторы файлов при сортировке имен файлов и не обрабатывает управляющие символы в именах файлов. Его нельзя прерывать.<br><br>Подстановка команд поддерживает несколько команд и условий, но не циклов или обратных точек.<br><br>Сообщайте об ошибках на http://bugs.gw.com/, желательно с исправлениями. Если вы хотите помочь сохранить и протестировать tcsh, отправьте сообщение по адресу tcsh-request@mx.gw.com с текстом `subscribe tcsh 'на отдельной строке в теле.<br><br>В ТСШ<br>В 1964 году DEC выпустил PDP-6. PDP-10 была более поздней реорганизацией. Он был переименован в DECsystem-10 в 1970 году или около того, когда DEC выпустила вторую модель KI10.<br><br>TENEX был создан в Bolt, Beranek &amp; Newman (исследовательский центр в Кембридже, Массачусетс) в 1972 году в качестве эксперимента в операционных системах виртуальной памяти с запросами. Они построили новый пейджер для DEC PDP-10 и создали ОС для этого. Это было чрезвычайно успешным в академических кругах.<br><br>В 1975 году DEC выпустила новую модель PDP-10, KL10; они предполагали иметь только версию TENEX, которую они лицензировали у BBN, для новой коробки. Они назвали свою версию TOPS-20 (их капитализация является торговой маркой). Многие пользователи TOPS-10 (`Операционная система для PDP-10 ') возражали; таким образом, DEC обнаружил, что поддерживают две несовместимые системы на одном и том же оборудовании, - но тогда на PDP-11 было 6!<br><br>TENEX и TOPS-20 до версии 3, завершилось завершение команды через библиотеку подпрограмм уровня пользовательского кода под названием ULTCMD. С версией 3 DEC переместил все эти возможности и больше на монитор (ядро для вас типов Unix), доступ к которому осуществляется с помощью команды COMND% JSYS (инструкция Перейти к SYStem, механизм вызова супервизора [мои корни IBM также отображаются? ]).<br><br>Создатель tcsh был впечатлен этой функцией и несколькими другими из TENEX и TOPS-20 и создал версию csh, которая имитировала их.<br>ОГРАНИЧЕНИЯ<br>Слова могут быть не более 1024 символов.<br><br>Система ограничивает списки аргументов до 10240 символов.<br><br>Количество аргументов команды, которая включает расширение имени файла, ограничено 1/6-м числом символов, разрешенных в списке аргументов.<br><br>Замены команд могут заменить больше символов, чем разрешено в списке аргументов.<br><br>Чтобы обнаружить цикл, оболочка ограничивает количество подстановок псевдонимов в одной строке до 20.<br>СМОТРИТЕ ТАКЖЕ<br>csh (1), emacs (1), ls (1), newgrp (1), sh (1), setpath (1), stty (1), su (1), tset (1), vi (1), x (1), access (2), execve (2), fork (2), killpg (2), pipe (2), setrlimit (2), sigvec (2), stat (2), umask (2), vfork (2), wait (2), malloc (3), setlocale (3), tty (4), a.out (5), termcap (5), environ (7), termio (7), Введение в C Shell<br>ВЕРСИЯ<br>Настоящее руководство содержит документы tcsh 6.14.00 (Astron) 2005-03-25.<br><br>AUTHORS<br><br>William Joy<br>    Original author of csh(1) <br>J.E. Kulp, IIASA, Laxenburg, Austria<br>    Job control and directory stack features <br>Ken Greer, HP Labs, 1981<br>    File name completion <br>Mike Ellis, Fairchild, 1983<br>    Command name recognition/completion <br>Paul Placeway, Ohio State CIS Dept., 1983-1993<br>    Command line editor, prompt routines, new glob syntax and numerous fixes and speedups <br>Karl Kleinpaste, CCI 1983-4<br>    Special aliases, directory stack extraction stuff, login/logout watch, scheduled events, and the idea of the new prompt format <br>Rayan Zachariassen, University of Toronto, 1984<br>    ls-F and which builtins and numerous bug fixes, modifications and speedups <br>Chris Kingsley, Caltech<br>    Fast storage allocator routines <br>Chris Grevstad, TRW, 1987<br>    Incorporated 4.3BSD csh into tcsh <br>Christos S. Zoulas, Cornell U. EE Dept., 1987-94<br>    Ports to HPUX, SVR2 and SVR3, a SysV version of getwd.c, SHORT_STRINGS support and a new version of sh.glob.c <br>James J Dempsey, BBN, and Paul Placeway, OSU, 1988<br>    A/UX port <br>Daniel Long, NNSC, 1988<br>    wordchars <br>Patrick Wolfe, Kuck and Associates, Inc., 1988<br>    vi mode cleanup <br>David C Lawrence, Rensselaer Polytechnic Institute, 1989<br>    autolist and ambiguous completion listing <br>Alec Wolman, DEC, 1989<br>    Newlines in the prompt <br>Matt Landau, BBN, 1989<br>    ~/.tcshrc <br>Ray Moody, Purdue Physics, 1989<br>    Magic space bar history expansion <br>Mordechai ????, Intel, 1989<br>    printprompt() fixes and additions <br>Kazuhiro Honda, Dept. of Computer Science, Keio University, 1989<br>    Automatic spelling correction and prompt3 <br>Per Hedeland, Ellemtel, Sweden, 1990-<br>    Various bugfixes, improvements and manual updates <br>Hans J. Albertsson (Sun Sweden)<br>    ampm, settc and telltc <br>Michael Bloom<br>    Interrupt handling fixes <br>Michael Fine, Digital Equipment Corp<br>    Extended key support <br>Eric Schnoebelen, Convex, 1990<br>    Convex support, lots of csh bug fixes, save and restore of directory stack <br>Ron Flax, Apple, 1990<br>    A/UX 2.0 (re)port <br>Dan Oscarsson, LTH Sweden, 1990<br>    NLS support and simulated NLS support for non NLS sites, fixes <br>Johan Widen, SICS Sweden, 1990<br>    shlvl, Mach support, correct-line, 8-bit printing <br>Matt Day, Sanyo Icon, 1990<br>    POSIX termio support, SysV limit fixes <br>Jaap Vermeulen, Sequent, 1990-91<br>    Vi mode fixes, expand-line, window change fixes, Symmetry port <br>Martin Boyer, Institut de recherche d'Hydro-Quebec, 1991<br>    autolist beeping options, modified the history search to search for the whole string from the beginning of the line to the cursor. <br>Scott Krotz, Motorola, 1991<br>    Minix port <br>David Dawes, Sydney U. Australia, Physics Dept., 1991<br>    SVR4 job control fixes <br>Jose Sousa, Interactive Systems Corp., 1991<br>    Extended vi fixes and vi delete command <br>Marc Horowitz, MIT, 1991<br>    ANSIfication fixes, new exec hashing code, imake fixes, where <br>Bruce Sterling Woodcock, sterling@netcom.com, 1991-1995<br>    ETA and Pyramid port, Makefile and lint fixes, ignoreeof=n addition, and various other portability changes and bug fixes <br>Jeff Fink, 1992<br>    complete-word-fwd and complete-word-back <br>Harry C. Pulley, 1992<br>    Coherent port <br>Andy Phillips, Mullard Space Science Lab U.K., 1992<br>    VMS-POSIX port <br>Beto Appleton, IBM Corp., 1992<br>    Walking process group fixes, csh bug fixes, POSIX file tests, POSIX SIGHUP <br>Scott Bolte, Cray Computer Corp., 1992<br>    CSOS port <br>Kaveh R. Ghazi, Rutgers University, 1992<br>    Tek, m88k, Titan and Masscomp ports and fixes. Added autoconf support. <br>Mark Linderman, Cornell University, 1992<br>    OS/2 port <br>Mika Liljeberg, liljeber@kruuna.Helsinki.FI, 1992<br>    Linux port <br>Tim P. Starrin, NASA Langley Research Center Operations, 1993<br>    Read-only variables <br>Dave Schweisguth, Yale University, 1993-4<br>    New man page and tcsh.man2html <br>Larry Schwimmer, Stanford University, 1993<br>    AFS and HESIOD patches <br>Luke Mewburn, RMIT University, 1994-6<br>    Enhanced directory printing in prompt, added ellipsis and rprompt. <br>Edward Hutchins, Silicon Graphics Inc., 1996<br>    Added implicit cd. <br>Martin Kraemer, 1997<br>    Ported to Siemens Nixdorf EBCDIC machine <br>Amol Deshpande, Microsoft, 1997<br>    Ported to WIN32 (Windows/95 and Windows/NT); wrote all the missing library and message catalog code to interface to Windows. <br>Taga Nayuta, 1998<br>    Color ls additions. <br><br> <br>THANKS TO<br>Bryan Dunlap, Clayton Elwell, Karl Kleinpaste, Bob Manson, Steve Romig, Diana Smetters, Bob Sutterfield, Mark Verber, Elizabeth Zwicky and all the other people at Ohio State for suggestions and encouragement<br><br>All the people on the net, for putting up with, reporting bugs in, and suggesting new additions to each and every version<br><br>Richard M. Alderson III, for writing the `T in tcsh' section<br> 

<h3>Руководство не найдено.</h3><table cellspacing="0" cellpadding="1" bgcolor="#B0B190" align="center" width="100%" border="0">
<tbody><tr>
<td valign="TOP">

<table cellspacing="0" cellpadding="0" bgcolor="#E9EAD6" width="100%" border="0">
<tbody><tr><td>&nbsp;<b>- 1. Команды и прикладные программы пользовательского уровня</b></td><td> <a href="/man_1.shtml">русские</a> </td><td> <a href="/man_1_eng.shtml">linux</a> </td><td> <a href="/man_1_bsd.shtml">freebsd</a> </td><td> <a href="/man_1_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=1&amp;russian=3">разные</a> </td><td> <a href="/man.shtml?list=1&amp;russian=5">posix</a></td></tr>
<tr><td>&nbsp;<b>- 2. Системные вызовы</b></td><td> <a href="/man_2.shtml">русские</a> </td><td> <a href="/man_2_eng.shtml">linux</a> </td><td> <a href="/man_2_bsd.shtml">freebsd</a> </td><td> <a href="/man_2_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=2&amp;russian=3">разные</a></td></tr>
<tr><td>&nbsp;<b>- 3. Библиотечные вызовы</b></td><td> <a href="/man_3.shtml">русские</a> </td><td> <a href="/man_3_eng.shtml">linux</a> </td><td> <a href="/man_3_bsd.shtml">freebsd</a> </td><td> <a href="/man_3_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=3&amp;russian=3">разные</a> </td><td> <a href="/man.shtml?list=3&amp;russian=5">posix</a></td></tr>
<tr><td>&nbsp;<b>- 4. Специальные файлы /dev/*</b></td><td> <a href="/man_4.shtml">русские</a> </td><td> <a href="/man_4_eng.shtml">linux</a> </td><td> <a href="/man_4_bsd.shtml">freebsd</a> </td><td> <a href="/man_4_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=4&amp;russian=3">разные</a> </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;<b>- 5. Форматы файлов</b></td><td> <a href="/man_5.shtml">русские</a> </td><td> <a href="/man_5_eng.shtml">linux</a> </td><td> <a href="/man_5_bsd.shtml">freebsd</a> </td><td> <a href="/man_5_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=5&amp;russian=3">разные</a> </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;<b>- 6. Игры</b></td><td> <a href="/man_6.shtml">русские</a> </td><td> <a href="/man_6_eng.shtml">linux</a> </td><td> <a href="/man_6_bsd.shtml">freebsd</a> </td><td> <a href="/man_6_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=6&amp;russian=3">разные</a> </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;<b>- 7. Макропакеты и соглашения</b></td><td> <a href="/man_7.shtml">русские</a> </td><td> <a href="/man_7_eng.shtml">linux</a> </td><td> <a href="/man_7_bsd.shtml">freebsd</a> </td><td> <a href="/man_7_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=7&amp;russian=3">разные</a> </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;<b>- 8. Команды системного администрирования</b></td><td> <a href="/man_8.shtml">русские</a> </td><td> <a href="/man_8_eng.shtml">linux</a> </td><td> <a href="/man_8_bsd.shtml">freebsd</a> </td><td> <a href="/man_8_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=8&amp;russian=3">разные</a> </td><td>&nbsp;</td></tr>
<tr><td>&nbsp;<b>- 9. Ядро</b></td><td> &nbsp; </td><td> <a href="/man_9_eng.shtml">linux</a> </td><td> <a href="/man_9_bsd.shtml">freebsd</a> </td><td> <a href="/man_9_solaris.shtml">solaris</a> </td><td> <a href="/man.shtml?list=9&amp;russian=3">разные</a> </td><td>&nbsp;</td></tr>
</tbody></table>
</td></tr>
</tbody></table>

<br>
<form method="get" action="/search.shtml">
<font size="-1">
<font color="#555555">Поиск по тексту MAN-ов:&nbsp;</font><input size="30" name="words" value="tcsh" type="text">
<input name="restrict" value="/man" type="hidden">
<input value="Найти" type="submit">
</font>
<input name="method" value="and" type="hidden">
<input name="format" value="builtin-long" type="hidden">
<input name="sort" value="score" type="hidden">
</form>
<br>
<!--htdig_noindex-->
<noindex>
<br>


</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br><br>
<div style="background-color: #E9EAD6; width:100%; height: 61px;">
<div style="margin-right: 20px; float:left; line-height: 61px; vertical-align: middle; margin-left: 10px; font-size: 120%;">
Спонсоры:
</div>
<div style="float:left; height: 60px;  line-height: 60px; margin-left: 20px;">
<a style="align: middle;" target="_blank" href="https://inferno.name/"><img src="/img/inferno2.png" alt="Inferno Solutions" height="57" width="200"></a>
</div>
<div style="float:right; height: 60px;  line-height: 60px;  margin-left: 15px;">
<a style="align: middle;" target="_blank" href="http://hoster.ru/?utm_source=site&amp;utm_medium=banner&amp;utm_campaign=opennet"><img src="/img/dh143x60t.png" alt="Hosting by Hoster.ru" height="60" width="143"></a>
</div>
<div style="float:right;  height: 60px;  line-height: 60px; vertical-align: middle;font-size: 120%;">
Хостинг:
</div>

</div>

<div style="clear: both;"></div>


<br>
<table class="ttxt" style="border-top: 3px solid #C9CaB6;">
<tbody><tr><td width="35%">
<a href="/cgi-bin/opennet/bookmark.cgi">Закладки на сайте</a><br>
<a href="/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить за страницей</a>
</td>
<td align="RIGHT" width="65%">
Created&nbsp;1996-2021&nbsp;by <b><a href="/contact.shtml" title="email maxim.chirkov@gmail.com">Maxim&nbsp;Chirkov</a></b><br>
<a href="https://www.opennet.ru/add.shtml">Добавить</a>, <a href="https://www.opennet.ru/donate.shtml" style="color: #C00000;">Поддержать</a>, <a href="https://www.opennet.ru/banners2.shtml">Вебмастеру</a>
</td>
</tr>
</tbody></table>
<br><br>


<!--/htdig_noindex-->
<!-- end of footer -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>




</rc></no></lc></ec></ec></filename></rc></color-code></lc></args></program></skipped></skipped></cmd></body>
<!---------------------------------------------  0  ---------------------------------------------->
