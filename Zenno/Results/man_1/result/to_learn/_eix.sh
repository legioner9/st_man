#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 eix (1) >>  eix  (1)   ( Русские man: Команды и прикладные программы пользовательского уровня ) 
    eix ¶ 


	 НАЗВАНИЕ ¶ 


	 eix  - набор утилит для поиска, определения различий и обновления бинарного кэша из вашего локального дерева 


	 СИНТАКСИС ¶ 


	 eix  [ общие опции ] [ ОПЦИИ ]  ВЫРАЖЕНИЕ 


	 eix-update  [ общие опции ] [_опции eix-update] 


	 eix-diff  [ общие опции ]  СТАРЫЙ КЭШ  [ НОВЫЙ КЭШ ] 


	 eix-sync 


	 eix-test-obsolete 


	 eix-remote 


	 eix-layman 


	 eix-installed-after 


	 eix-installed 


	 eix-functions.sh 


	 versionsort 


	 ОПИСАНИЕ ¶ 


	 eix-update  генерирует бинарный кэш локального дерева портежей и оверлеев.  eix  позволяет осуществлять в этом кэше поиск, ограничивая его условиями, указанными в  ВЫРАЖЕНИи . Соответственно, если вы не указываете таких условий, будут выведены все пакеты.  eix-diff  сравнивает два бинарных кэша на предмет обнаружения пакетов, которые были добавлены, удалены или пакеты с новыми стабильными версиями. 


	 Все перечисленные программы и сценарии обращаются к конфигурационным файлам, которые будут описаны ниже.  eix-sync  дополнительно имеет собственный конфигурационный файл. 


	 eix-sync  умеет синхронизировать дерево портежей/оверлеев и сравнивать новые данные со старым кэшем с помощью  eix-diff . Для получения подробной справки по  eix-sync  выполните  eix-sync -h . Вам также следует обратиться к документации по файлу  /etc/eix-sync.conf  (см. ниже); заметьте, что его содержимое может также сохраняться в переменной  EIX_SYNC_CONF . 


	 eix-test-obsolete  - сценарий, несколько раз вызывающий  eix  для структурированного вывода  eix -tTc . 


	 eix-remote  позволяет синхронизировать текущую базу eix с внешним сервером, добавляя/удаляя из неё данные. Заметьте, что при следующем вызове eix-update данные, полученные с сервера, обнулятся; чтобы обойти это поведение, следует включить  KEEP_VIRTUALS=true  в /etc/eixrc. Для получения подробной справки по  eix-remote  выполните  eix-remote -h , а также обратитесь к документации по файлу  /etc/eix-remote.conf  (см. ниже). 


	 eix-layman  умеет добавлять локальные оверлеи layman к текущей базе данных и удалять их из нее. Этот сценарий полезен в том случае, если вы не указываете источник данных для layman в локальном  /etc/make.conf . Для получения подробной справки по  eix-layman  выполните  eix-layman -h .  eix-layman  также является примером использования  eix-functions.sh . 


	 eix-installed-after  - простой и хорошо откомментированный сценарий, демонстрирующий некоторые возможности кастомизации формата вывода eix. Он выводит перечень пакетов, установленных до (или после) последней (или первой) установки определённого пакета/версии. Для получения подробной справки выполните  eix-installed-after -h . 


	 eix-functions.sh  предоставляет вспомогательные функции, вызываемые  eix-sync ,  eix-remote  и  eix-layman . Их можно использовать и при написании собственных подобных сценариев. Заметьте, что сразу после назначения источников данных для  eix-functions.sh , вероятно, потребуется вызвать  read_functions  [ АРГУМЕНТЫ ] для передачи соответствующих  АРГУМЕНТов  functions.sh программе baselayout . 


	 eix-installed  представляет собой простой сценарий, который выводит все установленные пакеты (с их точными версиями), а также может осуществлять поиск пакетов, установленных как с информацией о репозитарии или данными времени сборки, так и без таковой (ср. описание переменных  CHECK_INSTALLED_OVERLAYS  и  USE_BUILD_TIME ). Для получения подробной справки по  eix-installed  выполните  eix-installed -h . 


	 versionsort  - вспомогательная утилита для сценариев, которая убирает номера версий из аргументов и выводит их, отсортировав согласно правилам сортировки версий portage. Подробнее см. в конце этой man-страницы. 


	 ПРИМЕРЫ ¶ 


	 Нижеследующие примеры демонстрируют некоторые полезные, но не вполне привычные случаи использования eix. Мы приводим их, чтобы показать широту возможностей утилиты. Поскольку предполагается, что примеры могут копироваться непосредственно со справочной страницы, мы приводим их здесь с минимальным описанием. Для понимания принципа их работы следует, разумеется, полностью ознакомиться с руководством. Дополнительные примеры можно посмотреть, например, в сценарии  eix-installed-after  - он снабжен пространными комментариями. 


	 команда  | eix '-|*' --format '<markedversions:NAMESLOT>' 


	 Подразумевая, что  команда  создает список в формате  категория/пакет-версия  или  =категория/пакет-версия , будет вывыведен соответствующий список в виде  категория/пакет  или  категория/пакет:СЛОТ  (в зависимости от того, релевантно ли значение  СЛОТа ). 


	 команда  | eix '-|*' --format '<markedversions:NAMEASLOT>' 


	 Аналогично предыдущей команде, но вывод всегда будет в виде  категория/пакет:СЛОТ , даже если значение  СЛОТа  излишне. (Легко запомнить:  A lways ("всегда")). 


	 eix '-I*' --format '<installedversions:NAMEVERSION>' 


	 Будут отображены установленные пакеты в виде  категория/пакет-версия . Очевидно, что формат вывода можно изменить, вместо  NAMEVERSION  используя  NAMESLOT  или  NAMEASLOT . В таком окружении единственное предназначение опции  -I  заключается в некотором ускорении вывода. 


	 eix '-I*' --format '<installedversions:EQNAMEVERSION>' 


	 Аналогично предыдущей команде, но вывод будет произведен в виде  =категория/пакет-имя , обеспечивая тем самым прямую передачу данных portage. 


	 eix '-I*' --format '<installedversions:DATESORT>' | sort -n | cut -f2-3 


	 Будут выведены установленные пакеты (если слоты имеют значение, то со слотами), в порядке, соответствующем дате установки. Е сли вам желателен вывод в ином формате, следует заменить  DATESORT  подходящей переменной (исходное определение вывода вы можете видеть, выполнив  eix --dump ). 


	 Вот как определяется порядок вывода запрошенных пакетов: переменная  DATESORT  формирует первый столбец, отображая в нем прошедшее время в секундах (если выполнить команду  eix --print DATESORT , вы увидите, что за это отвечает переменная  DATESORT_DATE , первая запись в которой -  %s ). Затем программа  sort  перестраивает список пакетов в алфавитном порядке. В последнюю очередь вызывается программа  cut , которая отсекает первый столбец, который был нужен только для сортировки. 


	 В приведенных выше примерах  NAMEVERSION  и  DATESORT  - имена переменных, предопределенных в eix (чтобы их увидеть, выполните  eix --dump ). Но ничто не мешает вам также определить и использовать собственные переменные. Работа с ними описана в man-руководстве; обратите особое внимание на описание строки  FORMAT . }}} 


	 ОПЦИИ ¶ 


	  Общие опции ¶ 


	 Здесь перечисляются опции, общие для  eix ,  eix-diff  и  eix-update . 


	 -h ,  --help 


	 Вывести справку и выйти. 


	 -Q ,  --quick    (переключатель)    (не используется с  eix-update ) 


	 (Не) считывать слоты установленных версий, которые невозможно предположить (например, установленные версии пакетов с как минимум двумя различными слотами, для которых в базе данных уже нет установленной версии). Учтите, что при использовании этой опции eix и eix-diff могут выдавать ложноположительные результаты при рекомендациях по обновлению/откату таких пакетов. 


	 --care     (не используется с  eix-update ) 


	 Отключить опцию --quick; кроме того, слоты установленной версии всегда будут считываться, а не определяться предположительно. В частности, при изменении имени слота установленной версии система проверит наличие рекомендации по обновлению/откату. Учтите, что при этом значительно замедлится скорость первого вызова. (Если ваша файловая система использует кэш разумной величины, только первого - последующие вызовы должны выполняться почти с такой же скоростью, как если бы эта опция не использовалась.) 


	 -q ,  --quiet    (переключатель) 


	 Отключить стандартный вывод утилиты в консоль. Вы можете уменьшить время выполнения eix, используя эту опцию в связке либо с  --brief , либо с  --brief2  (в зависимости от того, что вам нужно) и установив значение переменной  COUNT_ONLY_PRINTED=false . См. также переменные  NOFOUND_STATUS  и  MOREFOUND_STATUS 


	 --dump 


	 Показать действующие значения переменных eixrc, а значения по умолчанию будут отображены как комментарии; затем выйти. 


	 --dump-defaults 


	 Показать значения по умолчанию переменных eixrc, а действующие значения будут отображены как комментарии; затем выйти. 


	 --print  ПЕРЕМЕННАЯ 


	 Вывести значение указанной аргументом  ПЕРЕМЕННОЙ  eixrc или portage, в расширенном виде, предназначенном для внутреннего использования eix; затем выйти. Прежде всего это полезно в сценариях или для отладки. Если вы используете данную опцию в сценариях, вам может потребоваться указать также значение  PRINT_APPEND  для поддержки закрывающих пробелов (см. описание  PRINT_APPEND ). 


	 -V ,  --version 


	 Вывести номер версии и выйти. 


	 -n ,  --nocolor 


	 Отключить использование цветового кода ANSI. Это имеет смысл для терминалов, не поддерживающих ANSI. (Данная опция автоматически включается, если стандартный вывод - не терминал, но может быть переопределена использованием опции --force-color) 


	 -F ,  --force-color 


	 Поведение, обратное --nocolor. 


	  Особые опции информирования ¶ 


	 Следующие особые опции информирования работают только с бинарным кэшем  eix . Это одноразовые исключающие опции - иными словами, при их использовании eix выведет только требуемые данные и завершит работу. 


	 --print-overlay-path  оверлей _ 


	 Вывести путь к первому оверлею, соответствущему запрошенному  ОВЕРЛЕю . В качестве  ОВЕРЛЕя  можно указывать метку оверлея, путь (маску) или число. 


	 --print-overlay-label  оверлей 


	 Вывести метку оверлея, соответствущую запрошенному  ОВЕРЛЕю . В качестве  ОВЕРЛЕя  можно указывать метку оверлея, путь (маску) или число. 


	 --print-all-useflags 


	 Вывести все IUSE words, используемые в определенном пакете. 


	 --print-all-keywords 


	 Вывести все ключевые слова, используемые в определенном пакете. 


	 --print-all-slots 


	 Вывести все строки слотов, используемые в определенном пакете. 


	 --print-all-provides 


	 Вывести все строки PROVIDE, используемые в определенном пакете. 


	 --print-all-licenses 


	 Вывести все строки LICENSE, используемые в определенном пакете. 


	 --print-world-sets 


	 Вывести сеты world. 


	 --is-current 


	 Проверить только, доступен и корректен ли  /var/cache/eix  (в версии, поддерживаемой бинарным  eix ). Если да, то eix успешно завершает работу, не выводя никаких сведений. 


	  Опции вывода ¶ 


	 -x ,  --versionsort     (переключатель) 


	 Вывести доступные версии, отсортировав их по слотам/версиям. Если сортировка производится по слотам, на каждой строке должен располагаться только один слот. 


	 -l ,  --versionlines    (переключатель) 


	 Вывести доступные версии (вертикальным списком). Кроме того, данные о IUSE будут отображаться отдельно для каждой версии (а не для всего пакета). 


	 -c ,  --compact    (переключатель) 


	 Использовать компактный формат вывода результатов поиска eix. Это удобно, если выводится длинный перечень; кроме того, тем самым ускоряется поиск на медленных соединениях, например, при использовании серийной консоли. 


	 -v ,  --verbose    (переключатель) 


	 Использовать подробный вывод с дополнительной информацией о результатах поиска - например, сообщать о лицензии, под которой распространяется пакет. 


	 --xml    (переключатель) 


	 Использовать вывод в формате XML. Если вы хотите передать эту опцию внешней программе, возможно, потребуется использовать ее в связке с  --care  и экспортировать некоторые переменные, такие как  LOCAL_PORTAGE_CONFIG , чтобы убедиться, что пользовательские настройки вывода не влияли на ваш вывод. Когда опция включена, автоматически включаются также  OVERLAYS_LIST=none  и  --pure-packages . Формат вывода можно незначительно модифицировать с помощью переменных  XML_* . Используемый XML-формат документирован и хранится в удобочитаемом виде в файле eix-xml.html или eix-xml.txt, а в менее удобном для восприятия виде (как xml-схема) - в файле eix-xml.xsd. 


	 -* ,  --pure-packages    (переключатель) 


	 (Не забывайте ставить кавычки, если используете краткую форму в оболочке.) Исключить вывод в конце дополнительной информации (имен оверлеев, количество найденных пакетов). Это может пригодиться при использовании сценариев интерпретатора с парсингом вывода. 


	 --only-names    (переключатель) 


	 Как "-*", но дополнительно выводить только категории и имена запрошенных пакетов. 


	 -0 ,  --brief    (переключатель) 


	 Вывести максимум один пакет и остановиться. Как правило, выполнение этой опции можно ускорить, назначив  COUNT_ONLY_PRINTED=false . В этом последнем случае при поиске по приблизительному соответствию могут быть выведены не самые последние доступные для установки версии. 


	 --brief2    (переключатель) 


	 Как  --brief , но вывод будет ограничен двумя пакетами. 


	  Особые опции  eix ¶ 


	 -t ,  --test-non-matching 


	 Перед очередным выводом отображать записи в /etc/portage/package.*, которые не соответствуют ни одной существующей версии в базе данных пакетов или пусты и не имеют смысла (см.  TEST_FOR_EMPTY ). 


	 Эта опция выводит также все установленные, но не фигурирующие в базе данных пакеты. 


	 Заметьте, что она действует совершенно иначе, нежели  -T  (см. ниже), которая только проверяет пакеты  в базе данных  на предмет наличия в /etc/portage/package.* дублированных записей или, соответственно, доступности установленных версий. 


	 Эту опцию предпочтительнее использовать в связке с  -T , для очистки /etc/portage/package.* 


	 Можно совмещать ее и с опцией  -e , чтобы избежать дополнительного вывода. 


	 Если по какой-либо причине вы хотите исключить отдельные записи/пакеты из числа проверяемых, вам следует поместь соответствующие записи в файл /etc/portage/package.*.nonexistent, где *=keywords,mask,unmask,use,env,cflags,installed. Эти файлы и порядок их переименования будут описаны ниже. 


	 --cache-file  ФАЙЛ 


	 Использовать  ФАЙЛ  вместо  /var/cache/eix . 


	  Опции ВЫРАЖЕНИя ¶ 


	 ВЫРАЖЕНИЕ используется для ограничения вывода пакетов при вызове eix. 


	 ВЫРАЖЕНИЕ может содержать булевы операторы и условия, согласно следующему синтаксису: 


	 ВЫРАЖЕНИЕ ::= [  --not  |  -!  ] ФИГУРНАЯ_СКОБКА_ИЛИ_ПРОВЕРКА | 


	 ВЫРАЖЕНИЕ [  --and |  -a  ] ВЫРАЖЕНИЕ | 


	 ВЫРАЖЕНИЕ [  --or  |  -o  ] ВЫРАЖЕНИЕ | 


	 ФИГУРНАЯ_СКОБКА_ИЛИ_ПРОВЕРКА ::=  --open | -(  ВЫРАЖЕНИЕ  --close | -)  | 


	 ПРОВЕРКА_ПО_КРИТЕРИЯМ 


	 ПРОВЕРКА_ПО_КРИТЕРИЯМ ::= [КРИТЕРИИ_ПРОВЕРКИ] [ШАБЛОН] 


	 Не забывайте, что в интерпретаторе символы  ! ,  ( ,  )  необходимо заключать в кавычки, чтобы eix распознал их как часть аргумента! 


	 Если вам необходимо, чтобы ВЫРАЖЕНИЕ начиналось с  - , поставьте впереди два дефиса подряд:  -- . Тогда ВЫРАЖЕНИЕ не будет воспринято как опция, а добавочные символы  --  будут проигнорированы. Например, команда  eix ---tool --or ---util  выведет пакеты, содержащие  -tool  или  -util . 


	 Думается, значение логических операторов очевидно - за исключением, может быть, следующих особенностей: 


	 1. Если между двумя ВЫРАЖЕНИями не стоит ни  --and | -a , ни  --or | -o , молчаливо принимается один из операторов. Какой из них -  -a  или  -o  - зависит от значения переменной конфигурации  DEFAULT_IS_OR . 


	 2. Операторы  -a  и  -o  имеют одинаковый приоритет, а содержащая их строка имеет левую ассоциативность. Иными словами,  X -o Y -a Z  не будет выполнено, если не выполнено  Z . 


	 3.  --not | -!  отрицает только результат следующего элемента ФИГУРНАЯ_СКОБКА_ИЛИ_ПРОВЕРКА. 


	 4. Если ШАБЛОН опущен, по умолчанию используется пустой ШАБЛОН. Например, при стандартных настройках  eix , будучи вызван без аргументов, выведет все пакеты, поскольку каждое имя содержит пустую строку. С другой стороны,  eix -e , как правило, не должен выводить ничего, ведь не существует пакета с именем,  в точности  совпадающим с пустой строкой. 


	 5. Заметьте, синтаксис подразумевает, что ШАБЛОН всегда завершает выражение. КРИТЕРИИ_ПРОВЕРКИ после ШАБЛОНа всегда начинают новое выражение (т.е. неявно подставляется  --and  или  --or , в зависимости от значения переменной  DEFAULT_IS_OR ). Так, команда  eix -e foo  не эквивалентна  eix foo -e . Вторая запись означает то же, что и  eix foo --and -e  или  eix foo --or -e , в зависимости от значения  DEFAULT_IS_OR . 


	 6. Имейте в виду, что КРИТЕРИИ_ПРОВЕРКИ могут включать несколько опций. Все они применяются одновременно, в том смысле, что они соединены логическим  и  (каково бы ни было значение переменной  DEFAULT_IS_OR ). Здесь присутствует некоторая двусмысленность, поскольку ШАБЛОН можно опустить. Во избежание этой двусмысленности последовательные КРИТЕРИИ_ПРОВЕРКИ всегда рассматриваются как часть одной ПРОВЕРКИ_ПО_КРИТЕРИЯМ. Например, в команде  eix -I -O -e foo  все опции рассматриваются как часть одного  ВЫРАЖЕНИЯ  (а не четырех, как это было бы в случае записи  eix -I '' -O '' -e '' foo ). С другой стороны, в команде  eix -I --not -e  оператор  --not  заставит следующий КРИТЕРИЙ_ПРОВЕРКИ  -e  воспринимать как относящийся к новому  ВЫРАЖЕНИю . Опции, отличные от КРИТЕРИЕВ_ПРОВЕРКИ и логических операторов (таких как  -! ,  -( ,  -) ,  -a ,  -o ), здесь игнорируются. Например,  eix -I -c -e  генерирует только одно  ВЫРАЖЕНИЕ , поскольку  -c  не является ни КРИТЕРИЕМ_ПРОВЕРКИ, ни логическим оператором, а следовательно, не влияет на интерпретацию  ВЫРАЖЕНИя . 


	 7. КРИТЕРИИ_ПРОВЕРКИ могут определять  алгоритм соответствия  и  выбор операции . Они относятся  только  к текущей ПРОВЕРКЕ_ПО_КРИТЕРИЯМ - в частности, они включены только для следующего  ШАБЛОНА . 


	 Знайте, что выражения можно использовать как в описанном синтаксисе, так и для неявного отбора пакетов по другим критериям, пусть это и займет дополнительное время. Для этого следует определить  FORMATSTRING  (см. ниже) с использованием условных выражений так, чтобы eix для нежелательных пакетов выводила пустую строку. 


	 Вот допустимые КРИТЕРИИ_ПРОВЕРКИ: 


	 -I ,  --installed 


	 Искать только среди установленных пакетов. Не используйте эту опцию вместо  eix-installed -a ,  qlist -ICv  или  equery  - они дают разные результаты. В данном случае в выводе не окажется пакетов, которые установлены, но были исключены из дерева портежей или оверлеев; впрочем, их лучше вовсе не иметь в системе (разумно будет помещать их в оверлеи на случай, если вдруг потребуется переустановка). Для обнаружения таких пакетов вы можете использовать команду  eix -te  (или  eix -tI  для включения в вывод и установленных пакетов из портежей), но имейте в виду, что обычные правила  FORMAT  не распространяются на eix -t. Таким образом, не следует включать эту опцию в сценариях, если вы не вполне уверены в своих действиях. 


	 Если вы все же решите использовать ее в сценарии вместо equery, есть смысл делать это вместе с одной из следующих опций: 


	 --format --only-names 


	 --format '<installedversions:NAMEVERSION>' --pure-packages 


	 --format '<installedversions:EQNAMEVERSION>' --pure-packages 


	 --format '<installedversions:NAMESLOT>' --pure-packages 


	 --format '<installedversions:NAMEASLOT>' --pure-packages 


	 --format '<installedversions:DATESORT>' --pure-packages 


	 -i ,  --multi-installed 


	 Искать только среди пакетов, имеющих как минимум две разных установленных версии. Как правило, это означает, что версии были помещены в разные слоты (во время установки). 


	 -d ,  --dup-packages 


	 Искать только среди дублирующих друг друга пакетов: например, sys-foo/bar может быть доступен как в официальном дереве портежей, так и в локальном оверлее. Если включена переменная  DUP_PACKAGES_ONLY_OVERLAYS  (см. ниже), искомые пакеты должны находится в двух разных оверлеях. 


	 -D ,  --dup-versions 


	 Искать только среди пакетов с дублирующими друг друга версиями: например, sys-foo/bar-0.2.1 может быть доступен как в официальном дереве портежей, так и в локальном оверлее. Если включена переменная  DUP_VERSIONS_ONLY_OVERLAYS  (см. ниже), искомые пакеты должны оба находится в оверлеях. 


	 -1 ,  --slotted 


	 Искать только среди пакетов с непустым слотом, т.е. с непустым и отличным от "0" значением SLOT. 


	 -2 ,  --slots 


	 Искать только среди пакетов с по крайней мере двумя различными слотами. В отличие от опции -1, здесь, если доступен только один слот, например, "4.3", пакет не будет отображен. 


	 -u ,  --upgrade ,  --upgrade+ ,   --upgrade- 


	 Искать только среди пакетов, имеющих как минимум одну установленную версию пакета в слоте, которая не является лучшей версией в этом слоте. Как правило, это означает, что вам следует либо обновить пакет, либо откатиться до более ранней версии. 


	 Впрочем, проверка будет произведена с учетом значения переменной  UPGRADE_TO_HIGHEST_SLOT  (см. ниже). 


	 Если вы использовали опции  --upgrade+  или  --upgrade- , операция осуществляется так, как если бы  LOCAL_PORTAGE_CONFIG  имела значение  true  или  false . Иначе утилита будет исходить из значения переменной  UPGRADE_LOCAL_MODE . 


	 Если вы хотите, чтобы отображались только пакеты, рекомендуемые для отката, вам следует обратиться к функциям  FORMATSTRING  (описание см. ниже). 


	 --stable ,  --testing ,  --non-masked ,  --system ,  --system-plain+ 


	 Искать только среди пакетов, хотя бы одна версия которых, соответственно, является стабильной (и не замаскированной), тестируемой или стабильной (и не замаскированной), не замаскированной, системной или виртуальным пакетом, только системной. Если в одном запросе вы совмещаете несколько опций из этого ряда, будет отображена только та версия, которая удовлетворяет им всем. 


	 --stable+ ,  --testing+ ,  --non-masked+ ,  --system+ ,  --system-plain+ 


	 Аналогично описанному выше, но временно принимается значение переменной  LOCAL_PORTAGE_CONFIG=true . 


	 --stable- ,  --testing- ,  --non-masked- ,  --system- ,  --system-plain- 


	 Аналогично описанному выше, но временно принимается значение переменной  LOCAL_PORTAGE_CONFIG=false . 


	 --installed-unstable ,  --installed-testing ,  --installed-masked 


	 Искать только среди пакетов, у которых установлена хотя бы одна версия, соответственно, нестабильная, тестируемая или замаскированная (временно принимается значение переменной  LOCAL_PORTAGE_CONFIG=false ). Если в одном запросе вы совмещаете несколько опций из этого ряда, будет выведена только та версия, которая удовлетворяет им всем. 


	 --world ,  --world-plain 


	 Искать только среди пакетов сета @world (а при  --world  - и среди пакетов-виртуалов для @world). Сопоставимо с "emerge @world", так как включает в поиск не только пакеты, перечисленные в файле world, но и пакеты из world-сетов и сета @system. Если вам это не нужно, выберите другую опцию для более узкой выборки. 


	 --world-file ,  --world-plain 


	 Искать только среди пакетов, фигурирующих в файле world или сете @system. При использовании опции  --world-file  будут отображаться и соответствующие им виртуальные пакеты. 


	 --world-set ,  --world-set-plain 


	 Искать только среди пакетов из файла world_sets или из сета @system. При использовании опции  --world-set  будут отображаться и соответствующие им виртуальные пакеты. 


	 --selected ,  --selected-plain 


	 Искать только среди пакетов из сета @selected. Сопоставимо с "emerge @selected", так как включает в поиск не только пакеты, перечисленные в файле world, но и пакеты из world-сетов и сета @system. (Если пакеты из сета @system у вас включены в файл world_sets, то вывод команды, разумеется, будет идентичен выводу при опции  --world ). При использовании опции  --selected  в вывод будут включены соответствующие пакеты-виртуалы. Если вам это не нужно, выберите другую опцию для более узкой выборки. 


	 --selected-file ,  --selected-file-plain 


	 Искать только среди пакетов из файла world. При использовании опции  --selected-file  в вывод будут включены также соответствующие виртуальные пакеты. 


	 --selected-set ,  --selected-set-plain 


	 Искать только среди пакетов из файла world_set. При использовании опции  --selected-set  в вывод будут включены также соответствующие виртуальные пакеты. 


	 --binary 


	 Искать только среди пакетов с бинарным файлом (*.tbz2-архивом) в PKGDIR. Версия бинарного файла должна совпадать с доступной либо установленной версией пакета. (Заметьте, однако, что если доступной версии нет, пакет также не будет обнаружен.) Проверяется только существование соответствующего *.tbz2-архива. Может ли portage использовать его - это уже другой вопрос, и ответ на него зависит также от состояния метаданных в *.tbz2 (например, от настроек USE), но eix за это не отвечает. 


	 -O ,  --overlay 


	 Искать только среди пакетов с как минимум одной версией в оверлее. 


	 --in-overlay  оверлей 


	 Искать только среди пакетов с как минимум одной версией в оверлее, удовлетворяющем шаблону  оверлей  в аргументе. 


	 Допускаются множественные аргументы: повторите опцию нужное количество раз, указав таким образом все  оверлеи , которые хотите включить в поиск. 


	 оверлей  может представлять собой либо шаблон, либо число. Обратите внимание, что, используя предлагаемое по умолчанию значение переменной  OVERLAYS_LIST=all-used-renumbered , вы не увидите корректной нумерации оверлеев; чтобы узнать правильный номер интересующего вас оверлея, необходимо вызвать: 


	 OVERLAYS_LIST=all eix --not 


	 ...а в сценариях - лучше так: 


	 OVERLAYS_LIST=all PRINT_COUNT_ALWAYS=never eix -! 


	 Специальные значения  0  и  $PORTDIR  соответствуют основному дереву портежей (оно условно принимается за нулевой оверлей). 


	 Если аргумент  оверлей  пуст (или опущен, если последняя опция  --in-overlay ), поиск будет произведен по всем оверлеям, кроме основного дерева портежей (т.е.  --in-overlay ''  работает идентично  -O ). 


	 --only-in-overlay  оверлей 


	 Искать среди пакетов с версиями только в оверлее, соответствующем шаблону  оверлей . 


	 Допускаются множественные аргументы: повторите опцию нужное количество раз, указав таким образом все  оверлеи , которые хотите включить в поиск. 


	 оверлей  может представлять собой либо шаблон, либо число, аналогично  --in-overlay .  --only-in-overlay ''  выведет все соответствующие аргументу пакеты не из официального дерева портежей, доступные только в оверлеях. 


	 -J ,  --installed-overlay 


	 Искать только среди пакетов, установленных из какого-либо оверлея. Чтобы обеспечить надежность результатов, укажите значением переменной  CHECK_INSTALLED_OVERLAYS  true (это значение не выставлено по умолчанию, потому что значительно замедляет работу утилиты). Подробнее см. в описании переменной  CHECK_INSTALLED_OVERLAYS . 


	 --installed-from-overlay  оверлей 


	 Эта опция аналогична  --in-overlay  с той разницей, что поиск будет произведен только среди пакетов, хотя бы одна версия которых установлена из  оверлея . Например, по запросу  --installed-from-overlay 0  будут выведены только те пакеты, хотя бы одна версия которых была установлена из дерева портежей. Чтобы обеспечить надежный результат при использовании -J, выставите значением переменной  CHECK_INSTALLED_OVERLAYS  true. 


	 --installed-in-some-overlay 


	 Искать только среди пакетов с по крайней мере одной установленной версией, доступной также в оверлеях. 


	 --installed-in-overlay  оверлей 


	 Опция аналогична  --in-overlay  с той разницей, что поиск ведется только среди пакетов, хотя бы одна установленная версия которых существует в  оверлее . Так, если задать  --installed-in-overlay 0 , будут выведены только те пакеты, у которых установлена хотя бы одна версия, доступная также в основном дереве портежей. 


	 --restrict-fetch 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=fetch. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-mirror 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=mirror. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-primaryuri 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=primaryuri. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-binchecks 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=binchecks. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-strip 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=strip. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-test 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=test. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-userpriv 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=userpriv. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-installsources 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=installsources. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-bindist 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=bindist. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --restrict-parallel 


	 Искать только среди пакетов, у которых хотя бы для одной версии RESTRICT=parallel. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --properties-interactive 


	 Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=interactive. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --properties-live 


	 Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=live. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --properties-virtual 


	 Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=virtual. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 --properties-set 


	 Искать только среди пакетов, у которых хотя бы для одной версии PROPERTIES=set. При использовании в связке с другими критериями проверки PROPERTIES/RESTRICT выводится только та версия, которая удовлетворяет им всем. 


	 -T ,  --test-obsolete 


	 Искать только среди устаревших пакетов. 


	 Пакеты считаются устаревшими, если им соответствуют дублирующие друг друга записи в /etc/portage/package.* (при условии, что переменная  TEST_FOR_REDUNDANCY  имеет значение true) или если не все установленные версии существуют (при условии, что переменная  TEST_FOR_NONEXISTENT  имеет значение true). 


	 Определение дублирования содержится в переменных  REDUNDANT_IF , описанных ниже, а определение несуществования - в переменных  NONEXISTENT_IF . Обратите внимание, что проверка версий пакетов из устаревших оверлеев надежна только в том случае, если переменная  CHECK_INSTALLED_OVERLAYS  у вас имеет значение true (это не значение по умолчанию, поскольку при его использовании проверка значительно замедляется). Подробнее см. в описании переменной  CHECK_INSTALLED_OVERLAYS . 


	 Учтите, что данная опция обеспечивает проверку только тех пакетов, которых находятся в базе данных - в частности, при ее использовании вы не обнаружите в выводе записей, соответствующих переименованным или удаленным пакетам (из дерева портежей). Если вы хотите увидеть именно их, используйте  -t . 


	 Итак, для поиска устаревших записей другого рода целесообразно применять данную опцию в связке с -t. 


	 Если по какой-либо причине вы хотите исключить из проверки некоторые пакеты, вы можете внести соответствующие записи в файл (или каталог) /etc/portage/package.nowarn. Он будет описан ниже; там же вы найдете информацию о том, как указывать альтернативные/дополнительные файлы). 


	 -| ,  --pipe 


	 (Помните, что интерпретатор команд не обработает символ  |  без кавычек.) 


	 Искать только среди пакетов из стандартного ввода. Как правило, эту опцию удобно использовать в конвейере, например, перенаправляя вывод emerge -pv (аналогично genlop -p). Будут обработаны все данные, формат которых содержит следующие слова (через пробел или знак новой строки): 


	 категория / пакет - версия  или 


	 категория / пакет 


	 Кроме того, все пакеты/версии, обработанные таким образом, в выводе будут маркированы. Подробнее о маркировании см. в описании строк формата  marked  и  markedversions:* . 


	 Даже если опция  --pipe  встречается несколько раз, стандартный ввод, разумеется, будет считан лишь единожды, но каждое вхождение опции обрабатывается отдельно (т.е. если первая --pipe выдает соответствие, то выдадут соответствие и остальные). 


	 Если вы хотите использовать стандартный ввод только для маркирования, но не для выбора, можно использовать выражение вида 


	 eix something -a "-(" --pipe -o "-)" 


	  Выбор поля соответствия ¶ 


	 Следующие опции определяют поля критериев, на соответствие которым будет проверяться шаблон. 


	 Одно выражение может включать несколько полей (выражение удовлетворяет запросу, если шаблон удовлетворяет хотя бы одному из указанных полей). Если вы не укажете некоторые из приведенных опций, по умолчанию будет выбрано поле соответствия  --name , но если у вас особый шаблон - например, вида "категория/пакет" или "@сет", вместо этого по умолчанию будет использовано поле соответствия  --category-name ,  --set ,  --description ,  --homepage ,  --virtual  или  --license . Параметры эвристической процедуры определяются переменной конфигурации  DEFAULT_MATCH_FIELD  (подробнее о ней см. ниже). 


	 -s ,  --name 


	 В аргументе, например, eix. 


	 -S ,  --description 


	 В аргументе, например, Small utility for searching. 


	 -C ,  --category 


	 В аргументе, например, app-portage. 


	 -A ,  --category-name 


	 В аргументе, например, app-portage/eix. 


	 -H ,  --homepage 


	 В аргументе, например,  http://eix.berlios.de/ . 


	 -L ,  --license 


	 В аргументе, например, GPL-2. 


	 -P ,  --provide 


	 В аргументе, например, virtual/blackbox. 


	 --set 


	 В аргументе - имя локального сета пакетов версии, содержащейся в базе данных (т.е. соответствующей файлу в каталоге  /etc/portage/sets ,  /etc/portage/sets.eix , или другом каталоге из значений переменной  EIX_LOCAL_SETS_ADD ; см. комментарии к  EIX_LOCAL_SETS ). Сеты system и world здесь преднамеренно не учитываются; для их сканирования следует использовать опции  --system[+-] ,  --world ,  --world-all  и  --world-sets . 


	 --slot 


	 В аргументе - имя слота версии в базе данных, например, kde-4. 


	 --installed-slot 


	 В аргументе - имя слота установленной версии. Помните, что без опции  --care  (или выставленного значения переменной  CAREMODE=true ) имя слота может быть только предположено. 


	 -U ,  --use 


	 В аргументе - USE-флаг, определенный IUSE в некоторой версии некоторыми ебилдами пакета. Чаще всего эта опция используется вместе с -e. 


	 --installed-with-use 


	 В аргументе - USE-флаг, который был включен при установке пакета. Разумеется, поиск в этом случае ведется только среди установленных пакетов. Заметьте, что это относится и к опции  -I  - в обоих случаях в обработку будут включены только пакеты, в настоящий момент присутствующие в базе данных. 


	 --installed-without-use 


	 В аргументе - USE-флаг, который был отключен при установке пакета. Разумеется, поиск в этом случае ведется только среди установленных пакетов. Заметьте, что это относится и к опции  -I  - в обоих случаях в обработку будут включены только пакеты, в настоящий момент присутствующие в базе данных. 


	  Алгоритм соответствия ¶ 


	 Нижеследующие опции определяют алгоритм, по которому поля соответствия будут соотнесены с шаблоном. Для одного соответствия можно выбрать только один алгоритм. Если вы опустите какие-либо из этих опций, значение по умолчанию будет определено эвристически, в зависимости от вида шаблона, по которому ведется поиск. В большинстве случаев по умолчанию будет использована опция  --regex , за исключениев случаев, когда вид шаблона говорит о том, что это glob-шаблон или подстрока (тогда по умолчанию используется соответствующий алгоритм), или когда шаблон имеет особый вид, например, или  категория/пакет  или  @сет  - в этом случае большинство пользователей ожидают поиска по всей строке или, соответственно, по началу строки. Параметры эвристической процедуры определяются переменной конфигурации  DEFAULT_MATCH_ALGORITHM  (подробнее о ней см. ниже). 


	 -e ,  --exact 


	 В аргументе - точная (полная) строка шаблона. Например, команда eix -e gcc выведет только пакеты gcc. 


	 -b ,  --begin 


	 Шаблон находится в начале строки. Так, команда eix -b gcc выведет не только пакет gcc, но и, например, gcc-config. 


	 --end 


	 Шаблон находится в конце строки. 


	 -z ,  --substring 


	 Шаблон находится в пределах строки. 


	 -f  [ N ],  --fuzzy  [ N ] 


	 Будет произведен приблизительный поиск с максимальным расстоянием Левенштейна  N  (по умолчанию) для всей строки. Имейте в виду, что использование этой опции замедляет поиск. 


	 -p ,  --pattern 


	 В аргументе - подстановочный шаблон (для всей строки). Подробности см. в справке по  fnmatch (3) и/или  glob (7). Убедитесь, что шаблоны заключены в одинарные кавычки (чтобы оболочка не перехватывала подстановочные знаки). 


	 -r ,  --regex 


	 В аргументе - регулярное выражение. Оно ищется только как подстрока (если только не используются символы ^, $); пустой шаблон вызывает вывод всех пакетов. Более подробную информацию об этом вы найдете в man-руководстве  regex (7). Как и в предыдущем случае, убедитесь, что шаблон заключен в одинарные кавычки. 


	  Определение формата вывода (см. ниже  FORMATSTRING ) ¶ 


	 --format   ФОРМАТ 


	 Назначить  ФОРМАТ  стандартным форматом вывода результатов поиска. 


	 --format-compact   ФОРМАТ 


	 Назначить  ФОРМАТ  компактным форматом вывода результатов поиска. 


	 --format-verbose   FORMAT 


	 Назначить  ФОРМАТ  подробным форматом вывода результатов поиска. 


	  Особые опции для  eix-update ¶ 


	 -o   файл_вывода ,  --output   файл_вывода 


	 При использовании этой опции  eix-update  запишет базу данных eix не в  /var/cache/eix , а в  файл_вывода , не проверяя и не меняя права доступа к этому файлу. 


	 -a   оверлей ,  --add-overlay   оверлей 


	 Эта опция аналогична добавлению  оверлея  в значения переменной  PORTDIR_OVERLAY  в файле /etc/make.conf или изменению  ADD_OVERLAY , но имеет то преимущество, что вам нет нужды редактировать переменные, а кроме того, вы можете использовать пробелы в аргументе. Оверлеи, добавленные с помощью данной опции, идут следом за оверлеями, добавленными через  KEEP_VIRTUALS . Если  оверлей  уже фигурирует в списке оверлеев, эта опция отработает вхолостую. Опция может быть использована несколько раз, для добавления нескольких оверлеев. 


	 -x   оверлей ,  --exclude-overlay   оверлей 


	 Эта опция аналогична добавлению  оверлея  в значения переменной  EXCLUDE_OVERLAY , но имеет то преимущество, что вам нет нужды редактировать переменную, а кроме того, вы можете использовать пробелы в аргументе.  оверлей  здесь рассматривается как маска. Все удовлетворяющие шаблону оверлеи (даже те, которые были добавлены с помощью описанных ниже опций  --add-overlay ) исключаются из списка оверлеев. Каталог  PORTDIR  рассматривается как обычный оверлей, который также может быть исключен (в таком случае в качестве  PORTDIR  будет сохранен первый  оверлей  из перечисленных). Опция может быть использована несколько раз, для исключения нескольких оверлеев. 


	 -m   оверлей   метод ,  --override-method   оверлей   метод 


	 Изменить текущий метод кэширования  оверлея  (каталог  PORTDIR  считается допустимым  оверлеем ) на указанный аргументом  метод .  оверлей  рассматривается как маска, т.е. может содержать подстановочные знаки. Если  оверлей  не сопоставлен ни одной записи в списке оверлеев, эта опция отработает вхолостую. Данная опция аналогична добавлению записи " оверлей   метод " в конец переменной  OVERRIDE_CACHE_METHOD . Опция может быть использована несколько раз, для переопределения метода кэширования для нескольких оверлеев. Приоритет имеет последнее значение. В частности, значение, переопределенное с помощью данной опции, будет иметь приоритет над значением  OVERRIDE_CACHE_METHOD . 


	 -r   путь-к-оверлею   метка-оверлея ,  --repo-name   путь-к-оверлею   метка-оверлея 


	 Оверлей, расположенный по адресу  путь-к-оверлею , получит  метку-оверлея , независимо от других настроек. Это поведение можно переопределить через  REPO_NAMES . В отличие от значения  REPO_NAMES ,  путь-к-оверлею  представляет собой не шаблон, а точный путь. 


	 ВЫВОД ¶ 


	  Слоты ¶ 


	 В отличие от обычного вывода версий в emerge,  eix  может отображать также имена слотов, если они непусты и отличны от нуля. Это поведение определяется содержимым  FORMATSTRING . 


	 Если слоты отображаются, то имя слота либо отделяется от номера версии двоеточием, либо заключается в скобки. Вы можете выбрать предпочтительный формат разделителя, редактируя переменную  COLON_SLOTS . 


	 Если переменная  PROPERTIES  или  RESTRICT  определена в ебилде, это по умолчанию показывается в строке версии; более тонкая настройка доступна путем редактирования переменных конфигурации. 


	 Вот несколько примеров: 


	 4.1.1:4.1     или     4.1.1(4.1) 


	 Версия 4.1.1 будет установлена в слот 4.1. 


	 3.14p:GNAT-3.14p     или     3.14p(GNAT-3.14p) 


	 Версия 3.14p будет установлена в слот GNAT-3.14p. 


	 2.0.0_rc1-r6 


	 Версия 2.0.0_rc1-r6, значение SLOT либо пусто, либо "0". 


	 1.0+i+l+v+s!f!m!p!b!s!t!u!i!d!P{tbz2} 


	 Версия 1.0, для которой PROPERTIES="interactive live virtual set", а также RESTRICT="fetch mirror primaryuri binchecks strip test userpriv installsources bindist parallel" Кроме того, в  PKGDIR . существует *.tbz2-архив (бинарный пакет) для этой версии. 


	 5.0-r3(5.0R3)!f 


	 Версия 5.0-r3 будет установлена в слот 5.0R3, с ограничением по загрузке. 


	  Маскировка ¶ 


	 Достаточно поработать с gentoo неделю, чтобы легко опознавать формат маскировки в строках версий. Тем не менее мы напомним об этом на нескольких примерах. Разумеется, изложенное ниже относится только к стандартным настройкам; чтобы изменить параметры, используйте параметры конфигурации. 


	 [P]2.95.3-r8 


	 Если в файлах пакетов вашего профиля была обнаружена маска пакета, но данная версия не совпадает с ней, говорят, что версия "замаскирована профилем". 


	 [M]4.0.0_alpha20050213 


	 Версия совпадает с маской из /etc/portage/package.mask, $PORTDIR/profiles/package.mask или package.mask в вашем профиле. Portage называет это "маскировкой package.mask". 


	 [m]4.1.4 


	 Версия совпадает с локальной маской (из /etc/portage/package.mask), но не замаскирована ни профилем, ни $PORTDIR/profiles/package.mask. 


	 {P}2.95.3-r8 


	 Первоначально версия была замаскирована профилем, но эта маскировка была локально изменена в /etc/portage/profile/packages. 


	 {M}4.0.0_alpha20050213 


	 Первоначально версия была замаскирована $PORTDIR/profiles/package.mask, но эта маскировка была локально изменена в /etc/portage/package.unmask. 


	 * 3.3.3 


	 Версия "замаскирована отсутствующим ключевым словом", но стабильна на других архитектурах. 


	 ~*3.3.3 


	 Версия замаскирована отсутствующим ключевым словом и нестабильна на других архитектурах. 


	 **3.3.3 


	 Версия замаскирована отсутствующим ключевым словом для всех архитектур. 


	 (**)3.4.3-r2 


	 Первоначально версия не имела ключевого слова, но этот параметр был локально изменен (в /etc/portage/package.keywords или путем редактирования переменной ACCEPT_KEYWORDS). 


	 -*3.4.3-r2 


	 Версия "замаскирована ключевым словом -*" для всех архитектур (в скором времени это обозначение перестанет поддерживаться). 


	 -0.8.14 


	 Версия замаскирована -ARCH. 


	 ~3.3.5.20050130 


	 Версия замаскирована ключевым словом ~keyword. 


	 (~)3.3.5.20050130 


	 Первоначально версия была замаскирована ключевым словом ~keyword, но эта маскировка была локально изменена (в /etc/portage/package.keywords или путем редактирования переменной ACCEPT_KEYWORDS). 


	 [M]~1.0.9626 


	 Версия замаскирована одновременно package.mask и ключевым словом ~keyword. 


	 [m](~)4.1.4-r1 


	 Первоначально версия была замаскирована только ключевым словом ~keyword, но эта маскировка была локально изменена (в /etc/portage/package.keywords или путем редактирования ACCEPT_KEYWORDS). Тем не менее версия замаскирована локально (в /etc/portage/package.mask). 


	 3.3.1 


	 Наконец, эта запись обозначает стабильную версию; она стабильна и без локальных настроек. 


	  eix-diff ¶ 


	 Вывод утилиты  eix-diff  полностью определяется переменными конфигурации ( DIFF_FORMAT_NEW ,  DIFF_FORMAT_DELETE ,  DIFF_FORMAT_CHANGED  и a множество других переменных, к которым - по крайней мере, при стандартных настройках - обращаются перечисленные посредством отложенной замены. См. ниже.) Таким образом, ниже на примерах мы показываем только стандартное поведение текущей версии eix. Хотя этот стандартный формат уже довольно давно не меняется, в новых версиях eix мы не можем гарантировать стабильности настроек по умолчанию. 


	 [N]   >> foo/bar (~1.0): description of foo/bar 


	 В дереве портежей появился свежий пакет  foo/bar . 


	 [*N]  >> foo/bar (1.0): description of foo/bar 


	 В дереве портежей появился свежий пакет  foo/bar . Кроме того, он имеет версию (1.0), которая может быть установлена без размаскировки или изменения ключевых слов. 


	       << foo/bar ({M}1.0): description of foo/bar 


	 Пакет  foo/bar  был удален из дерева портежей; предыдущая версия,  1.0 , ранее была замаскирована, но сейчас уже не замаскирована (вероятно, потому, что разработчик при удалении пакета удалил файл package.mask). 


	 [*>]   == foo/bar (1.0): description of foo/bar 


	 Статус пакета  foo/bar  в дереве портежей изменился (для ваших настроек): для него появилась версия (1.0), которая может быть установлена без размаскировки и изменения ключевых слов, в то время как ранее foo/bar такой версии не имел. Кроме того, символ  >  означает, что один слот получил более новую версию. В данном случае появление и  > , и  *  вызвано одним и тем же изменением. 


	 [><]  == foo/bar (1.1(1) 2.0(2) -> 1.0(1) 2.1(2)): description 


	 Статус пакета  foo/bar  в дереве портежей изменился (для ваших настроек): символы в левой части строки означают, что один слот получил более новую версию пакета, которая может быть установлена без размаскировки и изменения ключевых слов, а из другого слота эта новая версия была удалена. Если вы посмотрите на версии, то увидите, что слот  2  получил новую версию (предыдущая стабильная версия в этом слоте была  2.0 , теперь  2.1 ), а версия, которая до этого была последней,  1.1 , была удалена из слота  1  или замаскирована (текущая стабильная версия в этом слоте -  1.0 ). 


	 [UD]  == foo/bar (1.1(1)@01.01.2009; 1.1(1) -> 2.0(2)): description 


	 Статус пакета  foo/bar  в дереве портежей изменился (для ваших настроек): символы в левой части строки означают, что единственный установленный слот может быть обновлен (без изменения масок/ключевых слов), а другой слот, в который производилась установка, был удален/замаскирован. Версии, указанные в правой части строки, показывают, что установленная версия  1.1  в слоте  1  была удалена или замаскирована, а другой установленной версии в  1  нет. Однако в слоте  2  появилась новая стабильная версия (слот  2  ранее не существовал или не имел стабильной версии). 


	 Поскольку еще ни одна версия не была установлена в слот  2 , eix в этой ситуации не может определить, уместно ли обозначение " U ". Ведь eix не отслеживает зависимости и поэтому не знает, будет ли использован новый слот, например,  world-файлом, или же существует только некоторая зависимость со старым слотом. Поэтому символ " U " в этом случае будет отображен только если выставлено значение  UPGRADE_TO_HIGHEST_SLOT=true  или если пакет фигурирует в  /etc/portage/package.slot_upgrade_allow . 


	 Вывод вида   == foo/bar ...  был бы, на самом деле, более логичным, поскольку дополнительно один слот приобрел новую стабильную версию, а из другого слота была удалена версия, до бывшая до того времени новейшей стабильной. Однако, поскольку " U " или, соответственно, " D " это и так подразумевают, разработчики приняли решение по умолчанию никогда не отображать символы  <  и  > , если имеется обозначение  U  или  D . Разумеется, вы вправе изменить это поведение, создав собственную строку  DIFF_FORMAT_HEADER_CHANGED . 


	 FORMATSTRING ¶ 


	 Строка формата может содержать условные блоки, свойства пакетов, настройки цветного вывода и стандартные строки. Если для какого-либо пакета строка формата занимает часть пустой строки, отображается и завершающий переход на новую строку. Таким образом, вы можете заключить всю строку формата в условный блок, чтобы выводились только те пакеты, которые соответствуют условию. Ниже будет приведен пример такого сценария-обертки. 


	  Условные блоки ¶ 


	 Принцип действия условий прост: расширяется какое-либо свойство, и результирующая строка сопоставляется с другой строкой. Если они совпадают, условие признается истинным и выполняются команды в блоке. С условиями можно использовать отрицание, чтобы, когда условие истинно, выполнялись команды из части "else", а когда оно ложно - команды из части "if". Часть "else" может не выполняться вовсе. 


	 { [ ! ] СВОЙСТВО [ = RHS ' ] } TCODE {} 


	 Если строка, полученная в результате развертывания  СВОЙСТВа , совпадает с  RHS , выполнить  TCODE . Символ  !  обозначает отрицание действия.  RHS  представляет собой либо свойство (если заключен в <>), либо переменную (если имеет префикс $), либо строку (если заключен в кавычки или не сопровождается никакими служебными символами). 


	 { [ ! ] СВОЙСТВО [ = RHS ] } TCODE {else} FCODE {} 


	 Если строка, полученная в результате развертывания  СВОЙСТВа , совпадает с  СТРОКОЙ , выполнить  TCODE . Иначе выполнить  FCODE . 


	 СВОЙСТВО  может быть либо одним из свойства пакетов, описанных ниже, либо обращением к переменной. Обращение к переменной имеет вид  $ ПЕРЕМЕННАЯ . Нет необходимости инициализировать эту  ПЕРЕМЕННую  : по умолчанию она содержит пустую строку. 


	 Для изменения  ПЕРЕМЕННой  исполняемой среды используйте следующий синтаксис: 


	 { [ ! ] * ПЕРЕМЕННАЯ [ = RHS ] } 


	 Значением переменной исполняемой среды  ПЕРЕМЕННАЯ  станет  СТРОКА . С  !  результат будет либо пустым, либо равным 1, в зависимости от того, пуста или непуста  СТРОКА . Если опущена завершающая часть (включая символ  = ), блок получает особое значение:  {*I<ПЕРЕМЕННАЯ}  устанавливает значением  ПЕРЕМЕННой  единицу,  {!*I<ПЕРЕМЕННАЯ }> устанавливает значением  ПЕРЕМЕННой  пустую строку. 


	  Свойства пакетов ¶ 


	 Имена, которые соответствуют отдельным свойствам обрабатываемого пакета. Если вы используете имя для вывода свойства, оно  должно быть заключено в "уголки"  (т.е. иметь вид "<имя>"). 


	 name ,  category ,  homepage ,  licenses 


	 Соответственно название, категория, веб-страница проекта текущего пакета и лицензии, под которыми он распространяется. 


	 availableversions: ПЕРЕМЕННАЯ ,  availableversions: ПЕРЕМЕННАЯ : СЛОТЫ_ПЕРЕМЕННЫХ 


	 Для каждой версии выводится содержимое переменной конфигурации/окружения с именем  ПЕРЕМЕННАЯ ; оно интерпретируется как строка формата. При использовании второго типа синтаксиса и если хотя бы один слот пакета непуст, вместо  ПЕРЕМЕННой  работают  СЛОТЫ_ПЕРЕМЕННЫХ , а версии сортируются по слотам. 


	 На всякий случай уточним: требуемый формат нельзя указывать непосредственно после двоеточия; вместо этого необходимо сохранить его в новой переменной.  ПЕРЕМЕННАЯ  и  СЛОТЫ_ПЕРЕМЕННЫХ  - всего лишь их имена. 


	 Полезными примерами  ПЕРЕМЕННой  являются  NAMEVERSION ,  EQNAMEVERSION ,  EQNAMEVERSION ,  ANAMESLOT ,  ANAMEASLOT ,  NAMESLOT ,  NAMEASLOT ,  DATESORT .  ANAMESLOT  и  ANAMEASLOT  предназначены для использования во втором типе синтаксиса, т.е. в конструкциях  availableversions:ANAMESLOT:ANAMESLOT  или  availableversions:ANAMEASLOT:ANAMEASLOT  (Легко запомнить:  A SLOT отображает слот всегда ( a lways)).  NAMESLOT ,  NAMEASLOT  и  DATESORT  имеют смысл только для установленных версий. Подробнее об этих переменных читайте, выполнив  eix --dump . 


	 markedversions: ПЕРЕМЕННАЯ ,  markedversions: ПЕРЕМЕННАЯ : СЛОТЫ_ПЕРЕМЕННЫХ 


	 Аналогично  availableversions  с той разницей, что будут выведены только маркированные версии. 


	 bestversion: ПЕРЕМЕННАЯ ,  bestversion*: ПЕРЕМЕННАЯ ,  bestslotversions: ПЕРЕМЕННАЯ ,  bestslotversions*: ПЕРЕМЕННАЯ ,  bestslotupgradeversions: ПЕРЕМЕННАЯ ,  bestslotupgradeversions*: ПЕРЕМЕННАЯ 


	 Аналогично  availableversions  с той разницей, что будет выведена только лучшая/-ие версия/-ии в каждом слоте. При использовании конструкций с символом  *  в вывод включаются и нестабильные версии. При использовании конструкций, включающих  upgrade , обрабатываться будут только те версии, которые должны появиться после обновления. 


	 installedversions: ПЕРЕМЕННАЯ 


	 Аналогично  availableversions  с той разницей, что будут выведены только установленные версии. 


	 installedmarkedversions: ПЕРЕМЕННАЯ 


	 Аналогично  installedversions  с той разницей, что будут только маркированные версии. 


	 first ,  last ,  slotfirst ,  slotlast ,  oneslot 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Вы можете использовать эти флаги, чтобы выяснить, первую или последнию версию пакета вы просматриваете (как правило, это бывает полезно, если вам необходим вывод какого-либо дополнительного текста). Аналогично, если вывод сортируется по слотам, вы можете проверить, первая или последняя версия в слоте отображается; возможно, существует всего один слот. Если условие удовлетворено, все эти свойства пусты, иначе их значение - 1. Чтобы было удобнее повторно использовать код, когда вывод сортируется по слотам, переменная  slotfirst / slotlast  эквивалентна  first / last , а значение  oneslot  равно 1. 


	 slot ,  isslot ,  overlayver ,  overlaynum ,  versionkeywords 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Будет выведен текущий слот, оверлей или полные ключевые слова для текущей версии. Переменная  overlayver  пуста, если пакет целиком из одного оверлея; в этом случае, чтобы увидеть оверлей, следует использовать  overlay .  overlaynum  же содержит номер оверлея; не поддерживает цветной вывод (если пакет не из оверлея, переменная пуста). Формат вывода  versionkeywords  обусловлен значениями переменных  FORMAT_BEFORE_KEYWORDS ,  FORMAT_AFTER_KEYWORDS ,  PRINT_EFFECTIVE_KEYWORDS ,  FORMAT_BEFORE_EFFECTIVE_KEYWORDS ,  FORMAT_AFTER_EFFECTIVE_KEYWORDS .  isslot  позволяет выяснить, не пуст ли слот, и в этом случае возвращает 1, в противном случае не возвращает ничего. 


	 isbestupgrade ,  isbestupgrade* ,  isbestupgradeslot ,  isbestupgradeslot* 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Если текущая версия является лучшей или, соответственно, лучшей в текущем слоте для обновления, будет возвращена единица. При использовании конструкций, включающих символ  * , в обработку будут включены нестабильные версии. 


	 installedversion ,  markedversion 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Возвращает 1, если текущая версия установлена или, соответственно, маркирована, иначе возвращает пустую строку. 


	 ishardmasked ,  washardmasked ,  isprofilemasked ,  wasprofilemasked ,  ismasked ,  wasmasked ,  isstable ,  wasstable ,  isunstable ,  wasunstable ,  isalienstable ,  wasalienstable ,  isalienunstable ,  wasalienunstable ,  ismissingkeyword ,  wasmissingkeyword ,  isminuskeyword ,  wasminuskeyword ,  isminusunstable ,  wasminusunstable ,  isminusasterisk ,  wasminusasterisk 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Возвращает 1, если текущая версия стабильна в локальной конфигурации или, соответственно, в конфигурации по умолчанию, иначе возвращает пустую строку. 


	 isbinary 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Если существует соответствующий версии *.tbz2-архив, возвращает 1, если архив не существует, возвращает пустую строку. 


	 restrict ,  restrictfetch ,  restrictmirror ,  restrictprimaryuri ,  restrictbincheck ,  restrictstrip ,  restricttest ,  restrictuserpriv ,  restrictinstalledsources ,  restrictbindist ,  restrictparallel 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Если для версии включен какой-либо из атрибутов  RESTRICT , возвращает 1, если нет, возвращает пустую строку. 


	 properties ,  propertiesinteractive ,  propertieslive ,  propertiesvirtual ,  propertiesset 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Если для версии включен какой-либо из атрибутов  PROPERTIES , возвращает 1, если нет, возвращает пустую строку. 


	 haveuse ,  use 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Отображает информацию сообразно значениям переменной  IUSE  (для доступных версий) или  USE  (для установленных версий).  haveuse  можно использовать для проверки, будет ли вывод непустым (тогда возвращает 1, иначе пустую строку). Для доступных версий  use  выводит переменную  IUSE . Для установленных версий  use  выводит  USE  -флаги и информацию о том, установлены ли они (если нет, содержимое переменных  FORMAT_BEFORE_SET_USE ,  FORMAT_AFTER_SET_USE ,  FORMAT_BEFORE_UNSET_USE ,  FORMAT_AFTER_UNSET_USE  выводится там, где это предусмотрено). 


	 date: ПЕРЕМЕННАЯ 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Отображает дату установки; формат функции даты strftime() считывается из  ПЕРЕМЕННОЙ . 


	 version 


	 Только если  ПЕРЕМЕННАЯ  используется в контексте вывода версий. Выводит простую версию в текстовом формате. 


	 installed ,  best ,  best* 


	 Возвращает 1, если хотя бы одна версия пакета установлена или, соответственно, имеется лучшая стабильная/нестабильная версия пакета, иначе возвращает пустую строку. 


	 versionlines 


	 Если утилите был передан флаг --versionlines, возвращает 1, иначе возвращает пустую строку. 


	 slotsorted 


	 Если утилите был передан флаг --versionsort, возвращает 1, иначе возвращает пустую строку. 


	 color 


	 Если вывод поддерживает цвета/маркеры, возвращает 1, иначе возвращает пустую строку. Например, если вывод перенаправляется в терминал и явно не выставлена обратная опция, переменная будет пуста. 


	 setnames ,  allsetnames 


	 Имена всех локальных сетов, которым принадлежит пакет, через пробел. При использовании  allsetnames  в обработку будет включен сет system. 


	 binary 


	 Если хотя бы для одной версии (доступной или установленной) имеется соответствующий ей *.tbz2-архив, возвращает 1, иначе пустую строку. См. примечания к опции  --binary . 


	 overlaykey 


	 Если все версии находятся в одном оверлее, значение "[overlaykey]" будет выведено с поддержкой цвета. 


	 system 


	 Если пакет существует в системном профиле или является виртуалом пакета из системного профиля, переменная получает значение 1. 


	 world 


	 Если пакет фигурирует в world-файле или является виртуалом пакета из world-файла, переменная получает значение 1. 


	 world_sets 


	 Если пакет принадлежит world-сетам или является виртуалом пакета из world-сетов, переменная получает значение 1. 


	 systempure 


	 Если пакет существует в системном профиле, переменная получает значение 1. 


	 worldpure 


	 Если пакет фигурирует в world-файле, переменная получает значение 1. 


	 world_setspure 


	 Если пакет принадлежит world-сетам, переменная получает значение 1. 


	 provide 


	 Строка PROVIDE для пакета. 


	 marked 


	 Если пакет был передан утилите с опцией  --pipe , переменная получает значение 1. Обычно это имеет смысл только для проверки. 


	 havemarkedversion 


	 Если хотя бы одна доступная версия пакета маркирована, возвращает 1, иначе пустую строку. Имейте в виду, что пакет может оказаться маркирован, при том что не маркирована ни одна из его версий. 


	 slots ,  slotted 


	 Если имеется как минимум два слота или, соответственно, как минимум один непустой слот, переменная получает значение 1. 


	 colliuse ,  havecolliuse 


	 Набор IUSE-флагов (т.е. все флаги вместе взятые) для всех доступных версий пакета, через пробел. Переменная  havecolliuse  получает значение 1, если  colliuse  непуста; она работает быстрее, чем colliuse. 


	 haveversionuse 


	 Для экономии памяти и/или дискового пространства eix можно собирать без поддержки  IUSE  -флагов для каждой отдельно взятой версии. Если текущий пакет взят из такой базы данных или если eix был скомпилирован без учета этой информации, будет возвращена пустая строка, иначе 1. Даже если проверка дала отрицательный результат, вы можете использовать синтаксис  use:... , как описано выше. В этом последнем случае, однако, переменная окажется пуста. 


	 havebest ,  havebest* 


	 Если пакет имеет лучшую стабильную или, соответственно, нестабильную версию, переменная получает значение 1. 


	 upgrade ,  upgradeorinstall ,  downgrade ,  recommend ,  recommendorinstall 


	 upgrade  получает значение 1, если пакет установлен и как минимум один слот может быть обновлен (или если лучшая стабильная версия занимает новый слот, а значение переменной  UPDATE_TO_HIGHEST_SLOT  - true). Другие переменные из этого ряда аналогичным образом проверяют, может ли пакет быть обновлен или установлен заново, следует ли откатить его до более ранней версии, может/должно ли быть произведено обновление/откат, может/должно ли быть произведено обновление/откат/установка, соответственно. Переменная  RECOMMEND_LOCAL_MODE  определяет, подчиняется ли описанная проверка  LOCAL_PORTAGE_CONFIG . 


	 bestupgrade ,  bestupgradeorinstall ,  bestdowngrade ,  bestrecommend ,  bestrecommendorinstall 


	 Как в предыдущем случае, с той разницей, что во внимание принимается только лучшая стабильная версия пакета (а не все слоты). 


	 better ,  worse ,  differ ,  bestbetter ,  bestworse ,  bestdiffer 


	 Могут использоваться только в условных выражениях внутри  DIFF_FORMAT_CHANGED .  better  получает значение 1, если новый пакет имеет новый слот или новую стабильную версию (или прежнюю версию, но из другого оверлея) в любом слоте.  worse  ведет себя аналогично в том случае, если прежняя версия имеет как минимум один лучший слот или слот, недоступный для нового пакета.  differ  возвращает единицу в том случае, если не все лучшие стабильные слоты прежних и новых пакетов совпадают. Соответствующие  best*  -версии ведут себя аналогично с той разницей, что учитываются только лучшие стабильные версии (а не все слоты). Переменная  RECOMMEND_LOCAL_MODE  определяет, подчиняется ли проверка настройкам переменной  LOCAL_PORTAGE_CONFIG . 


	 old... ,  new... 


	 Могут использоваться только внутри  DIFF_FORMAT_CHANGED . Любое свойство может получить префикс  old  или  new  и соответствующее этому свойству значение, но с учетом, соответственно, прежних или новых данных. Если префикса  old  или  new  нет, по умолчанию принимается новая версия. Например, конструкция  oldavailableversions:ПЕРЕМЕННАЯ  выведет предыдущие доступные версии (ПЕРЕМЕННАЯ при этом определяет формат вывода), а  newavailableversions:ПЕРЕМЕННАЯ  и  availableversions:ПЕРЕМЕННАЯ  выведут доступные версии текущего (т.е. нового) пакета. 


	  Цвета вывода ¶ 


( ИМЯ , ЯРКОСТЬ ; МАРКЕРЫ )

	 Последовательность ", ЯРКОСТЬ " и/или "; МАРКЕРЫ " может быть опущена. 


	 При  ЯРКОСТи , равной 1, eix будет использовать для  ИМени  соответствующий 'яркий' (насыщенный) цвет ; если  ЯРКОСТЬ  равна 0 - стандартный цвет. 


	 Пустое  ИМЯ  соответствует значению default, и, в отличие от значения none, возвращает вывод к стандартным настройкам цвета, без маркеров. 


	 Пустое значение (или отсутствие)  МАРКЕРов  соответствует значению none, т.е. изменения атрибутов не происходит. Можно одновременно указывать несколько атрибутов маркировки (через запятую). 


	 Доступные цвета:  default (по умолчанию), none (нет), black (черный), red (красный), green (зеленый), yellow (желтый), blue (синий), purple (лиловый), cyan (ультрамарин), gray (серый) . 


	 Доступные атрибуты маркировки:  none (нет), bold (жирный), underline (подчеркивание), blink (мигание), inverse (негатив) . 


	  Примеры: ¶ 


	 FORMAT='{installed}(yellow,1;underline){else}(yellow,0){}<name>()}\n' eix ... 


	 Если пакет  ...  установлен, выводит его имя ярким желтым цветом с подчеркиванием, иначе обычным желтым цветом. 


	 FORMAT='<category>/<name><installedversions:INSTFORMAT>\n' INSTFORMAT='{first}:{}<version><date:DATEFORMAT>{!last}\n\t{}' DATEFORMAT='%x' eix autom* 


	 Для каждого пакета  autom*  выводит имя с указанием категории, а если пакет установлен, то и установленные версии и соответствующие им даты установки. Тот же результат можно было бы получить, вместо  \t\n{}  поставив  :{else}\t\n{} , поскольку в конце каждой версии, кроме последней, и в начале каждой версии, кроме первой, выводится, разумеется, одна и та же последовательность  \t\n . 


	 FORMAT='{downgrade}%{FORMAT_ALL}{}' eix -I 


	 Будут выведены все установленные пакеты, которые рекомендуется откатить до более ранних версий. Заметьте, что конструкция  FORMAT='{downgrade}%{FORMAT}{}'  не работает, поскольку в этом случае в отложенной замене возникает определение со ссылкой на само себя; естественно, переменную нельзя определять значением самой этой переменной. Поэтому начиная с версии eix 0.13.4 содержимое  FORMAT  и других подобных ей переменных значительно упростилось:  %{FORMAT_ALL}  (для других родственных переменных аналогично). Таким образом, вы можете свободно вставлять полное определение исходного значения  FORMAT  (что мы и сделали в приведенном примере). 


	 Обратите внимание: если вы хотите представить предыдущий пример в компактном выводе, вы не можете просто добавить опцию  -c  - единственным эффектом, которого вы добьетесь, будет то, что для определения строки формата будет использована переменная  FORMAT_COMPACT , а не  FORMAT . Для того, чтобы действительно получить компактный вывод, используйте либо: 


 FORMAT_COMPACT='{downgrade}%{FORMAT_ALL_COMPACT}{}' eix -Ic  

	 либо (что еще проще): 


	 FORMAT='{downgrade}%{FORMAT_ALL_COMPACT}{}' eix -I 


	 ФАЙЛЫ ¶ 


	  /etc/eix-sync.conf ¶ 


	 В данном файле хранятся команды и настройки, применяемые к сценарию  eix-sync . Комментарии в нем начинаются с символа  #  (строки обрезаются при первом вхождении  # ; с  #  нельзя использовать маски). Строки могут иметь описанный ниже вид и исполняются в заданном порядке перед вызовом  emerge --sync . 


	 Обратите внимание, что к этому файлу добавляется содержимое переменной  EIX_SYNC_CONF . По умолчению она расширена на  EIX_SYNC_OPTS , так что значения этой переменной также добавляются в файл. Обе упомянутые переменные могут использоваться для переопределения настроек по умолчанию, указанных в  /etc/eix-sync.conf . При выполнении  eix-sync  анализируется большая часть этих строк, поэтому необходимо учитывать требования безопасности! 


	 опция/-ии 


	 Использовать  опцию/-ии  по умолчанию для eix-sync (ставится перед всеми остальными опциями). В общем случае  опции  должны начинаться с символа " - ".  опции  анализируются оболочкой внутри сценария  eix-sync , поэтому обратите внимание на безопасность и убедитесь, что разделители команд оболочки правильно оформлены кавычками! 


	 Имя 


	 Вызвать команду  layman -s   Имя . Утилита  layman  предназначена для синхронизации оверлеев и доступна в портежах как  app-portage/layman . 


	 * 


	 Вызвать  layman -S  (т.е. синхронизировать оверлеи с помощью layman). 


	 ! команда 


	 Анализировать  команду  внутри сценария оболочки  eix-sync  (в той же оболочке).  команда  должна успешно завершить работу, в противном случае  eix-sync  сделает останов и выдаст ошибку. (Таким образом, конструкция  !layman   Имя  практически идентична записи  Имя .) Если вы хотите, чтобы статус выхода игнорировался, пишите в конце команды "; true". 


	 Вы можете использовать данную функцию для распаковки оверлея перед вызовом  layman  или для внесения локальных изменений после вызова  layman . 


	 В последних версиях eix  команда  уже ничего не выводит (если вам необходим вывод, используйте einfo) и не анализируется в подоболочке. Иными словами, при необходимости вы можете свободно редактировать переменные окружения, начинать/завершать перенаправление. Недостаток такого поведения состоит в том, что не менее легко и допустить ошибку: переопределить внутренние переменные или функции eix-sync. Если вы опасаетесь что-либо нарушить, заключайте команду в скобки (...), чтобы она запускалась в подоболочке. 


	 !! команда 


	 Аналогично записи  !   команда  с той разницей, что в данном случае  команда  будет выполнена в любом случае, даже при использовании опций -d, -u, -l. Это позволяет устанавливать переменные окружения для других программ. 


	 ~ команда 


	 Имеет смысл только при использовании eix-sync опций  -s  и  -2 . В таком случае  команда  будет выполнена перед первым вызовом  rsync ; вывод  команды  анализируется внутри оболочки  eix-sync . Если  команда  или анализ ее вывода отрабатывают с ошибкой,  eix-sync  перестанет выполняться и выдаст сообщение об ошибке. Это можно использовать, например, чтобы выполнить  keychain  и возвратить содержимое соответствующего файла  ~/.keychain/*-sh , либо для возвращения команд экспорта для текущих переменных  SSH_AUTH_SOCK  и  SSH_AGENT_PID . Допускается также вывод  команды  в виде команды, изменяющей значения переменных  PORTAGE_RSYNC_OPTS ,  PORTAGE_RSYNC_EXTRA_OPTS ,  PORTDIR ,  PORTDIR_SERVER ,  PORTDIR_CLIENT ,  SERVER ,  CLIENT . При вызове  команды  данные переменные получат значения по умолчанию и в дальнейшем будут использованы для команд  rsync  с их очевидным значением. 


	 @ команда 


	 Добавить привязку к  команде ; фактическое выполнение  команды  будет отложено до вызова  emerge --sync  (успешного). 


	 @@ команда 


	 Добавить привязку к  команде ; фактическое выполнение  команды  будет отложено до вызова  emerge --sync  (успешного) с последующим  eix-update . 


	 Вот  примерная  последовательность привязок/команд: 


	 привязки  !! 


	 cp /var/cache/eix /var/cache/eix.previous 


	 вызов layman, привязки  !  в порядке, указанном в /etc/eix-sync.conf 


	 привязки  ~ 


	 emerge --sync 


	 привязки  @ 


	 eix-update 


	 привязки  @@ 


	 eix-diff /var/cache/eix.previous 


	 Несколько полезных примеров вы найдете в  /etc/eix-sync.conf : 


	 -C --ignore-default-opts 


	 Используйте эту строку, если у вас включена опция --ask в переменной EMERGE_DEFAULT_OPTS в файле /etc/make.conf, но вы не хотите, чтобы при выполнении eix-sync было затребовано подтверждение операции. 


	 -r -M 


	 Используйте эти параметры, если у вас  PORTDIR_CACHE_METHOD=assign , а функция  FEATURES=metadata-transfer  неактивна или (по умолчанию в последних версиях portage) отключена. При необходимости вы можете также использовать  -r  и  -M  по отдельности или заменить  -M  строкой. 


	 @emerge --regen 


	 Запускать  emerge --regen  вместо  emerge --metadata . 


	 @egencache --repo=local --update 


	 Обновлять кэш метаданных оверлея с именем репозитария local между вызовами eix-update и emerge --sync. Это имеет смысл в том случае, если для данного оверлея используется метод кэширования  metadata-flat , и вы хотите убедиться, что кэш метаданных обновлен. Побочным эффектом этого поведения является то, что команда  egencache  будет выполняться даже в том случае, если репозитарий не изменился (так обычно и происходит с локальными репозитариями). 


	 !egencache --repo=foo --update 


	 Обновить кэш метаданных оверлея с именем репозитария foo. Это имеет смысл в том случае, если ранее у вас была строка  foo  или  !команда для обновления foo , призванная обеспечить обновление репозитария (будь то с помощью layman или какой-либо другой утилиты), а вы хотите использовать для этого оверлея метод кэширования  metadata-flat , несмотря на то, что кэш метаданных содержит ошибки или не существует в данном репозитарии. 


	 !!exec >/var/log/eix-sync.log ; chown portage: /var/log/eix-sync.log || true 


	 Направить вывод в журнал (с соответствующими правами). true в конце обозначает, что выполнение сценария будет продолжено принудительно даже в том случае, если chown выдает ошибку. Если вы не хотите перенаправлять вывод конечного  eix-diff , вам следует использовать эту конструкцию в связке со следующей: 


	 @@exec >/dev/tty 


	 Отображать статистику выполнения  eix-diff  в терминале, даже если было сделано перенаправление. 


	 @@exit 0 


	 Не выполнять  eix-diff . 


	 !!export FORCE_USECOLORS= ${FORCE_USECOLORS:-true} 


	 Если только переменная FORCE_USECOLORS не определяет иное для вашего окружения, вывод eix будет цветным даже в случае перенаправления. 


	 ~keychain --quiet ~/.ssh/id_rsa ; cat ~/.keychain/ `hostname`-sh 


	 @@eix-remote update  * `portageq portdir`/local/layman/eix-caches.tar.bz2 * 


	 (Если вам не нужна локальная копия данных из каталога /usr/portage/local/layman, последний аргумент можно опустить.) 


	 @eix-remote fetch /var/cache/remote-cache.tbz2 


	 @@eix-remote add /var/cache/remote-cache.tbz2 


	  /etc/eixrc ¶ 


	 Глобальный конфигурационный файл eix. Значения переменных в  ~/.eixrc  или в окружении могут переопределять переменные, определенные в этом файле. См.  ~/.eixrc . 


	  EIXRC ¶ 


	 Если эта переменная окружения установлена, то ее значение будет использовано вместо /etc/eixrc при обращении к данным конфигурации. В таком случае содержимое файла ~/.eixrc будет проигнорировано (но вы, разумеется, можете указать явно, что должны использоваться его значения, если это необходимо). 


	  EIX_SYNC_OPTS, EIX_SYNC_CONF, EIX_REMOTE_OPTS, EIX_LAYMAN_OPTS, EIX_TEST_OBSOLETE_OPTS ¶ 


Хотя эти переменные обычно настраиваются в ~/.eixrc (описаны в соответствующем разделе), мы упоминаем их здесь, поскольку они чрезвычайно важны для безопасности. Они (по крайней мере некоторые) анализируются оболочкой, если вы запускаете сценарии с соответствующим именем. Поэтому вы непременно должны убедиться, что при запуске этих сценариев из-под root'а переменные не будут изменены. 

	  ~/.eixrc ¶ 


	 Пользовательский файл конфигурации. Переменные в этом файле могут быть переопределены переменными окружения. Для присвоения им значений вы можете использовать shell-подобный синтаксис. Вы можете подключать и другие файлы, использовать вспомогательные переменные для настройки. 


	 Если вы используете вспомогательные переменные обычным образом, вы можете только просматривать заменяемые значения с помощью --dump или --dump-defaults и не можете заменять подставляемые значения, например, в окружении. 


	 Таким образом, вы можете обращаться к переменным не только используя обычный синтаксис оболочки, но и с помощью конструкции  %{ ПЕРЕМЕННАЯ }  (скобки можно опускать). Это означает, что замена будет отложена до того момента, когда все файлы конфигурации и переменные среды будут обработаны. Отложенная замена не отображается при использовании опций with --dump или --dump-defaults. 


	 Такое поведение именуется отложенной заменой / отложенным обращением и предоставляет несколько дополнительных возможностей: 


	 Специальные символы для отложенной замены 


	  %{% 


	 Требуется в случае, если вам необходимо использовать в переменной  %{  (в противном случае произойдет отложенная замена). 


	 * ПЕРЕМЕННАЯ 


	 Если отложенное обращение использует имя переменной, начинающееся с  * , символ  *  заменяется на  EIX_  или  DIFF_ , в зависимости от того, вызывается ли переменная из  eix / eix-update  или из  eix-diff . Это позволяет иметь различные настройки по умолчанию для этих программ. 


	 Так, отложенное обращение  %{* ПЕРЕМЕННАЯ }  подставит расширенное значение  EIX_ ПЕРЕМЕННАЯ  или  DIFF_ ПЕРЕМЕННАЯ , сооветственно. 


	 Атрибуты  \  и  *  могут быть совмещены (порядок не имеет значения). 


	 \ ПЕРЕМЕННАЯ 


	 Если отложенное обращение использует имя переменной, начинающееся с  \ , все символы \ символы [\n\r\t ] в значении (расширенной)  ПЕРЕМЕННой  рассматриваются как экранированные. 


	 Так, отложенное обращение  %{\ ПЕРЕМЕННАЯ }  может быть использовано в таких переменных как  CACHE_METHOD  или  EIX_LOCAL_SETS ; это гарантирует, что  ПЕРЕМЕННАЯ  имеет не более одной "необработанной" записи, даже если она содержит пробелы или обратный слэш. 


	 Атрибуты  \  и  *  могут быть совмещены (порядок не имеет значения). 


	 Условные блоки в отложенных обращениях 


	 Если вы хотите заменять значения нескольких переменных совершенно иным образом, в зависимости от статуса определенной переменной (булевой), вы можете использовать условные блоки. 


	 В известной степени их функционирование здесь аналогично поведению условных блоков в FORMATSTRING: если переменная, к которой происходит обращение, наконец получает булево значение true ( true / 1 / yes / y / on ) (или, соответственно, любое непустое значение, если  ПЕРЕМЕННАЯ  имеет префиксом дополнительный символ  ? ), в результате будет возвращено значение true, и соответствующий блок строки будет расширен. Можно использовать отрицание условий, чтобы расширялась часть "else", когда условие истинно, и часть "if", когда условие ложно. Часть "else" может не выполняться вовсе. Допустимо использовать особые имена переменных:  * ПЕРЕМЕННАЯ  вместо  ПЕРЕМЕННАЯ . 


	 %{? ПЕРЕМЕННАЯ } TCODE %{} 


	 Расширить  TCODE , если  ПЕРЕМЕННАЯ  получает значение true. 


	 %{?? ПЕРЕМЕННАЯ } TCODE %{} 


	 Расширить  TCODE , если  ПЕРЕМЕННАЯ  получает значением непустую строку. 


	 %{! ПЕРЕМЕННАЯ } TCODE %{} 


	 Расширить  TCODE , если  ПЕРЕМЕННАЯ  получает значение false. 


	 %{!? ПЕРЕМЕННАЯ } TCODE %{} 


	 Расширить  TCODE ,  ПЕРЕМЕННАЯ  получает значением пустую строку. 


	 %{? ПЕРЕМЕННАЯ } TCODE %{else} FCODE %{} 


	 Расширить  TCODE , если  ПЕРЕМЕННАЯ  получает значение true, иначе  FCODE . 


	 %{?? ПЕРЕМЕННАЯ } TCODE %{else} FCODE %{} 


	 Расширить  TCODE , если  ПЕРЕМЕННАЯ  получает значением непустую строку, иначе  FCODE . 


	 %{! ПЕРЕМЕННАЯ } TCODE %{else} FCODE %{} 


	 Расширить  TCODE , если  ПЕРЕМЕННАЯ  получает значением false, иначе  FCODE . 


	 %{!? ПЕРЕМЕННАЯ } TCODE %{else} FCODE %{} 


	 Расширить  TCODE , если  ПЕРЕМЕННАЯ  получает значением пустую строку, иначе  FCODE . 


	 Условный блок может и целиком помещаться в одной переменной. В этом случае будет невозможно, например, заменить символ  %{}  путем отложенного обращения к другой переменной (но в  TCODE / FCODE  использование отложенных обращений допускается). 


	 Заметьте, что все переменные, которые вы добавляете для отложенной замены, выводятся с помощью опции --dump, только если они действительно используются (т.е. если к ним обращаются какие-либо другие переменные). Если вы хотите видеть их во всех случаях, например, для удобства комментирования или последующих изменений, вы можете собрать ссылки на них в переменной  DUMMY . 


	 Следующие переменные не содержат используемых только для отложенных обращений. Чтобы получить подробное описание этих последних переменных (и их стандартных настроек), выполните  eix --dump . 


	 DUMMY   (строка) 


	 Эта переменная не влияет напрямую на программы, но может быть использована для хранения отложенных обращений к переменным (не обрабатываемым иным образом), чтобы их можно было просмотреть с помощью --dump или --dump-defaults. 


	 EIX_SYNC_OPTS ,  EIX_SYNC_CONF   (строка) 


	 Значение переменной  EIX_SYNC_CONF  добавляется в файл  @SYSCONFDIR/eix-sync.conf . Подробности см. в описании этого файла. По умолчанию  EIX_SYNC_CONF  представляет собой отложенную замену для  EIX_SYNC_OPTS , т.е. вы обычно можете использовать  EIX_SYNC_OPTS  в тех же целях. Помните, что если одна из этих переменных будет поставлена под угрозу, при вызове  eix-sync  с привилегиями администратора может произойти практически всё что угодно - подумайте о безопасности ! Если вы используете эти переменные, аккуратно расставляйте кавычки! 


	 EIX_REMOTE_OPTS ,  EIX_LAYMAN_OPTS ,  EIX_TEST_OBSOLETE_OPTS   (строка) 


	 Содержимое этих переменных анализируется и используется в качестве аргументов сценариями  eix-remote ,  eix-layman  и  eix-test-obsolete  соответственно. Поэтому не забывайте о рисках безопасности и всегда ставьте переменные в кавычки! 


	 EIXRC_SOURCE   (строка) 


	 Данный путь используется как префикс source-команд в /etc/eixrc. Стандартно он должен быть определен в окружении, но может быть определен и в файле /etc/eixrc. В последнем случае он переопределит значение переменной окружения непосредственно при обработке, пока всем файлам не будут сопоставлены источники. Обратите внимание, что в момент считывания значения переменной отложенная замена еще не произведена. 


	 EIX_PREFIX   (строка префикса)  ("строка префикса" означает строку, но если она имеет значение '/', оно будет заменено на '') 


	 Эта переменная предназначена главным образом для присвоения значения в окружении, если вы хотите использовать chroot. Она применяется как префикс пути, по которому ищется /etc/eixrc. Если этот путь не определен, служит префиксом значения переменной окружения  PORTAGE_CONFIGROOT . Если не определена и она, используется значение переменной по умолчанию (как правило, пустое). 


	 Кроме того, данная переменная используется при отложенной замене для определения префикса путей других переменных; подробнее о переменных, которые к ней обращаются, см. в выводе  eix --dump . При текущих настройках по умолчанию она изменяет все пути, за исключением: 


	 EPREFIX   (строка префикса) 


	 Для этой переменной значение по умолчанию берется из EIX_PREFIX; к нему добавляется умолчание, зависящее от конфигурации (для prefix-portage). Эта переменная не имеет собственного значения и используется при отложенной замене для определения префикса путей других переменных (если не изменены их значения по умолчанию); подробнее о переменных, которые к ней обращаются, см. в выводе  eix --dump . При текущих настройках по умолчанию она изменяет все пути, за исключением: 


	 /usr/bin/eix-functions.sh 


	 ~/.eixrc 


	 путь к файлу/-ам кэша , переданный командной строке 


	 PORTAGE_PROFILE  (переменная, но не ссылка) 


	 PORTDIR 


	 Пути доступа к оверлеям 


	 Последние три могут быть изменены через  EPREFIX_TREE . 


	 Переменная  EPREFIX  предназначена для обеспечения доступа, подобного chroot, к prefix-portage. Заметьте, что как пользователь prefix-portage вы должны будете выполнять eix-sync с опцией  -e . 


	 ROOT   (строка префикса) 


	 EPREFIX_TREE   (строка префикса) 


	 EPREFIX_ROOT   (строка префикса) 


	 На самом деле это не внутренние переменные eix - они просто используются для отложенной замены со следующими переменными, аналогично  EPREFIX  (см. ниже). 


	 Для базового отслеживания использования portage данной переменной служит переменная  ROOT . Заметьте, что переменные в файле /etc/make.conf не переопределяют переменные конфигурации eix. Так, команда  ROOT= что-либо , прописанная в /etc/make.conf, никак не скажется на поведении eix. Если вам нужно обратное, установите новое значение в окружении или в конфигурационном файле eix. 


	 Вы можете легко изменить пути, к которым относятся  EPREFIX  и  ROOT  : для этого просто используйте при определении соответствующих переменных отложенные обращения  %{EPREFIX} ,  %{ROOT} ,   %{EPREFIX_ROOT}  (которые, в свою очередь, определяются как отложенное обращение, так что вы можете свободно переопределять поведение программы, в случае если и  EPREFIX , и  ROOT  непусты: вы можете совместить эти два пути, а можете выбрать только один из них), или же не используйте ничего. Разумеется, для отложенного обращения вы можете назначать и другие переменные, например: 


	 EIX_CACHEFILE= %{EPREFIX_PROFILE}/var/cache/eix 


	 Используйте эту настройку, если вы хотите, чтобы файл кэша eix зависел от профиля администратора (и только от него). 


	 PORTAGE_CONFIGROOT   (строка префикса) 


	 Используется как префикс путей каталога /etc. Задача - сохранять PORTAGE_CONFIGROOT аналогично тому, как это делает portage. Если вы определяете эту переменную в окружении, одновременно изменится и путь доступа к /etc/eixrc. (Заметьте, что обращение к файлу /etc/eixrc происходит до выполнения отложенной замены.) 


	 MAKE_GLOBALS   (строка) 


	 Если этот файл существует, он будет использован вместо  %{PORTAGE_CONFIGROOT}/etc/make.globals . Значение по умолчанию соответствует поведению *portage-2.2* и выше. 


	 EPREFIX_SOURCE   (строка префикса) 


	 Используется как префикс путей - аргументов source-команд в файлах /etc/make.conf и /etc/make.globals. 


	 EPREFIX_INSTALLED   (строка префикса) 


	 Используется как префикс пути, по которому eix ожидает информацию об установленных пакетах. 


	 EPREFIX_PORTAGE_CACHE   (строка префикса) 


	 Используется как префикс пути к кэшу портежей. 


	 EPREFIX_ACCESS_OVERLAYS   (строка префикса) 


	 Используется как префикс путей к оверлеям, для доступа к их файлам. 


	 EPREFIX_PORTDIR   (строка префикса) 


	 Используется как префикс  PORTDIR . 


	 EPREFIX_OVERLAYS   (строка префикса) 


	 Используется как префикс всех записей в  PORTAGE_OVERLAY . 


	 EPREFIX_PROFILE   (строка префикса) 


	 Используется как префикс  PORTAGE_PROFILE  (переменной, а не ссылки). 


	 EPREFIX_VIRTUAL   (строка префикса) 


	 Используется как префикс оверлеев в базе данных eix для проверки их существования. 


	 EIX_CACHEFILE   (строка) 


	 Файла кэша eix (обычно  %{EPREFIX}/var/cache/eix ). 


	 EIX_WORLD   (строка) 


	 Файл, который eix рассматривает как файл world. Учтите, что обычно этот файл доступен для чтения только в том случае, если вы входите в группу portage. Во избежание проблем с правами доступа можно использовать переменную  SAVE_WORLD . 


	 EIX_WORLD_SETS   (строка) 


	 Файл, который eix рассматривает как файл world_sets. Для него справедливо всё сказанное для  EIX_WORLD . 


	 EIX_LOCAL_SETS   (список строк) (что такое список строк, объясняется далее) 


	 Это список каталогов, которые содержат локально определенные сеты. Каталоги считываются в заданном порядке; файлы с именами сетов, которые были обработаны ранее, игнорируются: в этом отношении предшествующие записи в  EIX_LOCAL_SETS  имеют приоритет над новыми. 


	 Для относительных каталогов (т.е. каталогов, имена которых не начинаются с символа  / ) родительским считается  $PORTDIR . Записи в  EIX_LOCAL_SETS , начинающиеся со специального символа  * , рассматриваются особо, как несколько записей; при этом символ  *  последовательно заменяется путями доступа к оверлеям, в обратном порядке (это сделано потому, что в некотором смысле более ранние записи  EIX_LOCAL_SETS  переопределяют более поздние, в то время как для переменной  PORTDIR_OVERLAY  программа ожидает обратного). 


	 По умолчанию эта переменная содержит  /etc/portage/sets ,  /etc/portage/sets.eix ,  sets  (т.е., в общем,  ${PORTDIR}/sets , исходя из предыдущего абзаца),  */sets  (т.е., в общем,  ${PORTIDR_OVERLAY}/sets , исходя из предыдущего абзаца), а также  %{EIX_LOCAL_SETS_ADD} . Последнее обращение позволяет вам добавлять дополнительные каталоги к значению переменной  %{EIX_LOCAL_SETS_ADD}  в файле  /etc/eixrc . Это может быть полезно, в частности, если вы определили другой каталог для множественных сетов (например, для оверлея или для обработки "world-candidate = False") в файле /etc/portage/sets.conf вашей системы или в файле sets.conf file какого-либо оверлея. 


	 Во всех списках строк переменных разделителями записей могут служить [ \t\r\n]. Если вы хотите использовать один из них внутри строки, не забудьте экранировать его с помощью  \ . Все обратные слэши также должны быть экранированы, поскольку служебные обратные слэши при символах обратного слэша и при разделителях удаляются. Если вы хотите использовать переменную в "обычном" виде, вы можете прибегнуть к отложенной замене: конструкция  %{\ ПЕРЕМЕННАЯ }  вставит в текст значение  ПЕРЕМЕННОЙ  с экранированными [\ \t\r\n]. (Подробнее см. в разделе об отложенной замене.) 


	 EAPI_REGEX 


	 Это регулярное выражение соответствует распознанным EAPI в суффиксах ебилдов, интерпретируемых согласно GLEP 55. Может потребоваться изменить это выражение локально, в зависимости от установленной версии portage (чтобы убедиться, что она умеет производить синтаксический анализ соответствующих EAPI). В исключительных случаях переменная может оказаться пуста; тогда все ебилды с EAPI-суффиксами будут проигнорированы. 


	 SAVE_WORLD   (true / false) 


	 Если эта переменная имеет значение true, данные вашего world-файла будут храниться в /var/cache/eix. Таким образом, всякий, кто имеет доступ к этому файлу, будет располагать содержимым вашего "мира". Если вы этого не хотите, не ставьте значением переменной true. 


	 CURRENT_WORLD   (true / false) 


	 При значении false будут использованы данные world-файла, хранящиеся в файле /var/cache/eix, даже если текущий world сам доступен для чтения. Иначе эти данные будут переопределены текущим world-файлом (при условии, что он доступен для чтения). 


	 SKIP_PERMISSION_TESTS   (true / false) 


	 При значении  true  eix-update не будет проверять группы и привилегии. Вероятно, это имеет смысл, если вы используете более тонкий способ настройки прав доступа (NSS/LDAP, acl, утилиты, использующие pam и т.д.), иначе eix может неверно определить права. Единственный недостаток такого режима заключается в том, что eix-update не будет выдавать ошибок в начале, а выдаст ошибку (иногда неверно ее истолковав) при попытке  получить доступ к кэш-файлу без достаточных привилегий. 


	 EBUILD_USER ,  EBUILD_GROUP ,  EBUILD_UID ,  EBUILD_GID 


	 Эти переменные определяют права методов кэширования  ebuild / ebuild* . Подробнее см. в разделе о данных методах кэширования. 


	 PORTAGE_ROOTPATH ,  PORTAGE_BIN_PATH 


	 Если эти переменные не пусты, они без изменений передаются сценарию ebuild.sh, при кэшировании методом  ebuild* . Заметьте, что ebuild.sh использует данные переменные для расчета пути PATH, так что здесь кроется серьезная угроза безопасности. 


	 NOFOUND_STATUS   (целое число) 


	 Это значение используется в качестве статуса выхода в том случае, если найдено 0 соответствий запросу. Учитывается значение переменной  COUNT_ONLY_PRINTED . 


	 MOREFOUND_STATUS   (целое число) 


	 Это значение используется в качестве статуса выхода в том случае, если найдено хотя бы 2 соответствия запросу. Учитывается значение переменной  COUNT_ONLY_PRINTED . 


	 QUICKMODE   (true / false) 


	 Если переменная имеет значение true, eix и eix-diff по умолчанию будут использовать опцию  --quick . 


	 CAREMODE   (true / false) 


	 Если переменная имеет значение true, eix и eix-diff по умолчанию будут использовать опцию  --care . 


	 USE_BUILD_TIME   (true / false) 


	 Переменная определяет, использовать ли запись BUILD_TIME из базы данных портежей (если она существует) вместо отметки времени каталога (обычно это время установки). Разница между двумя этими возможностями имеет значение только для пакетов, устанавливаемых из .tbz2-архивов. В большинстве случаев важнее время сборки; эти данные к тому же надежнее. К сожалению, время сборки доступно только для пакетов, собранных и установленных portage не ниже версии 2.2_rc63. Чтобы выяснить, к каким пакетам это относится, а к каким нет, можно использовать команду  eix-installed [no-]buildtime . Считывание времени сборки всегда занимает больше времени, чем использование отметки времени из каталога (даже если время сборки недоступно). Поэтому, возможно, будет удобнее назначить данной переменной значение  false , если для вас важнее скорость работы eix, чем корректность данных времени сборки. 


	 QUIETMODE   (true / false) 


	 Если переменная имеет значение true, eix и eix-diff по умолчанию будут использовать опцию  --quiet . 


	 PRINT_APPEND   (строка) 


	 Эта строка добавляется к выводу опции of --print. Внутри нее стандартно интерпретируются специальные символы, например, \n. По умолчанию - новая строка для разумного вывода в интерактивной оболочке. Обратите внимание, что при замене команд в сценариях оболочки удаляются все пробелы в конце, поэтому новая строка не создаст здесь никакого неудобства (а пробелы в конце переменной в сценарии в любом случае будут  удалены). Поэтому чтобы считывать переменные, предоставляемые eix, внутри сценария оболочки без опущения завершающих пробелов, следует использовать видимый символ для переменной PRINT_APPEND и работать с конструкциями типа *<nt>ПЕРЕМЕННАЯ="`PRINT_APPEND=x eix --print ПЕРЕМЕННАЯ`" ; ПЕРЕМЕННАЯ="${VAR%x}"</nt>* 

*NEWLINE* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение true, eix будет переходить на новую строку после каждой версии, для которой строка формата предусматривает какой-либо вывод. Значение *true* может быть полезно, если вы используете пустые строки формата, выводящие только одну строку (если не хотите вручную добавлять переход на новую строку в строке формата). Однако если вы используете строку формата, которая выводит по версии на строку, причем отображаются только те версии, которые удовлетворяют определенному запросу, оказывается довольно неудобно отслеживать непосредственно в строке формата, делать ли явный переход на новую строку или это произойдет автоматически. В этом случае оптимальным решением будет значение *NEWLINE=false*<nt>.</nt> Стандартная строка формата eix корректно обрабатывает оба варианта (проверяет значение переменной *NEWLINE* и переходит на новую строку, только если это требуется).

p((((. Если только вам не нужна поддержка строки формата, которую вы прописали ранее, мы рекомендуем сохранить значение по умолчанию *NEWLINE=false* и вручную добавить *\n* (или явно перейти на новую строку) в конце строки формата. Если же вы самостоятельно писали строки формата, следует обновить их так, чтобы происходил переход на новую строку, а не указывать *NEWLINE=true*. Данная возможность существует лишь в интересах обратной совместимости и может быть исключена в следующих версиях eix. 

*DEFAULT_FORMAT* *(normal*<nt>/</nt>*compact*<nt>/</nt>*verbose)* 

p((((. Определяет, какой из двух режимов - *<nt>--compact</nt>* или *<nt>--verbose</nt>* - используется по умолчанию.

*DIFF_ONLY_INSTALLED* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение true, eix-diff будет обрабатывать изменения версии только для установленных пакетов.

*DIFF_NO_SLOTS* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение true,  eix-diff не будет обрабатывать слоты для изменившихся версий.

*DIFF_SEPARATE_DELETED* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение true, eix-diff отобразит удаленные пакеты в отдельном блоке. Иначе eix-diff выведет удаленные и измененные пакеты общим алфавитным списком.

*DIFF_PRINT_HEADER* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение true, eix-diff выведет информационный заголовок.

*NO_RESTRICTIONS* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение false, будут выведены данные RESTRICTION и PROPERTIES. 

*RESTRICT_INSTALLED* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение true, будут рассчитываться ограничения загрузки и зеркала для установленных версий.

*CARE_RESTRICT_INSTALLED* *(true*<nt>/</nt>*false)* 

p((((. Если переменная имеет значение true, ограничения загрузки и зеркала для установленных версий всегда будут браться с диска, даже если эти данные могут быть считаны непосредственно с соответствующей версии пакета. Это медленнее, но надежнее, так как будут выявлены и измененные ограничения.

*FORMAT*, *FORMAT_COMPACT*, *FORMAT_VERBOSE* *(строка)* 

p((((. Эти переменные определяют соответственно стандартный, компактный и подробный форматы вывода *eix*<nt>.</nt> См. *FORMATSTRING*<nt>.</nt> Начиная с eix-0.13.4 эти переменные просто расширяются на отложенную замену переменных *FORMAT_ALL*, *FORMAT_ALL_COMPACT* и *FORMAT_ALL_VERBOSE*<nt>, соответственно</nt>. Такое определение призвано упростить доступ к стандартному определению, когда вы меняете определение *FORMAT*<nt>.</nt> 

*DIFF_FORMAT_NEW*, *DIFF_FORMAT_DELETE*, *DIFF_FORMAT_CHANGED* *(строка)* 

p((((. Эти переменные определяют формат вывода для пакетов, которые были добавлены, удалены или для которых стала доступна новая стабильная версия. Они используются только *eix-diff*<nt>.</nt> См. *FORMATSTRING*<nt>.</nt> Начиная с eix-0.13.4 эти переменные просто расширяются на отложенную замену переменных *DIFF_FORMAT_ALL_NEW*, *DIFF_FORMAT_ALL_DELETE* и  DIFF_FORMAT_ALL_CHANGED , соответственно. 


	 FORMAT_INSTALLATION_DATE ,  FORMAT_SHORT_INSTALLATION_DATE 


	 Определяется формат функции strftime(), используемые для отображения времени установки (в стандартном или, соответственно, сокращенном виде). 


	 FORMAT_INSTALLED_USE 


	 Определяет printf-подобный формат, используемый для отображения USE-флагов установленных пакетов. Если значением переменной является пустая строка, обработка происходит несколько быстрее, поскольку данные не будут считываться. 


	 FORMAT_BEFORE_KEYWORDS ,  FORMAT_AFTER_KEYWORDS ,  FORMAT_BEFORE_EFFECTIVE_KEYWORDS ,  FORMAT_AFTER_EFFECTIVE_KEYWORDS 


	 Эти строки выводятся перед/после строки KEYWORDS (текущей) для данной версии. 


	 FORMAT_BEFORE_SET_USE ,  FORMAT_AFTER_SET_USE ,  FORMAT_BEFORE_UNSET_USE ,  FORMAT_AFTER_UNSET_USE 


	 Эти строки выводятся перед/после включенных/отключенных USE-флагов установленных версий. 


	 FORCE_USECOLORS   (true / false) 


	 Отображать в цвете, даже если стандартный вывод не терминал. 


	 FORCE_PERCENTAGE   (true / false) 


	 Отображать ход выполнения операции в процентах, даже если стандартный вывод не терминал. 


	 STYLE_VERSION_SORTED   (true / false) 


	 Определяет, включена ли по умолчанию опция  --versionsort . 


	 STYLE_VERSION_LINES   (true / false) 


	 Определяет, включена ли по умолчанию опция  --versionlines . 


	 DUP_PACKAGES_ONLY_OVERLAYS   (true / false) 


	 Определяет, производится ли проверка дублирующих друг друга пакетов только среди оверлеев, т.е. будет ли считаться пакет дублированным только в том случае, если он существует по меньшей мере в двух оверлеях. 


	 DUP_VERSIONS_ONLY_OVERLAYS   (true / false) 


	 Определяет, производится ли проверка дублирующих друг друга версий только среди оверлеев, т.е. будет ли считаться пакет дублированным только в том случае, если он существует по меньшей мере в двух оверлеях. 


	 DEFAULT_IS_OR   (true / false) 


	 Если имеется несколько шаблонов в аргументах, не соединенных логически (операторами -a и -o), eix подразумевает их неявное объединение. Если значением этой переменной является true, подразумевается, что производится дизъюнкция -o (or), иначе конъюнкция -a (and). 


	 OVERLAYS_LIST   (all / all-if-used / all-used / all-used-renumbered / no) 


	 Пользователи, работающие со множеством оверлеев, хотели ли бы, чтобы в конце отображались не все оверлеи, а только действительно используемые. Это поведение настраивается здесь. Значение переменной интерпретируется следующим образом: 


	 all-if-used / if-used / if 


	 Отображать все оверлеи, если используется хотя бы один из них. В версиях eix ниже 0.6.0 эта настройка предлагалась по умолчанию. 


	 used-renumbered / renumber / renumbered / number 


	 Отображать только действительно используемые оверлеи с "правильной" нумерацией (т.е. если используется только два оверлея, они будут пронумерованы как [1] и [2]). Этот подход неудобен тем, что нумерация оверлеев меняется в зависимости от запроса. Впрочем, порядок следования остается прежним. 


	 all-used / only-used / used 


	 Отображать только действительно используемые оверлеи, сохраняя единую, не зависящую от запроса нумерацию (в одной базе данных). 


	 no / false 


	 Никогда не выводить перечень оверлеев. 


	 иное 


	 Выводить перечень оверлеев при каждом запросе (даже если ни один из них не нужен). 


	 LEVENSHTEIN_DISTANCE   (целое число) 


	 Устанавливает расстояние Левенштейна по умолчанию. 


	 EXCLUDE_OVERLAY   (список строк) 


	 Устанавливает перечень подстановочных шаблонов для путей к оверлеям, исключенным из индекса. См. опцию  --exclude-overlay  для *eix-update*. 


	 ADD_OVERLAY   (список строк) 


	 Устанавливает перечень оверлеев, добавленных в индекс. См. опцию  --add-overlay  для *eix-update*. 


	 EXPORT_PORTDIR_OVERLAY   (true / false) 


	 Если значение переменной true, и все оверлеи исключены/добавлены, будет экспортирована соответственно измененная переменная *PORTDIR_OVERLAY*. Это означает, что в некотором смысле и соответствующие еклассы этих оверлеев <nt>исключены/добавлены для методов кэширования eix и eix*.</nt> 

*CACHE_METHOD_PARSE* *(строка)* 

p((((. <nt>Эта строка добавляется ко всем методам кэширования, использующим parse/parse*/ebuild/ebuild*.</nt> По умолчанию содержит строку *#metadata-flat*<nt>.</nt> Если только вы не экспериментируете с настройками, вам, скорее всего, потребуется именно этот метод. Он подразумевает, что если для ебилда доступны текущие метаданные, они будут использованы, вместо парсинга/исполнения ебилда. Последние либо не вполне надежны (парсинг) либо занимают долго времени (исполнение), поэтому обращение к метаданным, при условии, что они доступны и обновлены, всегда предпочтительнее.

*PORTDIR_CACHE_METHOD*, *OVERLAY_CACHE_METHOD* *(строка)* 

p((((. Устанавливает тип кэша, используемого портежами и оверлеями. По умолчанию переменная *PORTDIR_CACHE_METHOD* имеет значение _metadata-flat_<nt>,</nt> *OVERLAY_CACHE_METHOD* - _<nt>parse|ebuild*</nt>_<nt>.</nt> 

p((((. *Внимание:* Если вы не вполне доверяете ебилдам в используемых вами оверлеях, лучше указать значение *OVERLAY_CACHE_METHOD=parse*<nt>.</nt> 

p((((. Возможно, вы захотите временно выставить значение *<nt>OVERLAY_CACHE_METHOD=eix*::~</nt>*<nt> -</nt> как будет разъяснено ниже, в этом случае eix по умолчанию будет брать данные об оверлеях из прежней базы данных eix. 

p((((. Ниже описаны доступные методы кэширования. Возможно, вы захотите переопределить метод кэширования для отдельных оверлеев. Это можно сделать с помощью следующих переменных:

*CACHE_METHOD*, *OVERRIDE_CACHE_METHOD* *(список строк)* 

p((((. Эти переменные представляют собой списки строк вида "_оверлей_ _метод_ _оверлей_ _метод_ ...". Методом кэширования _оверлея_ устанавливается следующий за ним _метод_<nt>;</nt> тем самым переопределяются значения по умолчанию переменной *OVERLAY_CACHE_METHOD* (или *PORTDIR_CACHE_METHOD* если _оверлей_ - каталог *PORTDIR*). _оверлей_ интерпретируется как подстановочный шаблон, который должен соответствовать _пути_ к оверлею (разрешаются символические ссылки)  <nt>(вы не можете указать здесь имя репозитария, вы должны использовать настоящий </nt>_путь_). Новые записи переопределяют старые: последняя удовлетворяющая запись имеет приоритет. 

p((((. Переменные *CACHE_METHOD* и *OVERRIDE_CACHE_METHOD* отличают тем, что первая применяется незамедлительно, тогда как вторая может быть использована для расширения/переопределения неявных изменений при использовании *KEEP_VIRTUALS* (см. ниже). 

p((((. Определения переменных *CACHE_METHOD* и *OVERRIDE_CACHE_METHOD* по умолчанию содержат *<nt>%{ADD_CACHE_METHOD}</nt>* и, соответственно, *<nt>%{ADD_OVERRIDE_CACHE_METHOD}</nt>*. Согласно механизму отложенной замены (сущность которого мы раскрываем в другом разделе), это означает, что переменные *ADD_CACHE_METHOD* и  ADD_OVERRIDE_CACHE_METHOD  также могут быть использованы для локального переопределения метода кэширования. Если вы изменяете  CACHE_METHOD  или  OVERRIDE_CACHE_METHOD  в файле  /etc/eixrc , рекомендуется добавить "  %{ADD_CACHE_METHOD} " или, соответственно, "  %{ADD_OVERRIDE_CACHE_METHOD} " (обратите внимание на пробел перед  % ) в конце измененных определений, чтобы эти переменные продолжали применяться для локального переопределения значений. 


	 Доступны следующие методы кэширования: 


	 metadata-flat  или  metadata-flat: ПУТЬ 


	 Использовать кэш метаданных, расположенный в дереве портежей ($PORTDIR/metadata/cache). Это стандартный метод, который работает всегда, когда дерево портежей доступно для чтения при запуске eix-update. 


	 Если вы явно пропишете  ПУТЬ , это значение переопределит путь, указанный выше. При этом вы должны использовать полный путь (без префикса). Возможно, вы захотите переопределить  ПУТЬ , если вы используете какой-либо пакетный менеджер для генерирования метаданных в соответствующем каталоге. 


	 metadata-assign  или  metadata-assign: ПУТЬ 


	 Аналогично  metadata-flat  с той разницей, что файлы внутри кэша метаданных ожидаются в "формате присвоения" (ТИП=значение). Это справедливо для ряда оверлеев alt-gentoo. 


	 sqlite 


	 Это чрезвычайно быстрый метод кэширования; для его использования необходимо, что portage работал с бэкендом sqlite. См.  http://en.gentoo-wiki.com/wiki/Portage_SQLite_Cache  (первоначальная версия этого руководства располагалась на странице  http://gentoo-wiki.com/TIP_speed_up_portage_with_sqlite  , которая, возможно, всё еще доступна по адресу  http://gentoo-wiki.info/TIP_speed_up_portage_with_sqlite ). Обратите внимание, что, в отличие от метода кэширования  metadata , принимаемого по умолчанию, при использовании данного метода перед вызовом  eix-update  вы должны будете выполнить  emerge --metadata . 


	 Поскольку этот метод поддерживается, только если установлен пакет  sqlite , он может не поддерживаться "из коробки". Если вы планируете его использовать, вам потребуется установить  eix  с соответствующим USE-флагом (или, при ручной установке, выполнить   ./configure --with-sqlite  перед компиляцией). 


	 Что касается остальных методов кэширования, они обрабатывают только категории, подключенные через profile/categories (в дереве портежей или оверлее). Если вам это не подходит, используйте  sqlite*  (см. ниже). 


	 sqlite* 


	 Аналогичен методу кэширования  eix  с той разницей, что в кэш добавляются все категории, найденные в  ФАЙЛе , даже те, которые не были подключены через profile/categories. 


	 cdb 


	 Используйте этот метод кэширования, если у вас portage версии ниже 2.1 и модуль cdb из  http://forums.gentoo.org/viewtopic-t-261580.html  в качестве бэкенда для portage (cdb со словарями cpickle'd в качестве значений). Заметьте, что, в отличие от стандартного  metadata-* , при использовании данного метода перед вызовом  eix-update  вы должны будете выполнить  emerge --metadata  . 


	 flat  или  flat: ПУТЬ 


	 Этот метод аналогичен  metadata-flat  с той разницей, что метаданные ожидаются в каталоге  ПУТЬ  - ${PORTAGE_OR_OVERLAY_DIR} . Если _ПУТЬ  опущен, его значением по умолчанию принимается  /var/cache/edb/dep . 


	 Вы можете использовать этот метод кэширования с portage версий ниже 2.1 и бэкендом по умолчанию. 


	 assign  или  assign: ПУТЬ 


	 Этот метод аналогичен  flat  с той разницей, что файлы внутри кэша метаданных ожидаются в "формате присвоения" (ТИП=значение). Это справедливо для portage-2.1 с дефолтным бэкендом. 


	 Если вы используете portage-2.1 и выше с бэкендом по умолчанию, вы можете использовать этот метод, если у вас нет доступа к дереву портежей при выполнении eix-update. Заметьте, что, в отличие от стандартного  metadata-* , при использовании данного метода перед вызовом  eix-update  вы должны будете выполнить  emerge --metadata  . В таком случае, вы скорее всего обратитесь к соответствующей опции eix-sync. 


	 repo-flat  или  repo-flat: ПУТЬ  /  repo-assign  или  repo-assign: ПУТЬ 


	 Метод аналогичен  flat / assign  с той разницей, что метаданные ожидаются в каталоге  ПУТЬ / ${repo_name} . Если значение  ${repo_name}  пусто, за имя репозитария принимается  x- XXX , где  XXX  - последний ненулевой компонент пути к каталогу портежей/оверлея. Это поведение соответствует политике именования paludis. Если в результате предлагается ошибочный путь к оверлею, вы можете переопределить его вручную, например, так:  OVERRIDE_CACHE_METHOD=' ошибочный_путь   metadata-assign : исправленный_путь_к_оверлею ' . 


	 parse [ # _метод_для_метаданных ]... 


	 Извлечь информацию из ебилдов, проанализировав их эвристически. Использование данного метода хотя и не ставит под угрозу безопасность, но может стать причиной ряда проблем. Например, если переменные получают значения только в еклассах, они будут проигнорированы. Среди проблем, с которыми сопряжено применение данного метода, можно указать отсутствующие данные SLOT для типичных ебилдов категории kde-base или фиксированных номеров версий для кросс-компиляторов gcc. Соответствует методу кэширования  none  в старых версиях eix (ниже 0.11.1). 


	 Возможно добавить одну или более строк вида  # метод_для_метаданных , где под  методом_для_метаданных  подразумевается один из перечисленных выше методов кэширования (исключая  sqlite  и  cdb ). В этом случае методы кэширования метаданных используются для проверки, содержат ли эти метаданные они более новую информацию по сравнению с ебилдом. Если это так, то вместо данных ебилда будут использоваться эти метаданные (приоритет имеют первые удовлетворяющие запросу метаданные). 


	 Как правило, пользователю нужно именно такое поведение, особенно когда речь идет об оверлеях, поскольку метаданные надежнее, чем результаты, полученные методом кэширования  parse . Разумеется, это имеет смысл лишь в том случае, если метаданные нашего оверлея   foo  регулярно обновляются мейнтейнерами оверлея. 


	 egencache --repo= foo  --update 


	 (Будет ли выполнено это действие для оверлеев layman, зависит от команды сопровождения оверлея; для своих локальных оверлеев вы, естественно, можете вручную ввести приведенную команду. 


	 Как правило, это поведение удовлетворяет большинство пользователей, поэтому строка в  CACHE_METHOD_PARSE  по умолчанию добавляется к методу кэширования  parse . 


	 Конечно, если вы заранее знаете, что метаданные оверлея свежие, будет (несколько) быстрее напрямую использовать подходящий метод кэширования (как правило,  metadata-flat ). Это имеет смысл, когда, например, вызывается  egencache  из сценария синхронизации оверлея (e.g. in eix-sync). 


	 parse* [ # метод-для_метаданных]... 


	 Этот метод кэширования наалогичен  parse  с той разницей, что переменные не расширяются в определениях переменных. Он соответствует методу кэширования  none*  из предыдущих (ниже 0.11.1) и ранних версий eix (before 0.7.1) 


	 ebuild [ # метод_для_метаданных]... 


	 Если кэш портежей недоступен (например, речь идет об оверлеях), этот метод кэширования обеспечивет наибольшую совместимость, но и наиболее медленный. Данные извлекаются из ебилда с помощью "/usr/bin/ebuild ... depend". Поскольку все ебилды будут выполняться в оболочке bash, это может быть небезопасно, если вы не уверены в надежности всех ebuild-сценариев и переменных окружения.  eix-update  предпримет попытку заменить пользователя/группу на  EBUILD_USER / EBUILD_GROUP  (если предыдущая переменная не имеет смысла - используя  EBUILD_UID / EBUILD_GID ), прежде чем выполнять ебилд. Окружение преднамеренно не инициализируется до фактического начала выполнения действия, чтобы можно было последовательно передать несколько переменных ебилду. Однако это же может привести к неожиданному поведению или даже к угрозе безопасности, поскольку многие сценарии bash могут быть обойдены в разных окружениях. Во избежание проблем используйте  env -i eix-update , если для вас важен этот аспект. 


	 Используйте этот метод, только если вы уверены в надежности всех ебилдов, к которым он будет применен! 


	 Об опциональных дополнениях  # метода_для_метаданных  см. в описании метода кэширования  parse . Заметьте, что, если доступны соответствующие метаданные, в общем случае этот вариант окажется быстрее, чем выполнение ебилда. 


	 ebuild* [ # метод_для_метаданных]... 


	 Этот метод представляет собой несколько более быструю, хотя и в меньшей степени совместимую версию  ebuild : данные берутся недокументированного "/usr/lib/portage/ebuild.sh". Вместо выполнения программы на для каждого ебилда, как это происходит при использовании метода кэширования  ebuild , "only" a lengthy shell-script and the ebuild itself is executed (таким образом, этот метод небезопасен, если вы не вполне уверены в надежности всех ebuild-сценариев). Большинство переменных окружения, за исключением переменных portage и PATH, инициализируются; PORTAGE_BIN_PATH и PORTAGE_ROOTPATH экспортируются (учтите, что ebuild.sh использует эти переменные для вычисления PATH, создавая тем самым серьезную угрозу безопасности); некоторые специфичные для ебилдов переменные, такие как $P, получают свои значения при выполнении ебилда. Этот метод обеспечивает несколько худшую совместимость, нежели  ebuild , и успешность его применения в большей степени зависит от версии portage. Тем не менее он работает значительно быстрее, чем  ebuild , и достаточно стабилен для обработки, например, типичных ебилдов категории kde-base. 


	 Используйте этот метод, только если вы уверены в надежности всех ебилдов, к которым он будет применен! 


	 parse|ebuild ,  parse*|ebuild ,  parse|ebuild* ,  parse*|ebuild*  [ # метод_для_метаданных]... 


	 Здесь скомбинированы методы кэширования  parse / parse*  и  ebuild / ebuild* . Сначала каждый ебилд проверяется на возможность использования метода  parse / parse* . Если предполагаемый результат содержит лакуны или выглядит станно, ебилд проверяется на возможность использования метода  ebuild / ebuild* . По эмпирическим данным этот метод работает значительно быстрее, чем  ebuild / ebuild* , но всё же намного медленнее, чем  parse / parse* . Конечно, он имеет те же риски безопасности, что и  ebuild / ebuild* . 


	 Используйте этот метод, только если вы уверены в надежности всех ебилдов, к которым он будет применен! 


	 eix   или    eix: ФАЙЛ   или   eix: ФАЙЛ : оверлей 


	 Использовать кэш-файл  ФАЙЛ , предварительно сгенерированный  eix-update . Если значение опущено или пусто, по умолчанию  ФАЙЛ  - это /var/cache/eix. 


	 Что касается остальных методов кэширования, для них будут считываться только категории, подключенные через profile/category (в дереве портежей или оверлее). Если вам это не нужно, используйте  eix*  (см. ниже). 


	 Если  оверлей  не задан или имеет пустое значение, будет обрабатываться только основное дерево портежей в  ФАЙЛе , а оверлеи из  ФАЙЛа  игнорируются. Иначе будет считываться только та часть  ФАЙЛа , которая соответствует  оверлею . Под соответствием мы здесь подразумеваем, что будет использован первый оверлей из  ФАЙЛа , удовлетворяющий подстановочному шаблону. При проверке, удовлетворяет ли оверлей шаблону, сначала сканируется метка, затем путь и, наконец, номер оверлея в  ФАЙЛе . Заметьте, что  оверлей  обычно не зависит от действительных имен оверлеев или их порядка - роль играют только имена/порядок, сохраненные в  ФАЙЛе . 


	 Существуют два исключения для  оверлея , обрабатываемые согласно другим правилам: 


	 Если  оверлей  имеет специальное значение "~", в качества аргумента _оверлей_ будет неявно использована действительная метка этого оверлея; если действительная метка оверлея пуста или не подходит, используется текущий путь к оверлею. 


	 Если  оверлей  имеет специальное значение "*", будут обработаны  все  оверлеи в  ФАЙЛЕ . Для большинства пользователей это предпочтительное поведение, поскольку в результате, если  ФАЙЛ  изначально содержал несколько оверлеев, структура оверлеев будет "выровнена". 


	 eix*   или    eix*: ФАЙЛ   или   eix*: ФАЙЛ : оверлей 


	 Аналогичен методу кэширования  eix  с той разницей, что добавляются все категории, найденные в  ФАЙЛе , даже те, которые были включены через profile/categories. 


	 Данный метод кэширования имеет смысл, если  ФАЙЛ  содержит данные какого-либо каталога оверлея, для которого неизвестны или, возможно, устарели соответствующие файлы profile/categories на локальном хосте. 


	 Применяется для  eix-remote . 


	 Обратите внимание, что, в частности, при использовании  PORTDIR_CACHE_METHOD="eix*::~" , данные оверлея по умолчанию лишь "копируются" из предыдущего кэш-файла eix. 


	 KEEP_VIRTUALS   (true / false) 


	 Если переменная имеет значение true, eix-update сохранит все виртуальные оверлеи из предыдущей базы данных, если таковые имеются. Тот же результат вы получили бы,добавив для каждого виртуального оверлея из старой базы " имя-оверлея " в переменной  ADD_OVERLAY  и соответствующую запись " оверлей  eix*:: оверлей " в переменной  CACHE_METHOD . Это означает, что данная опция должна переопределять настройки  CACHE_METHOD , но может быть сама переопределена значением  OVERRIDE_CACHE_METHOD . 


	 REPO_NAMES 


	 Эта переменная содержит список строк вида " шаблон-каталога   метка-оверлея   шаблон-каталога   метка оверлея  ...". При создании нового файла кэша оверлей, совпадающий с  шаблоном-каталога , получает  метку-оверлея , независимо от содержимого файла profiles/repo_name. Эта переменная может также сопоставлять метки виртуальным оверлеям, которые не содержат такого файла. Кроме того, переменная также переопределяет метки оверлеев, установленные переменной KEEP_VIRTUALS. Старые записи переопределяются новыми: приоритет имеет последнее соответствие. 


	 LOCAL_PORTAGE_CONFIG   (true / false) 


	 Если переменная имеет значение false, содержимое /etc/portage и  ACCEPT_KEYWORDS  (будь то в файле make.conf или в окружении) игнорируется. В eix начиная с версии 0.7.9 рекомендуется оставлять за этой переменной значение true, поскольку при значении false часть информации будет упущена. 


	 ALWAYS_ACCEPT_KEYWORDS   (true / false) 


	 Если переменная имеет значение true, переменная  ACCEPT_KEYWORDS  будет использована даже без  LOCAL_PORTAGE_CONFIG , например, для определения стабильности "по умолчанию". 


	 UPGRADE_LOCAL_MODE   (+  или  local / -  или  non-local /иное ) 


	 Есле переменная имеет значение  +  /  - , вызов eix с опцией  --upgrade  всегда будет производить поиск так, как если бы переменная  LOCAL_PORTAGE_CONFIG  имела значение  true  /  false . 


	 RECOMMEND_LOCAL_MODE   (+   или  local / -  или  non-local /иное ) 


	 Если переменная имеет значение  +  /  - , рекомендации по обновлению/откату, равно как и проверка изменений версий, производимая eix-diff, всегда будут отрабатывать, как если бы переменная  LOCAL_PORTAGE_CONFIG  имела значение  true  /  false . 


	 UPGRADE_TO_HIGHEST_SLOT   (true / false) 


	 Если переменная имеет значение true, любая проверка предложит на обновление установленный пакет не с лучшей стабильной версией в слоте. Исключения из этого общего правила можно прописать в  /etc/portage/package.slot_upgrade_forbid  или, соответственно,  /etc/portage/package.slot_upgrade_allow . 


	 RECURSIVE_SETS   (true / false) 


	 Если переменная имеет значение true, сеты и пакеты в составе включенного сета рассматриваются как часть сета более высокого уровня. 


	 PRINT_EFFECTIVE_KEYWORDS   (true / false) 


	 Если переменная  PRINT_KEYWORDS  используется и ее значение равно true, причем ключевое слово KEYWORD версии изменено профилем, то на основе значения KEYWORDS, установленного в ебилде, будут отображены действующие ключевые слова (определяются профилем). 


	 XML_KEYWORDS (full / effective / both / true / full* / effective* / none / false) 


	 При использовании опции --xml данная переменная решает, отображать ли для каждой версии полные/действительные ключевые слова  KEYWORDS  (или оба типа). Под "полным" (full) ключевым словом здесь подразумевается строка  KEYWORDS  в ебилде, а под "действительным" (effective) - ключевое слово, трансформированное профилем. Значения  full* / effective*  аналогичны  full / effective , но для обоих типов ключевых слов вывод будет произведен только в том случае, если их значения различаются. Значения  true / false  эквивалентны  full* / none . 


	 XML_OVERLAY   (true / false) 


	 При использовании опции --xml эта переменная определяет, будет ли для каждой версии отображаться оверлей (т.е. путь к нему). Эта настройка не повлияет на версии из оверлеев без метки (имени репозитария): для таких версий вывод во всех случаях подразумевает отображение пути доступа к оверлею. 


	 SORT_INST_USE_ALPHA   (true / false) 


	 Если переменная имеет значение  true , USE-флаги установленных пакетов будут выведены в алфавитном порядке. Иначе первыми отображаются (в алфавитном порядке) те флаги, статус которых был изменен при установке пакета, а затем (также в алфавитном порядке) все остальные флаги. 


	 CHECK_INSTALLED_OVERLAYS   (true / false / repository) 


	 Если переменная имеет значение  true , утилита всегда будет проверять, из какого оверлея установленный пакет. Если ее значение  false , будут проверены только пакеты с версиями, доступными как минимум в двух деревьях - иными словами, только те пакеты, которые, судя по базе данных, могли быть установлены из другого оверлея. Однако это может быть и не так, если такой пакет был удален из какого-либо оверлея или если сам оверлей теперь отсутствует в базе данных. 


	 Вы можете использовать специальное, компромиссное значение  repository : если при установке были сохранены данные о репозитарии (в последних версиях portage это именно так; чтобы проверить, как ведет себя ваша версия portage, выполните  eix-installed [no-]repository ), то во всех случаях будут использоваться эти данные. Только если данные нечитаемы или не соответствуют состоянию системы, поведение утилиты для данной версии будет таким же, как при  CHECK_INSTALLED_OVERLAYS=false . 


	 Если вы выставите значением этой переменной  false  или  repository , особенно в сочетании с опциями -T (если значение  NONEXISTENT_IF_OTHER_OVERLAY  равно true) и -J, то получите огромный прирост скорости. Но вы должны отдавать себе отчет в том, что используемые в этом случае сведения об установленном оверлее не вполне надежны (для версий, установленных с ранними версиями portage). В частности, опция -T не обнаружит, что установленная версия пакета происходит из дублированного оверлея, если в текущей базе данных все версии пакета из одного (другого) дерева. 


	 OBSOLETE_MINUSASTERISK   (true / false) 


	 Если переменная имеет значение true, обрабатывать  -*  в /etc/portage/package.keywords так, как это делал portage версии 2.1.2 и ниже. Уже в portage-2.1.2 ключевое слово  -*  фактически устарело и было заменено на  ** , которому может соответствовать всё что угодно (даже ебилд с пустым значением  KEYWORDS ). Заметьте, что существуют родственные ключевые слова  *  и  ~* , которые разрешают установку стабильных или, соответственно, нестабильных версий любой архитектуры, указанной в  KEYWORDS . 


	 PRINT_COUNT_ALWAYS   (true / false / never) 


	 Если переменная имеет значение true, в последней строке всегда будет отображаться количество совпадений с запросом, даже если их 0 или 1. Если  PRINT_COUNT_ALWAYS=never , то последняя строка в любом случае будет опущена. В обычных условиях неудобен и тот, и другой вариант, однако они могут упростить написание отдельных сценариев, основанных на парсинге вывода eix. 


	 COUNT_ONLY_PRINTED   (true / false) 


	 Если переменная имеет значение false, будет выведено только количество соответствий запросу, независимо от того, насколько они результативны в действительности. Это может быть полезно для ускорения отдельных сценариев, для которых вам важно только число соответствий, если вы используете, например,  FORMAT='' . 


	 DEFAULT_MATCH_FIELD   (список строк) 


	 Это список строк вида  регулярное_соответствие [\n\r\t ] поле_соответствия , который используется для определения стандартного поля соответствия. Шаблон поиска в командной строке сопоставляется со всеми  регулярными_соответствиями  из этого списка в заданном порядке. Для первого сопоставления по умолчанию используется соответствующее  поле_соответствия . Вы можете указать последнее  поле_соответствия  (без  регулярного_выражения ) в этом списке - оно используется как резервное в случае, если соответствий не было обнаружено; если такой записи не существует, по умолчанию принимается  name . Чтобы дополнительно не экранировать символы вручную, может быть удобно использовать отложенную замену ${\ПЕРЕМЕННАЯ} для  регулярного_выражения . 


	 Для  поля_соответствия  допустимы значения:  name ,  category ,  category/name  (или  category-name ),  description ,  license ,  homepage ,  provide ,  virtual ,  set ,  slot ,  installed-slot ,  use  (или  iuse ),  with-use  (или  installed-with-use ),  without-use  (или  installed-without-use ). Они соответствуют аналогичным консольным опциям для поля соответствия. Специальное значение  virtual  совмещает в себе две опции командной строки -   -A  и  -P . 


	 DEFAULT_MATCH_ALGORITHM   (список строк) 


	 Это список строк вида  регулярное_выражение [\n\r\t ] алгоритм_соответствия , который используется для определения стандартного алгоритма соответствия. Аналогично  DEFAULT_MATCH_FIELD  с тем отличием, что  алгоритм_соответствия  указывает на предпочитаемый алгоритм соответствия.  алгоритм_соответствия  может принимать значения  regex ,  pattern ,  substring ,  begin ,  end ,  exact ,  fuzzy . Они соответствуют аналогичным  консольным опциям для алгоритма соответствия. Если не указано другого алгоритма соответствия по умолчанию, будет использоваться  regex . 


	 TEST_FOR_EMPTY   (true / false) 


	 Определяет, отображать ли пустые записи в /etc/portage/package.* с опцией -t. 


	 TEST_KEYWORDS   (true / false) 


	 Определяет, сканировать ли /etc/portage/package.keywords с помощью опции -t. 


	 TEST_MASK   (true / false) 


	 Определяет, сканировать ли /etc/portage/package.mask с помощью опции -t. 


	 TEST_UNMASK   (true / false) 


	 Определяет, сканировать ли /etc/portage/package.unmask с помощью опции -t. 


	 TEST_USE   (true / false) 


	 Определяет, сканировать ли /etc/portage/package.use с помощью опции -t. 


	 TEST_ENV   (true / false) 


	 Определяет, сканировать ли /etc/portage/package.env с помощью опции -t. 


	 TEST_CFLAGS   (true / false) 


	 Определяет, сканировать ли /etc/portage/package.cflags с помощью опции -t. 


	 TEST_REMOVED   (true / false) 


	 Определяет, сканировать ли удаленные пакеты с помощью опции -t. 


	 TEST_FOR_NONEXISTENT   (true / false) 


	 Определяет, считать ли несуществующие установленные версии удовлетворяющими проверке с помощью опции -T. Определение несуществующих версий содержится в переменных  NONEXISTENT_IF . 


	 TEST_FOR_REDUNDANCY   (true / false) 


	 Определяет, считать ли повторяющиеся записи в /etc/portage/package.* удовлетворяющими проверке с помощью опции -T. Определение повторяющихся записей содержится в переменных  REDUNDANT_IF . 


	 ACCEPT_KEYWORDS_AS_ARCH   (full / true / false) 


	 Если переменная имеет значение full или true, значение ARCH будет изменено через ACCEPT_KEYWORDS. Эта переменная определяет, какие ключевые слова считать ARCH и OTHERARCH. Значение full изменяет также исходные ключевые слова ARCH. 


	 NONEXISTENT_IF_OTHER_OVERLAY   (true / false) 


	 Определяет, считать ли версии несуществующими для TEST_FOR_NONEXISTENT, если они из другого оверлея, нежели установленная версия. 


	 NONEXISTENT_IF_MASKED   (true / false) 


	 Определяет, считать ли замаскированные версии несуществующими для TEST_FOR_NONEXISTENT. 


	 REDUNDANT_IF_DOUBLE   (строка) 


	 Справедливо, если /etc/portage/package.keywords содержит повторы ключевых слов длянекоторых/всех ((не)установленных) версий. 


	 строка  описывает версии, которые будут подвергнуты обработке. Она может иметь следующие значения: 


	 no  или  false 


	 Не проверять на подобную избыточность. 


	 some 


	 Сигнализировать об избыточности некоторых версий в базе данных. 


	 all 


	 Сигнализировать только об избыточности всех версий в базе данных. 


	 some-installed 


	 Сигнализировать об избыточности некоторых установленных версий в базе данных. Неустановленные версии будут проигнорированы. 


	 all-installed 


	 Сигнализировать только об избыточности всех установленных версий в базе данных. Если версия не установлена, она должна быть указана хотя бы один раз. 


	 some-uninstalled 


	 Сигнализировать об избыточности некоторых неустановленных версий в базе данных. Установленные версии будут проигнорированы. 


	 all-uninstalled 


	 Сигнализировать только об избыточности всех неустановленных версий в базе данных. Если версия установлена, она должна быть указана хотя бы один раз. 


	 -   один_из_перечисленных_вариантов  или   +   один_из_перечисленных_вариантов 


	 Проверка имеет смысл, только если дополнительно не установлено ни одной версии пакета (для  - ) или, соответственно, установлена по крайней мере одна версия (для  + ). 


	 один_из_перечисленных_вариантов    or   один_из_перечисленных_вариантов 


	 Результат общей проверки считается положительным, если результативна хотя бы одна частная проверка. Вместо оператора " or " дизъюнкция может записываться как " | " или " || ". 


	 REDUNDANT_IF_DOUBLE_LINE   (строка) 


	 Справедливо, если /etc/portage/package.keywords содержит две одинаковых строки для одного адресата; в этом случае portage должен отбросить первую из этих двух строк. Заметьте, что строки, адресованные  foo/bar  и  =foo/bar-1 , portage (а вслед за ним eix) не будет считать совпадающими, даже если  foo/bar  относится к версии  1 . Для обнаружения повтора в этом последнем, неявном случае можно использовать  REDUNDANT_IF_DOUBLE_LINE ,  REDUNDANT_IF_MIXED  и  REDUNDANT_IF_STRANGE . 


	 REDUNDANT_IF_MIXED   (string , см. ниже ) 


	 Справедливо, если /etc/portage/package.keywords содержит два различных ключевых слова, например, ~ARCH и -*, для релевантных версий. 


	 REDUNDANT_IF_WEAKER   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.keywords для релевантных версий содержит ключевое слово, которое может быть заменено менее жестким ключевым словом - например, -* или ~OTHERARCH или OTHERARCH вместо ~ARCH, или ~OTHERARCH вместо OTHERARCH. 


	 REDUNDANT_IF_STRANGE   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.keywords для релевантных версий содержит постороннее ключевое слово, например, UNKNOWNARCH (неизвестно .ebuild-сценарию и ARCH) или -OTHERARCH. 


	 REDUNDANT_IF_MINUSASTERISK   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.keywords содержит запись -*. Эта проверка имеет смысл, только если переменная  OBSOLETE_MINUSASTERISK  имеет значение false. 


	 REDUNDANT_IF_NO_CHANGE   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.keywords предоставляет ключевые слова, которые не изменяют состояние ключевых слов доступности для релевантных версий. 


	 REDUNDANT_IF_MASK_NO_CHANGE   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.mask содержит записи, которые не меняют статус маскировки для релевантных версий. 


	 REDUNDANT_IF_UNMASK_NO_CHANGE   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.unmask содержит записи, которые не меняют статус маскировки для релевантных версий. 


	 REDUNDANT_IF_DOUBLE_MASKED   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.mask содержит две одинаковых записи для релевантных версий. 


	 REDUNDANT_IF_DOUBLE_UNMASKED   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.unmask содержит две одинаковых записи для релевантных версий. 


	 REDUNDANT_IF_DOUBLE_USE   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.use содержит две одинаковых записи для релевантных версий. 


	 REDUNDANT_IF_DOUBLE_ENV   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.env содержит две одинаковых записи для релевантных версий. 


	 REDUNDANT_IF_DOUBLE_CFLAGS   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.cflags содержит две одинаковых записи для релевантных версий. Обратите внимание, что этот файл не поддерживается portage, но вы, возможно, обеспечили его поддержку в вашей личной конфигурации /etc/portage/bashrc. Естественно, это означает и то, что формат для /etc/portage/package.cflags не определен. eix подразумевает, что формат его аналогичен /etc/portage/package.{keywords,use} (т.е. по одной записи на строку, версии, отвечающие критерию, в начале). Как и другие файлы /etc/portage/package.*, /etc/portage/package.cflags может представлять собой и каталог; в таком случае все находящиеся в нем нескрытые файлы/подкаталоги обрабатываются рекурсивно, разрешаются символические ссылки. 


	 REDUNDANT_IF_IN_KEYWORDS   (строка , см. ниже ) 


	 Справедливо, если /etc/portage/package.keywords содержит непустую запись для релевантной версии (для обнаружения пустых записей используйте -t). Конечно, никому не придет в голову видеть избыточность во всех совпадениях (хотя возможно использовать эту опцию нерационально, просто для отображения всех совпадений). Однако совпадающие, но не установленные пакеты могут рассматриваться как избыточные. Поэтому этой переменной, как правило, присваивают значение  -some  или аналогичное ему  -some-uninstalled  (либо  false , если записи для неустановленных пакетов воспринимать как нормальное явление и не считать избыточными). 


	 REDUNDANT_IF_IN_MASK   (строка , см. ниже ) 


	 Аналогично  REDUNDANT_IF_IN_KEYWORDS , но для /etc/portage/package.mask. 


	 REDUNDANT_IF_IN_UNMASK   (строка , см. ниже ) 


	 Аналогично  REDUNDANT_IF_IN_KEYWORDS , но для /etc/portage/package.unmask. 


	 REDUNDANT_IF_IN_USE   (строка , см. ниже ) 


	 Аналогично  REDUNDANT_IF_IN_KEYWORDS , но для /etc/portage/package.use. 


	 REDUNDANT_IF_IN_ENV   (строка , см. ниже ) 


	 Аналогично  REDUNDANT_IF_IN_KEYWORDS , но для /etc/portage/package.env. 


	 REDUNDANT_IF_IN_CFLAGS   (строка , см. ниже ) 


	 Аналогично  REDUNDANT_IF_IN_KEYWORDS , но для /etc/portage/package.cflags. См. выше комментарии к этому файлу. 


	 SLOT_UPGRADE_FORBID   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.slot_upgrade_forbid 


	 SLOT_UPGRADE_ALLOW   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.slot_upgrade_allow 


	 KEYWORDS_NONEXISTENT   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.accept_keywords.nonexistent 


	 MASK_NONEXISTENT   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.mask.nonexistent 


	 UNMASK_NONEXISTENT   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.unmask.nonexistent 


	 USE_NONEXISTENT   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.use.nonexistent 


	 ENV_NONEXISTENT   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.env.nonexistent 


	 CFLAGS_NONEXISTENT   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.cflags.nonexistent 


	 INSTALLED_NONEXISTENT   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.installed.nonexistent 


	 PACKAGE_NOWARN   (список строк) 


	 Перечень имен файлов/каталогов, которые используются как /etc/portage/package.nowarn 


	  /etc/portage/sets.eix ¶ 


	 Каталог, аналогичный  /etc/portage/sets  (см. справочную страницу portage). Поскольку portage располагает несколькими способами определения сетов пакетов, недоступными eix, вы можете использовать этот каталог для хранения сетов (статических), чтобы eix мог их опознать (чтобы записи для сетов в /etc/portage/package.keywords корректно обрабатывались). 


	  /etc/portage/package.slot_upgrade_forbid ¶ 


	  /etc/portage/package.slot_upgrade_allow ¶ 


Аналогично другим адресам /etc/portage/package.*, могут быть как файлами, так и каталогами. Записи в них имеют вид  категория/пакет  (по записи на строку). Соответствующие записям пакеты рассматриваются как исключения для переменной  UPGRADE_TO_HIGHEST_SLOT . 

	  /etc/portage/package.accept_keywords.nonexistent ¶ 


	  /etc/portage/package.keywords.nonexistent ¶ 


	  /etc/portage/package.mask.nonexistent ¶ 


	  /etc/portage/package.unmask.nonexistent ¶ 


	  /etc/portage/package.use.nonexistent ¶ 


	  /etc/portage/package.env.nonexistent ¶ 


	  /etc/portage/package.cflags.nonexistent ¶ 


Аналогично другим адресам /etc/portage/package.*, могут быть как файлами, так и каталогами.  Разделителем записей служит либо пробел, либо новая строка. Если какая-либо запись совпадает с первым словом в строке соответствующего файла /etc/portage/package.{keywords,mask,unmask,use,cflags}, данная строка не будет проверяться опцией -t (на предмет имен, отсутствующих в базе данных). Так вы можете избежать некоторых предупреждений при использовании -t. 

	  /etc/portage/package.installed.nonexistent ¶ 


Аналогичен другим файлам/каталогам /etc/portage/package.*.nonexistent с той разницей, что не будут выводится сообщения опции -t об установленных пакетах, которые были удалены из базы данных. Записи в этом файле имеют вид  категория/пакет , но категорию можно и опустить (хотя это не рекомендуется). 

	  /etc/portage/package.nowarn ¶ 


Аналогично другим адресам /etc/portage/package.*, может быть как файлом, так и каталогом. Позволяет отключать проверку -T для отдельных пакетов. Формат файла совпадает с форматом /etc/portage/package.use с той разницей, что существует возможность включения/отключения проверки. Учитываться будут те строки, для которых имеется хотя бы одно соответствие. Так, если он содержит строки:

	 sys-kernel/*-sources no_change weaker 


	 >sys-kernel/hardened-sources-2.6.40 -weaker 


	 опция -T не обнаружит пакет sys-kernel/*-sources только потому, что активен ключ  REDUNDANT_IF_NO_CHANGE  или  REDUNDANT_IF_WEAKER . Исключение из правила делается для  REDUNDANT_IF_WEAKER  и для hardened-sources только в том случае, если доступная версия пакета на ниже 2.6.40. Записи в файле могут располагаться в произвольном порядке; в случае вхождения символа "-" он всегда имеет приоритет. 


	 В данном файле вы можете указывать один пакет несколько раз. В этом случае будут проверяться вместе все условия, определенные для одного пакета. 


	 Доступные критерии проверки:  in_keywords ,  no_change ,  double ,  mixed ,  weaker ,  minusasterisk ,  double_line ,  in_mask ,  mask_no_change ,  double_masked ,  in_unmask ,  unmask_no_change ,  double_unmasked ,  in_use ,  double_use ,  in_env ,  double_env ,  in_cflags ,  double_cflags . По смыслу они идентичны соответствующим переменным  REDUNDNANT_IF_* . 


	 Дополнительно можно использовать критерии  nonexistent ,  masked ,  other_overlay , по смыслу идентичные, соответственно,  TEST_FOR_NONEXISTENT ,  NONEXISTENT_IF_MASKED ,  NONEXISTENT_IF_OTHER_OVERLAY . 


	  /var/cache/eix ¶ 


	 Это бинарная база данных eix. При необходимости адрес можно изменить с помощью переменной  EIX_CACHEFILE  (по умолчанию она соотносится с  EPREFIX , используя механизм отложенного обращения). Но для обеспечения проверки отдельных привилегий перед выполнением  eix-update  необходимо использовать стандартный путь /var/cache/eix. 


	 versionsort ¶ 


	 versionsort  представляет собой вспомогательный инструмент для обработки сценариев и имеет двоякое назначение. Сначала он отсекает информацию о версии от аргументов либо интерперетирует сами аргументы как строки версий (в зависимости от используемой эвристической процедуры). Затем он отображает собранные строки версий упорядоченным списком, согласно правилам сортировки версий, принятым для portage. Если аргументов несколько, каждая версия (включая последнюю) завершается переходом на новую строку. Так, команда 


	 versionsort gcc-4.4 4.4_alpha0 sys-devel/gcc-4.05 4.5 


	 выведет следующее: 


	 4.05 


	 4.4_alpha0 


	 4.4 


	 4.5 


	 Если вы передаете утилите только один аргумент, eix менее жестко подходит к обработке версий: даже если строка версии не вполне корректна, выводимые строки гарантированно будут соответствовать обработанным строкам версий. Вы можете включать в сценарии запуск versionsort с одним аргументом, чтобы отделить имя пакета от версии, например 


	 split=1-font-adobe-75dpi-1.3-r1 


	 version=`versionsort "X${split}"`; name=${split%"-${version}"} 


	 Хотя в настоящее время разницы нет, надежнее в таком случае (принимая во внимание, что в будущем возможно расширение формата версии), если аргумент(ы) начинается/-ются не с числа ( X  в приведенном примере), дабы гарантировать, что versionsort действительно отделяет версию от аргумента, а не принимает за версию весь аргумент целиком. 


	 ОШИБКИ (+ ЧАВО) ¶ 


	 Об обнаруженных ошибках либо сообщайте напрямую девелоперам eix:  http://developer.berlios.de/projects/eix/ , либо оставьте заявку на багтрекере Gentoo:  http://bugs.gentoo.org/ . 


	 eix не поддерживает и, вероятно, никогда не будет поддерживать обработку зависимостей и/или USE-флагов. Это, в частности, означает, что вывод eix -u в целом будет отличаться от вывода emerge update; для нормального функционирования системы ориентироваться следует на последний. Прежде всего это справедливо для обновления пакетов со слотами. Переменная  UPGRADE_TO_HIGHEST_SLOT  и исключения, вручную установленные в  /etc/portage/package.slot_upgrade_forbid  либо, соответственно, в  /etc/portage/package.slot_upgrade_allow , могут помочь частично обойти эти неудобства. 


	 eix не обеспечивает и планирует обеспечивать полную поддержку всех поддерживаемых portage сетов. В настоящее время не предполагается, что eix когда либо будет поддерживать даже рекомендуемые настройки PROPERTIES=set для помещения пакетов в дерево (поскольку для их успешной обработки утилите потребовалась бы полная поддержка зависимостей и USE-флагов). В качестве временного решения вы можете вручную определить дополнительные сеты в  /etc/portage/sets.eix . Далее, eix не поддерживает и, вероятно, не будет поддерживать обращение к файлам sets.conf. Если вы указывали дополнительные каталоги  sets/ , например, в каком-либо оверлее, вы должны добавить эти каталоги, вручную изменив значение переменной  EIX_LOCAL_SETS  в файле /etc/eixrc. Проще всего будет поместить в /etc/eixrc запись вида 


 EIX_LOCAL_SETS_ADD=" /путь/к/оверлею1/sets   /путь/к/оверлею2/sets   ... "  

	 (см. выше описание  EIX_LOCAL_SETS ). 


	 eix-diff никогда не обращается к /etc/portage/profile. (Это объясняется тем, что сохраненная база данных содержит только сведения о маскировке в исходном профиле, но не сам профиль. С другой стороны, /etc/portage/profile может быть интерпретирован, только если профиль известен.) 


	 Если вы хотите использовать номер оверлея в какой-либо переменной/команде с аргументами eix, вывод с применяемым по умолчанию  OVERLAYS_LIST=all-used-renumbered  неудобен. 


	 Не существует настройки метода кэширования, которая позволяла бы получать информацию из оверлеев (для таковых метаданные кэша портежей недоступны) одновременно с высокой скоростью и надежностью - вам всегда приходится выбирать между ними. Стандартно система предпочитает режим максимальной скорости, но при этом зачастую некорректно отображаются слоты и возникают другие проблемы. 


	 Всегда непросто работать с  EPREFIX / ROOT . В частности, уже в силу поддержки множества таких переменных, eix не может не быть подвержен локальным атакам, если его вызывать из потенциально небезопасного окружения. 


	 Для многих было неудобно принятое ранее по умолчанию значение  KEEP_VIRTUALS=true . Однако с новым, отрицательным значением, сомнительно, что кто-либо вообще обнаружит такую возможность. :( 


	 Для переменной  OBSOLETE_MINUSASTERISK  не существует значения по умолчанию, которое удовлетворяло бы пользователей как старых, так и новых версий portage. 


	 Eix обладает настолько широким функционалом, что документация по нему и, соответственно, настройка с течением времени чрезвычайно усложнились. И тем не менее многие параметры по-прежнему не поддаются конфигурированию... 


	 ИСТОРИЯ ¶ 


	 Изначально утилита  eix  существовала под названием  portagedb . Переименована она была во избежание двусмысленности - в составе portage уже имелся инструмент portagedb. 


	 В первых версиях функционал eix-update обеспечивался вызовом eix с ключом -u. Затем для облегчения сопровождения он был отделен, и появилась  update-eix . В конечном итоге исполняемый файл был сохранен, его назначение определяется командой вызова, а оригинальное название, update-eix, превратилось в  eix-update . 


	 Утилита  eix-diff  сначала также именовалась иначе, а именно  diff-eix . Нынешняя  eix-remote  была известна как  update-eix-remote ,  eix-layman  - как  update-eix-layman , а  eix-functions.sh  - как  functions-eix.sh  (а в изначальной версии - как  update-eix-functions.sh ). Все эти переименования преследовали цель создать логично организованный набор утилит: все программы, идущие с eix, теперь имеют префикс eix-* (за исключением  versionsort , которая, в общем-то, представляет собой самостоятельный инструмент). Если вам непривычна эта новая схема именования или если вы используете сценарии, зависящие от прежних имен переменных, вы можете использовать символические ссылки на оригинальные имена; такое поведение полностью поддерживается и не будет отменено. Если вы вызываете eix'  ./configure  с опцией  --enable-obsolete-symlinks  или  --enable-obsolete-reminder , такие ссылки (или обертки, которые также напоминают об устаревших именах) создаются автоматически - хотя и не по умолчанию, ведь новым пользователям эта возможность не нужна. Мы рекомендуем обновить ваши сценарии, заменив в них имена обрабатываемых переменных на новые, чтобы их можно было выполнять и на свежих системах. Кроме того, в  eix-functions.sh  по соображениям логики были переименованы две переменные ( CallUpdateEix  ->  CallUpdate  и  ClearUpdateEixArgs  ->  ClearUpdateArgs ); была переименована и внутренняя переменная, к которой они обращаются (но ее никогда не предполагалось использовать в сценариях). Если вы всё еще используете какую-либо из перечисленных опций  ./configure , будет установлена также обертка для  functions-eix.sh , поддерживающая устаревшие имена функций (и выдающая предупреждение, когда они используются с включенной опцией  --enable-obsolete-reminder ). 


Начиная с eix-0.8.0, где был введен синтаксис %{*VARIABLE}, нет смысла использовать разные имена переменных для eix и eix-diff. Поэтому соответствующие  DIFF_*  -переменные исчезли. 

	 Метод кэширования  metadata-flat  ранее именовался  metadata . Метод кэширования  assign  ранее именовался  backport  или  portage-2.1 . Метод кэширования  flat  носил имя  portage-2.0 , его и предпочитали употреблять. Несмотря ни на что, устаревшие имена продолжают поддерживаться. 


	 portage-2.1 и portage-2.1.1 не удаляют старого кэша зависимостей, поэтому при использовании метода кэширования  flat / assign  eix может обнаружить пакеты, которые уже не в дереве портежей. Чтобы обойти это поведение, eix-sync ранее удалял сохраненный прежде кэш (rm -rf /var/cache/edb/dep/*). Поскольку большинство пользователей уже не нуждаются в данном методе кэширования, а удаление старого кэша замедлит следующий запуск portage, оно было исключено из стандартных настроек (но по-прежнему доступно как опция, которую можно прописать в /etc/eix-sync.conf). 


	 Прежде eix-sync по умолчанию работал с gensync instead, а не с layman. Если вы хотите использовать gensync, несмотря на то, что он устарел, см. описание /etc/eix-sync.conf. 


	 eix-sync более не поддерживает журналирование; опции -v и -V были удалены. Это позволяет избежать таких проблем как отсутствие видимого вывода при выставленном EMERGE_DEFAULT_OPTS=--ask. Сейчас, если вы хотите вызывать eix-sync по расписанию, используйте перенаправление. 


	 Механизм, который теперь описывается переменной  DEFAULT_MATCH_FIELD , изменился. Использовавшиеся ранее переменные  MATCH_.*_IF  и  MATCH_ORDER  (обладавшие меньшими возможностями) теперь не поддерживаются. 


	 Переменные  ADD_CACHE_METHOD  и  ADD_OVERRIDE_CACHE_METHOD  более не являются встроенными, а используются, если не указано иное, при отложенной замене при стандартных  CACHE_METHOD  и  OVERRIDE_CACHE_METHOD . В частности, настройка переменных в файле  /etc/eixrc  без добавления отложенной замены " %{ADD_CACHE_METHOD} " или, соответственно, " %{ADD_OVERRIDE_CACHE_METHOD} ", лишает смысла применявшиеся ранее переменные. 


	 В версиях eix ниже 0.18.0, такие параметры пользовательского отображения версий как  <installedversions: ПЕРЕМЕННАЯ >  или  <availableversions: ПЕРЕМЕННАЯ >  не существовали. Выполнение сопоставленных им функций возлагалось на ряд разрозненных параметров для  <installedversions:*>  и набор вариантов вывода списка доступных или установленных версий для вызова из сценариев, подобных  <fullvailableversions> . Все они были упразднены, а на смену им пришли переменные  NAMEVERSIONS ,  EQNAMEVERSION ,  ANAMESLOT ,  ANAMEASLOT ,  NAMESLOT ,  NAMEASLOT  и  DATESORT  (причем  DATESORT  предоставляет сравнительный пример, ранее недоступный). См. описание этих переменных в выводе команды  eix --dump . Чтобы испытать эффект от их использования, попробуйте, например, выполнить: 


	 eix --format '<availableversions:ANAMESLOT:ANAMESLOT>' --pure-packages gcc 


	 См. также комментарии к опции  -I . 


	 Начиная с версии eix 0.20.0, логические связки  ВЫРАЖЕНий  претерпели серьезные изменения: теперь они не только допускают скобки, но и цепочки с операторами  -a  и  -o  интуитивно имеют левую ассоциативность. Отрицание  --not  теперь обрабатывается как логическая операция, начинающая новый ФИГУРНАЯ_СКОБКА_ИЛИ_ПРОВЕРКА, и не рассматривается как часть КРИТЕРИЕВ_ПРОВЕРКИ (многим пользователям было трудно это воспринимать). Теперь  --pipe  действительно входит в состав КРИТЕРИЕВ_ПРОВЕРКИ и не подразумевает использования логических связок. 


Начиная с eix-0.20.1, все ранее использовавшиеся файлы /etc/portage/package.*.nowarn уже не поддерживаются по умолчанию: все их заменил один файл file/dir /etc/portage/package.nowarn. Если вы хотите продолжать использовать множественные файлы .nowarn, установите значение переменной окружения  OBSOLETE_NOWARN=true . Подробнее см. в описании переменной  PACKAGE_NOWARN  (в выводе  eix --dump ).

	 В версия  eix  ниже 0.22.4  eix-installed  входил в состав  eix-test-obsolete , что было неудобно и для пользователей, и для обеспечения сопровождения, поскольку эти две утилиты имеют совершенно различное назначение. 


	 АВТОРЫ ¶ 


	 
	 Martin V\(:ath < vaeth@mathematik.uni-wuerzburg.de > (разработчик, текущее сопровождение) 
	 


	 
	 Emil Beinroth < emilbeinroth@gmx.net > (разработчик, ранее обеспечивал сопровождение) 
	 


	 
	 Wolfgang Frisch < xororand@users.sourceforge.net > (неактивный разработчик, автор первой версии eix) 
	 


	 
	 Roland Wittmann < linuxcommando@users.sourceforge.net > (неактивный разработчик) 
	 


	 СМ. ТАКЖЕ ¶ 


	 portage (5),  fnmatch (3),  regex (7),  emerge (1),  esearch (1),  qsearch (1),  layman (8) 


	 На домашней странице eix,  http://eix.berlios.de/ , содержится дополнительная информация и ссылки. 


	 ПЕРЕВОД ¶ 


	 
	 Елена Гаврилова < e.vl.gavrilova@yandex.ru > 
	 


	     


	 23 марта 2011 







 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename