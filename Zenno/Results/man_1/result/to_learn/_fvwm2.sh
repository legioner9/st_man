#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 fvwm2 (1)   fvwm2  (1)   ( Solaris man: Команды и прикладные программы пользовательского уровня ) >>  fvwm2  (1)   ( Русские man: Команды и прикладные программы пользовательского уровня ) 
 
   
 НАЗВАНИЕ 

 
fvwm2 - F(?) Виртуальный менеджер окон для X11
 
   
 СИНТАКСИС 

 
 fvwm2  [  options  ]
 
   
 ОПИСАНИЕ 

 Fvwm  это менежер окон (программа, управляющая окнами) для
X11. Он является проиводным от  twm , переделанным с
минимальными требованиями к памяти, предоставлением a 3-D
офрмления окон и простого виртуального десктопа. Версия
2.xx использует незначительно больше памяти, чем 1.xx,
зато имеет множество дополнительных опций для управления
окнами.
 
Как и стандартный Fvwm  Fvwm2  совмещает два
достоинства:больщой виртуальный desktop и множество
отдельных desktop'ов, которые могут быть использованы по
отдельности или вместе. Виртуальный desktop позволяет вам
иметь экран как бы большего размера, чем на самом деле и
перемещаться по нему. Множество раздельных desktop'ов
позволяет вам иметь как бы несколько экранов для работы,
но каждый экран полностью независим от других.
 
Fvwm2 дает вам использовать горячие клавиши, которые
позволяют выполнять многие функции менеджера окон, включая
перемещение и изменение размеров окон и операции с меню.
 
Fvwm2 также имеет нечеткие различия между командами
конфигурации и встроенными командами (такими как команды
управления окнами). Команды конфигурации обычно
устанавливают шрифты, цвета, клавиши, задают содержимое
меню, указывают какие функции выполняются мышью, в то
время как встроенные команды обычно делают такие вещи как,
например, активация окна. Fvwm2 не делает таких
различий и позволяет изменять что угодно когда угодно.
 
Другие замечательные различия между Fvwm2 и прочими
менеджерами окон для X Window состоят в методах SloppyFocus
и per-window focus. SloppyFocus делает окно
активным с помощью мыши, но окно не становится
неактивным, когда мышь покидает его и перемещается в
главное(root) окно. Когда SloppyFocus используется как
стиль активации окон по умолчанию, он прекрасен для окон
в которые вы обычно ничего не вводите (xmag, xman,
xgraph, xclock, xbiff, и т.д.), так что ваше терминальное
окно не потеряет активности.
 
 
 АВТОРСКИЕ ПРАВА 
 
Так как  fvwm2  является производным от  fvwm , то он
разделяет его авторские права.
 
 fvwm  copyright 1988 Evans и Sutherland Computer
 
Corporation, Salt Lake City, Utah, и 1989 Massachusetts
Institute of Technology, Cambridge, Massachusetts, Все
права защищены. Также copyright 1993 и 1994 Robert
Nation.
 
 Права  
 
на использование, копирование, изменение и
распостранение этого программного обеспечения и его
документации для любых целей и без каких-либо гарантий
предоставляются при условии предоставления замечения по
авторским правам на все копии и при условии, что и данное
замечание по авторским правам и данное замечание по правам
на использование будет предоставлено в документации, и
кроме того, что имена Evans и Sutherland и M.I.T. не будут
использованы при рекламировании и паблисити при
распостранении данного программного обеспечения без
специального письменного разрешения.
 
 ROBERT  
 
NATION, CHARLES HINES, EVANS & SUTHERLAND, AND
M.I.T. DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL EVANS & SUTHERLAND OR
M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
NEGLIGENCE OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 АНАТОМИЯ ОКНА 
 
 Fvwm  создает вокруг многих окон декоративный бордюр. Этот
бордюр содержит полоску на каждую сторону окна и маленькую
"L" образную секцию в каждом углу. В добавление к этому
вверху окна есть широкая полоса, называемая заголовком
(title bar) окна. На этой полосе можно разместить до 10-ти
кнопок(title-bar button). Верхие, нижние полоски и полоски
 
 по  
 
     сторонам обобщенно назваются полоски по
сторонам(side-bars). Угловые части называются рамкой.
 
 Если установки по  
 
умолчанию не были модифицированы в
конфигурационных файлах, то нажав левую кнопку мыши на
заголовке окна или полоске на одной из сторон вы можете
переместить окно. Нажав левую кнопку мыши в углу рамки
окна вы можете изменять его размер. Нажав среднюю кнопку
мыши (для трехкнопочной мыши. Для двухкнопочной в случае
включенной эмуляции 3-й кнопки нужно нажать одновременно
левую и правую кнопки) в любом месте бордюра получите
список операций с окном.
 
 Как  
 
уже говорилось на полосе заголовка окна может
сущетсвовать до 10-ти кнопок. Их использование полностью
определяется пользователем. Конфигурация по умолчанию
задает по одной кнопке на каждую сторону заголовка окна.
Одна, которая слева используется для получения списка
операций с окном, какая бы кнопка мыши не была нажата.
Кнопка справа используется для сворачивания окна в иконку.
На каждую кнопку, что находится на полосе заголовка окна
пользователь может задать выполнение какой-либо функции
по нажатию кнопоки мыши. Смотрите ниже секцию
конфигурационного параметра "Mouse".
 
 ВИРТУАЛЬНЫЙ DESKTOP 
 
 Fvwm2  предоставляет множество виртуальных desktop'ов
для пользователей, которые хотят их использовать. Экран
это поле вывода на desktop'e который может быть больше,
чем сам экран. Может быть доступно сразу несколько
различных desktop'ов (Стратегия: один desktop для
каждого проекта, или один desktop для каждого
приложения, когда нужно, чтобы ясно были видны все окна
или окно приложения).Теперь, когда каждый desktop может
быть больше, чем физический экран, можно легко видеть те
окна, которые больше размера экрана или большие группы
независимых окон.
 
Размер виртуальных desktop'ов может быть изменен в любое
время с помощью использования встроенной команды
DeskTopSize. Все виртульные desktop'ы могут быть разного
размера. Максимально возможно число различных desktop'ов
не определено, но приблизительно составляет около 4-х
миллиардов. Все окна в на desktop'ах можно увидеть с
Pager'а, который имеет миниатюрный вид desktop'ов. Pager
это специальная программа являющаяясь одним из модулей
Fvwm, которая не является важной для управления
менеджером окон. Окна могут быть также отображены в
 
 списке, включая их геометрию, в специальном окне  
 
(window
list), доступном из всплывающего вертикального (pop-up)
меню или как самомтоятельное окно, называемое FvwmWinList
(другой модуль).
 
"Sticky"("приклеенные") окна это окна которые находятся
вне пределов виртуального desktop'а как "Приклеенные к
стеклу экранна". Они всегда остаются на экране.Это удобно
 
 для таких программ как claock и xbiff, таким образом  
 
вам
нужно только запустить одну такую программу и она всегда
останется с вами. Иконки также могут быть "приклеены", в
случае необходимости.
 
 Геометрия  
 
    окна определяется относительно текущего
поля просмотра. Например:
 
xterm -geometry +0+0
 
 будет  
 
всегда показывать в вверхнем левом углу видимой
части экрана. Геометрические параметры можно задать так,
чтобы они определяли место окон на виртуальном desktop'е,
но вне экрана. Например, если видимый экран имеет размер
1000 на 1000 точек и размер desktop'а 3 на 3, и текущее
поле просмотра это верхний левый угол desktop'а, то вызов
 
xterm -geometry +1000+1000
 
 поместит окно в точно вне правого нижнего угла экрана. Его 
 
можно увидеть если переместить мышь в правый нижний угол
экрана и подождать пока произойдет сдвиг экрана вниз.
 
Это не работает в случае, если окно помещается на desktop,
отличный от текущего активного десктопа.
 
 Можно задать геометрию окна и так: 
 
xterm -geometry -5-5
 
 поместит  
 
нижний правый угол окна на 5 точек от нижнего
правого угла видимой части экрана. Не все приложения
поддерживают геометрические параметры с отрицательным
смещением.
 
 Некоторые  
 
    приложения которые понимают стандратные
агрументы командной строки Xt и ресурсы X, такие как
xterm и xfontsel, позволяют пользователю определять
desktop, на который будет выведено окно приложения в
командной строке:
 
xterm -xrm "*Desk:1"
 
запустит xterm на desktop'е номер 1. Не все приложения
понимают эту опцию.
 
 Вы  
 
можете получить такойже результат со следующей
строкой:
 
XTerm*Desk: 1
 
 ИНИЦИАЛИЗАЦИЯ 
 
Во время инициализации,  Fvwm  будет искать конфигурационный
файл который описывает различные параметры такие как
назначение клавиатуры, задание функций мыши и др. Формат
этого файла будет описан позже. Сперва  fvwm2  ищет файл
.fvwm2rc или .fvwmrc в зависимости от того как был
скомпилирован Fvwm (.fvwm2rc по умолчанию) в домашнем
каталоге пользователя. Если там этого файла нет, то  fvwm 
смотрит /usr/local/lib/X11/fvwm2/system.fvwm2rc для чтения
установок по умолчанию. Если и этот файл не найден, то
 fvwm2  запустится, но его нельзя будет использовать.
 
 fvwm2  устанавливает две переменных окружения которые
будут унаследованы его потомкомками.Это $DISPLAY и $HOSTDISPLAY.
$DISPLAY описывает дисплей, на котором запущен
 fvwm2 . $DISPLAY может принимать значения unix:0.0 или 0.0.
Значение 0.0 не работает также хорошо, как unix:0.0, когда
работают через rsh на другой машине. $HOSTDISPLAY
устанавливает и использует сетевое описание дисплея.
Переменную $HOSTDISPLAY использвует протокол TCP/IP
 
 (каждый раз при локальном соединении), однако и  
 
$DISPLAY
может испльзоваться при локальных соединениях, так как
они можгут использовать Unix-domain sockets, которые
быстрее.
 
 fvwm  имеет две специальные функции для инициальзации:
InitFunction и RestartFunction, которые запускаются
соответственно во время Инициализации и Перезапуска. Они
могут быть описаны вручную в пользовательском rc файле
через вызов AddToFunc (описано ниже), и могут
использоваться для старта модулей или программ, которые бы
вы захотели запустить при старте  fvwm .
 
 Fvwm  также имеет специальную функцию для выхода: ExitFunction,
которая запускается или перезапускается перед
выходом или в других случаях. Она может быть использована
для явного убивания модулей и т.д.
 
 ОПЦИИ КОМПИЛЯЦИИ 
 
 Fvwm  имеет несколько способов для снижения использования
памяти, что достигается ограничинием использование
определенных особенностей  fvwm , во время компляции. Если у
вас возникли проблемы при использовании определенной
команды или особенности, то проверьте была ли включена
поддержка данной особенности во время компиляции.
Необязательные особенности полностью описаны в
конфигурационном файле Imake: Fvwm.tmpl.
 
 ИКОНКИ 
 
Базовая конфигурация  fvwm2  использует черно-белые иконки,
симулирующие twm. Если  fvwm2  скомпилирован с поддержкой
XPM (а это почти наверняка), то могут использоваться
цветные иконки симулирующие ctwm, MS-Windows или Macintosh.
Обычно для использования таких иконок нужен XPM
package как описано в конфигурационном Imake файле
Fvwm.tmpl.
 
 Если и SHAPE и XPM опции скопилированы, то вы можете взять 
 
цветные иконки, которые покажутся вам более красивыми.
 
 МОДУЛИ 
 
Модули - это отдельные программы, которые запускаются как
отдельные процессы Unix, но которые передают команы  fvwm2 
для выполнения. Пользователи могут написать свои
собственные модули для каких-либо манипуляций, чтобы не
интегрировать их в  fvwm2  во избежание распухания
последнего.
 
Модули ДОЛЖНЫ быть вызваны  fvwm2  так как он устанавливает
два канала: для  fvwm2  и модуля с которым он работает.
Каналы будут уже открыты для модуля, когда он запускается
и дескрипторы файлов для каналов предоставляются как
агрументы командной строки.
 
Модули могут быть вызваны  fvwm2  в любое время в течении
X-сессии при помощи втроенной команды Module. Модули
могут существовать во время X-сессии, или могут выполнятся
и заканчиваться как отдельные задачи. Если модуль еще
активен, когда  fvwm2  завершает свою работу, то  fvwm2 
закрывает соединительные каналы и ждет когда придет из
модуля сигнал SIGCHLD, показывающий, что модуль
определил, что канал закрыт и закончил свою работу. Если
модуль не определил, что канал закрыт  fvwm2  закончит
свою работу после ожидания приблизительно 30 секунд.
Максимальное число модулей, которое может быть запущено
одновременно ограничивается максимальным числом
одновременно открытых файлов в операционной системе приблизительно
между 60 и 256.
 
Модули просто передают текстовые команды во внутрь  fvwm .
Текстовые команды форматируются также как в случае
задания команд для мыши в файле .fvwm2rc. Также
передается некоторая дополнительная информация, также, как
например, в модуле FvwmButtons. Модуль FvwmButtons
описывается собственной страницей man. The FvwmButtons
module is documented in its own man page.
 
 ICCCM COMPLIANCE   fvwm2  пытается быть совместимым с
ICCCM 1.1. Кроме того, свойства ICCCM сделали бы возможным
для приложений принимать ЛЮБУЮ строку, в которой не
содержаться "горячие" клавиши, которые использованы в
 fvwm2  и многих других менеджерах окон.
 
 Одно из свойств ICCCM которым обладает окно это 
 
 WMINTS(WMINTS): 
 
Клиент принимает ввод или фокус ввода: Ложь
 
 не должно было бы дать  
 
фокус ввода клавиатуры оконного
менеджера. Однако, эти окна могут взять фокус ввода сами.
Некоторые же приложения включают это свойство и в любом
случае еще ожидают, что оконнный менеджер даст им фокус
клавиатуры, но  fvwm2  предоставляет оконный стиль "Linience",
который позволит  fvwm2  не замечать этого правила
ICCCM.
 
 
   
 M4</bf> <bf>Preprocessing 

 
M4 pre-processing управляется модулем в  fvwm2 . Для более
детального описания смотрите man FvwmM4. В кратце, если
вы хотите чтобы  fvwm2  проверял ваши файлы с помощью M4,
то замените слово "Read" на "FvwmM4" в вашем файле
 
fvwm2 -f "FvwmM4 .fvwm2rc"
 
   
 Cpp</bf> <bf>Preprocessing 

 
Cpp это препроцессор языка С.  fvwm2  предлагает Cpp
обработку, которую отражает M4 pre-processing. Для поиска
данных об этом, перечитайте секцию M4 снова, но замените
"m4" на "cpp".
 
   
 Auto-raise</bf>  (автоматическое перемешение окна  <bf>наверх) 

 
Окна могут быть автоматически помещены наверх когда они
принимают фокус или через некоторое количество миллисекунд
после принятия фокуса при использовании модуля FvwmAuto.
 
 
 ОПЦИИ 
 
Это опции командной строки что воспринимаются  fvwm2 :
 
 -f <config command> 
 
Заставляет Fvwm использовать <config command>
вместо "Read".
 
Заставляет  fvwm  использовать  config_command  как команду
инициализации вместо "Read .fvwm2rc". (Заметим,
что может быть задано до 10  -f  и  -cmd  параметров и
они выполняться по порядку)
 
 -debug  Помещает  
 
транзакции X в синхронном режиме, который
ужасно медленно, но гарантирует, что сообщения
о внутренних ошибках  fvwm2  корректны.
 
 -d displayname 
 
Управление осуществляется дисплеем "displayname"
вместо имени взятом из переменной окружения
$DISPLAY.
 
 -s   
 
     В много-экранном дисплее, запускает Fvwm только на
экране названном в переменной окружения $DISPLAY
или предоставленном ранее через опцию -d. Обычно
 fvwm2  пытается запуститься на всех экранах
многоэкранного дисплея.
 
 -version 
 
Печатает версию Fvwm на stderr.
 
 КОНФИГУРАЦИОННЫЙ ФАЙЛ 
 
Конфигурационный файл используется для описания
клавиатуры, задания функций мыши, цветов, размера
вертикального десктопа и др. Обычно конфигурационный файл
называется .fvwm2rc. Используя встроенную команду "Read",
он легко читает другие заданные вами конфигурационные
файлы.
 
 Строки  
 
начинающиеся с `#' будут игнорированы. В строках
начинающихся с `*' ожидаются команды конфигурации модуля
(или команды конфигурации для самого  fvwm2 ).
 
 fvwm  не делает различий между командами конфигурации и
встроенными командами, таким образом любая команда,
упомянутая в секции внутренних команд может быть помещена
в строку  fvwm2  для выполнения, так как он читает
конфигурационный файл, или она может быть помещена как
выполняемая команда в меню или присвоена кнопке мыши или
клавише клавиатуры. Она может использоваться пользователем
и при инициализации и во время работы.
 
 ВСТРОЕННЫЕ ФУНКЦИИ 
 
 fvwm2  поддерживает некоторое количество встроенных
функций, которые могут быть присвоены клавиатуре или
кнопкам мыши. Если ожидает найти встроенную функцию в
команде, но не находит ее, он проверяет описанна ли
команда, которую он встретил,но не понял в выражении типа
"Function <команда>" или "Module <команда>". Это
позволяет комплексным функциям или модулям быть вызванными
способом выглядящим довольно прозрачно.
 
Пример: файл .fvwm2rc содержит строку "HelpMe".  fvwm2 
будет искать встроенную команду называемую "HelpMe" и не
найдет ее. Затем он будет искать заданную пользователем
комплексную функцию, названную "HelpMe". Если такая
функция существует, то  fvwm2  попытается ее выполнить.
 
 Кавычки  
 
требуются только когда есть необходимость
заставить  fvwm2  рассматривать два и более слова как один
агрумент. Однако допускается использование кавычек и для
аргумента из одного слова. Если вы хотите заключить в
кавычки символ в вашем тексте, вы должны использовать
обратные и прямые апострофы - вот так ``<символ>''.
Например, если вы имеете pop-up меню с названием WindowOps,
то кавычки вам не нужны - пишите: Popup Window-Ops,
но если вы замените символ "-" на пробел, то вам будут
нужны кавычки: Popup "Window Ops".
 
AddButtonStyle  button [state] [style] [  --  [!]flag ... ] 
Добавляет стиль кнопки к  button .  button  может быть
номером кнопки или "All", "Left" или "Right".  state 
может быть "ActiveUp," "ActiveDown" или "Inactive."
Если  state  опускается, то стиль добавляется к
каждому состоянию. Если стиль кнопки и флаги
находятся в круглых скобках, то множество
определений состояний может быть помещено в одну
строку. Флаги для дополнительных стилей кнопок не
могут быть изменены после их задания.
 
 Кнопки  
 
рисуются в порядке их задания, начиная с
более нового ButtonStyle, с добавлением AddButtonStyle.
Для очистки стиля стека стиля кнопки,
измените флаги стиля, а для подробностей описания
стилей и флагов смотрите команду ButtonStyle.
Примеры:
 
ButtonStyle 1 Pixmap led.xpm -- Top Left
ButtonStyle 1 ActiveDown HGradient 8 grey black
ButtonStyle All -- UseTitleStyle
AddButtonStyle 1 ActiveUp (Pixmap a.xpm) ActiveDown (Pixmap b.xpm -- Top)
AddButtonStyle 1 Vector 4 50x30@1 70x70@0 30x70@0 50x30@1
 
 Первоначально  
 
для этого примера все состояния
кнопок устанавливаются в pixmap. Вторая строка
замещает состояние ActiveDown на градиент (это
перекрывает назначение pixmap что было сделано в
предыдущей строке). Затем, флаг UseTitleStyle
устанавливается для всех кнопок, что заставит  fvwm 
рисовать все стили установленные через TitleStyle
перед прорисовкой кнопок. Наконец, AddButtonStyle
используется для помещения добавочных pixmaps в оба
состояния ActiveUp и ActiveDown и стиль кнопки Vector
рисуется поверху всех состояний.
 
AddTitleStyle  [state] [style] [  --  [!]flag ... ] 
Добавляет стиль заголовка для полосы заголовка
окна.  state  должен быть одним из "ActiveUp,"
"ActiveDown," или "Inactive." Если  state 
опускается, то стить добавляется к каждому
состоянию. Если стиль и флаг помещены в круглые
скобки, то в одной строке может быть помещено
множество определений состояний. Эта команда сходна
с командой AddButtonStyle (смотрите выше).
 
 Полосы  
 
заголовков прорисовываются в порядке их
определения, начиная с более нового TitleStyle, с
добавлением AddTitleStyle. Для очиски стека стилей
заголовков изменить флаги состояния, а для описания
стилей и флагов смотрите команды TitleStyle и ButtonStyle.
 
AddToDecor  decor 
 
Добавить или откланяет команды для декора
названного  decor . Декор это какое-либо имя,
которое дается для установки команд, которые
привязывают стили кнопок, стили полос заголовков
окон, стили границ окна, цвета и шрифты окна. Если
 decor  не существует, то он создается; в противном
случае он модифицируется.
 
 Созданные декоры действуют точно также как и  
 
декор
fvwm по умолчанию без каких-либо переопределений
стилей. Данный декор может быть применен к
установке окон с опцией UseDecor комады Style.
Модифицируя существуюший декор можно привязать его
к окнам, которым в данный момент он назначен.
 
AddToDecor используется также как команды AddToMenu
и AddToFunc, за исключением того, что меню и
функции замещаются командами ButtonStyle, AddButtonStyle,
TitleStyle, AddTitleStyle, BorderStyle,
HilightColor и WindowFont. Декоры созданные
AddToDecor могут впоследствии изменятся опциями
ChangeDecor, DestroyDecor, UpdateDecor, и UseDecor
команды Style.
 
 Следующий  
 
пример создает декор и стить, оба
названные "flatness." Несмотря на одинаковое имя,
это разные вещи:
 
AddToDecor flatness
 
+ ButtonStyle All ActiveUp (-- flat) Inactive (-- flat)
+ TitleStyle -- flat</p>
+ BorderStyle -- HiddenHandles NoInset
+ HilightColor white navy</p>
Style "flatness" UseDecor flatness,Color white/grey40,HandleWidth 4
 
Style "xterm" UseStyle flatness
 
 Существующий декор  
 
окна может быть переназначен
ChangeDecor или командой Style и следующей за ней
командой Recapture. Внешний вид всех окон или
конкретный декор может быть обновлен UpdateDecor
(полезно после модификации внешнего вида; изменение
опций Style требует вызова Recapture вместо UpdateDecor).
Декор может быть уничтожен через вызов
DestroyDecor.
 
AddToMenu
 
Начинает или добавляет определение меню. Обычно
определение меню выглядит где-то так:
 
 AddToMenu Utilities "Utilities"  
 
     Title
 
 +  
 
           "Xterm" Exec xterm -e tcsh
 
 +  
 
           "Rxvt" Exec rxvt
 
 +  
 
           "Remote Logins" Popup Remote-Logins
 
 +  
 
           "Top" Exec rxvt -T Top -n Top -e top
 
 +  
 
           "Calculator" Exec xcalc
 
 +  
 
           "Xman" Exec xman
 
 +  
 
           "Xmag" Exec xmag
 
 +  
 
           "emacs" Exec xemacs
 
 +  
 
           "Mail" MailFunction xmh "-font fixed"
 
 ""  
 
        Nop
 
 +  
 
           "Modules" Popup Module-Popup
 
 +  
 
           "" Nop
 
 +  
 
           "Exit Fvwm" Popup Quit-Verify
 
 Меню может быть вызвано через 
 
 Mouse 1 R  
 
    A Menu Utilities Nop
 
 или 
 
 Mouse 1 R  
 
    A Popup Utilities
 
 В меню не имеется каких-либо символов  
 
конца меню.
Меню не должны определятся в смежной области файла
.fvwm2rc. Заключенная в кавычки порция в
приведенном выше примере это метка меню, которая
будет видна в меню, когда пользователь вызовет его.
Оставшаяся часть это встроеннвя команда, которая
будет вызвана если пользователь выберет этот пункт
меню. Пустая метка меню ("") и функция Nop
используются для вставки разделителя в меню.
 
 Если  
 
метка меню содержит подстроку, которая
 
 содержит  
 
звездочки, то ожидается, что текст между
звездочками это имя файла иконки (в xpm или bitmap
формате), которая будет вставлена в меню. Например
 
 +  
 
         "Calculator*xcalc.xpm*" Exec xcalc
 
вставляет пункт меню с меткой "calculator" с
картинкой калькулятора сверху метки. А в случае
 
 +  
 
         "*xcalc.xpm*" Exec xcalc
 
 будет видна только картинка. 
 
 Если метка меню содержит подстроку которая содержит 
 
символ "%", то ожидается, что текст между символами
процентов содержит имя файла иконки (в xpm или
bitmap формате), которая будет вставлена слева или
справа от метки меню. Например
 
 +  
 
         "Calculator%xcalc.xpm%" Exec xcalc
 
вставляет пункт меню с меткой "calculator" с
картинкой калькулятора справа от надписи. В случае
 
 +  
 
         "%xcalc.xpm%" Exec xcalc
 
 будет  
 
видна только картинка. Картинки для
использования в таких случаях должны быть
маленикими (около 16x16 точек)
 
AddToFunc
 
Начинает или добавляет описание функции. Пример:
 
 AddToFunc Move-or-Raise  
 
     "I" Raise
 
 +  
 
                      "M" Move
 
 +  
 
                      "D" Lower
 
Функция с именем Move-or-Raise может быть вызвана
из меню или через клавиатуру и мышь:
 
 Mouse 1 TS  
 
        A Move-or-Raise
 
 Порция, заключенная  
 
в кавычки говорит, какой вид
действия будет выполнять соманду, которая следует
за ней. "I" ставится для НЕМЕДЛЕННОГО выполнения, и
запуск происходит как только вызывается функция.
"M" ставится для ДЕЙСТВИЯ, т.е. если пользователь
запускает перемещение мыши. "C" ставится для
НАЖАТИЯ, т.е. если пользователь нажимает и
отпускает кнопку мыши в короткий период времени.
"D" ставится для ДВОЙНОГО НАЖАТИЯ. Действие "I" в
этом случае будет запущено по нажатию кнопки мыши,
если функция вызывается уже с активным окном.
 
Специальные символы $w и от $0 до $9 доступны
в комплексных функциях, макросах или других
функциях какие вы захотите использовать для их
вызова. Вместе с макросом, $w расширяется до
id-окна (выражается в шестнадцатиричной системе,
например 0x10024c) того окна для которого был
вызван макрос.Символы от $0 до $9 это агрументы для
макроса, таким образом если вы вызываете
 
Key F10 R A Function MailFunction xmh "-font fixed"
 
и MailFunction это
 
 AddToFunc MailFunction  
 
     "I" Next [$0] Iconify -1
 
 +  
 
                    "I" Next [$0] focus
 
 +  
 
                    "I" None [$0] Exec $0 $1
 
 То следующая строка функции становится 
 
 +  
 
                    "I" None [xmh] Exec xmh -font fixed
 
 Извлечение  
 
выполняется как только функция
запустится, таким образом вы можете использовать
некоторую функцию со всеми видами различных
аргументов.Я могу использовать
 
Key F11 R A Function MailFunction zmail "-bg pink"
 
в каком либо .fvwm2rc, если захочу. А вот пример
использования символа $w:
 
 AddToFunc PrintFunction  
 
     "I" Raise
 
 +  
 
                 "I" Exec xdpr -id $w
 
 Заметим,что $$ будет преобразовано в $. 
 
 Beep   
 
Так можно сделать гудок на терминале.
 
 BorderStyle [state] [style] [ -- [!]flag ... ] 
Задает стиль границ для окон.  state  может быть или
"Active" или "Inactive." Если  state  опускается, то
стиль устанавливается для обоих состояний. Если
стиль и флаг помещены в круглые скобки, то в одной
строке может быть помещено множество определений
состояний.
 
 style  это поднабор доступных ButtonStyles, и может
быть только TiledPixmap (одинаковые pixmaps,
которые совпадают по цветам контура для этого
случая то, что надо). Если символ "!" предшествует
какому-нибудь флагу, то поведение флага меняется на
противоположное. Если  style  не определено, то один
раз, можно изменить флаги без сброса данного стиля.
 
Флаг "HiddenHandles" прячет линии управления углов
для окон с управлением (эта опция не имеет эффекта
для NoHandle окон). По умолчанию HiddenHandles
запрещается.
 
Флаг "NoInset" дополняет HiddenHandles. Если он
задан, то внутренний контур вокруг рамки окна не
рисуется. Если HiddenHandles не задан, то этот
флаг ничего не делает.
 
 Для оформления активной и  
 
неактивной границ окна
текстурной pixmap нужно задать:
 
BorderStyle Active TiledPixmap marble.xpm
BorderStyle Inactive TiledPixmap granite.xpm
BorderStyle Active -- HiddenHandles NoInset
 
 Для очистки стиля для обоих состояний: 
 
BorderStyle Simple
 
 Для очистки одного состояния: 
 
BorderStyle Active Simple
 
 Для сброса флага для данного состояния: 
 
BorderStyle Inactive -- !NoInset
 
 Кнопки  
 
полосы заголовка окна могут наследовать
стиль границы окна с флагом UseBorderStyle
(смотрите ButtonStyle).
 
ButtonStyle  button [state] [style] [  --  [!]flag ... ] 
Задает стиль для кнопки полосы заголовка окна.  but_ t on 
это номер кнопки полосы заголовка окна между 0
и 9 включительно или "All", "Left", "Right", или
"Reset." Кнопка нумеруется как описано в секции
Mouse (см. ниже). Если стиль и флаг помещены в
круглые скобки, то в одной строке может быть
помещено множество определений состояний.
 
 state  это то состояния кнопки, которое должно быть
установлено. Состояния кнопки задаются как:
"ActiveUp" и "ActiveDown", что соответствует
ненажатому и нажатому состояниям кнопок активный
окон; в то время как состояние "Inactive" означает
кнопки на неактивных окнах.
 
Если  state  это ActiveUp, ActiveDown или Inactive,
то устанавливается особое состояние кнопки. Если
 state  опускается, каждое состояние будет
установлено. Задание стиля уничтожает текущий стиль
(используйте AddButtonStyle для того чтобы этого не
происходило).
 
Если  style  опускается, то флаги, которые зависят от
состояния могут быть установлены для первичного
стиля кнопки без уничтожения текущего стиля.
Примеры (каждая стока должна рассматриваться
независимо):
 
ButtonStyle Left -- flat
 
ButtonStyle All ActiveUp (-- flat) Inactive (-- flat)
 
 Первая строка устанавливает каждое состояние кнопок 
 
слева в flat в то время как вторая установливает
только состояния ActiveUp и Inactive на каждую
кнопку flat (изменяются только флаги;
индивидуальные стили кнопок не изменяются).
 
 Если  
 
вы хотите сбросить все кнопки в состояние по
 
 умолчанию: 
 
ButtonStyle Reset
 
Для сброса ActiveUp состояния кнопки 1 в состояние
по умолчанию:
 
ButtonStyle 1 ActiveUp Default
 
 Для  
 
сброса всех состояний кнопоки 1 в состояния по
умолчанию кнопки номер 2:
 
ButtonStyle 1 Default 2
 
 Для любой заданной кнопки,  
 
множество определенний
состояний может быть задано в одной строке, где
стили и флаги заключены в круглые скобки. Если в
одной строке только одно описание, то скобки не
нужны.
 
 flags  влияют на заданные  state . Если "!"
предшествует  flag , то его поведение меняется на
противоположное. Доступные зависимые от состояния
флаги для всех стилей описываются здесь (следующий
ButtonStyle имеет дело с флагами, зависимыми от
состояния).
 
"Raised" заставляет использовать выпуклый рельеф.
 
"Sunk" заставляет использовать вдавленный рельеф.
 
"Flat" блокирует рельеф.
 
"UseTitleStyle" заставляет состояние заданной
кнопки переключится в текущий стиль заголовка окна
вместо переключения в собственные стили кнопки.
Флаги Raised, Flat и Sunk параметра TitleStyle
игнорируются так как они являются избыточными для
данного случая.
 
"UseBorderStyle" заставляет кнопку наследовать
опции BorderStyle.
 
Raised, Sunk и Flat взаимно исключают друг друга и
могут быть заданы только для первоначального ButtonStyle.
UseTitleStyle и UseBorderStyle также
взаимно ислючающие (однако выключены могут быть
оба). По умолчанию используется Raised вместе с
выключенными UseBorderStyle и UseTitleStyle.
 
 Важное замечание  по состоянию ActiveDown. Когда
кнопка нажимается ее релиеф изменяется на
противоположный. Именно поэтому для получения
состояния вдавленного ActiveDown вы должны задать
противоположный релиеф (т.е. для получения видимого
нажатого состояния кнопки, которая имеет выпуклое
состояние нужно задать Sunk для ActiveDown). Это
поведение правильно, но может поначалу вызвать
недоумение.
 
 Стили кнопки классифицируются как  
 
недеструктивные,
частично деструктивные или полностью деструктивные.
Недеструктивные стили не ничего не делают с image.
Частично деструктивные могут работать со некоторыми
или всеми частями используемого image (т.е.
pixmap). Полностью деструктивные стили работают с
полносью внутренними image (т.е. Solid или один из
градиентных стилей). Таким образом, стили с
AddButtonStyle (или AddTitleStyle для полосы
заголовка окна), надо использовать рационально,
чтобы смешанный набор стилей делал минимальное
перерисовывание.
 
 Доступные  
 
стили и их аргументы в данный момент
следующие (зависят от опций компиляции, некоторые
стили могут быть недоступны).
 
Стиль "Simple" ничего не делает. Он не имеет
аргументов, и является примером недеструктивного
стиля.
 
Стиль "Default" условно имеет один аргумент: номер
которые задает количество номеров кнопок для
загрузки. Если задана команла стиля ButtonStyle или
AddButtonStyle, то агрумент необязателен (если
задано, то будет перекрываться текущая кнопка).
Если используется команда отличная от ButtonStyle
или AddButtonStyle, то количество должно быть
определено.
 
Стиль "Solid" заполняет кнопку сплошным цветом.
Цвет рельефа границы окна не изменяется. Цвет
должен быть задан как одиночный аргумент. Этот
стиль полностью деструктивный.
 
Стиль "Vector" прорисовывает линии по шаблону. Так
как это стандартный стиль кнопки, то ключевое слово
"Vector" необязательно. Вот маленький примерчик:
 
ButtonStyle 2 Vector 4 50x30@1 70x70@0 30x70@0 50x30@1
 
 где  
 
    оформление кнопки 2 заключается в
использловании 4-точечного шаблона состоящего из
линии идущей с (x=50,y=30) по (70,70) в цвете тени
(@0), и затем к (30,70) в цвете тени, и наконец к
(50,30) в цвете выделения (@1). Слишком сложно?
Смотрите примеры в .fvwm2rc. Этот стиль частично
деструктивный.
 
Стили "VGradient" и "HGradient" задают градиентные
стили. Префиксы H и V задают горизонатльное и
вертикальное управление.
 
 Этот стиль имеет две формы: 
 
 Первая форма задает линейный градиент. Аргументы: 
 
общее число цветов (между 2 и 128),
первоначальный цвет и финальный цвет.
 
 Вторая  
 
форма определяет нелинейный градиент.
Аргументы: общее число цветов (между 2 и 128),
затем количество сегментов. Для кадого сегмента
определяется стартовый цвет, процент увеличения и
затем конечный цвет. Каждая последоваетельность
сегментов начинается с цвета последнего сегмента.
Все проценты должны быть в пределах 100.
 
 Пример: 
 
TitleStyle VGradient 16 3 Red 20 Blue 30 Black 50 Grey
 
 Градиентный стиль полностью деструктивный. 
 
Стиль "Pixmap" отображает pixmap. Pixmap должен
быть определен как аргумент. Например, следующее
должно задать для кнопки 2 некоторую pixmap для
обоих состояний и для кнопки 4 различные pixmap для
состояний up, down и inactive.
 
ButtonStyle 2 Pixmap my_pixmap.xpm
ButtonStyle 4 ActiveUp (Pixmap up.xpm) ActiveDown (Pixmap down.xpm)
ButtonStyle 4 Inactive Pixmap inactive.xpm
 
Спецификация pixmap может быть дана как полное или
короткое имя файла (см. PixmapPath). Если pixmap не
найден, то стиль кнопки становится Simple.
Возможные флаги для стиля Pixmap следующие: "Left,"
"Right", "Top" и "Bottom." Они могу быть
использованы для выравнивания pixmap (по умолчанию
центруется для обоих состояний). Pixmap выводится
прозрачно на цвет "None". Этот стиль частично
деструктивный.
 
Стиль "MiniIcon" прорисовывает миниатюрные иконки
на кнопке, которые определяются с опцией MiniIcon
комадны Style. Этот стиль кнопок не имеет
аргументов. Например:
 
 Style "*"  
 
          MiniIcon mini-bx2.xpm
 
 Style "xterm"  
 
      MiniIcon mini-term.xpm
 
 Style "Emacs"  
 
      MiniIcon mini-doc.xpm
 
ButtonStyle 1 MiniIcon
 
Стиль "TiledPixmap" позволяет позволяет приделать
pixmap на фон кнопок. Одна pixmap определяется как
аргумент Прозрачность pixmap не используется. Этот
стиль полностью деструктивный.
 
ButtonStyle  button  -  [!]flag ... 
 
Устанавливает независимые от состояния флаги для
заданной кнопки  button . Каждый флаг отделяется
пробелом. Если префикс "!" предшествует флагу, то
флаг меняет свое поведение на противоположное.
 
"MWMButton" может быть назначен кнопке максимизации
для окон с опцией MWMButtons команды Style (это
обычно назначается одиночной кнопке). Когда окно
 
 максимизированно,  
 
      этот флаг заставляет
инвертироватся линии описанные а стиле кнопки Vector.
Этот флаг включен для крайней правой кнопки по
умолчанию.
 
ChangeDecor  decor 
 
Изменяет декор окна на  decor .  decor  это "Default,"
или имя декора заданного через AddToDecor. Если
вызов происходит из окна или его границы, то это
окно изменяется. Если вызов происходит из главного
окна, то пользователю позволят выбрать нужное окно.
ChangeDecor меняет только атрибуты, которые могут
быть установленв командой AddToDecor.
 
ChangeDecor "CustomDecor1"
 
 ClickTime delay 
 
Задает максимальную задержку (в миллисекундах)
между нажатиям кнопки и ее отпусканием для
встроенной функции, которая рассматривает нажатие
кнопок мыши. По умолчанию задержка равна 150
миллисекундам.
 
 Close  Если окно принимает протокол удаления окна, то
некоторое сообщение посылается окну ответившего
ему для изящного удаления себя самого. Если
окно не понимает протокол удаления окна, то окно
уничтожаестся.
 
 ColormapFocus [FollowsMouse | FollowsFocus] 
По умолчанию,  fvwm2  устанавливает карту цветов
окна, в котором находится курсор. Если вы
используете ColormapFocus FollowsFocus, то
установленная карта цветов будет такой же для окна,
которое в данный момент имеет фокус клавиатуры.
 
 CursorMove horizontal vertical 
 
Перемещает указатель мыши на horisontal страниц по
X и vertical страниц по Y. Или один или оба
параметра могут быть отрицательны. И horisontal и
vertical величины выражаются в процентах страниц,
таким образом "CursorMove 100 100" переместит
курсор вниз и влево на одну полную страницу.
"CursorMove 50 25" переместит курсор влево
наполовину страницы и вниз на четвертую часть
страницы. Функция CursorMove не может быть вызвана
из pop-up меню.
 
 Delete  Посылает сообщение окну ответившему, что оно
удалит само себя, хорошо для выхода из приложения.
 
 Desk <arg1> <arg2> 
 
Изменяет desktop на другой.
 
Если  arg1  не нуль, то следующий номер desktop'а
будет равен текущему номеру desktop'а плюс  arg1 .
Номера desktop'ов могут быть отрицательны.
 
Если  arg1  ноль, то новый номер desktop'а будет
равнятся  arg2 .
 
Номер активных desktop'ов определяется динамически.
Только desktop'ы, которые содержат окна или что в
данный момент отображены являются активными.
Номера desktop'ов могут лежать в диапазоне от
2147483647 до -2147483647 (надеюсь этого хватит?)
 
 DeskTopSize <Horizontal> <Vertical> 
 
Задает размер виртуального desktop'а в единицах
физического размера экрана.
 
 Destroy 
 
Грубо уничтожает окно приложения.
 
 DestroyFunc 
 
Удаляет функцию, так что последующие ссылки на нее
больше не верны. Вы можете использлвать эту
возможность для изменения содержимого функции во
время сессии  fvwm2 . Функция может быть перезадана,
используя AddToFunc.
 
DestroyFunc "PrintFunction"
 
DestroyDecor  decor 
 
Удаляет  decor  заданный через AddToDecor, так что
последующие ссылки на него больше неправильны.
Окна, использующие этот  decor  переключаются на
декор fvwm по умолчанию. Декор названный "Default"
не может быть удален.
 
DestroyDecor "CustomDecor1"
 
 DestroyMenu 
 
Удаляет меню, так что в последствии описание для
него больше не доступно. Вы можете использовать это
для измениния содержимого меню во время  fvwm2 
сессии. Меню может быть перестроено при
использовании AddToMenu.
 
DestroyMenu "Utilities"
 
 DestroyModuleConfig 
 
Удаляет конфигурационные строки модуля, таким
образом могут быть введены новые конфигурационные
строки вместо старых. Вы можете использовать данную
возможность как способ запуска модуля во время
 fvwm2  сессии без перезапуска самого  fvwm2 . Можно
использовать шаблоны для замены части имени.
 
DestroyModuleConfig FvwmFormFore
DestroyModuleConfig FvwmButtons*
 
Echo  string 
 
Выдает сообщение на stderr. Можно использовать для
отладки в вашем .fvwm2rc.
 
Echo Beginning style defs...
 
 EdgeResistance scrolling moving 
 
 Говорит как жестко будет изменятся  
 
поле простотра
desktop'а при перемещении мыши вверх к пределу
экрана и как жестко будет перемещаться окно вверх
к пределу экрана.
Первый параметр говорит сколько миллисекунд
указатель мыши должен удерживаться на границе
экрана перед тем как  fvwm2  изменит поле просмотра.
Это предназначается для людей использующих "EdgeScroll
100 100", и которых самих достает
случайный сдвиг страниц, когда они этого не хотят.
 
 Второй  
 
параметр говорит на какое количество точек
вверх за границу экрана должна быть перемещена
граница окна перед действительными перемещениями
частично отключенного экрана.
 
Заметим, что с "EdgeScroll 0 0", он замедлит
возможность перемещать окно или изменять размер
окна через границу текущего экрана. При задании
первого парамертра в EdgeResistance 10000 этот тип
действия станет невозможен. С EdgeResistance
меньше, чем 10000, но больше 0 перемещение страниц
выше становится трудным, но не невозможным.
 
 EdgeScroll horizontal vertical 
 
Задает процентную долю страницы для скроллинг,
когда курсор встает на границу страницы. Если вы не
хотите попадать на другие страницы или делать
скроллинг когда вы находитесь на границе
страницы, то вам нужно включить строку "EdgeScroll
0 0" в ваш файл .fvwm2rc. Если вы хотите пустые
страницы используйте "EdgeScroll 100 100". Оба
параметра и  horisontal  и  vertical  должны быть
положительными числами.
 
Если  horisontal  и  vertical  заданы больше 1000, то
скроллинг будет обрезаться вокруг границы desktop'а.
Если использвано "EdgeScroll 100000 100000",
 fvwm2  будет делать скроллинг пустых страниц
обрезая их вокруг границы desktop'а.
 
 Exec command 
 
Выполняет  command . Exec не требует добавления
`exec'.
 
 Следующий  
 
пример назначает функциональную клавишу
F1 в главное окно, без модификаторов, для
выполнения функции. Программа rxvt будет запущена с
представленными агрументами.
 
Key F1 R N Exec rxvt -fg yellow -bg blue -e /bin/tcsh
 
 ExecUseShell [shell] 
 
Задает команде Exec использование определенного
shell, или значени переменной окружения $SHELL,
если не задан этот параметр, вместо shell по
умолчанию (/bin/sh).
 
ExecUseShell
 
ExecUseShell /usr/local/bin/tcsh
 
FlipFocus
 
Переключает фокус между последними окнами, где был
фокус.
 
 Focus  Делает поле просмотра или окно видимым выбранным
окном. Помещает фокус ввод клавиатуры в выбранное
окно. Помещает окно поверх остальных если это
необходимо для того чтобы окно стало видимым.
Помещает указатель в выбранном окне в режим
focus-follows-mouse. Не разворачивает окно из
иконки.
 
 Function FunctionName 
 
Используется для назначения предварительно
определенной функции клавиатуре или кнопке мыши.
 
 Следующий пример назначает  
 
левую кнопку мыши для
вызова функции "Move-or-Raise", чье определение
было предоставлено в примере выше. После выполнения
этого разначения  fvwm2  будет выполнять функцию
Move-or-Raise как только левая кнопка мыши будет
нажата на полосе заголока окна.
 
Mouse 1 T A Function Move-or-Raise
 
Ключевое слово "Function" может быть опущено если
FunctionName не совпадает с именем какой-либо
встроенной функции  fvwm2 .
 
GlobalOpts  [options] 
 
Это ВРЕМЕННАЯ КОМАНДА, используемая для установки
некоторых глобальных опций, которые будут
впоследствии управлять параметрами Style (или
опциями параметров Style). В данный момент есть
следующие опции: SmartPlacementIsReallySmart/SmartPlacementIsNormal,
ClickToFocusDoesntPassClick/ClickToFocusPassesClick,
ClickToFocusDoesntRaise/ClickToFocusRaises,
MouseFocusClickDoes
ntRaise/MouseFocusClickRaises
 
GlobalOpts ClickToFocusDoesntPassClick, ClickToFocusDoesntRaise
 
 GotoPage x y 
 
Перемещает поле просмотра desktop'а на страницу с
координатами (x,y). Верхняя левая страница это
(0,0), верняя правая (N,0), где N это число
меньшее, чем текущее число горизонтальных страниц,
описанное в команде DeskTopSize. Левая нижняя
страница это (0,M) и нижняя правая страница это
(N,M), где M это вертикальный размер desktop'а как
задано в команде DeskTopSize. Функция GotoPage не
может быть использована в pop-up меню.
 
 HilightColor textcolor backgroundcolor 
 
Задает цвета текста и фона для оформления окна,
которое находится в данный момент в фокусе
клавиатуры.
 
 IconFont fontname 
 
Говорит  fvwm2  использовать шрифт fontname для
пометки иконок. Если этот параметр опущен, то
будет использован шрифт меню (заданный через
конфигурационный параметр MenuFont)
 
 Iconify [value] 
 
Сворачивает окно в иконку если оно уже не свернуто
или разворачивает обратно если оно уже свернуто.
Если необязательный аргумент value положителен, то
только свертывание будет допустимо. Если он
отрицателен, то допустимо будет только
развертывание.
 
 IconPath path 
 
Задает раздельный список полных имен директорий,
где могут находится одноцветные иконки (bitmap).
Каждое имя директории должно начинаться со слэша.
Могут быть использованы переменные окружения (т.е.
$HOME или ${HOME}).
 
Замечание: Если используется FvwmM4 для проверки
ваших rc файлов, то m4 может захотеть зарубить вам
слово "include", которое возможно будет указано в
команде IconPath или PixmapPath. Для устранения
этого добавьте undefine(`include') перед командой
IconPath или лучше используйте опцию `-m4-prefix'
для того, чтобы все директивы m4 имели перификс
"m4 (см. man FvwmM4).
 
 Key keyname Context Modifiers Function 
 
Назначает клавише клавиатуры опеределенную
встроенную функцию  fvwm2 . Присвоение происходит
также как для мыши за исключением того, что номер
кнопки мыши заменяется на имя клавиши. keyname
может быть задано как одно из имен определенных в
/usr/include/keysymdef.h, с опущенным XK. Поля
context и Modifiers задаются также как и для мыши.
 
 Следующий  
 
пример назначает всплытие списка окон по
нажатию Alt-Ctrl-Shift-F11:
 
Key F11 A SCM WindowList
 
 Назначение клавиши для кнопки  
 
в полосе заголовка
окна не говорит, что кнопка покажется, если также
не существует назанчение этой кнопки для мыши.
 
 KillModule name 
 
Заставляет модуль, которой был вызван с именем name
совершить самоубийство ;). name может включать
шаблон (wild-cards).
 
 Lower  Позволяет пользователю опустить окно вниз.
 
 Maximize [horizontal vertical] 
 
Без этих необязательных аргументов Maximize
заставляет окно переключаться из полноэкранного
размера в его нормальный размер и обратно.
 
С необязательными аргументами horisontal и vertical,
которые выражаются как процентные доли полного
экрана, пользователь может контролировать новый
размер окна. Если horisontal больше чем ноль, то
размер окна по горизонтали будет установлен в
horisontal*screenidth/100. Аналогично и по
вертикали. Следующий пример добавит кнопку в полосе
заловка окна для переключения окна в полный
размер экрана по вертикали:
 
Mouse 0 4 A Maximize 0 100
 
 Следующий  
 
пример заставит окна переключаться в
 
 полный размер по горизонтали: 
 
Mouse 0 4 A Maximize 100 0
 
 Эта  
 
строка делает окно размеров в половину размера
экрана в каждом направлении:
 
Mouse 0 4 A Maximize 50 50
 
 Величины больше  
 
чем 100 можно использовать, но
осторожно.
 
Если буква "p" добавляется к каждой координате
(horisontal и/или vertical), то это говорит о том,
что величины параметров заданы в точках.
 
 Menu menu-name double-сlick-action 
 
Заставляет всплыть заданное ранее pop-up меню в
манере "sticky". То есть, если пользователь
вызывает меню по нажатию кнопки вместо вызова из
другого меню, то меню всегда будет вверху.
Команда double-click-action будет вызвана если
пользователь сделал двойное нажатие при вызове
меню.
 
MenuStyle  forecolor backcolor shadecolor font style 
Устанавливает стиль меню. Когда используется
монохромный режим, цвета игнорируются. Теневой цвет
- это один из цветов, что используется для
прорисовки курсора-выбора выбора в меню, который
запрещается (или нерекомендуется) при mwm-hints,
которые имеет заданное приложение. Опция стиля
"fvwm" или "mwm", которые изменяют способ работы
меню.
 
 Module ModuleName 
 
Задает модуль который будет вызван во время
инициализации. В настоящее время доступны следующие
модули (включая модули  fvwm2 ): FvwmAudio (издаются
звуки при действиях менеджера окон), FvwmAuto
(модуль автоматического вытаскивания окна на верх),
FvwmBacker (для изменения цвета фона когда
происходит изменение desktop'ов), FvwmBanner (для
отображения XPM), FvwmButtons (создает
настраиваемую панель инструментов), FvwmCpp (для
предобработки вашего .fvwm2rc с использованием
Cpp), FvwmIdent (для получения информации об
окне), FvwmM4 (для предобработки вашего .fvwm2rc с
помощью m4), FvwmPager (мини версия десктоп'а),
FvwmSave (записывает состояние desktop'а в стиле
.xinitrc), FvwmSaveDesk (записывает состояние
десктопа в командах  fvwm2 ), FvwmScroll (помещает
полосу скроллинга в некоторые окна), FvwmTalk (для
интерактивного запуска команд  fvwm2 ), FvwmTaskBar
(панель задач как в Win95) и FvwmWinList (список
окон). Эти модули имеют свои страницы в man.
Могут быть и другие модули.
 
 Модули  
 
могут быть транзитными программами с
короткими временем жизни или как FvwmButtons
могут работать во время всей X сессии. Модули
будут уничтожены менеджером окон при презапуске или
выходе, если это будет возможно. Смотрите секцию
introdution по модулям. Ключевое слово "module"
может быть опущено если ModuleName легко отличимо
от всех встроенных имен и имен функций.
 
 ModulePath 
 
Задает раздельный список путей для поиска модулей
 fvwm2 . Могут использоваться переменные окружения
(т.е. $HOME или ${HOME}).
 
 Mouse Button Context Modifiers Function 
Описывает присвоение действий для мыши.  Button  это
номер кнопки мыши. Если Button нуль, то некоторая
кнопка будет выполнять специальную функцию. Context
описывает область применения присвоенного
действия. Допустимые значения context следующие: R
- для главного окна, W - для окна приложения, T для
полосы заголовка окна, S - для бордюра окна, F
- для углов окна. I - для Icon окна и от 0 до 9 для
кнопок на полосе заголовка окна. Возможны и
комбинации этих букв. A - для любых context
исключая кнопки заголовка окна. Для примера, context
FST будет работать, когда мышь находится
где-нибудь на бордюре окна, исключая кнопки на
полосе заголовка окна.
 
 Modifiers  - это любые комбинации из букв: N - без
модификаторов, S - для shift, M - для Meta, C - для
Сtrl или A - для всех. Например, модификатор SM
будет работать, когда будут нажаты вместе
клавиши Meta и Shift. X11 модифицирует от mod1 до
mod5, которые представляются как цифры от 1 до 5.
 
 Function  это одна из функций  fvwm2 .
 
 Кнопки  
 
на полосе заголовка окна нумеруются с
нечетными номерами слева и с четными справа от
заголовка окна.Кнопки с меньшими номерами
располагаются ближе к границам окна. Смотрите как
указано ниже
 
 1 3 5 7 9 0 8 6 4 2 
 
 Кнопка, которая имеет самый большой нечетный номер, 
 
и к которой привязано какое-либо действие определят
количество кнопок прорисовываемых слева полосы
заголовка. Кнопка, которая имеет самый большой
четный номер, и к которой привязано какое-либо
 
 дейтствие  
 
     определят количество кнопок
прорисовываемых справа полосы заголовка. Действие
может быть привязано или к кнопке мыши или к
клавиатурной клавише.
 
 Move [ x y ] 
 
Позволяет пользователю перемещать окно. Если вызов
происходит где-нибудь в окне или на бордюре окна,
то оно будет перемещено. Если вызов происходит из
главного окна, то пользователю будет позволено
выбрать окно для перемещения.
 
Если представлены необязательные аргументы x и y,
то окно будет перемещено таким образом, чтобы его
верхний левый угол находился в положении (x,y). x
и y - это процентные доли экрана, но если к
каждой координате добавлена буква "p", то в этом
случае координаты задаются в точках.
 
 Примеры: 
 
Mouse 1 T A Move
 
Mouse 2 T A Move 10 10</p>
Mouse 3 T A Move 10p 10p
 
 В первом примере пользователь будет перемещать окно 
 
в интерактивном режиме, во втором, окно, чей
заголовок был выбран будет перемещено так, чтобы
его левый верхний угол находился в положении 10% по
ширине и 10% по высоте экрана. Третий пример
аналогичен первому, только положение окна задатеся
точками а не процентами.
 
 Nop   
 
    Ничего не делает. Используется доя вставки пустой
строки или разделителя в меню. Если пунк меню задан
как Nop " ", то вставляется пустая линия, а если
Nop "", то вставляется разделитель. Может также
быть использован как для меню при двойном щелчке
мыши.
 
 Next [conditions] command 
 
Выполняет command (обычно Focus) для следующего
окна отвечающего всем conditions (условиям).
Условия включают "iconic","!iconic","CurrentDesk",
"Visible","!Visible" и "CurrentScreen". В
добавление, условие может включать имя окна. Имя
окна же может включать шаблон (символы "*" и
"?"). Имя окна, класс и ресурс будут рассмотрены,
при попытке дальнейшего поиска окна.
 
 None [conditions] command 
 
Выполняет command (обычно Focus) для следующего
окна отвечающего всем conditions (условиям).
Условия включают "iconic","!iconic","CurrentDesk",
"Visible","!Visible" и "CurrentScreen". В
добавление, условие может включать имя окна. Имя
окна же может включать шаблон (символы "*" и
"?"). Имя окна, класс и ресурс будут рассмотрены,
при попытке дальнейшего поиска окна.
 
 OpaqueMoveSize percentage 
 
Говорит  fvwm2  максимальный размер окна, с которым
было бы использовано перемещение окна как
сплошного. Percentage - это процентная доля всей
экранной области. С "OpaqueMove 0" все окна будут
перемещены с использованием традиционного
растягивающего контура. С "OpaqueMove 100" все окна
будут перемещаться как сплошные. По умолчанию
установлено "OpaqueMove 5", что позволяет
перемещать маленькие окна целиком, а большие с
помощью растягивающегося контура.
 
 PipeRead cmd 
 
Заставляет  fvwm2  читать команды выведенные из
программы с именем  cmd . Полезно для построения
динамических меню, основанных, например, на
содержимом директории.
 
 PixmapPath path 
 
Задает раздельный список путей, где будут искаться
цветные pixmap иконки. Каждый путь должен
начинаться со слэша. Допускается использование
переменных окружения (т.е. $HOME or ${HOME}).
 
 Popup PopupName 
 
Выполняет две функции: назначает меню клавише или
кнопке мыши, и назначает подменю в меню. Форматы
для этих двух функций различаются слабо.
 
Для назначения определенного ранее pop-up меню
клавише или кнопке мыши:
 
 Следующий  
 
пример назначает кнопки мыши 2 и 3 для
вызова pop-up меню "Window Ops". Меню будет
вызвано если будут нажаты кнопки 2 или 3 в углах
окна, на сторонах окна или в полосе заголовка,
без модификаторов (ctrl, shift или meta).
 
Mouse 2 FST N Popup "Window Ops"
Mouse 3 FST N Popup "Window Ops"
 
Pop-up меню могут быть назначены клавишам и при
использовании встроенной функции Key. Pop-up меню
могут быть вызваны без использования мыши при
назначении клавиш и с ними можно работать
используя клавиши up, down и enter.
 
Для назначения заданных ранее pop-up меню другим
меню, используйте подменю:
 
Следующий пример задает подменю "QuitVerify" и
назначает его в главное меню,названное "RootMenu":
 
AddToMenu Quit-Verify "Really Quit Fvwm?" Title
 
 +  
 
               "Yes, Really Quit" Quit
 
 +  
 
               "Restart Fvwm2" Restart fvwm2
 
 +  
 
               "Restart Fvwm 1.xx" Restart fvwm
 
 +  
 
               "" Nop
 
 +  
 
               "No, Don't Quit" Nop
 
AddToMenu RootMenu "Root Menu" Title
+ "Open an XTerm Window" Popup NewWindowMenu
 
 + "Login as Root"  
 
     Exec xterm -fg green -T Root -n Root -e su +
 
 "Login as Anyone"  
 
       Popup AnyoneMenu
 
 + "Remote Hosts"  
 
      Popup HostMenu
 
 + ""  
 
                Nop
 
 + "X utilities"  
 
               Popup Xutils
 
 + ""  
 
                Nop
 
 + "Fvwm Modules"  
 
      Popup Module-Popup
 
 + "Fvwm Window Ops"  
 
       Popup Window-Ops
 
 + ""  
 
                Nop
 
 + "Previous Focus"  
 
    Prev [*] Focus
 
 + "Next Focus"  
 
             Next [*] Focus
 
 + ""  
 
                Nop
 
 + "Refresh screen"  
 
    Refresh
 
 + "Recapture screen"  
 
      Recapture
 
 + ""  
 
                Nop
 
 + "Reset X defaults"  
 
      Exec xrdb -load $HOME/.Xdefaults
 
 + ""  
 
                Nop
 
 + ""  
 
                Nop
 
 + "Quit"  
 
         Popup Quit-Verify
 
Popup отличается от Menu в том, что pop-up меню не
остаются если пользователь нажмет кнопку мыши. При
стиле Twm, вы долны удерживать кнопку и выбирать
пункты меню перемещая мышь. Menu предоставляет меню
в стиле Motif или Microsoft-Windows.
 
 Prev [conditions] <command> 
 
Выполняет command (обычно Focus) для предыдущего
окна отвечающего всем conditions (условиям).
Условия включают "iconic","!iconic","CurrentDesk",
"Visible","!Visible" и "CurrentScreen". В
добавление, условие может включать имя окна. Имя
окна же может включать шаблон (символы "*" и
"?"). Имя окна, класс и ресурс будут рассмотрены,
при попытке дальнейшего поиска окна.
 
 Quit   
 
Выход из  fvwm2 , и обычно и из X тоже.
 
 Raise  Позволяет пользователю поднять окно на верх.
 
 RaiseLower 
 
Попеременно опускает окно вниз или поднимает
наверх.
 
 Read filename 
 
Заставляет  fvwm2  читать команды из файла с
именем filename.
 
 Recapture 
 
Заставляет  fvwm2  переинициализировать все в данных
окнах. Это необходимо чтобы были использованы более
 
 поздние  
 
       параметры стиля. Операция
переинициальзации заметно медленная.
 
 Refresh 
 
Заставляет все окна на экране перерисовать самих
себя.
 
 RefreshWindow 
 
Заставляет текущее (или выбранное) окна
перерисовать себя.
 
 Resize [x y] 
 
Позволяет пользователю изменять размер окна.
 
Если представлены необязательные агрументы x и y,то
размеры окна будут изменены так чтобы
соответствовать размеру x на y, где x и y это
процентные доли экрана, исключая использование
буквы "p", ибо тогда координаты берутся в точках.
 
 Restart WindowManagerName 
 
Заставляет  fvwm2  перезапускать самого себя если
WindowManagerName это "fvwm2" или переключаться в
альтернативный менеджер окон если он указан. Если
менеджер окон не находится в пути поиска, заданном
по умолчанию, то вы должны использовать полное имя
WindowManagerName.
 
 Это команда не допускает  
 
использование амперсанда
или переменных окружения. В примерах ниже два
первых неправильные, но третий OK:
 
Key F1 R N Restart fvwm &
Key F1 R N Restart /bin/fvwm
Key F1 R N Restart /home/nation/bin/fvwm
 
 SendToModule modulename string 
 
Посылает произвольную строку (кавычки не требуются)
всем модулям, совпадающим с  modulename , которое
может содержать шаблоны. Это дает эффект только
если модуль понимает данные строки и может работать
с ними. Может быть использовано для обмена
информацией между модулями или реализации в модулях
более комплексных команд.
 
 Scroll horizontal vertical 
 
Прокручивает поле просмотра виртуального desktop'а
на horisontal страниц по оси x и vertical страниц
по y. Один или оба параметра могут быть
отрицательными и выражают процентные доли
страниц, так что "Scroll 100 100" соответствует
прокрутке на одну полную страницу вниз и влево.
"Scroll 50 25" соответствует прокрутке на половину
страницы влево и на четверть страницы вниз. Функция
прокрутки не может быть вызвана из pop-up меню.
Обычно прокрутка останавливается по достижении
границ desktop'а.
 
Если horisontal и vertical больше, чем 1000, то
прокрутка все равно будет происходить до границы
desktop'а. Если "Scroll 100000 0" выполняется
дальше и дальше, то  fvwm2  будет перемещать на
следующую страницу desktop'а при каждом выполнении
и будет останавливаться на границе desktop'а, таким
образом каждая страница попадает в оборот.
Если буква "p" добавлена к координате, то она
рассматривается не в процентах а в точках.
 
 Stick  "Приклеевает" окно, если оно еще не "приклеено" или
отклеивает в противном случае.
 
 Style windowname options 
 
Эта команда заменяет такие старые глобальные
команды в Fvwm версий 1.xx как NoBorder, NoTitle,
StartsOnDesk, Sticky, StaysOnTop, Icon, WindowListSkip,
CirculateSkip, SuppressIcons, BoundaryWidth,
NoBoundaryWidth, StdForeColor, и StdBackColor
на одну мощную и понятную команду. Эта
команда используется для установки определенных
аттрибутов окна или установки стилей менеджера окон
по умолчанию.
 
 windowname  может быть именем окна, классом или
строкой ресурса и может содержать шаблоны
('*','?'), которые используются в именах фалйов
Unix.
 
 Заметим - окнам которые  
 
не имеют имени (WMAME)
дается имя "Untitled", а окнам которые не имеют
класса (WMLASS, res_class) дается Class="NOClass" и
наконец окнам что не имеют ресурса (WMLASS,
res_name) дается Resource = "NoResource".
 
 options  - это раздельный список команд содежащий
некоторые или все ключевые слова: BorderWidth,
HandleWidth, NoIcon/Icon, MiniIcon, IconBox, NoTitle/Title,
NoHandles/Handles, WindowListSkip/WindowListHit,
CirculateSkip/CirculateHit, StaysOnTop/StaysPut,
Sticky/Slippery, StartIconic/StartNormal,
Color, ForeColor, BackColor, StartsOnDesk/StartsAnyWhere,
IconTitle/NoIconTitle, MWMButtons/FvwmButtons,
MWMBorder/FvwmBorder,
 
MWMDecor/NoDecorHint, MWMFunctions/NoFuncHint, HintOverride/NoOverride,
 
 NoButton/Button,  
 
     OLDecor/NoOLDecor,
StickyIcon/SlipperyIcon, SmartPlacement/DumbPlacement,
RandomPlacement/ActivePlacement,
DecorateTransient/NakedTransient,
SkipMapping/ShowMapping, UseDecor, UseStyle, NoPPosition/UsePPosition,
Lenience/NoLenience, ClickToFocus/SloppyFocus/MouseFocus|FocusFollowsMouse.
 
 Вышеперечисленный список некоторых  
 
опций дан как
опция-стиля/противоположная-опция-стиля.
Противоположная-опция-стиля используется  fvwm2  по
умолчанию и нужна только если вы хотите
переопределить поведение по умолчанию.
 
Icon берется как строчный (без кавычек) агрумент,
который является именем файла формата pixmap или
bitmap.
 
IconBox имеет 4-ре числовых аргумента:
 
 IconBox  
 
l t r b
 
Где l - левая координата, t - верхняя, r -правая и
b - нижняя. Отрицательные координаты показывают
расстояние от правого или нижнего краев экрана. Сам
же IconBox - это окно на экране куда Fvwm будет
пытаться поместить иконки так чтобы они не
закрывали другие.
 
MiniIcon задает pixmap для использования ее как
миниатюрную иконку для окна. Миниатюрная иконка
может быть прорисована в кнопке полосы заголовка
окна (см. ButtonStyle) и может использоваться
различными модулями fvwm (FvwmWinList, FvwmIconMan
и FvwmTaskBar). Эта опция берет имя pixmap как
аргумент.
 
StartsOnDesk имеет числовой агрумент - это номер
desktop'а, на который будет помещено окно при
инициализации. Заметим, что стандартные Xt
программы могут также определять данный параметр
через ресурс (т.е. "-xrm `*Desk: 1'").
 
StaysOnTop делает окно таким, чтобы оно всегда
находилось поверх других окон. Это может быть
полезно для часов или почтового бокса, которые
должны быть видны всегда. Если окну явно дали
команду опустится под другие, то оно не будет
пытыться вернуть обратно, пока ему явно не дадут
команду всплыть наверх. StaysPut (по умолчанию)
позволяет окну быть нормальным.
 
BorderWidth имеет числовой аргумент который
является шириной бордюра окна, если оно не имеет
resize-handles.
 
HandleWidth имеет числовой аргумент, который
является шириной бордюра для помещения окна, если
оно не имеет resize-handles.
 
Button и NoButton имеют числовой аргумент , который
является номером кнопки полосы заголовка окна, что
может быть опущена или включена.
 
StickyIcon делает окно "приклеенным", когда оно
свернуто в иконку. Оно будет развернуто наверх
активного desktop'а.
 
MWMButtons создает видимость нажатой кнопки
максимизации когда окно максимицируется. Смотрите
флаг MWMButton в ButtonStyle для подробностей.
 
MWMBorder делает 3-D контур более закрытым как у
mwm.
 
MWMDecor говорит  fvwn95  попытаться определить и
использовать рекомендации по оформлению mwm'а. Это
иногда используют нектоторые приложения.
 
MWMFunctions говорит  fvwm2  попытаться определить
и использовать рекомендации mwm'а по запрещенным
операциям, что иногда используется приложениями.
HintOverride говорит  fvwm2  не использовать
опрерации, которые были бы запрещены в mwm, но
 fvwm2  все равно позволяет выполнять эти операции.
 
OLDecor говорит  fvwm2  пытаться определить и
использовать рекомендации olwm и olvwm, что
используют многие старые приложения XView и OLIT.
 
Color берет два аргумента. Первый - это цвет текста
метки окна и второй это нормальный цвет фона
оформления окна. Два цвета разделяются слэшем. Если
использование слэша вызывает проблемы, то разделите
их опциями ForeColor и BackColor.
 
UseDecor имеет один аргумент: имя декора,
созданного AddToDecor. Если UseDecor не задается,
то используется декор "Default". Окна вообще-то не
содержат декоров, но всегда они им всенла
назначаются. Если декор впоследствии изменен
AddToDecor, то изменения будут видны для всех окон,
которым был назначен данный декор. Декор для окна
может быть переназначен ChangeDecor.
 
UseStyle имеет один аргумент который является
именем другого стиля. Этот путь позволяет вам не
связывая имена окон, легко наследовать одинаковые
черты не вводя их повторно. Например: `Style
"rxvt" UseStyle "XTerm"'.
 
SkipMapping говорит fvwm2 не переключать окно на
другой desktop, когда происходит его инициализация
(полезно с StartsOnDesk).
 
Lenience говорит fvwm2 игнорировать преобразование
в ICCCM, которое состоит в том, что если приложение
устанавливает поле ввода структуры wm_hints в
False, то оно никогда не хочет, чтобы оконные
менеджер давал ему фокус ввода. Из приложений
которые нуждаются в этом, мне известны только sxpm
и что является глупым багом с тривиальным
исправлением и не имеет специального эфекта на
программу в любом случае. Наверное некоторые старые
приложнния тоже имеют эту проблему.
 
ClickToFocus говорит fvwm2 дать фокус окну, когда
внутри него нажата кнопка мыши. MouseFocus (или его
псевдоним FocusFollowsMouse) говорит fvwm2 дать
окну фокус как только указатель будет введен в
окно. Обычно установлен SloppyFocus, но он не дает
фокус если указатель покидает окно перемещаясь в
главное окно или в окно ClickToFocus (пока вы не
нажмете на нем кнопку мыши), что делает возможным
перемещать мышь без потери фокуса.
 
NoPPosition говорит  fvwm2  игнорировать поле PPosition,
когда добавляются новые окна. Приверженность
к полю PPosition требуется для некоторых
приложений, но если вы не имеете одного из них,
это доставляют головную боль.
 
RandomPlacement говорит создаваемому окну не
требовать у пользователя разместить его на
экране, а разместится самостоятельно используя
случайные координаты. Для лучшей работы
используйте и RandomPlacement и SmartPlacement.
 
SmartPlacement говорит создаваемому окну
разместится самостоятельно, используя для окна
незанятое другими окнами пространство на desktop'е.
Если такового не окажется, то пользователю придется
разместить окно самому или вызовется RandomReplacement,
если он был задан. Для лучшей работы
используйте и RandomPlacement и SmartPlacement.
 
 Например: 
 
Style "*" NoTitle,Icon unknown1.xpm, BorderWidth 4,HandleWidth 5
 
 # теперь, специальные установки окна: 
 
 Style "Fvwm*"  
 
     NoHandles,Sticky,WindowListSkip,BorderWidth 0
 
 Style "Fvwm Pager"  
 
             StaysOnTop, BorderWidth 0
 
 Style "*lock"  
 
     NoHandles,Sticky,StaysOnTop,WindowListSkip
 
 Style "xbiff"  
 
         Sticky, WindowListSkip
Style "FvwmButtons" NoHandles,Sticky,WindowListSkip
 
 Style "sxpm"  
 
        NoHandles
Style "makerkit"
 
 Style "xterm"  
 
     Title, Color black/grey
 
 Style "rxvt"  
 
       Icon term.xpm
 
 Style "xterm"  
 
       Icon rterm.xpm
 
 Style "xcalc"  
 
       Icon xcalc.xpm
 
 Style "xbiff"  
 
       Icon mail1.xpm
 
 Style "xmh"  
 
        Icon mail1.xpm, StartsOnDesk 2
 
 Style "xman"  
 
       Icon xman.xpm
 
 Style "matlab"  
 
      Icon math4.xpm, StartsOnDesk 3
 
 Style "xmag"  
 
       Icon magnifyinglass2.xpm
 
 Style "xgraph"  
 
      Icon graphs.xpm
Style "FvwmButtons" Icon toolbox.xpm
 
 Style "Maker"  
 
       StartsOnDesk 1
 
 Style "signal"  
 
      StartsOnDesk 3
 
 Заметим,  
 
что все свойства окон будут всегда
складываться. В вышепреведенном примере "FvwmPager"
берет свойство StaysOnTop через имя окна, но
также берет NoHandles, Sticky и WindowListSkip из
"Fvwm*". Он также возмет свойство NoTitle так как
оно определено для "*". Если определены стили,
которые конфликтуют, то будет использовано
последнее определение.
 
Если установлен аттрибут NoIcon то заданные окна
будут просто исчезнет при сворачивании. Окно может
быть восстановлено через окно списка. Если
установлен аттрибут Icon без аргумента, то аттрибут
NoIcon очищается, но иконка не задается. Вот
пример, который позволяет иметь иконку только
модулю FvwmPager:
 
Style "*" NoIcon
 
Style "Fvwm Pager" Icon
 
 Title  Ничего не делает. Используется для вставки строки
заголовка в popup меню.
 
 TitleStyle [justification] [height num] 
 
Устанавливает атрибуты для полосы заголовка окна.
Выравнивание может быть "Centered", "RightJustified,"
или "LeftJustified."  height  устанавливает
высоту полосы заголовка в точках. По умолчанию
установлено Centered и высота WindowFont. Параметр
 height  должен быть установлен после команды WindowFont
так как WindowFont сбрасывает высоту по
умолачанию для заданного шрифта:
 
TitleStyle LeftJustified Height 24
 
 TitleStyle [state] [style] [ -- [!]flag ... ] 
Устанавливает стиль для полосы заголовка окна.
 state  может быть "ActiveUp," "ActiveDown," или
"Inactive." Если  state  опускается, то стиль
добавляется к каждому состоянию. Если заключить в
круглых скобках стиль и флаги, то можно задавать
множество опредлений состояний в одной строке.
 style  может быть опущено так, что флаги могут быть
установлены без уничтожения текущего стиля.
 
Если символ "!" предшествует  flag , то его поведение
меняется на противоположное. Допустимые флаги для
каждого состояния это "Raised," "Flat," и "Sunk"
(они взаимно исключающие). По умолчанию Raised. См.
замечание в ButtonStyle касающееся состояния
ActiveDown. Примеры:
 
TitleStyle ActiveUp HGradient 16 navy black
TitleStyle ActiveDown (Solid red -- flat) Inactive (TiledPixmap wood.xpm)
TitleStyle ActiveUp (-- Flat) ActiveDown (-- Raised) Inactive (-- Flat)
 
Это устанавливает состояние ActiveUp к
горизонтальному градиенту, состояние ActiveDown в
сплошной красный цвет, и состояние Inactive в
фоновый pixmap. Наконец, ActiveUp устанавливается
как flat, в то время как ActiveDown устанавливается
в sunk (флаг Raised для состояния ActiveDown
заставляет выставить Sunk для инверсии рельефа), и
Inactive также устанавливает в flat. Пример, в
котором устанавливаются флаги для всех состояний:
 
TitleStyle -- flat
 
 Чтобы выглядело плоским: 
 
TitleStyle -- flat
 
ButtonStyle All ActiveUp (-- flat) Inactive (-- flat)
 
 UpdateDecor decor 
 
Обновляет офрмление окна. decor  это необязательный
аргумент который задает  decor  который будет
обновлен. Если он задан, то только окна которым
назначен данный  decor  будут обновлены. Эта команда
полезна для употребления после ButtonStyle,
TitleStyle или BorderStyle (возможно использовать и
c AddToDecor). Если задан неверный decor, то все
окна будут обновлены. Эта команда менее
распостранена чем Recapture, но ничего не делает с
опциями стиля окна как делает Recapture.
 
 WarpToWindow x y 
 
Помещает курсор для соответствующего окна.
Параметры x и y по умолчанию определяют процентную
долю опускания окна из верхнего левого угла (или
число точек, если `p' добавляется к цифрам).
 
 Wait name 
 
Это встроенная функция предназначается для
использования только в функциях  fvwm2 . Она
выполняет функцию ожидания пока выводится новое имя
окна name.  fvwm2      остается полность
работоспособным во время ожидания. Это полезно при
использовании InitFuction если вы пытаетесь
запустить окно на специфичном desktop'е:
 
AddToFunc InitFunction "I" exec xterm -geometry 80x64+0+0
 
 +  
 
                "I" Wait xterm
 
 +  
 
                "I" Desk 0 2
 
 +  
 
                "I" Exec xmh -font fixed -geometry 507x750+0+0
 
 +  
 
                "I" Wait xmh
 
 +  
 
                "I" Desk 0 0
 
В приведенной выше функции запускается xterm на
текущем desktop'е, ждет пока он отобразит сам себя,
затем переключается на desktop 2 и запускает xmh.
После xmh управление переключается на desktop 0.
 
WindowsDesk  arg1 [arg2] 
 
Перемещает выбранное окно на другой десктоп.
 
Если  arg1  не ноль, то следующий номер десктопа
вычисляется как номер текущего десктопа плюс  arg1 .
Номер декстопов монут быть отрицательными.
 
Если  arg1  ноль, то новый номер десктопа будет  arg2 .
 
 Если  
 
задан только один аргумент, то выбранное окно
перемещается на десктоп заданный как rg1 .
 
WindowFont fontname 
 
Говорит fvwm2 использовать фонт fontname вместо
"fixed" для заголовков окон.
 
WindowId  id func 
 
Функция WindowId похожа на функции Next и Prev, за
исключением того, что она смотрит на заданный  id 
окна и запускат для него заданную функцию  func .
 
WindowId 0x34567890 Raise
 
WindowId 0x34567890 WarpToWindow 50 50
 
 Очень полезно для функций испольщующихся с функцией 
 
WindowList.
 
 WindowList options 
 
Создает и показывает pop-up меню, в котором видны
заголоки и геометрия каждого из окон, которые
отображены на desktop'е. Геометрия свернутых окон
показывается в круглых скобках. Выбор пункта меню
из этого окна по умолчанию запустит функцию WindowListFunc
с id окна который устанавливается в $0.
По умолчанию WindowListFunc выглядит так:
 
AddToFunc WindowListFunc "I" WindowId $0 Iconify -1
 
 +  
 
                        "I" WindowId $0 Focus
 
 +  
 
                        "I" WindowId $0 Raise
 
 +  
 
                        "I" WindowId $0 WarpToWindow 5p 5p
 
Вы можете уничтожить встроенную WindowListFunc и
создать свою собственную если вас что-то не
устраивает.
 
 options  применимые к WindowList иогут быть "NoGeometry",
"Function <funcname>", "Desk <desknum>",
"CurrentDesk", "NoIcons", "Icons", "OnlyIcons",
"NoNormal", "Normal", "OnlyNormal", "NoSticky",
"Sticky", "OnlySticky", "NoOnTop", "OnTop", "OnlyOnTop",
"Unsorted", "UseIconName".
 
(Заметим - в обычном случае не NoIconic, NoSticky,
NoOnTop)
 
Если вы указали в функции через "Function <funcname>",
$0 это id окна:
 
AddToFunc IFunc "I" WindowId $0 Iconify
WindowList Function IFunc, NoSticky, CurrentDesk, NoIcons
 
Если вы хотите использовать WindowList как менеджер
иконок, вы можете вызывать его так:
 
WindowList OnlyIcons, Sticky, OnTop, Geometry
 
(Заметим - Опции "Only" существенно стирают все
другие...)
 
WindowShade [  opt  ]
 
Переключает состояние shade окна для окон с
заголовками. Окна в состоянии shade показываю
только строку заголовка. Если  opt  не задано, то
состояние окна shade переключается на
противоположное. Если  opt  есть 1, то окно
переключается в состояние shade. Если  opt  есть 2,
то окно переключается в состояние не-shade.
Максимизированные окна и окна без заголовков не
могут быть в состоянии shade.
 
 XORvalue number 
 
Изменяет значение битов для задания цвета
растягивающейся рамки, получающейся при изменении
размера или перемещении окна.
 
 +   
 
      Используется для добавления следующей заданной
функции или меню. Смотрите AddToFunc и AddToMenu.
 
 ПЕРЕКЛЮЧАТЕЛИ КЛАВИАТУРЫ 
 
Все (Я думаю) операции менеджера окон могут быть
выполнены с помощью клавиатуры, таким образом возможно
выполнение операций в отсутствии мыши. Добавим, что для
прокрутки по виртуальному desktop'у могут быть назначены
 
 клавиши  
 
также как и для функций move, resize вызова меню
и многих других. Для этого могут быть использованы
модифкаторы задействующие клавиши shift, ctrl. Однажды
встроенная функция запускается и указатель перемещается,
используя клавиши up, down, left, и right, и завершая
действие нажатием return. Удерживая нажатой клавишу shift
можно заставить указатель перемещаться большими шагами, а
удерживая клавишу ctrl можно заставить указатель
перемещаться меньшими шагами. Стандартное управление
перемщением курсора в emacs и vi это (^n, ^p, ^f, ^b, и
^j, ^k, ^h, ^l) может быть использовано вместо стрелок.
 
 СТАНДАРТНАЯ КОНФИГУРАЦИЯ 
 
Простой конфигурационый файл .fvwm2rc поставляется в
дистрибутиве fvwm2. Внутри довольно хорошо все описано и
может быть использовано в качестве исходной конфигурации
fvwm2.
 
Вместе с руководством в Debian'е, вы также увидите примеры
в /usr/doc/fvwm2/examples.
 
 ИСПОЛЬЗОВАНИЕ СОБСТВЕННЫХ МНОГОЭКРАННЫХ ДИСПЛЕЕВ 
 
Если аргумент командной строки -s не задан, fvwm2
автоматически запускается на каждый экран заданного
дисплея. После fvwm2 запускает независимую нить на каждый
экран. Перезапуск fvwm2 должен быть выполнен отдельно
для каждого экрана. Использование EdgeScroll 0 0 очень
рекомендуется для многоэкранных дисплеев.
 
 Вам также  
 
может понадобится при выходе выходить из
каждого экрана для полного завершения сессии.
 
 
   
 ОШИБКИ 

 
As of fvwm 0.99 there were exactly 39.342 unidentified
bugs. Identified bugs have mostly been fixed, though.
Since then 9.34 bugs have been fixed. Assuming that there
are at least 10 unidentified bugs for every identified
one, that leaves us with 39.342 - 9.32 + 10 * 9.34 =
123.402 unidentified bugs. If we follow this to its logical
conclusion we will have an infinite number of unidentified
bugs before the number of bugs can start to diminish,
at which point the program will be bug-free. Since
this is a computer program infinity = 3.4028e+38 if you
don't insist on double-precision. At the current rate of
bug discovery we should expect to achieve this point in
3.37e+27 years. I guess I better plan on passing this
thing on to my children....
 
Known bugs can be found in the BUGS file in the distribution,
and in the TO-DO list.
 
Bug reports can be sent to the FVWM mailing list (see the
FAQ).
 
 
 АВТОР 
 
Robert Nation при помощи кучи народа, основываясь на коде
 twm , который написал Tom LaStrange. Rob после этого
отошел от дел, а поддержку продолжает Charles Hines.
 
 Перевод  
 
с английского сделал Виктор Вислобоков
(2:5054/ 8.34@Fidonet.org )
 
 
 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 M4</bf> <bf>Preprocessing 
 Cpp</bf> <bf>Preprocessing 
 Auto-raise</bf>  (автоматическое перемешение окна  <bf>наверх) 
 ОШИБКИ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename