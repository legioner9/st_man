#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 gawk (1)   gawk  (1)   ( Solaris man: Команды и прикладные программы пользовательского уровня ) >>  gawk  (1)   ( Русские man: Команды и прикладные программы пользовательского уровня )   gawk  (1)   ( Linux man: Команды и прикладные программы пользовательского уровня ) 
   
 НАЗВАНИЕ 

gawk - язык поиска и обработки шаблонов
   
 СИНТАКСИС 

 gawk 

[ опции POSIX или GNU ]
 -f 

 файл-с-программой 

[
 -- 

] файл ...
 

 gawk 

[ опции POSIX или GNU ]
[
 -- 

]
 текст-программы 

файл ...
   
 ОПИСАНИЕ 

 Gawk 

- это GNU реализация языка программирования AWK.
Она соответствует определению языка, данному в
 POSIX  1003.2 Command Language And Utilities Standard.
Этот стандарт, в свою очередь, основан на книге
 The AWK Programming Language ,

авторы Aho, Kernighan и Weinberger. Кроме того, в
 gawk 

внесены некоторые дополнительные возможности, появившимися в версии
 awk 

для  UNIX  System V Release 4.
Поддерживаются и более поздние расширения
 awk ,

предложенные Bell Labs, а также некоторые расширения GNU.
 

Командная строка состоит из опций
 gawk ,

текста программы AWK (если не были указаны опции
 -f 

или
 --file )

и значений, которые в дальнейшем будут присвоены
встроенным переменным AWK
 ARGC 

и
 ARGV .

   
 ФОРМАТ ОПЦИЙ 

 

Опции
 gawk 

могут быть указаны как в традиционном для  POSIX  однобуквенном формате,
так и в формате длинных опций GNU. Опции  POSIX  начинаются с ``-'',
а длинные опции начинаются с ``--''.
Длинные опции доступны как для специфичных для GNU возможностей,
так и для стандартных возможностей  POSIX .
 

В соответствие со стандартом  POSIX , опции, специфичные для
 gawk ,

должны быть указаны в качестве аргументов опции
 -W .

Может быть указано несколько опций
 -W .

Каждой опции
 -W 

соответсвует длинная опция (см. ниже).
Аргументы длинных опций могут быть указаны после знака
 = 

(без пробелов), либо следующим аргументом командной строки.
Длинные опции можно сокращать, при условии сохранения уникальности
опции.
   
 ОПЦИИ 

 

 Gawk 

понимает следуюшие опции.
 
 
 
 -F  fs 

 
 
 --field-separator  fs 

Использовать
 fs 

в качестве разделителя полей (значение встроенной переменной
 FS ).

 
 
 -v  переменная = значение 
 
 
 --assign  переменная = значение 
Присвоить перед выполнением программы
 значение 

 переменной .

Такие переменные доступны в блоке
 BEGIN 

программы AWK.
 
 
 -f  файл-с-программой 

 
 
 --file  файл-с-программой 

Взять программу AWK из
 файла-с-программой ,

вместо того, чтобы брать ее из первого аргумента командной строки.
Может быть указано несколько опций
 -f 

(или
 --file ).

 
 
 -mf  NNN 

 
 
 -mr  NNN 

Установить различные ограничения памяти в
 NNN .

Флаг 
 f 

устанавливает максимальное количество полей, а флаг
 r 

- максимальный размер записи. Эти два флага опции
 -m 

были введены в исследовательской версии Bell Labs  UNIX 
 awk .

Они игнориуются 
 gawk ,

так как
 gawk 

не имеет предопределенных ограничений.
 
 
 -W traditional 

 
 
 -W compat 

 
 
 --traditional 

 
 
 --compat 

Работать в режиме 
 совместимости .

В этом режиме
 gawk 

работает как  UNIX 
 awk .

Расширения GNU не поддерживаются.
Рекомендуется включать этот режим опцией
 --traditional .

Более подробная информация приведена ниже в разделе
 РАСШИРЕНИЯ GNU .

 
 
 -W copyleft 

 
 
 -W copyright 

 
 
 --copyleft 

 
 
 --copyright 

Вывести краткую информацию GNU о правах и выйти.
 
 
 -W help 

 
 
 -W usage 

 
 
 --help 

 
 
 --usage 

Вывести относительно краткую справку по опциям.
(В соответствие с
 GNU Coding Standards ,

эти опции приводят к немедленному нормальному выходу.)
 
 
 -W lint 

 
 
 --lint 

Выдавать предупреждения о наличии сомнительных или
несовместих с другими версиями AWK конструкциях.
 
 
 -W lint-old 

 
 
 --lint-old 

Выдавать предупреждения о наличии конструкций,
несовместих со старыми версиями UNIX
 awk .


 
 
 -W posix 

 
 
 --posix 

Включить режим
 совместимости 

со следующими ограничениями:
 
 
 * 
Не распознаются экранирующие последовательности
 \x .

 * 
Если значение
 FS 

- один пробел, то разделителями считаются только
пробел и символ табуляции. Символ новой строки
разделителем не считается.
 * 
Не распознается синоним
 func 

ключевого слова
 function .

 * 
Операторы
 ** 

и
 **= 

не могут быть использованы вместо
 ^ 

и
 ^= .

 * 
Недоступна функция
 fflush() .

 
 

 
 
 -W re-interval 

 
 
 --re-interval 

Разрешить использование
 интервальных выражений 

в регулярных выражениях.
(см. раздел
 Регулярные выражения 

ниже).
Интервальные выражения традиционно отсутствовали в языке AWK.
Стандарт POSIX внес их для совместимости
 awk 

и
 egrep 

друг с другом.
Тем не менее, их использование может привести к ошибкам в работе
старых программ AWK, поэтому
 gawk 

распознает их только если указана эта опция или опция
 --posix .

 
 
 -W source  текст-программы 

 
 
 --source  текст-программы 

Использовать
 текст-программы 

в качестве текста программы AWK.
Эта опция позволяет совмещать вызовы библиотечных функций (подключаемых
через опции
 -f 

и
 --file )

с исходным кодом, вводимым в командной строке.
Эта опция, в первую очередь, предназначена для средних и больших по
размеру программ AWK, используемых в скриптах shell.
 
 
 -W version 

 
 
 --version 

Вывести информацию о версии вашей копии
 gawk .

Эта опция может быть полезна, если вы хотите узнать, не устарел ли
 gawk ,

установленный в вашей системе, а также если вы хотите сообщить об
ошибке.
(В соответствие с
 GNU Coding Standards ,

эти опции приводят к немедленному нормальному выходу.)
 -- 

 
Конец опций. Эта опция используется для возможности обработки аргументов,
начинающихся с ``-'', непосредственно программой AWK, что соответствует
соглашению об обработке аргументов, используемому большинством других
программ, совместимых со стандартом  POSIX .
 
 

В режиме совместимости все другие опции считаются неверными и игнорируются.
В обычном режиме, если указан текст программы, неизвестные опции передаются
через массив
 ARGV 

программе AWK для обработки. Это очень удобно для запуска программ через
``#!''.
   
 ИСПОЛНЕНИЕ ПРОГРАММЫ AWK 

 

Программы AWK состоит из последовательности операторов шаблон-действие и,
возможно, определений функций.
 
 

 шаблон  {  операторы  } 
 

 function  имя ( список параметров ) {  операторы  } 
 

 

Сначала
 gawk 

читает исходный текст программы из
 файлов-с-программой 

и из аргументов опции
 --source ,

если они указаны,
или из первого аргумента командной строки, не являющегося опцией.
Опции
 -f 

и
 --source 

могут быть указаны в командной строке несколько раз.
 Gawk 

воспринимает текст программы так, как будто все
 файлы-с-программой 

были сцеплены друг с другом. Это удобно при создании библиотек функций
AWK, так как не требует явного определения функций в каждой новой программе,
использующей их. Кроме того, эта возможность позволяет совмещать
библиотечные функции с программами, указанными в командной строке.
 

Переменная окружения
 AWKPATH 

содержит путь, по которому производится поиск файлов,
указанных в качестве аргумента опции
 -f. 

Если эта переменная не указана, то, по умолчанию, используется путь
 ".:/usr/local/share/awk" .
(Путь может быть и другим, это зависит от того, как
 gawk 

был скомпилирован и установлен.)
Если имя файла, указанное в качестве аргумента опции
 -f ,

содержит символ ``/'', то поиск не производистся.
 

 Gawk 

выполняет программы следующим образом.
Сперва
производится инициализация переменных, указанных опцией
 -v .

Далее
 gawk 

компилирует программу во внутренний формат.
Затем
 gawk 

исполняет код в блоке (блоках)
 BEGIN ,

если таковые имеются,
и начинает читать файлы, имена которых содержатся в массиве
 ARGV .

Если в командной строке не были указаны файлы, то
 gawk 

читает стандартный поток ввода.
 

Если имя файла в командной строке имеет вид
 переменная = значение ,
то оно воспринимается как операция присваивания.
 Переменной 

присваивается
 значение .

(Это происходит после выполнения блока (блоков)
 BEGIN .)

Присваивание значений переменным в командной строке удобно для
динамической инициализации переменных, используемых AWK для определения
способа деления входного потока на поля и записи. Кроме того, оно может
пригодится в тех случаях, когда требуется несколько раз обработать один
и тот же файл.
 

Если значение какого-либо элемента
 ARGV 

пусто ( "" ), то
 gawk 

пропускает его.
 

Каждую запись входного потока
 gawk 

проверяет на предмет совпадения
 шаблонов 

программы AWK.
Для каждого совпавшего шаблона выполняется соответствующее ему
 действие .

Проверка шаблонов производится в том порядке, в каком они встречаются
в программе.
 

Наконец,
после того, как весь входной поток обработан,
 gawk 

исполняет код блока (блоков)
 END ,

если таковые имеются.
   
 ПЕРЕМЕННЫЕ, ЗАПИСИ И ПОЛЯ 

В AWK используются динамические переменные, то есть, появляющиеся при первом
использовании. Переменные могут быть числами с плавающей запятой,
строками, или и тем, и другим, в зависимости от использования. AWK также
поддерживает одномерные массивы. Многомерные массивы могут быть
имитированы. Во время выполнения программы существуют несколько
встроенных переменных (см. ниже).
 
   
 Записи 

По умолчанию записи разделяются символами новой строки. Вы можете
переопределить способ разделения записей, присвоив нужное значение
встроенной переменной
 RS .

Если значение
 RS 

- единственный символ, то он будет использоваться для разделения
записей. В противном случае
 RS 

- регулярное выражение. Текст входного потока, совпавший с ним,
будет разделять записи. В режиме совместимости для разделения
записей будет использоваться только первый символ строки выражения.
Если
 RS 

- пустая строка, то записи будут разделяться пустыми строками.
При этом символ новой строки всегда будет работать как разделитель
полей, в дополнение к значению
 FS .

   
 Поля 

 

Каждую считываемую строку
 gawk 

разбивает на
 поля ,

используя значение переменной
 FS 

в качестве разделителя.
Если значение
 FS 

- единственный символ, то поля разделяются этим символом.
Если значение
 FS 

- пустая строка, то каждый символ считается отдельным полем.
В противном случае,
 FS 

считается регулярным выражением.
Исключение составляет случай, когда значение
 FS 

- один пробел. При этом поля разделяются комбинациями пробелов
и/или символов табуляции, и/или символами новой строки.
(См. также информацию по
 --posix 

ниже.)
Заметьте, что значение
 IGNORECASE 

(см. ниже) также будет влиять на разделение полей, если
 FS 

-  регулярное выражение, и  на разделение записей, если
 RS 

- регулярное выражение.
 

Если переменная
 FIELDWIDTHS 

содержит список чисел, разделенных пробелами, то
 gawk 

считает ширину каждого поля фиксированной и разделяет запись в
соответствие c указанными значениями. Значение переменной
 FS 

в этом случае игнорируется.
Присваивание нового значения переменной
 FS 

аннулирует использование
 FIELDWIDTHS 

и восстанавливает поведение, принятое по умолчанию.
 

На любое поле входной записи можно ссылаться по его позиции -
 $1 ,

 $2 

и так далее.
 $0 

ссылается на всю запись. Кроме того, любому полю можно присвоить значение.
Для ссылок на поля необязательно использовать константы. Например
 
 

 
n = 5
 

print $n
 
 

 

выведет пятое поле записи.
Переменная
 NF 

содержит количество полей входной записи.
 

Результатом ссылки на несуществующее поле (т. е. поле с номером,
превышающим
 $NF )

является пустая строка. Присваивание значения несуществующему полю
(например,
 $(NF+2) = 5 )

увеличивает значение
 NF 

и создает промежуточные поля с пустой строкой в качестве значения.
Содержимое переменной
 OFS  

используется в качестве разделителя полей. Значение 
 $0 

вычисляется заново.
Ссылка на поля с отрицательными номерами является ошибкой.
Уменьшение значения
 NF 

вызывает потерю значений полей с номерами, превышающими новое значение.
Значение
 $0 

вычисляется заново, поля разделяются содержимым переменной
 OFS .

   
 Встроенные переменные 

 

Встроенными переменными
 Gawk 

являются:
 

 
 ARGC 

 
Количество аргументов командной строки (исключая опции
 gawk 

и исходный текст программы).
 ARGIND 

 
Индекс массива
 ARGV ,

указывающий на обрабатываемый в данный момент файл.
 ARGV 

 
Массив аргументов командной строки. Индекс массива может принимать значения
от 0 до
 ARGC 

- 1.
Изменяя в процессе работы программы содержимое
 ARGV ,

можно контролировать, какие файлы обрабатываются.
 CONVFMT 

 
Формат преобразования чисел. По умолчанию  "%.6g" .
 ENVIRON 

 
Массив текущих значений переменных окружения. Массив индексирован по
названиям переменных, каждый элемент содержит значение соответствующей
переменной (например,  ENVIRON["HOME"]  может иметь значение
 /home/arnold ).

Изменение содержимого этого массива не влияет на значения переменных
окружения, видимых программами, запускаемыми из
 gawk 

с помощью функции
 system() .

(Возможно, в следующих версиях
 gawk 

это изменится.)

 ERRNO 

 
Если происходит системная ошибка при перенаправлении для
 getline ,

при чтении для 
 getline ,

или при вызове
 close() ,

то
 ERRNO 

будет содержать строку, которая описывает ошибку.
 FIELDWIDTHS 

 
Список длин полей, разделенный пробелами. Если этой переменной
присваивается новое значение, то
 gawk 

разделяет входные данные на поля фиксированной длины, при этом значение
переменной
 FS 

игнорируется.
Возможность работы с полями фиксированной длины все еще находится в
стадии проверки; семантика может поменяться в процессе развития
 gawk .

 FILENAME 

 
Имя файла, обрабатываемого в данный момент.
Если в командной строке не было указано ни одного файла, то значение
 FILENAME 

равно ``-''.
В блоке
 BEGIN 

переменная
 FILENAME 

не определена.
 FNR 

 
Номер входной записи в текущем входном файле.
 FS 

 
Разделитель полей во входном потоке, по умолчанию пробел. Обращайтесь к
подразделу
 Поля 

выше.
 IGNORECASE 

 
Контролирует зависимость всех регулярных выражений и строковых операций
от регистра.
Если значение
 IGNORECASE 

не равно нулю, то при работе с регулярными выражениями регистр будет
игнорироваться в следующих случаях:
при сравнении строк и проверке шаблонов в правилах;
при разделении на поля с использованием значения
 FS ;

при разделении на записи с использованием значения
 RS ;

в регулярных выражениях c
 ~ 

и
 !~ ;

во встроенных функциях
 gensub() ,

 gsub() ,

 index() ,

 match() ,

 split() 

и
 sub() .

Таким образом, если значение
 IGNORECASE 

не равно нулю, то
 /aB/ 

совпадет с любой строкой из  "ab" ,  "aB" ,  "Ab" 
или  "AB" .
Как и у всех переменных AWK, начальное значение
 IGNORECASE 

равно 0, так что все операции со строками и регулярными выражениями
изначально чувствительны к регистру.
В Unix при игнорировании регистра используется полный набор символов ISO
8859-1 Latin-1.
 ПРИМЕЧАНИЕ: 

В версиях
 gawk 

до 3.0 значение
 IGNORECASE 

влияло только на операции с регулярными выражениями. В данный момент оно
влияет и на операции сравнения строк.
 NF 

 
Количество полей в текущей входной записи.
 NR 

 
Общее количество встреченных записей.
 OFMT 

 
Формат вывода чисел. По умолчанию  "%.6g" .
 OFS 

 
Разделитель выходных полей. По умолчанию пробел.
 ORS 

 
Разделитель выходных записей. По умолчанию символ новой строки.
 RS 

 
Разделитель входных записей. По умолчанию символ новой строки.
 RT 

 
Конец записи.
 Gawk 

присваивает
 RT 

значение входного текста, совпавшего с символом или регулярным выражением,
содержащимся в 
 RS .

 RSTART 

 
Индекс первого символа, совпавшего при вызове
 match() .

0, если совпадения не было.
 RLENGTH 

 
Длина строки, совпавшей при вызове
 match() .

-1, если совпадения не было.
 SUBSEP 

 
Символ, используемый для разделения элементов в массиве. По умолчанию
 "\034" .
 
   
 Массивы 

 

Массивы индексируются по выражению, указанному между квадратными скобками
( [  и  ] ).

Если выражение является списком выражений
( выражение ,  выражение  ...),

то массив индексируется по строке, состоящей из сцепленных (строковых)
значений всех выражений, разделенных значением переменной 
 SUBSEP .

Эта возможность используется для имитирования многомерных массивов. 
Например
 

 
 
i = "A"; j = "B"; k = "C"
 

x[i, j, k] = "hello, world\n"
 
 

 

присваивает элементу массива
 x ,

индексированного по строке  "A\034B\034C" ,
строку  "hello, world\n" .
Все массивы в AWK ассоциативны, т.е. индексируются по строковым значениям.
 

Для проверки существования в массиве определенного индекса в операторах
 if 

и
 while 

может быть использован специальный оператор
 in .

 

 
 
 if (val in array)
        print array[val]
 


 

 

Если массив многомерный, используйте
 (i, j) in array .

 

Конструкция
 in 

может быть также использована в цикле
 for 

для перебора всех элементов массива.
 

Элемент может быть удален из массива оператором
 delete .

Кроме того, оператор
 delete 

может быть использован для удаления всего массива. Для этого нужно указать
имя массива без индекса.
   
 Типы переменных и их преобразование 

 

Переменные и поля могут быть числами с плавающей запятой, строками или и
тем, и другим одновременно. Тип переменной зависит от контекста. В числовых
выражениях переменная считается числом, в строковых - строкой.
 

Если вы хотите, чтобы переменная считалась числом, добавьте к ней 0. Если
вы хотите, чтобы переменная считалась строкой, сцепите ее с пустой строкой.
 

Конвертирование строки в число производится с помощью
 atof (3).

Конвертирование числа в строку производится с помощью
 sprintf (3),

путем использования значения
 CONVFMT 

в качестве строки форматирования, и числового значения переменной в качестве
аргумента.
Хотя все числа в AWK считаются числами с плавающей запятой, целые значения
 всегда 

преобразуются как целые. Поэтому в
 

 
 
 CONVFMT = "%2.2f"
a = 12
b = a ""
 


 

 

строковое значение переменной
 b 

будет  "12" , а не  "12.00" .
 

 Gawk 

выполняет сравнения следующим образом:
если две переменные имеют числовое значение, то они сравниваются как числа;
если одна переменная имеет числовое значение, а вторая является
``строкой-числом'' (т.е. строкой, состоящей из цифр), то переменные сравниваются как числа.
Во всех остальных случаях производится преобразование числа в строку, и переменные
сравниваются как строки.
Две строки, естественно, сравниваются как строки.
В соответствие со стандартом  POSIX , даже если две строки являются ``строками-числами'',
то они сравниваются как числа. Но это, безусловно, неправильно, поэтому
 gawk 

не делает этого.
 

Заметьте, что строковые константы, такие как  "57" ,
 не 

являются ``строками-числами'', а именно строковыми константами. Термин
``строка-число'' применим лишь к полям, входным данным
 getline ,

 FILENAME ,

элементам
 ARGV ,

элементам
 ENVIRON 

и тем элементам массива, созданного
 split() ,

которые являются числовыми строками.
Основная идея в том, что таким образом интерпретируется только
 входная информация пользователя ,

выглядящая, как число.
 

Переменные, неинициализированные явно, имеют числовое значение 0 и строковое
значение "" (пустая строка).
   
 ШАБЛОНЫ И ДЕЙСТВИЯ 

AWK - это язык, ориентированный на строки. Сперва указывается шаблон, затем
действие. Операторы действия заключаются в фигурные скобки
 { 

и
 } .

Шаблон или действие могут быть пропущены, но, естественно, не то и другое
одновременно. Если не указан шаблон, то действие будет выполняться для
каждой входной записи. Пропущенное действие эквивалентно
 
 

 { print } 

 

 

то есть, выводу всей записи.
 

Комментарии начинаются с символа ``#'' и продолжаются до конца строки.
Для разделения операторов могут использоваться пустые строки.
Обычно оператор заканчивается концом строки, кроме случаев, когда строки
оканчиваются символами
``,'',
 { ,

 ? ,

 : ,

 && 

или
 || .

Если строка оканчивается
 do 

или
 else ,

подразумевается, что оператор продолжается в следующей строке. В других
случаях строка может быть продолжена с помощью символа ``\'', при этом
символ новой строки будет проигнорирован.
 

Несколько операторов, помещенных в одной строке, должны быть разделены
символом ``;''. Это относится как к операторам действия пары
шаблон-действие (типичный случай), так и к самим парам шаблон-действие.
   
 Шаблоны 

Шаблоны AWK могут быть следующими:
 

 
 BEGIN 
 END 
 / регулярное выражение / 
 условное выражение 
 шаблон  &&  шаблон 
 шаблон  ||  шаблон 
 шаблон  ?  шаблон  :  шаблон 
 ( шаблон ) 
 !  шаблон 
 шаблон1 ,  шаблон2 
 

 

 

 BEGIN 

и
 END 

- два специальных шаблона, которые не проверяются на совпадение со входными
данными. Действия всех шаблонов
 BEGIN 

объединяются, как будто все операторы были указаны в одном блоке
 BEGIN .

Операторы этих блоков выполняются перед чтением каких-либо входных данных.
Подобным образом объединяются все блоки
 END .

Операторы этих блоков выполняются после чтения всех входных данных (или
после выполнения оператора
 exit ).

 BEGIN 

и
 END 

не могут быть объединены в шаблонных выражениях с другими шаблонами.
Действие для шаблонов
 BEGIN 

и
 END 

обязательно должно быть указано.
 

Действие, связанное с шаблонами
 / регулярное выражение / 

, выполняется для всех входных записей, совпавших с 
 регулярным выражением .

Регулярные выражения те же, что и в
 egrep (1),

общая информация по ним дана ниже.
 

 Условное выражение 

может состоять из любых операторов, описанных ниже в разделе, посвященном
действиям. В большинстве случаев, это проверки на совпадение определенных
регулярных выражений с определенными полями.
 

Операторы
 && ,

 || 

и
 ! 

- это логические И, ИЛИ и НЕ, соответственно. Эти операторы
используются для объединения более простых шаблонных выражений. Как и в
большинстве языков, для изменения очередности вычислений могут применяться
круглые скобки. Как и в C, используется краткое вычисление логических
выражений.
 

Оператор
 ?: 

соответствует оператору C. Если первый шаблон - истина, то для проверки
используется второй шаблон, в противном случае - третий. Вычисляется
только второй, или только третий шаблон.
 

Выражение
 шаблон1 ,  шаблон2 

называется 
 шаблоном области .

Он совпадает со всеми записями, начиная с записи, совпавшей с
 шаблоном1 ,

и заканчивая  совпавшей с
 шаблоном2 ,

включительно. Этот шаблон не может быть объединен с другими шаблонами.
   
 Регулярные выражения 

Регулярные выражения AWK - это расширенная версия регулярных выражений
 egrep .

Они составляются из символов следующим образом:
 
 c 

 
совпадает с не-метасимволом
 c .

 \c 

 
совпадает с символом
 c .

 . 

 
совпадает с любым символом,
 включая 

символ начала строки.
 ^ 

 
совпадает с началом строки.
 $ 

 
совпадает с концом строки.
 [ abc... ] 

 
список символов, совпадает с любыми символоми
 abc... .

 [^ abc... ] 

 
инвертированный список символов, совпадает с любыми символами, кроме
 abc... .

 r1 | r2 

 
альтернатива: совпадает либо с
 r1 ,

либо с
 r2 .

 r1r2 

 
сцепление: совпадает сперва с
 r1 ,

затем с
 r2 .

 r + 

 
совпадает с одним или более
 r .

 r * 

 
совпадает с ноль или более
 r .

 r ? 

 
совпадает с ноль или одним
 r .

 ( r ) 

 
группирование: совпадает с
 r .

 
 
 r { n } 

 
 
 r { n ,} 

 
 
 r { n , m } 

Одно или два числа в фигурных скобках обозначают
 интервальное выражение .

Если в скобках указано одно число, то предыдущее регулярное выражение
 r 

повторяется
 n 

раз. Если указаны два числа, разделенные запятой, то 
 r 

повторяется от
 n 

до
 m 

раз.
Если указано только одно число после запятой, то
 r 

повторяется, как минимум,
 n 

раз.
 
Интервальные выражения можно использовать, только если в командной строке
указана либо опция
 --posix ,

либо
 --re-interval .

 \y 

 
совпадает с пустой строкой либо в начале, либо в конце слова.
 \B 

 
совпадает с пустой строкой в слове.
 \< 

 
совпадает с пустой строкой в начале слова.
 \> 

 
совпадает с пустой строкой в конце слова.
 \w 

 
совпадает с любым текстовым символом (буква, цифра или подчеркивание).
 \W 

 
совпадает с любым нетекстовым символом.
 \` 

 
совпадает с пустой строкой в начале буфера (строки).
 \' 

 
совпадает с пустой строкой в конце буфера.
 
 

Все экранирующие последовательности, которые могут быть использованы
в строковых константах (см. ниже), могут употребляться и в регулярных
выражениях.
 

 Классы символов 

- новая возможность, введенная стандартом POSIX.
Класс символов - это специальная система обозначений списков символов,
имеющих особый признак. При этом символы списка в разных
странах и/или в разных наборах символов (кодировках) могут различаться.
Например, понятия символов алфавита различаются в США и во Франции.
 

Классы символов можно указывать в регулярных выражениях только
 внутри 

скобок, ограничивающих список символов.
Класс символов состоит из
 [: ,

ключевого слова, обозначающего класс, и
 :] .

Ниже приведены классы символов, определенные стандартом POSIX.
 
 [:alnum:] 

 
Текстовые символы (буквы, цифры, подчеркивание).
 [:alpha:] 

 
Алфавитные символы.
 [:blank:] 

 
Символы пробела или табуляции.
 [:cntrl:] 

 
Управляющие символы.
 [:digit:] 

 
Символы цифр.
 [:graph:] 

 
Символы одновременно и видимые, и печатаемые.
(Пробел печатаем, но не видим, в то время, как
 a 

- и то и другое.)
 [:lower:] 

 
Алфавитные символы нижнего регистра.
 [:print:] 

 
Печатаемые символы (не являющиеся управляющими).
 [:punct:] 

 
Знаки препинания (не буквы, не цифры, не управляющие символы и не пробел).
 [:space:] 

 
Символы пробела (такие, как пробел, табуляция, перевод формата).
 [:upper:] 

 
Алфавитные символы верхнего регистра.
 [:xdigit:] 

 
Символы, являющиеся шестнадцатеричными цифрами.
 
 

Например, до появления стандарта POSIX для совпадения текстовых символов
нужно было указать
 /[A-Za-z0-9]/ .

Если набор символов (кодировка) включал в себя другие символы, то совпадения
не происходило. С классами символов POSIX вы можете написать
 /[[:alnum:]]/ ,

это выражение совпадет со
 всеми 

алфавитными и цифровыми символами вашего набора символов (кодировки).
 

В списках символов могут быть указаны еще две дополнительные
последовательности. Они относятся к не-ASCII наборам символов, в которых
могут встречаться: символы (так называемые
 элементы сортировки ),

представленные более, чем одним символом;
эквивалентные, с точки зрения
 сортировки ,

символы.
(Например, во Франции, обычная ``e''
и акцентированная e` эквивалентны.)
 
 Символы сортировки 
Символы сортировки - это многосимвольные элементы сортировки,
заключенные между
 [. 

и
 .] .

Например, если
 ch 

- элемент сортировки, то
 [[.ch.]] 

- регулярное выражение, совпадающее с этим элементом сортировки, в то время,
как
 [ch] 

- регулярное выражение, совпадающее либо с
 c ,

либо с
 h .

 Классы эквивалентности 
Класс эквивалентности - это зависимое от локали (locale) имя для списка
символов, являющихся эквивалентными. Имя заключается между
 [= 

и
 =] .

Например, имя
 e 

может быть использовано для представления
``e,'' ``e`,'' и ``e`.''
В этом случае,
 [[=e]] 

- регулярное выражение, совпадающее с
 e ,

 e' ,

и
 e` .

 
 

Эти возможности очень ценны в не-английских локалях. Библиотечные функции,
используемые
 gawk 

для работы с регулярными выражениями, в данный момент распознают только
классы символов POSIX. Они не распознают символы сортировки и классы
эквивалентности.
 

Операторы
 \y ,

 \B ,

 \< ,

 \> ,

 \w ,

 \W ,

 \` 

и
 \' 

являются особенностью 
 gawk ,

а именно, его расширениями, основанными на
возможностях библиотек GNU для работы с регулярными выражениями.
 

Различные опции командной строки определяют, как
 gawk 

интерпретирует символы в регулярных выражениях.
 
 Без опций 
По умолчанию,
 gawk 

предоставляет все возможности регулярных выражений POSIX и операторов
GNU для регулярных выражений, как описано выше.  Не поддерживаются
лишь интервальные выражения.
 --posix 

 
Поддерживаются лишь регулярные выражения POSIX, операторы GNU не имеют
специального значения. (Например,
 \w 

соответствует букве
 w ).

Интервальные выражения разрешены.
 --traditional 

 
Используются традиционные регулярные выражения
Unix
 awk .

Операторы GNU не имеют специального значения, интервальные выражения не
поддерживаются, классы символов POSIX
( [[:alnum:]] 

и т. д.) не поддерживаются.
Символы, указанные с помощью восьмиричной или шестнадцатиричной
экранирующей последовательности, воспринимаются буквально, даже если они
представляют собой метасимволы регулярных выражений.
 --re-interval 

 
Позволяет использовать интервальные выражения, даже если указана опция
 --traditional .

 
   
 Действия 

Операторы действия заключаются в фигурные скобки
 { 

и
 } .

Операторы действия состоят из встречающихся во многих языках, 
операторов присваивания, ветвления, цикла. Операции, управляющие операторы
и операторы ввода/вывода похожи на подобные им из языка C.
   
 Операции 

 

В AWK определены следующие операции, в порядке убывания приоритета,
 

 
 ( ... ) 

 
Группирование
 $ 

 
Ссылка на поле.
 ++ -- 

 
Инкремент и декремент, оба могут быть префиксными и постфиксными.
 ^ 

 
Возведение в степень (можно также использовать  **  и  **=  с
оператором присваивания).
 + - ! 

 
Унарный плюс, унарный минус и логическое отрицание.
 * / % 

 
Умножение, деление и модуль.
 + - 

 
Сложение и вычитание.
 пробел 

 
Сцепление строк.
 
 
 < > 

 
 
 <= >= 

 
 
 != == 

Обычные операции сравнения.
 ~ !~ 

 
Совпадение и несовпадение регулярного выражения.
 ПРИМЕЧАНИЕ: 

Не используйте регулярное выражение-константу
( /foo/ )

слева от
 ~ 

или от
 !~ ,

только справа.
Выражение
 / foo /~ выражение 

имеет то же значение, что и  (($0 ~ / foo /) ~  выражение ) .
Обычно это
 не 

то, что предполагалось.
 in 

 
Существование в массиве.
 && 

 
Логическое И.
 || 

 
Логическое ИЛИ.
 ?: 

 
Условное выражение C. Оно имеет вид
 выражение1  ?  выражение2  :  выражение3 . Если
 выражение1 

является истиной, то результатом является
 выражение2 ,

в противном случае - 
 выражение3 .

Вычисляется либо
 выражение2 ,

либо
 выражение3 .

 
 
 = += -= 

 
 
 *= /= %= ^= 

Присваивание. Поддерживается как простое присваивание
 ( переменная = значение ) ,
так и сложные виды присваивания (операция-присваивание).
 
   
 Управляющие операторы 

 

Управляющими операторами являются:
 

 
 if ( условие )  оператор  [  else  оператор  ]
 while ( условие )  оператор 
 do  оператор  while ( условие ) 
 for ( выражение1 ;  выражение2 ;  выражение3 )  оператор 
 for ( переменная  in  массив )  оператор 
 break 
 continue 
 delete  массив [ индекс ] 
 delete  массив 
 exit  [  выражение  ]
 {  операторы  }
 

 

   
 Операторы ввода/вывода 

 

Операторами ввода/вывода являются:
 

 
 close( файл ) 

 
Закрыть файл (или канал, см. ниже).
 getline 

 
Считать следующую запись в
 $0 .

Установить
 NF ,

 NR ,

 FNR .

 getline < файл 

 
Считать следующую запись
 файла 

в
 $0 .

Установить
 NF .

 getline  переменная 

 
Считать следующую запись в
 переменную .

Установить
 NR ,

 FNR .

 getline  переменная  < файл 

 
Считать следующую запись
 файла 

в
 переменную .

 next 

 
Прекратить обработку текущей входной записи. Считать следующую входную
запись и начать ее обработку с первого шаблона программы AWK. Если
обработаны все входные данные, то выполнить блок(и)
 END ,

если таковые имеются.
 nextfile 

 
Прекратить обработку текущего входного файла. Следующая входная запись
будет прочитана из следующего входного файла.
 FILENAME 

и
 ARGIND 

обновляются,
 FNR 

присваивается 1, обработка начинается с первого шаблона программы AWK.
Если обработаны все входные данные, то выполнить блок(и)
 END ,

если таковые имеются.
 ПРИМЕЧАНИЕ: 

В ранних версиях gawk использовалась конструкция
 next file 

(в два слова). Хотя эта конструкция все еще распознается, выдается
предупреждающее сообщение. В конечном счете, она не будет поддерживаться.
 print 

 
Вывести текущую запись.
Запись оканчивается содержимым переменной
 ORS .

 print  список-выражений 

 
Вывести выражения.
Выражения разделяются содержимым переменной
 OFS .

Запись оканчивается содержимым переменной
 ORS .

 print  список-выражений  > файл 

 
Вывести выражения в
 файл .

Выражения разделяются содержимым переменной
 OFS .

Запись оканчивается содержимым переменной
 ORS .

 printf  формат, список-выражений 

 
Отформатировать и вывести.
 printf  формат, список-выражений  > файл 

 
Отформатировать и вывести в
 файл .

 system( командная-строка ) 

 
Выполнить команду, указанную в
 командной-строке ,

и вернуть код выхода из команды.
(Может не работать на не- POSIX  системах.)
 fflush( [ файл ] ) 
Сбросить буфера, связанные с открытым для записи файлом или каналом
 файл .

Если
 файл 

не указан, происходит сброс буферов стандартного потока вывода.
Если
 файл 

- пустая строка, то происходит сброс буферов всех открытых файлов и
каналов.
 
 

Разрешены и другие перенаправления ввода/вывода. Для
 print 

и
 printf ,

 >>  файл 

добавит выводимые данные в
 файл ,

а
 |  команда 

выведет данные в канал.
Подобным же образом,
 команда  | getline 

позволяет
 getline 

считывать данные из канала.
Команда
 getline 

возвращает 0 по достижении конца файла и -1 при ошибке.
   
 Оператор  printf 

 

AWK версии оператора
 printf 

и функции
 sprintf() 

(см. ниже)
воспринимают следующие форматы:
 
 %c 

 
 ASCII  символ.
Если аргумент
 %c 

является числом, то он интерпретируется как символ и выводится. В противном
случае, аргумент интерпретируется как строка,
и выводится только первый символ этой строки.
 
 
 %d 

 
 
 %i 

Десятичное число (целая часть).
 
 
 %e 

 
 
 %E 

Число с плавающей запятой в виде
 [-]d.dddddde[+-]dd .

Формат
 %E 

использует
 E 

вместо
 e .

 %f 

 
Число с плавающей запятой в виде
 [-]ddd.dddddd .

 
 
 %g 

 
 
 %G 

Использовать либо формат
 %e ,

либо формат
 %f ,

в зависимости от того, что короче. Незначащие нули не выводятся.
Формат
 %G 

испольует
 %E 

вместо
 %e .

 %o 

 
Беззнаковое восьмиричное число (целое).
 %s 

 
Строка символов.
 
 
 %x 

 
 
 %X 

Шестнадцатиричное число (целое).
Формат
 %X 

использует
 ABCDEF 

вместо
 abcdef .

 %% 

 
Один символ
 % .

Преобразование аргумента не производится.
 
 

Возможно указание дополнительных, необязательных параметров между символом
 % 

и буквой формата:
 
 - 

 
Выражение должно быть выравнено по левой границе поля.
 пробел 

 
Для числовых преобразований; выводить перед положительными значениями
пробел, перед отрицательными - знак минуса.
 + 

 
Знак плюса, указанный перед параметром ширины (см. ниже), предписывает
всегда выводить знак для числовых преобразований, даже если форматируемые
данные имеют положительное значение.
 + 

аннулирует параметр
 пробел .

 # 

 
Использовать ``альтернативный вид'' для некоторых форматов.
Для
 %o 

- вывести впереди ноль.
Для
 %x 

и
 %X 

- вывести впереди
 0x  

или
 0X ,

если результат отличен от нуля. 
Для
 %e ,

 %E 

и
 %f 

- результат всегда будет содержать десятичную запятую.
Для
 %g  

и
 %G 

- конечные нули не будут убраны из результата. 
 0 

 
Ведущий
 0 

(ноль) служит признаком того, что выводимое поле должно быть заполнено нулями, а не
пробелами. Это относится ко всем нечисловым форматам вывода. Признак
влияет, только если ширина поля превышает ширину выводимого значения.
 ширина 

 
Поле должно быть заполнено до этой ширины. Обычно поле заполняется
пробелами. Если указан параметр
 0 ,

то поле будет заполнено нулями. 
 . точность 

 
Число определяет точность вывода.
Для форматов
 %e ,

 %E 

и
 %f  

указывается количество цифр, выводимых справа от десятичной запятой.
Для форматов
 %g 

и
 %G 

указывается максимальное количество значащих цифр.
Для форматов
 %d ,

 %o ,

 %i ,

 %u ,

 %x 

и
 %X 

указывается минимальное количество выводимых цифр.
Для строки указывается максимальное количество выводимых символов
строки.
 
 

Поддерживаются динамическая
 ширина 

и
 точность 

функции
 printf() 

 ANSI  C.
Если вместо
 ширины 

или
 точности 

будет указана
 * ,

то их значения будут взяты из списка аргументов
 printf 

или
 sprintf() .

   
 Специальные имена файлов 

 

При перенаправлении ввода/вывода
 print  

и
 printf 

в файл
или
 getline 

из файла,
 gawk 

распознает некоторые специальные имена файлов. Эти имена могут
использоваться для доступа к дескрипторам открытых файлов, наследованных
от процесса, породившего
 gawk 

(обычно shell).
Другие специальные имена предоставляют доступ к информации о работающем
процессе
 gawk .

 
 /dev/pid 

 
Чтение этого файла возвращает идентификатор текущего процесса в десятичной
системе исчисления, с символом новой строки в конце.
 /dev/ppid 

 
Чтение этого файла возвращает идентификатор процесса, породившего текущий
процесс, в десятичной системе исчисления, с символом новой строки в конце.
 /dev/pgrpid 

 
Чтение этого файла возвращает идентификатор группы текущего процесса в
десятичной системе исчисления, с символом новой строки в конце.
 /dev/user 

 
Чтение этого файла возвращает одну запись, оканчивающуюся символом
новой строки. Поля разделены пробелами.
 $1 

- значение системного вызова
 getuid (2),

 $2 

- значение системного вызова
 geteuid (2),

 $3 

- значение системного вызова
 getgid (2),

и
 $4 

- значение системного вызова
 getegid (2).

Если имеются дополнительные поля, то они являются идентификаторами групп,
возвращенными
 getgroups (2).

Множественные группы не поддерживаются во всех системах.
 /dev/stdin 

 
Стандартный поток ввода.
 /dev/stdout 

 
Стандартный поток вывода.
 /dev/stderr 

 
Стандартный поток ошибок.
 /dev/fd/ n 

 
Файл, связанный с дескриптором открытого файла
 n .

 
 

Специальные имена файлов очень удобны для вывода сообщений об ошибках. Например:
 

 
 
print "You blew it!" > "/dev/stderr"
 
 

 

В противном случае, пришлось бы использовать
 

 
 
print "You blew it!" | "cat 1>&2"
 
 

 

Эти имена могут быть использованы в командной строке для указания файлов
данных.
   
 Числовые функции 

 

AWK имеет следующие встроенные арифметические функции:
 

 
 atan2( y ,  x ) 

 
возвращает арктангенс
 y/x 

в радианах.
 cos( выражение ) 

 
возвращает косинус
 выражения .

Выражение должно быть в радианах.
 exp( выражение ) 

 
экспоненциальная функция.
 int( выражение ) 

 
обрезает дробную часть.
truncates to integer.
 log( выражение ) 

 
функция натурального логарифма.
 rand() 

 
возращает случайное число между 0 и 1.
 sin( выражение ) 

 
возращет синус
 выражение .

Выражение должно быть в радианах.
 sqrt( выражение ) 

 
функция квадратного корня.
 srand( [ выражение ] ) 
устанавливает
 выражение 

как новую базу для генератора сучайных чисел. Если
 выражение 

не указано, то используется текущее время.
Возвращаемое значение равно предыдущей базе генератора случайных
чисел.
 
   
 Строковые функции 

 

 Gawk 

имеет следующие встроенные строковые функции:
 

 
 gensub( r ,  s ,  h  [ ,  t ] ) 
ищет в строке
 t 

совпадения с регулярным выражением
 r .

Если
 h 

является строкой, начинающейся с
 g 

или
 G ,

то заменяет все совпадения
 r 

на
 s .

В противном случае, 
 h 

является числом, указывающим, которое по счету совпадение
 r 

заменять.
Если
 t 

не указано, то используется
 $0 .

В тексте замены
 s 

последовательность
 \ n ,

где
 n 

- это цифра от 1 до 9, может быть использована для ссылки на текст
 n -ного,

заключенного в скобки, подвыражения. Последовательность
 \0 

ссылается на весь совпавший текст, как и символ
 & .

В отличие от
 sub() 

и
 gsub() ,

измененная строка возвращается как результат функции, а исходная
строка
 не 

изменяется. 
 gsub( r ,  s  [ ,  t ] ) 
каждую подстроку строки
 t ,

совпавшую с регулярным выражением
 r ,

заменяет на строку
 s 

и возвращает количество осуществленных замен.
Если
 t 

не указана, то используется
 $0 .

Вместо
 & 

в тексте замены подставляется совпавшая строка. 
Для вывода символа
 & 

используйте
 \& .

За полной информацией о правилах для
 & 

и \ в тексте замены в
 sub() ,

 gsub() 

и
 gensub() ,

обращайтесь к
 AWK Language Programming .

 index( s ,  t ) 

 
возвращает индекс строки
 t 

в строке
 s ,

или 0, если
 t 

не найдена.
 length( [ s ] ) 
возвращает длину строки
 s 

или, если
 s 

не указана, длину
 $0 .

 match( s ,  r ) 

 
возвращает позицию, с которой регулярное выражение
 r 

совпадает с
 s 

или, если
 r 

не совпадает, 0. Устанавливает значения
 RSTART 

и
 RLENGTH .

 split( s ,  a  [ ,  r ] ) 
разбивает строку
 s 

на основе регулярного выражения
 r ,

помещает результат в массив
 a 

и возвращает количество полей. Если
 r 

не указано, то используется
 FS .

Массив
 a 

предварительно очищается.
Функция работает подобно разбивке на поля, описанной выше.
 sprintf( fmt ,  expr-list ) 

 
выводит
 список-выражений 

в соответствии с
 форматом 

и возвращает получившуюся строку.
 sub( r ,  s  [ ,  t ] ) 
то же, что и
 gsub() ,

но заменяется только первая совпавшая подстрока.
 substr( s ,  i  [ ,  n ] ) 
возвращает
 n -символьную

подстроку строки
 s ,

начиная с
 i .

Если
 n 

не указано, то возвращается остаток строки
 s .

 tolower( строка ) 

 
возвращает копию
 строки ,

в которой все символы верхнего регистра, встречающиеся в
 строке ,

переведены в соответствующие им символы нижнего регистра.
Неалфавитные символы остаются без изменений.
 toupper( str ) 

 
возвращает копию
 строки ,

в которой все символы нижнего регистра, встречающиеся в
 строке ,

переведены в соответствующие им символы верхнего регистра.
Неалфавитные символы остаются без изменений.
 
   
 Функции для работы со временем 

 

Так как одно из основных применений программ AWK - обработка журнальных
(протокольных) файлов, содержащих отметки о времени,
 gawk 

предоставляет две функции для получения и форматирования меток времени.
 

 
 systime() 

 
возвращает текущее время в виде количества секунд с начала эпохи
(полночь UTC, 1 января 1970 г на системах  POSIX ).
 strftime( [ формат  [ ,  время ]] ) 
форматирует
 время 

в соответствии с указанным
 форматом. 

 Время 

должно быть в виде, возвращемом
 systime() .

Если
 время 

не указано, то использутеся текущее время.
Если не указан
 формат ,

то используется формат по умолчанию, эквивалентный выводу
 date (1).

Для гарантии правильности указываемых форматов обращайтесь
к руководствам по функции
 strftime() 

 ANSI  C. Свободно распространяемая версия
 strftime (3)

и руководство (man) к ней поставляются с
 gawk .

Эта версия была использована для сборки
 gawk ,

так что все форматы, описанные в руководстве, доступны в
 gawk. 

 
   
 Строковые константы 

 

Строковыми константами в AWK являются последовательности символов,
заключенные в двойные кавычки ( " ). В строках могут быть использованы
 экранирующие последовательности ,

соответствующие языку C. К ним относятся:
 

 
 \\ 

 
обратный слэш (backslash).
 \a 

 
символ ``предупреждение''. Обычно символ  ASCII   BEL .
 \b 

 
забой (backspace).
 \f 

 
перевод формата (form-feed).
 \n 

 
новая строка (newline).
 \r 

 
возрат каретки (carriage return).
 \t 

 
горизонтальная табуляци (horizontal tab).
 \v 

 
вертикальная табуляция (vertical tab).
 \x шестнадцатиричные цифры 

 
символ, соответствующий строке шестнадцатеричных цифр, следующих за
 \x .

Как и в  ANSI  C, все шестнадцатиричные цифры считаются частью экранирующей
последовательности.
(Эта возможность кое-что говорит нам о разработке языка комитетом.)
Например,  "\x1B"  является символом  ASCII   ESC 
(escape).
 \ ddd 

 
Символ, представленный 1-, 2- или 3-х цифровой последовательностью
восмиричных цифр. Например,  "\033"  является символом  ASCII 
 ESC  (escape).
 \ c 

 
Символ
 c .

 
 

Экранирующие последовательности также могут быть использованы в регулярных
выражениях-константах (например,
 /[ \t\f\n\r\v]/ 

совпадает с символами пустого места).
 

В режиме совместимости символы, представленные восмиричными или
шестнадцатиричными экранирующими последовательностями, в регулярных
выражениях-константах воспринимаются буквально. Поэтому 
 /a\52b/ 

соответствует
 /a\*b/ .

   
 ФУНКЦИИ 

Функции в AWK определяются следующим образом:
 

 
 function  имя ( список параметров ) {  операторы } 
 

 

Функции выполняются при вызове их из выражений шаблонов или действий.
Параметры, указанные при вызове функции используются для присваивания
значений объявленным в функции формальным параметрам. Массивы всегда
передаются по ссылке, остальные переменные - по значению.
 

Так как функции изначально отсутствовали в языке AWK, поддержка локальных
переменных оставляет желать лучшего - они объявляются как дополнительные
параметры в списке параметров. Принято отделять локальные переменные в
списке параметров от настоящих параметров дополнительными пробелами.
Например:
 

 
 
 function  f(p, q,     a, b)     # a & b - локальные переменные
{
        .....
}

/abc/   { ... ; f(1, 2) ; ... }
 


 

 

Левая скобка в вызове функции обязательно должна стоять сразу за именем
функции, без пробелов. Это требование введено для избежания неоднозначности
с операцией сцепления. Это ограничение не относится к встроенным функциям,
перечисленным выше.
 

Функции могут вызывать друг друга и сами себя. При вызове функций параметрам
функций, используемым как локальные переменные, присваивается
значение пустой строки и нуля.
 

Для возврата значения из функции используется
 return  выражение 

. Если возвращаемое значение не указано, то оно не определено. Оно также
не определено, если выход из функции производится по окончании тела функции. 
 

Если указана опция
 --lint ,

то
 gawk 

будет предупреждать о всех вызовах неопределенных функций не во время
работы программы, а заранее, во время предварительной обработки.
Вызов неопределенной функции во время работы программы - это непоправимая
ошибка.
 

Вместо слова
 function 

может быть использовано слово
 func .

   
 ПРИМЕРЫ 

 Вывести и отсортировать имена всех пользователей:

         BEGIN   { FS = ":" }
                { print $1 | "sort" }

 Подсчитать количество строк в файле:

                 { nlines++ }
        END     { print nlines }

 Вставить в файле перед каждой строкой ее номер:

         { print FNR, $0 }

 Вариация на ту же тему:

         { print NR, $0 }
 

   
 ССЫЛКИ 

 egrep (1),

 getpid (2),

 getppid (2),

 getpgrp (2),

 getuid (2),

 geteuid (2),

 getgid (2),

 getegid (2),

 getgroups (2)

 

 The AWK Programming Language ,

Alfred V. Aho, Brian W. Kernighan, Peter J. Weinberger,
Addison-Wesley, 1988. ISBN 0-201-07981-X.
 

 AWK Language Programming ,

Edition 1.0, published by the Free Software Foundation, 1995.
   
 СОВМЕСТИМОСТЬ С POSIX 

Основная цель
 gawk 

- совместимость как со стандартом  POSIX , так и с последними версиями
 awk 

для  UNIX .
Для этого
 gawk 

включает в себя следующие возможности, не описанные в книге, но
входящие в версию Bell Labs 
 awk 

и стандарт POSIX.
 

Введена новая опция
 -v 

для присваивания значений переменным до начала выполнения программы.
В книге сказано, что присваивание значений переменным, указанным в командной
строке, происходит перед открытием
 awk 

файла, что происходит после выполнения блока
 BEGIN .

Однако в ранних реализациях, если такое присваивание значений переменным
было указано до имен файлов, присваивание происходило 
 до 

выполнения блока
 BEGIN .

Эта ``возможность'' стала применяться в приложениях.
После того, как
 awk 

был приведен в соответствие с документацией, для удовлетворения нужд
приложений, зависимых от старого поведения, была добавлена эта опция.
(С введением этой возможности согласились как разработчики AT&T, так и GNU.)
 

Опция
 -W 

для реализации особенностей взята из стандарта  POSIX .
 

При обработке аргументов
 gawk 

использует специальную опцию `` -- '' для указания конца аргументов.
В режиме совместимости будет выдаваться предупреждение о существовании
неизвестных опций, но они будут игнорироваться.
В обычном режиме такие аргументы передаются для обработки программе AWK.
 

В соответствие с книгой по AWK, значение, возвращаемое
 srand() ,

не определено.
В стандарте  POSIX  возвращается предыдущее значение, что позволяет следить
за последовательностью случайных чисел. Поэтому
 srand() 

в
 gawk 

также возвращает значение текущей базы.
 

Другие новые возможности:
использование нескольких опций
 -f 

(из MKS
 awk );

массив
 ENVIRON ;

экранирующие последовательности
 \a 

и
 \v 

(изначально появившиеся в
 gawk 

и затем включенные в AT&T); функции
 tolower() 

и
 toupper() 

(из AT&T); параметры форматирования  ANSI  C
 printf 

(впервые появившиеся в версии AT&T').
   
 РАСШИРЕНИЯ GNU 

 Gawk 

имеет ряд расширений по сравнению с  POSIX 
 awk .

Они описаны в этом разделе. Все расширения, описанные здесь, могут быть
выключены запуском
 gawk 

с опцией
 --traditional .

 

Следующие опции
 gawk 

отсутствуют в  POSIX 
 awk .

 
 
 * 
Экранирующая последовательность
 \x .

(Отключается с
 --posix .)

 * 
Функция
 fflush() .

(Отключается с
 --posix .)

 * 
Функции
 systime(), 

 strftime() 

и
 gensub() .

 * 
Специальные имена файлов для перенаправления ввода/вывода не распознаются.
 * 
Переменные
 ARGIND ,

 ERRNO 

и
 RT 

не имеют специального значения.
 * 
Переменная
 IGNORECASE 

и ее эффекты отстутствуют.
 * 
Переменная
 FIELDWIDTHS 

и разделение на поля фиксированной ширины.
 * 
Использование
 RS 

как регулярного выражения.
 * 
Возможность разделения на отдельные символы путем присваивания
пустого значения переменной
 FS 

или третьему аргументу
 split() .

 * 
Не производится поиск по пути файлов, указанных через опцию
 -f .

Как следствие, переменная окружения
 AWKPATH 

не имеет специального значения.
 * 
Использование
 nextfile 

для прерывания обработки текущего входного файла.
 * 
Использование
 delete  array 

для удаления содержимого всего массива.
 
 

 

Книга по AWK не определяет значений, возвращаемых функцией
 close() .

Функция 
 close() 

 Gawk 

возвращает значение, которое вернула функция
 fclose (3)

или
 pclose (3)

при закрытии файла или канала соответственно.
 

Если при запуске
 gawk 

с опцией
 --traditional ,

аргумент
 fs 

опции
 -F 

имеет значение ``t'', то значением
 FS 

будет символ табуляции.
Заметьте, что
 gawk -F\t ... 

приведет лишь к экранированию символа ``t'', а не к передаче
``\t'' опции
 -F .

Так как это довольно специфический случай, то он не является поведением
по умолчанию. Он также не будет работать, если указана опция
 --posix .

Если вам действительно нужно использовать символ табуляции в качестве
разделителя полей, то лучше всего воспользоваться кавычками:
 gawk -F'\t' ... .


   
 ИСТОРИЧЕСКИЕ ВОЗМОЖНОСТИ 

 gawk 

Поддерживаются две возможности, существовавшие в ранних версиях AWK.
Во-первых, встроенная функция
 length() 

может быть вызвана не только без аргумента, но и скобок.
То есть,
 
 

 
a = length      # Holy Algol 60, Batman! 
 
 

 

является тем же самым, что и
 
 

 
a = length()
 

a = length($0)
 
 

 

Эта возможность ``осуждается'' в стандарте  POSIX , и
 gawk 

с опцией
 --lint 

будет выдавать об этом предупреждение.
 

Вторая возможность - это использование операторов
 continue 

и
 break 

вне тела циклов
 while ,

 for  

или
 do .

Традиционные реализации AWK воспринимали подобное использование
этих операторов как эквивалент оператору
 next .

 Gawk 

поддерживает такое использование, если указана опция
 --traditional .

   
 ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ 

Если в окружении существует переменная
 POSIXLY_CORRECT ,

то 
 gawk 

будет вести себя так, как если бы в командной строке была указана опция 
 --posix .

Если указана опция
 --lint ,

то
 gawk 

выдаст об этом предупреждающее сообщение.
 

Переменная окружения
 AWKPATH 

может быть использована для указания списка каталогов, в которых
 gawk 

будет искать файлы, указанные через опции
 -f 

и
 --file .

   
 ЗАМЕЧАНИЯ 

Опцию
 -F 

не обязательно указывать в командной строке. Она поддерживается лишь для
совместимости. 
 

Если ваша система имеет поддержку файлов
 /dev/fd , 

 /dev/stdin ,

 /dev/stdout 

и
 /dev/stderr ,

то вы можете получить от
 gawk 

несколько другие данные, нежели в системе без этих файлов. Если
непосредственно
 gawk 

обрабатывает эти файлы, то производится синхронизация вывода в стандартный
поток вывода с записью в
 /dev/stdout ,

в то время, как на системе с этими файлами вывод происходит в
другие файлы.
 

Короткие программы, содержащие синтаксические ошибки, имеют тенденцию
переполнять стек обработки, что приводит к выдаче мало помогающего
сообщения. В общем случае, на удивление сложно проводить диагностику
таких программ, и усилия, затраченные на это, обычно того не стоят.
   
 ИНФОРМАЦИЯ О ВЕРСИИ 

Это руководство описывает
 gawk 

версии 3.0.4.
   
 АВТОРЫ 

Исходная версия  UNIX 
 awk 

была разработана и реализована Альфредом Ахо (Alfred Aho), Петером 
Вейнбергером (Peter Weinberger) и Брайаном Керниганом (Brian Kernighan) в
AT&T Bell Labs. Брайан Керниган продолжает поддерживается и улучшать ее.
 

Пол Рубин (Paul Rubin) и Джей Фенласон (Jay Fenlason), Free Software
Foundation, написали
 gawk ,

совместимый с исходной версией
 awk ,

вошедшей в состав седьмой редакции  UNIX .
Джон Вудс (John Woods) исправил ряд ошибок.
Дэвид Трумэн (David Trueman), совместно с Арнольдом Роббинсом, сделал
 gawk 

совместимым с новой версией  UNIX 
 awk .

В данный момент поддержка осуществляется Арнольдом Роббинсом.
 

Первый перенос на DOS был сделан Конрадм Квоком (Conrad Kwok) и Скоттом
Гарфинклом (Scott Garfinkle).
Поддержка версии для DOS в текущее время осуществляется Скоттом Дэйфиком
(Scott Deifik). Пэт Рэнкин (Pat Rankin) перенес программу на VMS,
Майкл Джагермэнн (Michal Jaegermann) - на Atari ST. Перенос на OS/2 был
осуществлен Каем Уве Роммелем (Kai Uwe Rommel), совместно и с помощью
Даррела Ханкерсона (Darrel Hankerson). Фред Фиш (Fred Fish) предоставил
поддержку для Amiga.
   
 ПЕРЕВОД 

Перевод на русский язык осуществил Денис Дементьев < denm@asp-linux.com >,
SW Soft Pte, Ltd.
   
 СООБЩЕНИЯ ОБ ОШИБКАХ 

Если вы обнаружите ошибку в
 gawk ,

пожалуйста, вышлите электронной почтой сообщение на
 bug-gnu-utils@gnu.org ,

 с 

копией на 
 arnold@gnu.org .

Пожалуйста, укажите версию вашей операционной системы, версию
 gawk ,

какой вы использовали компилятор, а также тестовую программу и данные,
минимально возможного для выявления ошибки размера.
 

Перед тем, как выслать сообщение об ошибке, пожалуйста, сделайте две
вещи. Во-первых, удостоверьтесь, что у вас установлена последняя версия
 gawk .

Многие ошибки (обычно весьма тонкие) исправляются в каждой новой версии и,
возможно, ваша проблема уже решена. Во-вторых, пожалуйста, внимательно 
прочитайте это руководство, а также те, на которые в нем имеются ссылки,
чтобы быть уверенным в том, что это действительно ошибка, а не причуда
языка.
 

Чтобы вы не делали,
 НЕ 

посылайте сообщение об ошибке в
 comp.lang.awk .

Хотя разработчики
 gawk 

время от времени читают эту конференцию, отправка в нее сообщения об ошибке
- ненадежный способ. Вместо этого, сообщите о ней электронной почтой по
вышеуказанным адресам.
   
 БЛАГОДАРНОСТИ 

Брайан Керниган из Bell Labs предоставил ценную помощь во время
тестирования и отладки. Мы благодарим его.
   
 ПРАВА 

Copyright ©) 1996,97,98,99 Free Software Foundation, Inc.
 

Permission is granted to make and distribute verbatim copies of
this manual page provided the copyright notice and this permission
notice are preserved on all copies.

 

Permission is granted to copy and distribute modified versions of this
manual page under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
 

Permission is granted to copy and distribute translations of this
manual page into another language, under the above conditions for
modified versions, except that this permission notice may be stated in
a translation approved by the Foundation.
 
 
 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 ФОРМАТ ОПЦИЙ 
 ОПЦИИ 
 ИСПОЛНЕНИЕ ПРОГРАММЫ AWK 
 ПЕРЕМЕННЫЕ, ЗАПИСИ И ПОЛЯ 
 
 Записи 
 Поля 
 Встроенные переменные 
 Массивы 
 Типы переменных и их преобразование 
 
 ШАБЛОНЫ И ДЕЙСТВИЯ 
 
 Шаблоны 
 Регулярные выражения 
 Действия 
 Операции 
 Управляющие операторы 
 Операторы ввода/вывода 
 Оператор  printf 
 Специальные имена файлов 
 Числовые функции 
 Строковые функции 
 Функции для работы со временем 
 Строковые константы 
 
 ФУНКЦИИ 
 ПРИМЕРЫ 
 ССЫЛКИ 
 СОВМЕСТИМОСТЬ С POSIX 
 РАСШИРЕНИЯ GNU 
 ИСТОРИЧЕСКИЕ ВОЗМОЖНОСТИ 
 ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ 
 ЗАМЕЧАНИЯ 
 ИНФОРМАЦИЯ О ВЕРСИИ 
 АВТОРЫ 
 ПЕРЕВОД 
 СООБЩЕНИЯ ОБ ОШИБКАХ 
 БЛАГОДАРНОСТИ 
 ПРАВА 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename