#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 getrlimit (2)   getrlimit  (2)   ( Solaris man: Системные вызовы )   getrlimit  (2)   ( FreeBSD man: Системные вызовы ) >>  getrlimit  (2)   ( Русские man: Системные вызовы )   getrlimit  (2)   ( Linux man: Системные вызовы )   getrlimit  (3)   ( POSIX man: Библиотечные вызовы ) 
   
 НАЗВАНИЕ 

getrlimit, getrusage, setrlimit - считывает/устанавливает ограничения 
использования ресурсов
   
 СИНТАКСИС 

 #include < sys/time.h > 

 

 #include < sys/resource.h > 

 

 #include < unistd.h > 

 
 int getrlimit(int  resource , struct rlimit * rlim ); 

 

 int getrusage(int  who , struct rusage * usage ); 

 

 int setrlimit(int  resource , const struct rlimit * rlim ); 

   
 ОПИСАНИЕ 

 getrlimit 

и
 setrlimit 

соответственно получают и устанавливают ограничения использования ресурсов.  
Каждый ресурс имеет ассоциированное с ним мягкое и жесткое ограничение,
определяемое структурой
 rlimit 

(аргумент
 rlim 

и для
 getrlimit () и для  setrlimit ()):

 


 struct rlimit {
    rlim_t rlim_cur;   /* мягкое ограничение */
    rlim_t rlim_max;   /* жесткое ограничение 
                         (потолок для rlim_cur) */
};

 


Мягким ограничением является значение, принудительно устанавливаемое
ядром для соответствующего ресурса.
Жесткое ограничение работает как потолочное значение для мягкой границы:
непривилегированные процессы могут определять только свои мягкие лимиты
в диапазоне от 0 до жесткой границы, то есть однозначно меньше жесткого
ограничения. Привилегированные процессы могут принимать любые значения
в любых пределах.
 

Значение
 RLIM_INFINITY 

определяет отсутствие ограничений для ресурса (в обоих структурах,
возвращаемых от
 getrlimit ()

и в структуре, передаваемой в
 setrlimit ()).

 

Значение
 resource 

должно быть одним из:
 
 RLIMIT_CPU 

 
Системное время в секундах.
Когда процесс достигает своего мягкого лимита, то ему отправляется сигнал
 SIGXCPU .

Действием по умолчанию для этого сигнала является снятие и уничтожение процесса.
Однако, этот сигнал может быть отловлен и обработчик может передать управление
в основную программу.
Если процесс продолжает потреблять процессорное время, то ему будет
отправляться
 SIGXCPU 

раз в секунду до тех пор, пока не будет достигнут жесткий предел, и тогда
процессу отправится сигнал
 SIGKILL .

(Последний пункт описывает поведение Linux 2.2 и 2.4.
Разные реализации по своему разбираются с процессами,
пожирающими процессорное время после прохождения мягкого лимита.
Портируемые приложения, где требуется отлов сигнала, должны выполнять
явное указание на уничтожение после первого получения
 SIGXCPU .)

 RLIMIT_DATA 

 
Максимальный размер сегмента данных процесса (инициализированные
данные, время инициализации, кучу).
Этот лимит влияет на вызов
 brk () и  sbrk (),

которые выдадут ошибку
 ENOMEM 

по достижению мягкого лимита для этого ресурса.
 RLIMIT_FSIZE 

 
Максимальный размер файла, создаваемого процессом. Попытки расширить
файл сверх этого предела приведет к доставке сигнала
 SIGXFSZ .

По умолчанию этот сигнал уничтожает процесс, но процесс может поймать
этот сигнал и в этом случае связанный системный вызов (например,
 write (),  truncate ())

выдаст ошибку
 EFBIG .

 RLIMIT_LOCKS 

 
Ограничение на общее число блокировок
 flock ()

и аренд
 fcntl (),

устанавливаемое процессом
(в Linux 2.4 и далее).

 RLIMIT_MEMLOCK 

 
Максимальный объем заблокированного адресного пространства
Максимальное число байтов виртуальной памяти, блокированное
в ОЗУ, используя
 mlock () и  mlockall ().

 RLIMIT_NOFILE 

 
Определяет значение, на 1 больше максимального количества описателей
файлов, возможных для открытыя этим процессом.
Попытки исполнить
( open (),  pipe (),  dup (), и т.п.)

для превышения этого лимита приведут к ошибке.
 EMFILE .

 RLIMIT_NPROC 

 
Максимальное количество процессов, создаваемых для действительного
идентификаторв вызывающего процесса.
При достежиении этого лимита
 fork ()

начнет выдавать ошибку
 EAGAIN .

 RLIMIT_RSS 

 
Максимальное ограничение (в страницах) для rss (числа виртуальных
страниц в ОЗУ). Это ограничение имеет влияние только начиная 
с версии Linux 2.4, при этом только вызовы
 madvise ()

определяют 
 MADVISE_WILLNEED .

 RLIMIT_STACK 

 
Максимальный размер стека процесса в байтах.
При достижении этого лимита отправляется сигнал
 SIGSEGV .

Для обработки этого сигнала процесс должен иметь альтернативный стек сигналов
( sigaltstack (2)).

 
 

 RLIMIT_OFILE 

является названием BSD для
 RLIMIT_NOFILE .

 

 getrusage 

возвращает текущие ограничения на ресурсы для  who ,
который может быть или
 RUSAGE_SELF 

или 
 RUSAGE_CHILDREN. 

Первое запрашивает информацию о ресурсах используемых текущим процессом,
а второе о тех порожденных процессах, которые завершились или завершение
которых ожидается.
 


 struct rusage {
        struct timeval ru_utime;        /* время работы пользователя */
        struct timeval ru_stime;        /* использованное системное время */
        long    ru_maxrss;              /* максимальный rss */
        long    ru_ixrss;               /* общий объем разделяемой памяти */
        long    ru_idrss;               /* общий объем неразделяемых данных */
        long    ru_isrss;               /* общий объем неразделяемых стеков */
        long    ru_minflt;              /* количество процессов подгрузки страницы */
        long    ru_majflt;              /* количество ошибок при обращении к странице */
        long    ru_nswap;               /* количество обращений к диску при подкачке */
        long    ru_inblock;             /* количество операций блокового ввода */
        long    ru_oublock;             /* количество операций блокового вывода */
        long    ru_msgsnd;              /* количество отправленных сообщений */
        long    ru_msgrcv;              /* количество принятых сообщений */
        long    ru_nsignals;            /* количество принятых сигналов */
        long    ru_nvcsw;               /* количество переключений контекста процессом */
        long    ru_nivcsw;              /* количество принудительных переключений контекста */
};
 


   
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 

При нормальном завершении вызова возвращается ноль.
При ошибке возвращается -1, а переменной
 errno 

присваиваются соответствующие значения.
   
 НАЙДЕННЫЕ ОШИБКИ 

 
 EFAULT 

 
 rlim 

или
 usage 

указывают на недоступную область адресного пространства.
 EINVAL 

 
 getrlimit  или  setrlimit 

вызывается неправильным  resource , или
 getrusage  вызывается неправильным  who .
 EPERM 

 
производится попытка использования  setrlimit()  для установки
мягких (advisory) или жестких (mandatory) ограничений поверх текущих
жестких при отсутствии прав суперпользователя, или суперпользователь
пытается установить значение RLIMIT_NOFILE больше текущего максимума ядра.
 
   
 СООТВЕТСТВИЕ СТАНДАРТАМ 

SVr4, BSD 4.3
   
 ЗАМЕЧАНИЯ 

Подключение
 < sys/time.h > 

сейчас уже не требуется, но улучшает портируемость.
(В самом деле,
 struct timeval 

определяется в
 < sys/time.h > .)

 

В Linux, если
 SIGCHLD 

установлено в
 SIG_IGN 

то используемые ресурсы подпроцессов автоматически включаются
в значения, возвращаемое от
 RUSAGE_CHILDREN ,

хотя в POSIX 1003.1-2001 это явно запрещается.


 

Описанная выше структура была взята из BSD 4.3 Reno.
Не все поля имеют значения в Linux.
Сейчас (в Linux 2.4) поддерживаются только поля
 ru_utime ,

 ru_stime ,

 ru_minflt ,

 ru_majflt ,

 ru_nswap .

 
   
 СМ. ТАКЖЕ 

 dup (2),

 fcntl (2),

 fork (2),

 mlock (2),

 mlockall (2),

 mmap (2),

 open (2),

 quotactl (2),

 sbrk (2),

 wait3 (2),

 wait4 (2),

 malloc (3),

 ulimit (3),

 signal (7)

 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 СООТВЕТСТВИЕ СТАНДАРТАМ 
 ЗАМЕЧАНИЯ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename