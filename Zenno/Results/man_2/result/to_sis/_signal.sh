#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 signal (2) >>  signal  (2)   ( Русские man: Системные вызовы )   signal  (2)   ( Linux man: Системные вызовы )   signal  (3)   ( Solaris man: Библиотечные вызовы )   signal  (3)   ( FreeBSD man: Библиотечные вызовы )   signal  (3)   ( POSIX man: Библиотечные вызовы )   signal  (7)   ( Русские man: Макропакеты и соглашения )   signal  (7)   ( Linux man: Макропакеты и соглашения )   signal  (9)   ( FreeBSD man: Ядро ) Ключ  signal  обнаружен в базе ключевых слов. 
   
 НАЗВАНИЕ 

signal - работа с сигналами ANSI C
   
 СИНТАКСИС 

 #include < signal.h > 

 
 typedef void (*sighandler_t)(int); 

 
 sighandler_t signal(int  signum , sighandler_t  handler ); 

 
   
 ОПИСАНИЕ 

Системный вызов
 signal ()

устанавливает новый обработчик сигнала с номером
 signum 

в соответствии с параметром
 sighandler ,

который может быть функцией пользователя,
 SIG_IGN 

или
 SIG_DFL .

При получении процессом сигнала с номером
 signum 

происходит следующее:
если устанавливаемое значение обработчика равно
 SIG_IGN ,

то сигнал игнорируется;
если оно равно
 SIG_DFL ,

то выполняются стандартные действия, связанные с сигналом (см.
 signal (7)).

Наконец, если обработчик установлен в функцию
 sighandler ,

то сначала устанавливает значение обработчика в SIG_DFL
или выполняется зависимая от реализации блокировка сигнала,
а затем вызывается функция
 sighandler 

с параметром
 signum .

 
Использование функции-обработчика сигнала называется
"перехватом сигнала".
Сигналы
 SIGKILL 

и
 SIGSTOP 

не могут быть "перехвачены" или игнорированы.
   
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 

Функция
 signal ()

возвращает предыдущее значение обработчика сигнала или
 SIG_ERR 

при ошибке.
   
 ПОРТИРУЕМОСТЬ 

Стандартная функция
 signal ()

в UNIX устанавливает значение обработчика равным SIG_DFL;  
System V (а также ядро Linux и libc4,5) выполняют то же самое.
С другой стороны, BSD не перезагружает обработчик, а блокирует
новые сигналы на время вызова обработчика.
Библиотека glibc2 следует поведению BSD.
В системе libc5 включение
 < bsd/signal.h > 

вместо
 < signal.h > ,

приводит к переопределению
 signal 

в
 __bsd_signal ,

и эта функция начинает работать, как в BSD. Но это нежелательно.
 
В системе glibc2 при определении тестового макроса типа
 _XOPEN_SOURCE 

или при использовании отдельной функции
 sysv_signal 

поведение функции будет стандартным. Это тоже нежалательно.
Попытаться изменить семантику этой функции при помощи
определений и включений - не очень хорошая идея.
Лучше избегать использования функции
 signal 

вообще, и использовать вместо нее
 sigaction (2).

   
 ЗАМЕЧАНИЯ 

Согласно POSIX, поведение процесса после игнорирования сигналов
 SIGFPE ,

 SIGILL 

или
 SIGSEGV ,

не созданных при помощи функций 
 kill (2)

или 
 raise (3),

не определено.
Деление на ноль имеет непредсказуемый характер.
На некоторых машинах это приведет к получению сигнала
 SIGFPE .

Более того, деление самого большого по модулю
отрицательного числа на -1 приведет к появлению 
 SIGFPE .

Игнорирование этого сигнала может привести к появлению бесконечнного цикла.
 

POSIX (3.3.1.3) не определяет, что случается при
 SIGCHLD ,

установленном в
 SIG_IGN .

Поведение BSD и SYSV в этом случае различно. Это приводит к тому,
что BSD-программы, устанавливающие поведение 
 SIGCHLD 

равным
 SIG_IGN ,

в Linux не работают.
 

Использование
 sighandler_t 

является расширением GNU.
Разные версии libc определяют этот тип; libc4 и libc5 определяют
 SignalHandler ,

glibc определяет
 sig_t 

и
 _GNU_SOURCE ,

а также
 sighandler_t .

   
 СООТВЕТСТВИЕ СТАНДАРТАМ 

ANSI C
   
 СМ. ТАКЖЕ 

 kill (1),

 kill (2),

 killpg (2),

 pause (2),

 raise (3),

 sigaction (2),

 signal (7),

 sigsetops (3),

 sigvec (2),

 alarm (2)

 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
 ПОРТИРУЕМОСТЬ 
 ЗАМЕЧАНИЯ 
 СООТВЕТСТВИЕ СТАНДАРТАМ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename