#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 select (2)   select  (1)   ( Solaris man: Команды и прикладные программы пользовательского уровня )   select  (2)   ( FreeBSD man: Системные вызовы ) >>  select  (2)   ( Русские man: Системные вызовы )   select  (2)   ( Linux man: Системные вызовы )   select  (3)   ( Solaris man: Библиотечные вызовы )   select  (3)   ( POSIX man: Библиотечные вызовы )   select  (7)   ( Linux man: Макропакеты и соглашения ) Ключ  select  обнаружен в базе ключевых слов. 
   
 НАЗВАНИЕ 

select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - многопоточный синхронный ввод-вывод
   
 СИНТАКСИС 

/* В соответствие с POSIX 1003.1-2001 */
 

 #include < sys/select.h > 

 
/* В соответствие с более ранними стандартами */
 

 #include < sys/time.h > 

 

 #include < sys/types.h > 

 

 #include < unistd.h > 

 
 int select(int  n , fd_set * readfds ,
fd_set * writefds , fd_set * exceptfds ,
struct timeval * timeout ); 
 
 int pselect(int  n , fd_set * readfds ,
fd_set * writefds , fd_set * exceptfds ,
const struct timespec * timeout , const sigset_t *  sigmask ); 
 
 FD_CLR(int  fd , fd_set * set ); 

 

 FD_ISSET(int  fd , fd_set * set ); 

 

 FD_SET(int  fd , fd_set * set ); 

 

 FD_ZERO(fd_set * set ); 


   
 ОПИСАНИЕ 

Функции
 select 

и
 pselect 

ждут изменения статуса нескольких файловых описателей.
 

Эти функции идентичны, за исключением 3-х отличий между ними:
 
 (1) 
Функция
 select 

использует время ожидания, которое задано в структуре
 struct timeval 

(с секундами и микросекундами), тогда как
 pselect 

использует
 struct timespec 

(с секундами и наносекундами).
 (2) 
Функция
 select 

может обновить параметр
 timeout ,

который показывает сколько времени прошло.
Функция
 pselect 

не изменяет этот параметр.
 (3) 
Функция
 select 

не имеет параметра
 sigmask ,

и т.о. ведет себя также как функция
 pselect 

вызванная с этим параметром, установленным в NULL.
 
 

Отслеживаются 3 независимых набора описателей.
Те, что перечислены в
 readfds ,

будут отслеживаться для того, чтобы обнаружить появление символов,
доступных для чтения (говоря более точно, чтобы узнать, не будет ли
блокировано чтение; описатель файла также будет указывать
на конец файла);
те описатели, которые указаны в
 writefds ,

будут отслеживаться для того, чтобы узнать, не заблокирован ли процесс записи;
те же, что указаны в параметре
 exceptfds ,

будут отслеживаться для обнаружения исключительных ситуаций. При возврате
из функции наборы описателей модифицируются, чтобы показать, какие описатели
фактически изменили свой статус.
 

Для манипуляций наборами существуют четыре макроса:
 FD_ZERO ,

очищающий набор;
 FD_SET 

и
 FD_CLR 

добавляют заданный описатель к набору или удаляют его из набора;
 FD_ISSET 

проверяет, является ли описатель частью набора; этот макрос полезен
после возврата из функции
 select .

 

 n 

на единицу больше самого большого номера описателей из всех наборов.
 

 timeout  -

это верхняя граница времени, которое пройдет перед возвратом из
 select .

Можно использовать нулевое значение, и при этом
 select 

завершится немедленно. Если
 timeout 

равен NULL (нет времени ожидания), то
 select 

будет ожидать изменений неопределенное время.
 

 sigmask 

- это указатель на маску сигнала (см.
 sigprocmask (2));

если он не равняется NULL, то
 pselect 

сначала заменяет текущую маску сигнала на ту, на которую указывает
 sigmask ,

затем вызывается функция "select" и после этого восстанавливается
оригинальная маска.
   
 Время ожидания 

Используемые структуры времени определены в
 < sys/time.h > 

и выглядят следующим как
 
 
 struct timeval { 
    long    tv_sec;         /* seconds */
    long    tv_usec;        /* microseconds */
};
 

 

 
и
 
 
 struct timespec {
    long    tv_sec;         /* seconds */
    long    tv_nsec;        /* nanoseconds */
};
 

 

 
(Однако, смотри ниже на версии POSIX 1003.1-2001.)
 

Иногда
 select 

вызывается с пустыми наборами (всеми тремя),
 n 

равным нулю и непустым
 timeout 

для переносимой реализации (portable) перехода в режим ожидания (sleep)
на периоды с точностью более секунды.
 

В Linux функция
 select 

изменяет
 timeout 

для отражения времени, проведенного не в режиме ожидания; большая часть
других реализаций этого не делают. Это вызывает проблемы как при
переносе кода Linux, читающего
 timeout ,

на другие операционные системы, так и при переносе на Linux кода,
использующего struct timeval для многократного вызова
 select 

в цикле без его переинициализации. Во избежание этого следует считать, что
 timeout 

не определен после возврата из
 select .



   
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 

При успешном завершении
 select 

и 
 pselect 

возвращают количество описателей, находящихся в наборах, 
причем это количество может быть равным нулю, если
время ожидания на исходе, а интересующие нас события так и не произошли.
При ошибке возвращаемое значение равно -1, а переменной
 errno 

присваивается номер ошибки; наборы описателей и значение
 timeout 

становятся неопределенными, поэтому при ошибке нельзя полагаться на их
значение.
   
 НАЙДЕННЫЕ ОШИБКИ 

 
 EBADF 

 
В одном из наборов находится неверный файловый описатель.
 EINTR 

 
Был получен незаблокированный сигнал.
 EINVAL 

 
 n 

отрицательно или значение, содержащееся внутри
 timeout ,

некорректно.
 ENOMEM 

 
Функция
 select 

не может выделить объем памяти для внутренних таблиц.
 
   
 ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ 

 #include < stdio.h >
#include < sys/time.h >
#include < sys/types.h >
#include < unistd.h >
int 
main(void) {
    fd_set rfds;
    struct timeval tv;
    int retval;
    /* Ждем, пока на стандартном вводе (fd 0) что-нибудь
       появится. */
    FD_ZERO(&rfds);
    FD_SET(0, &rfds);
    /* Ждем не больше пяти секунд. */
    tv.tv_sec = 5;
    tv.tv_usec = 0;
    retval = select(1, &rfds, NULL, NULL, &tv);
    /* Не полагаемся на значение tv! */
    if (retval)
        printf("Данные доступны.\n");
        /* Теперь FD_ISSET(0, &rfds) вернет истинное значение. */
    else
        printf("Данные не появились в течение пяти секунд.\n");
    return 0;
}
 

   
 СООТВЕТСТВИЕ СТАНДАРТАМ 

4.4BSD (функция
 select 

впервые появилась в 4.2BSD).  Обычно переносится с не-BSD систем и на них,
если они поддерживают уровень BSD-сокетов (включая варианты System V).
Однако, заметим, что варианты System V обычно устанавливают значение
переменной timeout перед выходом, а вариант BSD - нет.
Функция
 pselect 

определена в стандарте IEEE Std 1003.1g-2000 (POSIX.1g) и в POSIX 1004.1-2001.
Она находится в библиотеке glibc2.1 и более свежих версиях.
Glibc2.0 имеет функцию с таким же именем, которая не принимает параметр
 sigmask .

   
 ЗАМЕЧАНИЯ 

fd_set является буфером фиксированного размера.
Исполнение FD_CLR или FD_SET со значением
 fd  

отрицательным, равным или большим чем FD_SETSIZE приведет к неопределенному
поведению. Более того, POSIX требует от
 fd  

быть корректным описателем файлов.
  
Относительно задействованных типов тут классическая ситуация с двумя
полями структуры timeval (как показано ниже), а структура определяется в
 < sys/time.h > .

Ситуация с POSIX 1003.1-2001 :
  
 
 struct timeval { 
    time_t         tv_sec;     /* секунды */ 
    suseconds_t    tv_usec;    /* микросекунды */ 
}; 
 

 

  
Структура определена в 
 < sys/select.h > ,

а типы данных time_t и suseconds_t определены в
 < sys/types.h > .

 

         
В соответствие с прототипами, в классическом случае для использования
 select 

необходимо включать
 < time.h > .

В случае POSIX 1003.1-2001 для использования
 select 

и
 pselect 

необходимо включать
 < sys/select.h > .

Libc4 и libc5 не имеют файла заголовков
 < sys/select.h > ;

в glibc 2.0 и более поздних версиях он имеется.
В glibc 2.0 прототип
 pselect 

ошибочно определен всегда, в glibc 2.1-2.2.1 прототип
 pselect 

определен только когда определено
 _GNU_SOURCE ,

в glibc 2.2.2-2.2.4 прототип определен когда определено
 _XOPEN_SOURCE 

и его значение равно 600 или более.
Несомненно, начиная с POSIX 1003.1-2001, этот прототип включен по умолчанию.
   
 СМ. ТАКЖЕ 

Обучение использованию этих функций с примерами приведено в
 select_tut (2).

 

Неявно связанные темы описаны в
 accept (2),

 connect (2),

 poll (2),

 read (2),

 recv (2),

 send (2),

 sigprocmask (2),

 write (2)

 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 
 Время ожидания 
 
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ 
 СООТВЕТСТВИЕ СТАНДАРТАМ 
 ЗАМЕЧАНИЯ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename