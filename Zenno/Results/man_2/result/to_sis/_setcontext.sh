#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 setcontext (2)   setcontext  (2)   ( Solaris man: Системные вызовы ) >>  setcontext  (2)   ( Русские man: Системные вызовы )   setcontext  (2)   ( Linux man: Системные вызовы )   setcontext  (3)   ( FreeBSD man: Библиотечные вызовы )   setcontext  (3)   ( POSIX man: Библиотечные вызовы ) 
   
 ИМЯ 

getcontext, setcontext - получить или установить пользовательский контекст
   
 ОБЗОР 

 #include < ucontext.h > 

 
 int getcontext(ucontext_t * ucp ); 

 

 int setcontext(const ucontext_t * ucp ); 

   
 ОПИСАНИЕ 

В окружение подобном SysV, существует два типа данных
 mcontext_t  и  ucontext_t , которые определены в файле
 < ucontext.h > 

и четыре функции
 getcontext() ,  setcontext() ,  makecontext() 
и  swapcontext() ,
которые позволяют контексту пользовательского уровня переключаться
между несколькими нитями (тредами) внутри одного процесса.
 

Тип  mcontext_t  является машинно-зависимым и примитивным типом данных.
Тип  ucontext_t  является структурой, которая по крайней мере имеет
следующие поля:
 
 typedef struct ucontext {
        struct ucontext *uc_link;
        sigset_t uc_sigmask;
        stack_t uc_stack;
        mcontext_t uc_mcontext;
        ...
} ucontext_t;
 

 

где  sigset_t  и  stack_t  определены в файле
 < signal.h > .

В этой структуре,  uc_link  указывает на контекст, к которому будет
осуществлён переход, когда завершается текущий контекст (в случае,
если текущий контекст был создан с помощью  makecontext() ),
 uc_sigmask  является списком сигналов, которые блокируются в
этом контексте (см.
 sigprocmask (2)),

 uc_stack  - это стек, который используется этим котекстом (см.
 sigaltstack (2))

и  uc_mcontext  является
машинно-специфическим представлением сохранённого контекста,
который включает регистры вызываемой нити.
 

Функция  getcontext()  инициализирует вышеописанную структуру,
указывая через  ucp  на текущий активный контекст.
 

Функция  setcontext()  восстанавливает пользовательский контекст,
на который указывает  ucp . Успешный вызов не возвращает ничего.
Контекст должен быть получен с помощью вызова  getcontext() 
или  makecontext() , или передан как третий аргумент обработчика
сигнала.
 

Если контекст был получен через вызов  getcontext() ,
выполнение программы продолжается как если бы этот вызов завершился
простым возвратом.
 

Если контекст был получен через вызов  makecontext() ,
выполнение программы продолжается с помощью вызова функции
 func , которая задаётся как второй аргумент вызова
 makecontext() . Когда происходит возврат из функции
 func , выполнение продолжается с поля
 uc_link  структуры  ucp , которая задаётся как
первый аргумент вызова  makecontext() .
Если это поле равно NULL, осуществляется выход из нити.
 

Если контекст был получен с помощью вызова обработчика сигнала,
то старый текст стандарта говорит, что "выполнение программы
продолжается с инструкции программы, которая следует за
инструкцией, прерванной сигналом". Однако, этот текст
был удален в SUSv2 в вердиктом "результат неопределён".
   
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ 

В случае успеха,  getcontext()  возвращает 0, а  setcontext() 
не возвращает ничего. В случае ошибки, возвращается -1 и значение
 errno  устанавливается соответствующим образом.
   
 ОШИБКИ 

Не определены.
   
 ЗАМЕЧАНИЯ 

В ранних версиях этого механизма использовался механизм
 setjmp() / longjmp() . В нём не было
определено управление контекстом сигнала, что было решено
в следущем варианте парой  sigsetjmp() / siglongjmp() .
Текущий механизм даёт много больше контроля. С другой стороны,
не существует лёгкого способа определить какое из двух
значений возвращает при первом запуске вызов  getcontext()  
или вызов  setcontext() . Пользователь имеет должен
придумать собственный способ и регистровую переменную,
которая должна сохраняется когда восстанавливаются значения
регистров.
 

Если возникнет сигнал, текущий пользовательский контекст
сохраняется и для обработчика сигнала ядром создаётся новый
контекст. Не выходите из этого обработчика, используя
 longjmp()  - неизвестно, что может случиться с контекстами.
Вместо этого используйте вызовы  siglongjmp()  или
 setcontext() .
   
 СООТВЕТСТВИЕ СТАНДАРТАМ 

SUSv2
   
 СМОТРИ ТАКЖЕ 

 sigaction (2),

 sigaltstack (2),

 sigprocmask (2),

 longjmp (3),

 sigsetjmp (3),

 makecontext (3)

   
 ПЕРЕВОД 

Перевёл с английского Виктор Вислобоков < corochoone@perm.ru > 2005
 
 

 
   Index 
 
 ИМЯ 
 ОБЗОР 
 ОПИСАНИЕ 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ 
 ОШИБКИ 
 ЗАМЕЧАНИЯ 
 СООТВЕТСТВИЕ СТАНДАРТАМ 
 СМОТРИ ТАКЖЕ 
 ПЕРЕВОД 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename