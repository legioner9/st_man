#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 sched_getscheduler (2)   sched_getscheduler  (2)   ( FreeBSD man: Системные вызовы ) >>  sched_getscheduler  (2)   ( Русские man: Системные вызовы )   sched_getscheduler  (2)   ( Linux man: Системные вызовы )   sched_getscheduler  (3)   ( Solaris man: Библиотечные вызовы )   sched_getscheduler  (3)   ( POSIX man: Библиотечные вызовы ) 
   
 НАЗВАНИЕ 

sched_setscheduler, sched_getscheduler - устанавливает или получает
алгоритм планировщика (и его параметры)
   
 СИНТАКСИС 

 #include < sched.h > 

 
 int sched_setscheduler(pid_t  pid , int  policy , 

 const struct sched_param * p ); 

 
 int sched_getscheduler(pid_t  pid ); 

 
 
 struct sched_param {
    ...
    int  sched_priority ;
    ...
};

 

   
 ОПИСАНИЕ 

 sched_setscheduler 

устанавливает алгоритм и параметры планирования процесса с номером
 pid . Если  pid  равен нулю, то будет задан алгоритм вызывающего
процесса. Тип и значение аргумента  p  зависят от алгоритма
планирования. В настоящее время в Linux поддерживаются следующие виды
планирования:
 SCHED_FIFO ,

 SCHED_RR ,

и 
 SCHED_OTHER ;

их работа описана ниже.
 sched_getscheduler 

получает алгоритм диспетчеризации процесса с номером  pid .
Если  pid  равен нулю, то возвращается алгоритм планирования
вызывающего процесса.
 
   
 Алгоритмы диспетчеризации 

Диспетчер - это часть ядра, отвечающая за распределение процессорного
времени между процессами. Диспетчер ядра предоставляет процессам три
алгоритма планировщика: один для обычных процессов и два для
процессов реального времени. Каждому процессу присваивается статический
приоритет  sched_priority , который можно изменить только при помощи
системных вызовов. В принципе, диспетчер хранит в памяти
списки всех работающих процессов для каждого возможного значения
 sched_priority , а это значение может находиться в интервале от
0 до 99. Для того, чтобы определить, какой процесс будет работать
следующим, диспетчер Linux ищет непустой список с наибольшим статическим
приоритетом и запускает первый процесс из этого списка. Алгоритм планирования
определяет, как процесс будет добавлен в список с тем же
статическим приоритетом и как он будет перемещаться внутри этого списка.
 SCHED_OTHER  - это используемый по умолчанию алгоритм со стандартным
разделением времени, с которым работает большинство процессов.
 SCHED_FIFO  и  SCHED_RR  предназначены для процессов,
зависящих от возникновения задержек, которым необходим более четкий контроль 
над порядком исполнения процессов. Статический приоритет процессов
с алгоритмом  SCHED_OTHER  равен нулю, а статические приоритеты
процессов с алгоритмами  SCHED_FIFO  и
 SCHED_RR  могут находиться в диапазоне от 1 до 99.
Статический приоритет, больший, чем 0, может быть установлен только
у суперпользовательских процессов, то есть только эти процессы
могут иметь алгоритм планировщика  SCHED_FIFO  или
 SCHED_RR . Для того, чтобы узнать возможный диапазон
значений статических приоритетов данного алгоритма планировщика,
необходимо использовать функции  sched_get_priority_min  и
 sched_get_priority_max . Это может понадобиться в переносимых
в другие системы программах для того, чтобы они соответствовали
стандарту POSIX.1b.
Планирование является упреждающим: если процесс с большим
статическим приоритетом готов к запуску, то текущий процесс будет
приостановлен и помещен в соответствующий список ожидания.
Алгоритм планирования определяет лишь поведение процесса
в списке работающих процессов с тем же статическим приоритетом.
 
   
 SCHED_FIFO: планировщик FIFO (First In-First Out) 

Алгоритм  SCHED_FIFO  можно использовать только со значениями статического
приоритета, большими нуля. Это означает, что если процесс с алгоритмом
 SCHED_FIFO  готов к работе, то он сразу запустится, а все
обычные процессы с алгоритмом  SCHED_OTHER  будут приостановлены.
 SCHED_FIFO  - это простой алгоритм без квантования времени.
Процессы, работающие согласно алгоритму  SCHED_FIFO  подчиняются следующим
правилам: процесс с алгоритмом  SCHED_FIFO , приостановленный другим
процессом с большим приоритетом, останется в начале очереди процессов с
равным приоритетом, и его исполнение будет продолжено сразу после того, как
закончатся процессы с большими приоритетами. Когда процесс с алгоритмом
 SCHED_FIFO  готов к работе, он помещается в конец очереди
процессов с тем же приоритетом. Вызов функции  sched_setscheduler  или
 sched_setparam  , который посылается процессом под номером  pid  
с алгоритмом  SCHED_FIFO  приведет к тому, что процесс будет перемещен 
в конец очереди процессов с тем же приоритетом. 
Как следствие, он может очистить текущий запущенный процесс, если
он имеет такой же приоритет.
(POSIX 1003.1 определяет, что процесс должен перейти в конец списка).


Процесс, вызывающий  sched_yield ,
также будет помещен в конец списка. Других способов перемещения процесса с
алгоритмом  SCHED_FIFO  в очереди процессов с одинаковыми статическим
приоритетом не существует. Процесс с алгоритмом  SCHED_FIFO  работает
до тех пор, пока не будет заблокирован запросом на ввод/вывод,
приостановлен процессом с большим статическим приоритетом или не вызовет
 sched_yield .
 
   
 SCHED_RR: циклический алгоритм планировщика 

 SCHED_RR  - это небольшое дополнение к алгоритму  SCHED_FIFO .
Все, относящееся к алгоритму  SCHED_FIFO , справедливо и для
 SCHED_RR  за исключением того, что каждому процессу разрешено
работать непрерывно не дольше некоторого времени, называемого карусельным
квантом. Если процесс с алгоритмом  SCHED_RR  работал столько же или
дольше, чем квант, то он помещается в конец очереди процессов с тем же
приоритетом. Процесс с алгоритмом  SCHED_RR , приостановленный
процессом с большим приоритетом, возобновляя работу, использует остаток
своего кванта. Длину этого кванта можно узнать, вызвав функцию
 sched_rr_get_interval .
   
 SCHED_OTHER: стандартный алгоритм планировщика с разделением времени 

Алгоритм  SCHED_OTHER  можно использовать только со значениями
статического приоритета, равными нулю.
 SCHED_OTHER  - это стандартный алгоритм диспетчеризации Linux с
разделением времени, предназначенный для процессов, не требующих
специальных механизмов реального времени со статическими приоритетами.
Порядок предоставления процессорного времени процессам со статическим
приоритетом, равным нулю, основывается на динамических приоритетах,
существующих только внутри этого списка. Динамический приоритет основан на
уровне nice (установленном при помощи системных вызовов  nice  или
 setpriority ) и увеличивается с каждым квантом времени, при котором
процесс был готов к работе, но ему было отказано в этом планировщиком. 
Это приводит к тому, что, рано или поздно, всем процессам с приоритетом
 SCHED_OTHER  выделяется процессорное время.


 
   
 Время ответа 

Блокированный процесс с высоким приоритетом, ожидающий ввода/вывода,
освобождает достаточно много процессорного времени до того, как снова
начнет работать. Авторы драйверов устройств могут сделать так, что это
время будет использоваться значительно эффективнее, если будет запущен
"медленный" обработчик прерываний.


   
 Разное 

Дочерние процессы наследуют алгоритм диспетчеризации и его
параметры после
 fork .

Обычно процессам реального времени необходимо блокировать
рабочие области памяти, для того чтобы избежать задержек
при страничном обмене. Это можно сделать при помощи функций
 mlock  

или 
 mlockall .

Неблокируемый бесконечный цикл в процессе, работающем с алгоритмом
 SCHED_FIFO  или  SCHED_RR , может заблокировать все процессы с
меньшим приоритетом, поэтому разработчик таких программ должен всегда
оставлять на одном из терминалов консоли оболочку, имеющую больший
статический приоритет, чем приоритет тестируемой программы. Это поможет (в случае
неполадок) прекратить работу отлаживаемого приложения реального времени,
которое работает не так, как ожидается. Процессы с алгоритмами
 SCHED_FIFO  и  SCHED_RR  могут полностью заблокировать работу
других процессов, поэтому в Linux только процессы суперпользователя могут
иметь алгоритмы диспетчеризации, отличные от  SCHED_OTHER .
В POSIX-системах, в которых существуют функции
 sched_setscheduler 

и
 sched_getscheduler ,

в < unistd.h > задается определение
 _POSIX_PRIORITY_SCHEDULING .

 
   
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 

При удачном завершении вызова
 sched_setscheduler 

возвращает 0.  
При удачном завершении
 sched_getscheduler 

возвращает алгоритм планировщика процесса (неотрицательное целое число).
При ошибке возвращается
-1, а переменной
 errno 

присваивается номер ошибки.
   
 НАЙДЕННЫЕ ОШИБКИ 

 
 ESRCH 

 
Процесса с номером  pid  не существует.
 EPERM 

 
Процесс не имеет достаточных прав для вызова функции.
Эффективный идентификатор пользователя процесса, вызывающего
 sched_setscheduler ,

должен быть равен либо эффективному или обычному идентификатору
пользователя процесса с номером
 pid ,

либо быть суперпользовательским.
 EINVAL 

 
Неизвестен алгоритм планировщика  policy , или параметр  p  не
соответствует этому алгоритму.
 
   
 СООТВЕТСТВИЕ СТАНДАРТАМ 

POSIX.1b (бывший POSIX.4)
   
 НАЙДЕННЫЕ ОШИБКИ 

В linux-1.3.81 алгоритм  SCHED_RR  еще не полностью
протестирован, и может работать не совсем так, как описано
в требованиях POSIX.1b.
   
 ЗАМЕЧАНИЯ 

Стандартный Linux - это операционная система общего
назначения. Она может работать как с фоновыми процессами,
так и с интерактивными приложениями и "мягкими" приложениями
реального времени (приложениями, которым
 желательно ,

чтобы задержки и интервалы времени выдерживались).
Эта страница предназначена именно для этих приложений.
 

Стандартный Linux
 не 

предназначается для работы "жестких" приложений реального времени,
то есть тех приложений, которым
 необходимо ,

чтобы задержки и интервалы времени (обычно значительно меньше секунды)
выдерживались очень точно, в противном случае это приведет к сбою системы.
Как и во всех других операционных системах общего назначения,
ставка в Linux делается на среднюю производительность,
а не на минимальную.
Минимальная производительность Linux при работе с прерываниями
значительно ниже средней. Различные блокировки ядра (например
в многопроцессорных системах) вызывают продолжительные задержки в работе.
Для Linux существует множество способов уменьшения среднего времени ожидания
за счет увеличения периода времени в худшем случае.
Во многих ситуациях именно это и необходимо пользователю,
но если Вы хотите написать "жесткую" программу  реального
времени, то используйте дополнения, такие, как RTLinux
( http://www.rtlinux.org),  или используйте
другую операционную систему, предназначенную для
"жестких" приложений реального времени.
   
 СМ. ТАКЖЕ 

 sched_setaffinity (2),

 sched_getaffinity (2),

 sched_setparam (2),

 sched_getparam (2),

 sched_yield (2),

 sched_get_priority_max (2),

 sched_get_priority_min (2),

 sched_rr_get_interval (2),

 nice (2),

 setpriority (2),

 getpriority (2),

 mlockall (2),

 munlockall (2),

 mlock (2),

 munlock (2)

 

 Programming for the real world - POSIX.4 

by Bill O. Gallmeister, O'Reilly & Associates, Inc., ISBN 1-56592-074-0
 

 IEEE Std 1003.1b-1993 

(Стандарт POSIX.1b)
 

 ISO/IEC 9945-1:1996 

это новая версия стандарта POSIX.1 1996-ого года, содержащая собранные
воедино POSIX.1(1990), POSIX.1b(1993), POSIX.1c(1995) и POSIX.1i(1995).
 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 
 Алгоритмы диспетчеризации 
 SCHED_FIFO: планировщик FIFO (First In-First Out) 
 SCHED_RR: циклический алгоритм планировщика 
 SCHED_OTHER: стандартный алгоритм планировщика с разделением времени 
 Время ответа 
 Разное 
 
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 СООТВЕТСТВИЕ СТАНДАРТАМ 
 НАЙДЕННЫЕ ОШИБКИ 
 ЗАМЕЧАНИЯ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename