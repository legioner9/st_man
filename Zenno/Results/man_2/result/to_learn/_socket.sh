#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 socket (2)   socket  (2)   ( FreeBSD man: Системные вызовы ) >>  socket  (2)   ( Русские man: Системные вызовы )   socket  (2)   ( Linux man: Системные вызовы )   socket  (3)   ( Solaris man: Библиотечные вызовы )   socket  (3)   ( POSIX man: Библиотечные вызовы )   socket  (4)   ( Linux man: Специальные файлы /dev/* )   socket  (7)   ( Русские man: Макропакеты и соглашения )   socket  (7)   ( Linux man: Макропакеты и соглашения )   socket  (9)   ( FreeBSD man: Ядро ) Ключ  socket  обнаружен в базе ключевых слов. 
   
 НАЗВАНИЕ 

socket - создает конечную точку соединения
   
 СИНТАКСИС 

 #include < sys/types.h > 

 

 #include < sys/socket.h > 

 
 int socket(int  domain , int  type , int  protocol ); 

   
 ОПИСАНИЕ 

 Socket 

создает конечную точку соединения и возвращает ее описатель.
 

Параметр
 domain 

задает домен соединения: выбирает набор протоколов, которые будут
использоваться для создания соединения. Такие наборы описаны в
 < sys/socket.h > .

В настоящее время распознаются такие форматы:
 

 
 Название Назначение Страница руководства 
 
 PF_UNIX, PF_LOCAL 

 
Локальное соединение
 
 unix (7)

 
 
 PF_INET 

 IPv4 протоколы Интернет 
 ip (7)

 
 
 PF_INET6 

 IPv6 протоколы Интернет 
 
 PF_IPX 

 IPX - протоколы Novell 
 
 PF_NETLINK 

 
Устройство для взаимодействия с ядром
 
 netlink (7)

 
 
 PF_X25 

 Протокол ITU-T X.25 / ISO-8208 
 x25 (7)

 
 
 PF_AX25 

 
Протокол AX.25 - любительское радио
 
 
 PF_ATMPVC 

 ATM - доступ к низкоуровневым PVC 
 
 PF_APPLETALK 

 Appletalk 
 ddp (7)

 
 
 PF_PACKET 

 
Низкоуровневый пакетный интерфейс
 
 packet (7)

 
 

 

Сокет имеет тип
 type ,

задающий семантику коммуникации.
В настоящее время определены следующие типы:
 
 SOCK_STREAM 

 
Обеспечивает создание двусторонних надежных и последовательных потоков байтов
,
поддерживающих соединения. Может также поддерживаться механизм
  внепоточных данных.
 SOCK_DGRAM 

 
Поддерживает датаграммы (ненадежные сообщения с ограниченной
длиной и не поддерживающие соединения).
 SOCK_SEQPACKET 

 
Обеспечивает работу последовательного двустороннего канала для 
передачи датаграмм
  с поддержкой соединений; датаграммы имеют ограниченную
длину; от получателя требуется за один раз прочитать целый пакет.
 SOCK_RAW 

 
Обеспечивает доступ к низкоуровневому сетевому протоколу.
 SOCK_RDM 

 
Обеспечивает надежную доставку датаграмм без гарантии, что они будут расположены
по порядку.
 SOCK_PACKET 

 
Устарел и не должен использоваться в новых программах; см.
 packet (7).

 
 

Некоторые типы сокетов могут быть не включены в определенные
наборы протоколов; например,
 SOCK_SEQPACKET 

не включен в набор
 AF_INET .

 

Параметр
 protocol 

задает конкретный протокол, который работает с сокетом. Обычно
существует только один протокол, задающий конкретный тип сокета
в определенном семействе протоколов, в этом случае
 protocol 

может быть определено, как 0.
Однако, возможно существование
нескольких таких протоколов (в этом случае и используется данный параметр).
Номер протокола зависит от используемого ``домена
коммуникации'', см.~
 protocols (5).

См.
 getprotoent (3),

где описано, как соотносить имена протоколов с их номерами.
 

Сокеты типа
 SOCK_STREAM 

являются соединениями полнодуплексных байтовых потоков, похожими на каналы. Они не
сохраняют границы записей. Потоковый сокет должен быть в состоянии
 соединения 

перед тем, как из него можно будет отсылать данные или принимать их 
в нем.
Соединение с другим сокетом создается с помощью системного вызова
 connect (2).

После соединения данные можно передавать, с помощью системных вызовов
 read (2)

,
 write (2)

или одного из вариантов следующих системных вызовов:
 send (2)

,
 recv (2).

Когда сеанс закончен, выполняется команда
 close (2).

Внепоточные данные могут передаваться, как описано в
 send (2),

а приниматься, как описано в
 recv (2).

 

Коммуникационные протоколы, которые реализуют
 SOCK_STREAM ,

следят, чтобы данные не были потеряны или дублированы.
Если часть данных, для которых имеется место в буфере протокола, не может быть 
передана за определенное время, соединение считается "мертвым".
Когда в сокете включен флаг
 SO_KEEPALIVE ,

протокол каким-либо способом проверяет, не отключена ли еще другая сторона.
Сигнал
 SIGPIPE 

появляется, если процесс посылает или принимает данные, пользуясь
"разорванным" потоком; это приводит к тому, что процессы,
не обрабатывающие сигнал, завершаются. Сокеты
 SOCK_SEQPACKET 

используют те же самые системные вызовы, что и сокеты
 SOCK_STREAM .

Единственное отличие в том, что вызовы
 read (2)

возвращают только запрошенное количество данных, а остальные данные пришедшего
пакета не будут учитываться.  Границы сообщений во входящих
датаграммах сохраняются.
 

Сокеты
 SOCK_DGRAM 

и
 SOCK_RAW 

позволяют посылать датаграммы принимающей стороне, заданной при вызове
 send (2).

Датаграммы обычно принимаются с помощью вызова
 recvfrom (2),

который возвращает следующую датаграмму с соответствующим обратным
адресом.
 

 SOCK_PACKET 

- это устаревший тип сокета, позволявший получать необработанные
пакеты прямо от драйвера устройства.  Используйте вместо него
 packet (7).

 

Системный вызов
 fcntl (2)

с аргументом
 F_SETOWN 

может использоваться для задания группы процессов, которая будет
получать сигнал
 SIGURG ,

когда прибывают внепоточные данные; или сигнал
 SIGPIPE ,

когда соединение типа
 SOCK_STREAM 

неожиданно обрывается.
Этот вызов также можно использовать, чтобы задать процесс или группу
процессов, которые получают асинхронные уведомления о событиях ввода-вывода 
с помощью
 SIGIO. 

Использование
 F_SETOWN 

эквивалентно использованию вызова
 ioctl (2)

с аргументом
 FIOSETOWN  

или
 SIOCSPGRP .

 
 

Когда сеть сообщает модулю протокола об ошибке (например, в случае IP,
используя ICMP-сообщение), то для сокета устанавливается флаг
ожидающей ошибки. Следующая операция этого сокета вернет код
ожидающей ошибки. Некоторые протоколы позволяют очереди ошибок в сокете 
получить детальную информацию об ошибке; см.
 IP_RECVERR 

в
 ip (7) . 

 

Операции сокетов контролируются их
 параметрами .

Эти параметры описаны в
 < sys/socket.h > .

Функции
 setsockopt (2)

и
 getsockopt (2)

используются, чтобы установить и получить необходимые параметры соответственно.
   
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 

В случае ошибки возвращается -1; в противном случае возвращается
описатель, ссылающийся на сокет.
   
 НАЙДЕННЫЕ ОШИБКИ 

 
 EPROTONOSUPPORT 

 
Тип протокола или указанный протокол не поддерживаются в этом домене.
 EAFNOSUPPORT 

 
Реализация не поддерживает указанное семейства адресов.
 ENFILE 

 
Недостаточно памяти, чтобы создать новый сокет.
 EMFILE 

 
Переполнение таблицы с файлами процесса.
 EACCES 

 
Нет доступа к созданию сокета указанного типа и/или протокола.
 ENOBUFS  или  ENOMEM 

 
Недостаточно памяти для создания сокета.
 EINVAL 

 
Неизвестный протокол или недоступный набор протоколов.
 
 

Другие ошибки могут быть созданы модулями
  протоколов более низкого уровня.
   
 СООТВЕТСТВИЕ СТАНДАРТАМ 

4.4BSD (системный вызов
 socket 

появился в 4.2BSD). Обычно переносим в не-BSD системы и с них
(включая варианты System V).
   
 ЗАМЕЧАНИЯ 

В наборах протоколов BSD 4.* используются константы PF_UNIX,
PF_INET и т.д., тогда как AF_UNIX и т.п. используется для указания
семейства адресов. Однако, в странице руководства BSD записано:
"Вообще, набор протоколов совпадает с семейством адресов", и во всех последующих
стандартах используется AF_*.
   
 НАЙДЕННЫЕ ОШИБКИ 

 SOCK_UUCP 

до сих пор не реализован.
   
 СМ. ТАКЖЕ 

 accept (2),

 bind (2),

 connect (2),

 fcntl (2),

 getpeername (2),

 getsockname (2),

 getsockopt (2),

 ioctl (2),

 listen (2),

 read (2),

 recv (2),

 select (2),

 send (2),

 shutdown (2),

 socketpair (2),

 write (2),

 getprotoent (3),

 ip (7),

 socket (7),

 tcp (7),

 udp (7),

 unix (7)

 

lqВводное Руководство по межпроцессной коммуникации в 4.3 BSDrq
(lqAn Introductory 4.3 BSD Interprocess Communication Tutorialrq)
перепечатано и называется
 Дополнительные документы для программиста UNIX, Том~1 ,

 ( UNIX Programmer's Supplementary Documents Volume~1 ).

 

lqРуководство по межпроцессной коммуникации в BSDrq
перепечатано и называется
 Дополнительные документы для программиста UNIX, Том~1 ,

 ( UNIX Programmer's Supplementary Documents Volume~1 ).

 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 СООТВЕТСТВИЕ СТАНДАРТАМ 
 ЗАМЕЧАНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename