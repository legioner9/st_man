#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 access (2)   access  (1)   ( Solaris man: Команды и прикладные программы пользовательского уровня )   access  (1)   ( Linux man: Команды и прикладные программы пользовательского уровня )   access  (2)   ( Solaris man: Системные вызовы )   access  (2)   ( FreeBSD man: Системные вызовы ) >>  access  (2)   ( Русские man: Системные вызовы )   access  (2)   ( Linux man: Системные вызовы )   access  (3)   ( Solaris man: Библиотечные вызовы )   access  (3)   ( POSIX man: Библиотечные вызовы )   access  (5)   ( Русские man: Форматы файлов )   access  (5)   ( Linux man: Форматы файлов ) Ключ  access  обнаружен в базе ключевых слов. 
   
 ИМЯ 

access - проверить права доступа пользователя к файлу
   
 ОБЗОР 

 #include < unistd.h > 

 int access(const char * pathname , int  mode ); 
 

   
 ОПИСАНИЕ 

 access 

проверяет, имеет ли процесс права на чтение или запись, или же просто
проверяет, существует ли файл (или другой объект файловой системы),
с именем
 pathname .

Если
 pathname 

является символьной ссылкой, то проверяются права доступа к файлу,
на который она ссылается.
 
 mode 

-- это маска, состоящая из одного или более флагов
 R_OK ,  W_OK ,  X_OK  и  F_OK .

 
 R_OK ,  W_OK  и  X_OK 

запрашивают соответственно проверку существования файла и возможности
его чтения, записи или выполнения.
 F_OK 

просто проверяет существование файла.
 
Результаты проверки зависят от прав доступа к каталогам, находящимся
по пути к файлу, заданному параметром
 pathname ,

и от прав доступа к каталогам и файлам, на которые ссылаются
символьные ссылки, встреченные по пути.
 
Проверка осуществляется, используя
 реальные ,

а не эффективные идентификаторы пользователя и группы.  Эффективные
идентификаторы будут использоваться при действительной попытке
выполнения той или иной операции.  Это дает setuid-программам простой
способ проверить права доступа настоящего пользователя.
 
Проверяются только биты прав доступа, а не тип файла или его
содержимое.  Таким образом, если каталог имеет "возможность записи",
это, вероятно, означает, что в нем можно создавать файлы, а не что в
этот каталог можно писать так же, как в обычный файл.  Подобно этому
файл из DOS может показаться "выполняемым", но системный вызов
 execve (2)

завершится неудачно.
 
Если процесс имеет соответствующие привелегии, то некоторые реализации
могут показать успех для
 X_OK 

даже если права на файл не содержат бит, разрешающий выполнение. 
   
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ 

В случае успеха (есть все запрошенные права) возвращается нуль.
При ошибке (по крайней мере один запрос прав из
 mode 

был неудовлетворен, или случилась другая ошибка), возвращается -1, а
 errno 

устанавливается должным образом.
   
 ОШИБКИ 

 access 

будет завершаться с ошибкой если:
 
 EACCES 

 
Запрошенный тип доступа не удовлетворен или один из каталогов в
 pathname 

не позволяет поиск.
 ELOOP 

 
Во время определения
 pathname 

встретилось слишком много символьных ссылок (зацикливание по символьным
сслыкам -- прим. пер.).
 ENAMETOOLONG 

 
 pathname 

слишком длинно.
 ENOENT 

 
Компонент пути
 pathname 

не существует или является "висячей" символической ссылкой.
 ENOTDIR 

 
Компонент пути, использованный как каталог в
 pathname ,

в действительности таковым не является.
 EROFS 

 
Файл находится на файловой системе, смонтированной только для чтения.
 
 

 
 access 

может завершиться с ошибкой, если:
 EFAULT 

 pathname 

указывает за пределы доступного адресного пространства.
 
 EINVAL 

 
 mode 

был задан неверно.
 EIO 

 
Произошла ошибка ввода-вывода.
 ENOMEM 

 
Ядру не хватило памяти.
 ETXTBSY 

 
Права на запись были затребованы для исполняемого файла, который
уже выполняется.
 
   
 ОГРАНИЧЕНИЯ 

 access 

возвращает ошибку, если один из запрошенных типов доступа не будет
удовлетворён, даже если другие типы прошли бы успешно.
 

 access 

может работать неверно на файловых системах NFS со включенным
преобразованием UID'ов, потому что это преобразование происходит на
сервере и спрятано от клиента, который пытается проверить права.
 

Использование
 access 

для проверки, можно ли пользователю, например, открыть файл перед тем, 
как действительно выполнить
 open (2),

создает дыру в защите, потому что пользователь может в короткий
промежуток между проверкой и открытием файла как-то его изменить.
   
 СООТВЕТСТВИЕ СТАНДАРТАМ 

SVID, AT&T, POSIX, X/OPEN, BSD 4.3
   
 СМОТРИ ТАКЖЕ 

 stat (2),  open (2),  chmod (2),  chown (2), 

 setuid (2),  setgid (2).

   
 ПЕРЕВОД 

Copyright (C) Alexey Mahotkin < alexm@hsys.msk.ru > 1999,
Виктор Вислобоков < corochoone@perm.ru > 2003
 

 
   Index 
 
 ИМЯ 
 ОБЗОР 
 ОПИСАНИЕ 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ 
 ОШИБКИ 
 ОГРАНИЧЕНИЯ 
 СООТВЕТСТВИЕ СТАНДАРТАМ 
 СМОТРИ ТАКЖЕ 
 ПЕРЕВОД 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename