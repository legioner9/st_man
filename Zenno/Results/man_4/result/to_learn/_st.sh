#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 st (4) >>  st  (4)   ( Русские man: Специальные файлы /dev/* )   st  (4)   ( Linux man: Специальные файлы /dev/* )   st  (7)   ( Solaris man: Макропакеты и соглашения ) 
   
 НАЗВАНИЕ 

st - ленточный накопитель SCSI 
   
 СИНТАКСИС 

 #include < sys/mtio.h > 

 int ioctl(int  fd , int  request  [, (void *) arg3 ]); 
 int ioctl(int  fd ,  MTIOCTOP , (struct mtop *) mt_cmd ); 
 int ioctl(int  fd ,  MTIOCGET , (struct mtget *) mt_status ); 
 int ioctl(int  fd ,  MTIOCPOS , (struct mtpos *) mt_pos ); 
 

   
 ОПИСАНИЕ 

Драйвер
 st 

участвует в установке связи с различными ленточными накопителями SCSI.
В настоящее время драйвер позволяет управлять любыми устройствами
lqпоследовательного доступаrq.
В драйвере
 st 

цифра 9 используется как основное число устройства.
 

Каждое устройство использует восемь второстепенных номеров устройства.
Первые пять битов во второстепенных номерах определяют последовательность обнаружения.
Второстепенные номера могут быть сгруппированы в два набора из четырех чисел: 
главные (автоперемотка) младшие числа устройства
 n ,

и числа устройства lqнеперемоткиrq,
 ( n + 128).

Открытые устройства используют главный номер устройства, посылая
команду  REWIND , когда закрываются.
(Заметьте, что использование устройства автоперемотки для установки ленты
в определенное положение, для примера, mt, не даст желаемого результата:
лента перемотается после команды mt, и следующая команда будет
выполняться с начала ленты).
 

В каждой группе четыре второстепенных номера доступны для определения
устройств с особыми характеристиками (такими, как: длина блока, сжатие, плотность 
и другое). Когда система запускается, только первое устройство доступно.
Другие три приводятся в действие, когда определены некоторые их характеристики
(смотрите ниже). Путем изменения константы при компиляции возможно
изменение баланса между максимальным числом ленточних накопителей и
числом из второстепенных номеров каждого накопителя. Начальное размещение
позволяет контролировать 32 ленточных устройства. Для примера, возможно
контролировать до 64-х ленточных устройств с двумя второстепенными номерами.
 

Устройства обычно создаются так:
 
 mknod -m 666 /dev/st0 c 9 0
mknod -m 666 /dev/st0l c 9 32
mknod -m 666 /dev/st0m c 9 64
mknod -m 666 /dev/st0a c 9 96
mknod -m 666 /dev/nst0 c 9 128
mknod -m 666 /dev/nst0l c 9 160
mknod -m 666 /dev/nst0m c 9 192
mknod -m 666 /dev/nst0a c 9 224
 

 

 

Нет соответствующего блочного устройства.
 

Драйвер использует внутренний буфер, что достаточно для сохранения в нем 
одного блока ленты. В ядре до появления версии 2.1.121 буфер был размещен как один
прилегающий блок. Ограничение размера блока обеспечивается распределителем
памяти ядра может. Ограничение в настоящее время состовляет: 128 kB для 32-битной
и 256 kB для 64-битной архитектуры. В новейших ядрах накопитель
располагает буфер в нескольких частях, если это необходимо. По умолчанию
максимальное число частей - 16. Это способ сделать максимальный размер
блока очень большим (2MB, если выделяется 16 блоков по 128 kB).
 

Размер внутреннего буфера драйвера определяется константой при
сборке; эта константа может быть изменена при загрузке ядра. Вдобавок к
этому, драйвер пытается разместить больший временный буфер во время
запуска, если это необходимо. Тем не менее, размещение во время запуска
больших блоков памяти можеть быть неудачным, и целесообразно не слишком
полагаться на размещение активного буфера в ядре версии 2.1.121 и более ранних
(это применяется также при загрузке драйвера по требованию kerneld или kmod).
 

После старта системы параметры ленточного устройства определены
программно-аппаратными средствами накопителя. Для примера, если
производитель выбирает фиксированный блочный режим, то ленточное
устройство использует этот режим. Параметры могуть быть изменены 
вызовом функции 
 ioctl()  

и действовать, когда устройство было закрыто и
потом открыто вновь. Установка параметров влияет на оба устройства
(автоперемотки и неперемотки).
 

Особые праметры могут быть определены для остальных устройств. Параметры
начинают работать, когда устройство открыто. Для примера, системный
администратор может определить одно устройство, которое записывает данные 
в режиме фиксированных блоков (с определенным размером блока), и другое, которое
записывает данные в режиме переменных блоков (если накопитель поддерживает оба
режима).
 

Драйвер поддерживает
 ленточные разделы , 

но только если их поддерживает сам накопитель (заметьте, что ленточные
разделы не влияют на разделы диска. Разделенная лента может быть отображена
как несколько логических лент). С ioctl возможна поддержка разделов.
Местоположение ленты зафиксировано внутри каждого раздела.
Раздел используется для запуска последующих ленточных операций, выбранных 
с помощью ioctl. Максимальное число разделов на ленте определяется
константой при компиляции (изначально оно равно четырем). Драйвер ограничивает ioctl,
что позволяет форматировать ленту с одним или двумя разделами.
 

Устройство
 /dev/tape 

обычно создает по умолчанию как "жесткую", так и символьную ссылку ленточного
устройства в системе.
   
 ПЕРЕДАЧА ДАННЫХ 

Драйвер поддерживает операции в обоих режимах: фиксированных и переменных
блоков (только если оба режима поддерживает сам накопитель). В режиме
фиксированных блоков накопитель записывает блоки определенного размера, 
и размер блока не зависит от количества требуемых байтов, которые
вызываются для записи системой. В режиме переменных блоков один блок
ленты записывается при каждом вызове записи и требует определения
размера соответствующего блока ленты. 
 

В режиме переменных блоков при чтении требуемых байтов размер блока ленты
точно не подбирается. Если требуемых байтов больше, чем в следующем блоке ленты, 
драйвер возвращает данные, а функция возвращает текущий размер блока.
Если размер блока больше, чем количество требуемых байтов, читается только количество
данных с начала блока, а остаток блока отбрасывается.
 

В режиме фиксированных блоков чтение количества байтов может быть
произвольным, если буферизация дает такую возможность, или
пропорциональным размеру блока ленты, если  такой возможности нет. Ядро 
версий, появившихся до 2.1.121, позволяет записывать блок с произвольным 
количеством байтов.
Во всех других случаях количество байтов должно быть
пропорциональным размеру блока ленты.
 

Метка файла автоматически записывается на ленту, если последней операцией 
до закрытия была запись.
 

Если данные остаются в буфере, то метка файла будет найдена и буферизация данных 
продолжится. Следующее чтение вернет ноль байтов, затем вернет данные из следующего
файла. В конце записи данные сообщат о возвращении нуля байтов для второго 
упорядоченного вызова записи. И, наконец, третье чтение вернет ошибку.
   
 СИСТЕМНЫЕ ВЫЗОВЫ 

Драйвер поддерживает три запроса ioctl.
Запросы, не опознанные драйвером 
 st ,

пропускаются в драйвер SCSI.
См.
 /usr/include/linux/mtio.h :

   
 MTIOCTOP  - выполнение ленточных операций 

 

Это требует использования типа аргумента
 (struct mtop *) .

Не любой накопитель поддерживает все операции.
Драйвер возвращает ошибку EIO, если накопитель не выполнил операцию.
 

 
 

 

Операции с магнитной лентой для нормального использования:

 
 MTBSF 
Перемотка ленты на
 mt_count 

файловых маркеров назад.
 MTBSFM 
Перемотка ленты на
 mt_count 

файловых маркеров назад. Перемотка ленты на сторону EOT последней метки файла.
 MTBSR 
Перемотка ленты на
 mt_count 

записей (блоков ленты) назад.
 MTBSS 
Перемотка ленты на
 mt_count 

установленных маркеров назад.
 MTCOMPRESSION 
Включение режима сжатия данных на ленте накопителя, если
 mt_count 

не нулевое, и отключение компрессии, если
 mt_count 

равно нулю. 
Эта команда использует страницу 15 МODE, поддерживаемую многими устройствами DAT.
 MTEOM 
Перемотка ленты к концу данных (для добавляемых файлов).
 MTERASE 
Стирает информацию с ленты в кассете.
 MTFSF 
Перемотка ленты на
 mt_count 

файловых маркеров вперед.
 MTFSFM 
Перемотка ленты на
 mt_count 

файловых маркеров вперед. Перемотка ленты на сторону BOT последней метки файла.
 MTFSR 
Перемотка ленты на
 mt_count 

записей (блоков).
 MTFSS 
Перемотка ленты на
 mt_count 

установленных маркеров вперед.
 MTLOAD 
Осуществляет загрузку команд SCSI. Специальные возможности доступны некоторым
автозагрузчикам HP. Если
 mt_count 

- константа, то MT_ST_HPLOADER_OFFSET прибавит к ней число, которое передается накопителю
для управления автозагрузчиком.
 MTLOCK 
Блокирует дверцу ленточного накопителя.
 MTMKPART 
Форматирует ленту на один или два раздела. Если
 mt_count 

- не нулевое, этот параметр выдает размер первого раздела, а второй раздел 
содержит остаток ленты. Если
 mt_count 

является нулевым, лента форматируется на один раздел.
Эта команда запрещена для накопителя, исключая тот случай, когда накопитель
поддерживает создание разделов (см. ниже MT_ST_CAN_PARTITIONS).
 MTNOP 
Сброс буфера накопителя.
Операция должна выполняться до чтения статуса с  MTIOCGET .
 MTOFFL 
Перематывает ленту и отключает устройство.
 MTRESET 
Возвращает устройству исходное состояние.
 MTRETEN 
Подтягивает ленту в касете.
 MTREW 
Перематывает ленту назад.
 MTSEEK 
Переход к блоку ленты с номером
 mt_count .

Эта операция требует одного из двух накопителей: SCSI-2, поддерживающего команду  LOCATE 
(адрес определенного устройства), или
Tandberg - совместимого накопителя SCSI-1 (Tandberg, Archive
Viper, Wangtek, ... ).
Номер блока должен быть равен единице, что заранее возвращает  MTIOCPOS , если
используется адрес определенного устройства.
 MTSETBLK 
Присваивает длине блока накопителя значение
 mt_count .

Нулевое значение устанавливает режим переменных блоков накопителя.
 MTSETDENSITY 
Устанавливает плотность данных на ленте в значение
 mt_count .

Плотность данных, поддерживаемая накопителем, может быть найдена
в документации самого устройства.
 MTSETPART 
Изменение значения активного раздела на значение
 mt_count . 

Разделы нумеруются, начиная с нуля. Эта команда только для накопителей, 
которые имеют поддержку разделов (см. ниже MT_ST_CAN_PARTITIONS).
 MTUNLOAD 
Осуществляет выгрузку команд SCSI (но не выталкивает кассету).
 MTUNLOCK 
Разблокирует дверцу ленточного накопителя.
 MTWEOF 
Устанавливает
 mt_count 

маркера файла в текущую позицию на ленте.
 MTWSM 
Записывает
 mt_count 

установленных меток.

 
 

Операции с магнитной лентой для установки параметров устройства (для суперпользователя):

 
 MTSETDRVBUFFER 
Установка значения 
 mt_count 

различных накопителей и параметров драйвера соответственно количеству битов.
Это: режим буферизации накопителя (13 битовых параметров драйвера),
буфер записи по умолчанию для размера блока, плотность и время ожидания 
(только для ядра версии 2.1 или более поздних).
Одна операция может присваивать устройству значение только одного пункта из списка выше 
(13 битовых параметров считаются одним пунктом).

 
Нулевое значение старших 4-х битов будет использовано для установки
режима буферизации накопителя.
Режимы буферизации:
 
 
 0 
Накопитель не сообщит, что запись прошла успешно до тех пор, пока блоки данных фактически
не записаны на носитель.

 1 
Накопитель может сообщить, что запись прошла успешно после того, как
все данные будут перемещены во внутренний буфер накопителя.
 2 
Накопитель может сообщить о том, что запись прошла успешно после того, как:
(а) все данные будут перемещены во внутренний буфер накопителя и (б) все буферизированные 
данные будут успешно записаны на носитель.

 
 

 
Для контроля записи пороговое значение
 mt_count 

должно включать в себя константу
 MT_ST_WRITE_THRESHOLD  с количеством блоков в первых
28-и битах. Она содержит количество блоков по 1024 байта (это не физические блоки
на диске). Пороговое значение не может превышать размер внутреннего буфера накопителя.
(см. выше
 DESCRIPTION ) 

 
Для установки и "очистки" битовых параметров 
 mt_count 

должна включать в себя одну из констант:
 MT_ST_BOOLEANS ,
 MT_ST_SETBOOLEANS ,  MT_ST_CLEARBOOLEANS ,
 MT_ST_DEFBOOLEANS  или любую их комбинацию.
Использование опций  MT_ST_BOOLEANS  может быть определено в 
соответствующих битах. В работе с опциями  MT_ST_SETBOOLEANS  могуть применяться
выборочные установки, а с опциями  MT_ST_DEFBOOLEANS  - выборочная очистка.
 
Изначально параметры для для ленточного устройства установлены равными  MT_ST_DEFBOOLEANS .
Неактивное ленточное устройство (например, устройство со второстепенными номерами 64 или 160)
активируется, когда изначальные параметры для него определены в первый раз.
Активированное устройство получает при загрузке параметры, не установленные явно.
 
Битовые параметры:
 

 
 
 MT_ST_BUFFER_WRITES   (по умолчанию true) 
Резервирует все операции записи в режиме фиксированных блоков.
Если установленное значение этой опции равно false и накопитель использует режим 
фиксированных блоков, то все операции записи должны выполняться для различных размеров блока.
Установленное значение этого параметра должно быть равным false для записи надежных 
многотомных архивов.
 MT_ST_ASYNC_WRITES   (по умолчанию true) 
Когда значение true этого параметра установлено, операции записи возвращают данные
перемещения на накопитель, если данные заполнили буфер драйвера.
Начальная запись определяет, как должен быть заполнен буфер до новых
SCSI-команд записи.
Любые ошибки, возвращенные накопителем, хранятся до следующей операции.
Установленное значение данного параметра должно быть false; это дает возможность 
записывать многотомные архивы.
 MT_ST_READ_AHEAD   (По умолчанию: true) 
Этот параметр приказывает драйверу использовать операцию чтения в режиме фиксированных блоков.
Если установленное значение этого параметра равно false и накопитель использует 
режим фиксированных блоков,
то все операции чтения используются для блоков переменной длины.
 MT_ST_TWO_FM   (По умолчанию: false) 
Этот параметр изменяет поведение драйвера после закрытия файла.
По умолчанию драйвер записывает один маркер файла.
Если установленное значение параметра равно true, то драйвер запишет два маркера файла.

 
Замечание:
этому параметру не может быть присвоено значение true для ленточных накопителей QIC.
Многие современные накопители также находят конец записанных данных,
и использование двух меток файла обычно необходимо только при замене ленты
в некоторых других системах.
 
 


 
 MT_ST_DEBUGGING   (По умолчанию: false) 
Этот параметр включает в себя возможность вывода сообщений драйвера при отладке,
она эффективна только в том случае, если драйвер был собран с ненулевым 
значением  DEBUG .  
 MT_ST_FAST_EOM   (По умолчанию: false) 
Этот параметр позволяет посылать операцию  MTEOM  накопителю непосредственно, 
потенциально увеличивая скорость операций; но возникает опасность потерять 
"дорожку" текущего файла.
Если установленное значение параметра  MT_ST_FAST_EOM  равно false, то
драйвер отвечает на запрос  MTEOM , перематывая ленту к концу записанных файлов.
 MT_ST_AUTO_LOCK  (по умолчанию false) 
Когда этому параметру присвоено значение true и устройство открыто, дверца накопителя заблокирована,
когда устройство закрыто, дверца разблокирована. 
 MT_ST_DEF_WRITES  (По умолчанию: false) 
Параметры чтения и записи на ленту (размер блока, режим, компрессия и т.д.) могут 
изменяться в случае с различными устройствами, связанными с накопителем, в зависимости от того,
как настроено устройство.
Этот параметр определяет, будет ли использоваться драйвер при помощи команд
SCSI, или накопитель сам автоматически будет выполнять операции, используя свои возможности.
Если установленное значение этой опции равно false, то драйвер будет посылать команды 
непосредственно устройству. Если установленное значение опции равно true, команды SCSI 
не отправляются до запроса записи. В этом случае программно-аппаратные средства накопителя
позволяют выполнять обнаружение структуры ленты во время чтения, а команды SCSI 
используются только для проверки правильности записи на ленту в соответствии со 
спецификацией.
 MT_ST_CAN_BSR  (по умолчанию false) 
Если используется упреждающее чтение, лента должна быть иногда перемотана назад
для правильного ее размещения при закрытом устройстве. Для этих целей используется
команда SCSI, которая выполняет перемотку ленты назад на одну запись.
Некоторые старые накопители не могут правильно обрабатывать эту команду,
и этот параметр может использоваться для того, чтобы драйвер данную команду
не применял. В конечном итоге, с упреждающим чтением и в режиме фиксированных блоков
файл может неверно быть записан на ленту при закрытом устройстве.
 MT_ST_NO_BLKLIMS  (по умолчанию false) 
Некоторые накопители не принимают SCSI-команду READ BLOCK LIMITS 
(ограничения чтения блока).
Если она используется, то драйвер не исполняет команду.
Недостатком этого является невозможность проверки драйвером до отправки команд, 
поддерживается ли выбранный размер блока накопителем.
 MT_ST_CAN_PARTITIONS  (по умолчанию false) 
Этот параметр дает возможность поддерживать несколько разделов на ленте.
Он применяется ко всем устройствам, связанным с накопителем.
 MT_ST_SCSI2LOGICAL  (по умолчанию false) 
Этот параметр заставляет драйвер использовать адрес логического блока,
определенного в стандарте SCSI-2 при выполнении операций поиска и пересчета
(с обеими командами MTSEEK и MTIOCPOS и в том случае, когда изменяются разделы ленты).
Желательно установить этот параметр, если накопитель поддерживает логические адреса,
потому что они рассчитывают также и метки файла.
 MT_ST_SYSV  (по умолчанию false) 
Когда этот параметр установлен, ленточные устройтва используют семантику SystemV.
В других случаях используется семантика BSD.
Основная разница между этими семантиками (когда устройство,
окрытое для чтения, закрыто) состоит в следующем: по семантике SYSV лента 
перематывается вперед за следующий маркер файла, если этого не произошло 
во время использования устройства.
В семантике BSD местоположение ленты не меняется.
 ПРИМЕР 
 
 struct mtop  mt_cmd ; 
 mt_cmd.mt_op  =  MTSETDRVBUFFER ; 
 mt_cmd.mt_count  =  MT_ST_BOOLEANS  | 
            MT_ST_BUFFER_WRITES  | 
            MT_ST_ASYNC_WRITES ; 
 ioctl( fd ,  MTIOCTOP , & mt_cmd ); 
 

 
 


 
Размер блока для устройства может быть установлен 
с помощью  MT_ST_DEF_BLKSIZE , а плотность данных может быть установлена 
с помощью  MT_ST_DEFDENSITY . Значения параметров ORed -
с помощью кода операции.
 
В ядре версии 2.1.x и более поздних время ожидания может быть установлено
подкомандой  MT_ST_SET_TIMEOUT  с секундным значением.
Долгое время ожидания (используется для перемотки и выполнения других команд,
занимающего длительное время) может быть установлено равным  MT_ST_SET_LONG_TIMEOUT .
Значения, используемые в ядре по умолчанию, слишком велики, поэтому нельзя быть уверенным в том,
время ожидания не истечет. Действие драйвера в этом случае может быть приостановлено.
Эти команды могут быть использованы для установки оптимальных
значений различных накопителей. Установка времени ожидания для одного устройства
применяется для всех устройств, связанных с этим накопителями.
 
   
 MTIOCGET  - получение статуса 

 

Этот запрос использует аргумент типа
 (struct mtget *) .

 

 /* структура для  MTIOCGET  */
struct mtget {
    long   mt_type;
    long   mt_resid;
    /* следующие регистры являются устройствозависимыим */
    long   mt_dsreg;
    long   mt_gstat;
    long   mt_erreg;
    /* следующие два поля используются не всегда */
    daddr_t          mt_fileno;
    daddr_t          mt_blkno;
};
 

 
 mt_type 
Заголовок файла определяет множество значений 
 mt_type ,

но текущий драйвер сообщает только об общих типах
 MT_ISSCSI1  (SCSI-1) и  MT_ISSCSI2  (SCSI-2).

 mt_resid 
включает в себя номер текущего раздела диска.
 mt_dsreg 
сообщает о текущих настройках размера блока драйвера (в младших 24-х битах)  
и плотности (в старших 8-х битах).
Эти поля определены в: 
 MT_ST_BLKSIZE_SHIFT ,  MT_ST_BLKSIZE_MASK ,
 MT_ST_DENSITY_SHIFT  и  MT_ST_DENSITY_MASK .
 mt_gstat 
сообщает об общем (устройствонезависимом) статусе.
Заголовок файла определяет макрос для тестирования:
 
 
 
 GMT_EOF( x ) :
текущая позиция сразу после маркера файла
(значение всегда становится ложным после выполнения операции  MTSEEK )
 
 GMT_BOT( x ) :
текущая позиция в начале первого файла
(всегда ложно после операции  MTSEEK )
 
 GMT_EOT( x ) :
текущая позиция в конце ленты.
 
 GMT_SM( x ) :
 
 GMT_EOD( x ) :
текущая позиция в конце записанных данных.
 
 GMT_WR_PROT( x ) :
накопитель зашищен от записи.
Для некоторых накопителей это может означать, что накопитель не поддерживает 
запись на носитель этого типа.
 
 GMT_ONLINE( x ) :
 
 GMT_D_6250( x ) ,  GMT_D_1600( x ) ,  GMT_D_800( x ) :
Сообщает о настройках текущей плотности для 9-и дорожек.
 
 GMT_DR_OPEN( x ) :
нет ленты в накопителе.
 
 GMT_IM_REP_EN( x ) :
сообщает о режиме. Этот бит устанавливается, если нет гарантии, что данные были 
правильно записаны на ленту. Этот бит приобретает нулевое значение,
когда драйвер не записывает данные в буфер и накопитель не настроен на
буферизацию данных.
 
 

 mt_erreg 
Поле, определенное в
 mt_erreg ,

возвращает номер ошибки в младших 16-и битах 
(ошибка определена в  MT_ST_SOFTERR_SHIFT  и  MT_ST_SOFTERR_MASK ).
 mt_fileno 
сообщает текущий номер файла.
Значение установлено равным -1, когда номер файла неизвестен (например, после
 MTBSS  или  MTSEEK ).
 mt_blkno 
сообщает о номере блока в пределах текущего файла.
Значение установлено равным -1, когда номер блока неизвестен
(например, после  MTBSF ,  MTBSS  или  MTSEEK ).

 
   
 MTIOCPOS  - получить текущую позицию 

 

Этот запрос использует аргумент типа
 (struct mtpos *) 

и сообщает текущий номер блока ленты, который необязательно будет
равен значению
 mt_blkno ,

возвращаемому  MTIOCGET .
Накопитель должен быть накопителем SCSI-2, чтобы поддерживать
команды  READ POSITION , или Tandberg-совместимым
накопителем SCSI-1 (Tandberg, Archive Viper, Wangtek, ... ).
 

 /* структура для  MTIOCPOS  */
 struct     mtpos {
    long   mt_blkno; /* текущий номер блока */
};
 

   
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 

 
 EIO 
Запрошеные операции могут быть завершены.
 ENOSPC 
Операции записи не могут завершиться, потому что лента закончилась.
 EACCES 
Попытка записать данные на ленту или "очистить" ленту, защищенную от записи.
Эта ошибка не появляется во время использования функции
 open() .

 EFAULT 
Параметры команды указывают на память, не принадлежащую вызывающему процессу.
 ENXIO 
Во время открытия ленточного устройства обнаруживается, что его не существует.
 EBUSY 
Устройство уже используется, или драйвер не способен выделить буфер.
 EOVERFLOW 
Попытка чтения или записи блоков переменной длины, больших, чем
внутренний буфер драйвера.
 EINVAL 
 ioctl() 

был передан неверный аргумент или запрошен неправильный размер блока.
 ENOSYS 
Неизвестный
 ioctl() .

 EROFS 
Попытка открыть накопитель с помощью O_WRONLY или O_RDWR, если лента в нем
защищена от записи.
 
   
 ФАЙЛЫ 

/dev/st*  : ленточные устройства SCSI с автоперемоткой
 

/dev/nst* : ленточные устройства SCSI без автоперемотки
   
 АВТОРЫ 

Драйвер был создан Kai M:akisara ( Kai.Makisara@metla.fi ) 
на основе драйвера, описанного Dwayne Forsyth. 
В этой работе принимали участие и другие авторы.
   
 СМ. ТАКЖЕ 

 mt (1)

 

Файл README.st в исходных текстах ядра содержит самую свежую информацию
о драйвере и его возможных конфигурациях.
   
 ЗАМЕЧАНИЯ 

1. При обмене данными между системами обе системы согласовывают
физический размер блока ленты. Параметры накопителя после загрузки
часто не являются теми, которые использует большинство операционных систем,
работающих с этими устройствами. Большинство систем используют накопители в режиме
переменных блоков, если этот режим поддерживается накопителем.
Это применимо к большинству современных накопителей, включающих в себя
DAT, DLT и т.д. Возможно, целесообразно использовать эти накопители в
режиме переменных блоков также и в Linux (т.е., используйте MTSETBLK
или MTSETDEFBLK при запуске системы для установки необходимого режима);
 

2. Многие программы (например, tar) позволяют пользователю 
определить блокировку в командной строке. Заметьте, что это 
помогает определить размер физического блока на ленте, но только 
в режиме переменных блоков;
 

3. Для использования ленточных накопителей SCSI и базового драйвера SCSI
в ядре созданы (или загружены в него как модули): один из драйверов SCSI-адаптера 
и драйвер ленты SCSI.
Если драйвера SCSI-ленты не существует, накопитель становится привилегированным, но 
поддержка ленты, описанная здесь, вряд ли будет Вами применяться;
 

4. Драйвер записывает сообщения об ошибках на консоль/ в журнал. 
   
 АВТОРСКИЕ ПРАВА 

Copyright © 1995 Robert K. Nichols.
 

Copyright © 1999 Kai M:akisara.
 

Разрешается делать и распространять точные копии этого документа, при условии 
наличия этой заметки об авторсикх правах и правилах распространения на каждой
копии документа.
Дополнительные условия содержатся в шапке файла.
  
 
 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 ПЕРЕДАЧА ДАННЫХ 
 СИСТЕМНЫЕ ВЫЗОВЫ 
 
 MTIOCTOP  - выполнение ленточных операций 
 MTIOCGET  - получение статуса 
 MTIOCPOS  - получить текущую позицию 
 
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
 ФАЙЛЫ 
 АВТОРЫ 
 СМ. ТАКЖЕ 
 ЗАМЕЧАНИЯ 
 АВТОРСКИЕ ПРАВА 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename