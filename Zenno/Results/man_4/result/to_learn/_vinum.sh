#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 vinum (4)   vinum  (4)   ( FreeBSD man: Специальные файлы /dev/* ) >>  vinum  (4)   ( Русские man: Специальные файлы /dev/* )   vinum  (8)   ( Русские man: Команды системного администрирования ) 
 
 
 vinum(4) 
 Руководство по интерфейсам ядра FreeBSD 
 vinum(4) 
 
 

 НАЗВАНИЕ 
 vinum  -- диспетчер логических томов (Logical Volume Manager) 

 СИНТАКСИС 
 
 
kldload vinum
 
 

 ОПИСАНИЕ 

 vinum  - диспетчер логических томов, созданный по мотивам, но не на основе
диспетчера томов  Veritas Volume Manager . Он обеспечивает следующие возможности: 

 
 Независимые от устройств логические диски, которые называют  томами . Тома не ограничены
размерами дисков системы. 
 Тома состоят из одного или более  сплетений , каждое из которых содержит все
адресное пространство тома. Это дает реализацию массива RAID-1 (зеркалирование). Несколько
сплетений могут также использоваться для: 
 
 Повышения пропускной способности при чтении. Драйвер  vinum  будет читать данные с наименее
активного диска, так что, если в томе есть сплетения на нескольких физических дисках, 
больше данных можно будет читать параллельно.  vinum  читает данные только с одного сплетения,
но записывает - на все сплетения. 
 Повышения надежности. Если сплетения хранятся на разных физических дисках, данные остаются
доступными даже когда одно из сплетений становится недоступным. По сравнению со сплетением типа 
RAID-5 (см. ниже), использование нескольких сплетений требует больше места на дисках, но
дает более высокую производительность, особенно в случае сбоя диска. 
 Дополнительные сплетения можно использовать для оперативной реорганизации данных.
Путем подключения дополнительного сплетения и последующего отключения одного из старых сплетений
можно оперативно переносить данные с одного диска на другой без потери доступа к ним. 
 Дополнительное сплетение можно использовать для получения согласованного дампа файловой
системы. Если подключить дополнительное сплетение и отключить его в определенный момент времени,
отключенное сплетение будет точным моментальным снимком файловой системы на момент отключения. 
 

 Каждое сплетение состоит из одной или нескольких логических секций
диска, которые называют  поддисками . Поддиски определяются как непрерывный фрагмент 
физического диска. Сплетение может состоять из любого разумного количества поддисков (другими
словами, реальное ограничение определяется не формальным числом, а другими факторами, 
такими как память и производительность, связанными с поддержкой большого количества
поддисков). 
 Поддерживается несколько структур поддисков для сплетений:
 
 Конкатенированные сплетения состоят из одного или нескольких поддисков, каждому из
которых соответствует непрерывный фрагмент адресного пространства сплетения. 
 Сплетения с чередованием (striped plexes) состоят из одного или нескольких поддисков
одинакового размера. Адресное пространство файла сопоставляется полосам, на размер которых
нацело делится размер поддиска. Последовательное адресное пространство сплетения сопоставляется
полосам каждого поддиска по очереди. Все поддиски сплетения с чередованием должны быть одного
размера. 
 Сплетения типа RAID-5 должны состоять, как минимум, из трех поддисков равного размера.
Они похожи на сплетения с чередованием, но в каждой полосе на одном из поддисков хранится информация
о четности (parity information). Этот поддиск для каждой полосы меняется: для первой полосы это будет
первый поддиск, для второй полосы - второй и т.д. В случае сбоя одного диска драйвер
 vinum  восстановит данные на основе информации, хранящейся на оставшихся поддисках. Такая структура
хорошо подходит для интенсивного чтения данных. Все поддиски сплетения типа RAID-5 должны быть одинакового
размера. 
 
 
 Диски - самый нижний уровень в иерархии хранения. Они представлены специальными файлами
устройств для физических дисков. 
 Драйвер  vinum  обеспечивает автоматический запуск. В отличие от файловых систем UNIX,
тома  vinum  содержат всю необходимую информацию о конфигурации, чтобы они корректно
запускались при включении соответствующей подсистемы. Это также существенное преимущество по
сравнению с файловой системой Veritas™ File System. Эта особенность связана с наличием
томов. Она не означает, что тома будут монтироваться автоматически, поскольку эта функция
выполняется стандартными процедурами запуска с помощью файла  /etc/fstab . 
 

 КОНФИГУРИРОВАНИЕ ЯДРА 

 Драйвер  vinum  в настоящее время поставляется как модуль KLD (загружаемый модуль
ядра), и не требует конфигурирования. Как и с другими модулями KLD, абсолютно необходимо, чтобы
версия KLD совпадала с версией операционной системы. В противном случае, драйвер  vinum  
выдаст сообщение об ошибке и прекратит работу. 

 Можно сконфигурировать  vinum  в ядре, но это не рекомендуется. Для этого добавьте следующую
строку в файл конфигурации ядра: 
    device vinum
 

   Опции отладки 

 Текущая версия  vinum , как модуль ядра, так и пользовательская программа  vinum(8) ,
включает интенсивную поддержку отладки. Ее пока удалять не рекомендуется, но если и удалять, то и
из ядра, и из пользовательских компонентов. Для этого отредактируйте файлы 
 /usr/src/sbin/vinum/Makefile  и  /usr/src/sys/modules/vinum/Makefile , убрав из
переменной  CFLAGS  опцию  -DVINUMDEBUG . Если вы сконфигурировали  vinum  в
ядро, либо добавьте строку 
    options VINUMDEBUG
 
 в файл конфигурации ядра, либо удалите опцию  -DVINUMDEBUG  из файла
 /usr/src/sbin/vinum/Makefile , как описано выше. 

 Если переменные  VINUMDEBUG  не совпадают, утилита  vinum(8) 
не сработает, выдавая сообщение, объясняющее причину проблемы и что делать, чтобы ее устранить. 

   Другие опции 
      options VINUM_AUTOSTART
 
 Требует от драйвера  vinum  автоматически просматривать все доступные диски при
подключении (at attach time). Этот способ не рекомендуется использовать - он предназначен,
в основном, для сред, где нежелательна зависимость от переменных среды ядра,
устанавливаемых с помощью  loader(8) . 

 Драйвер  vinum  ранее был досупен в двух версиях: свободно доступная версия, не
включающая поддержку массивов RAID-5, и полная версия, поддерживающая RAID-5, которая
распространялась только компанией  Cybernet Systems Inc . Текущая версия  vinum 
включает поддержку RAID-5. 

 ИСПОЛЬЗОВАНИЕ VINUM 

 Драйвер  vinum  является частью базовой системы FreeBSD. Он не требует установки. Для его запуска
выполните программу  vinum(8) , которая загрузит соответствующий модуль 
KLD, если его еще нет. Перед использованием  vinum , его необходимо сконфигурировать.
Подробнее о создании конфигурации  vinum  см. на странице справочного руководства 
 vinum(8) .  

 Обычно сконфигурированная версия  vinum  запускается при загрузке. Установите
переменной  start_vinum  в каталоге  /etc/rc.conf  значение " YES ",
чтобы  vinum  запускался при загрузке. (Подробнее см. на странице справочного
руководства  rc.conf(5) .) 

 Если драйвер  vinum  загружен как модуль KLD (рекомендованный способ), команда 
 vinum stop  выгрузит его (см.  vinum(8) ).  
Это также можно сделать с помощью команды  kldunload(8) . 

 Модуль KLD можеть быть выгружен только если он не работает, другими словами,
когда ни один том не смонтирован и не работают другие экземпляры программы  vinum(8) .
Выгрузка модуля KLD не повреждает данные, хранящиеся в томах. 

   Конфигурирование и запуск объектов 

 Для конфигурирования и запуска объектов  vinum  используйте утилиту 
 vinum(8) . 

 АВТОМАТИЧЕСКИЙ ЗАПУСК 

 Подсистему  vinum  можно автоматически запускать при подключении. Для этого
можно устанавливать две переменные среды ядра в файле 
 loader.conf(5) . 

 
 vinum.autostart 
Если эта переменная установлена (независимо от значения), функция  attach 
будет пытаться просканировать все доступные диски в поисках допустимых записей конфигурации
 vinum . Это - предпочтительный способ обеспечения автоматического запуска,
если он необходим.

 Пример: 
     vinum.autostart="YES"
 
 
 vinum.drives 
В качестве альтернативы, можно задать в этой переменной список дисковых устройств, которые
необходимо просматривать в поисках записей о конфигурации.
Учтите, что указывать надо только имена "базовых" устройств (дисков в целом),
поскольку  vinum  будет автоматически просматривать все возможные секции и разделы.

 Пример: 
     vinum.drives="da0 da1"
 
 

 Если используется автоматический запуск, устанавливать переменную  start_vinum 
в файле  rc.conf(5)  не обязательно. Учтите, что если  vinum 
должен предоставить том для корневой файловой системы, необходимо запускать эту подсистему на ранней
стадии. Этого можно добиться, указав 
     vinum_load="YES"
 
 в файле  loader.conf(5) . 

 ВЫЗОВЫ IOCTL 

 Вызовы  ioctl(2)  предназначены для использования только программой
конфигурирования  vinum(8) . Они описаны в заголовочном файле
 /sys/dev/vinum/vinumio.h . 

   Метки диска 
 Обычные дисковые устройства имеют метку диска во втором секторе устройства. Подробнее об
этом см. на странице справочного руководства  disklabel(5) .
Эта метка диска описывает структуру разделов на устройстве.  vinum  не делит тома на
части, поэтому у томов физической метки диска нет. Для удобства,  vinum  реализует 
вызовы  ioctl   DIOCGDINFO  (получить метку диска),  DIOCGPART  (получить
информацию о разделе),  DIOCWDINFO  (записать информацию о разделе) и  DIOCSDINFO  
(установить информацию о разделе).  Вызовы  DIOCGDINFO  и  DIOCGPART  ссылаются на
внутреннее представление метки диска, которой фактически нет на томе. В результате, 
опция  -r  команды  disklabel(8) , которая
читает диск "непосредственно", не сработает. 

 В общем случае, выполнять команду  disklabel(8)  для тома
 vinum  бесполезно. Если выполнить ее, она покажет три раздела, ' a ', ' b ' и
' c ', отличающиеся значением  fstype , например: 
 3 partitions:
#        size   offset    fstype  [fsize bsize bps/cpg]
  a:     2048        0    4.2BSD    1024  8192     0   # (Cyl.0 - 0)
  b:     2048        0      swap                       # (Cyl.0 - 0)
  c:     2048        0    unused       0     0         # (Cyl.0 - 0)
 
 vinum  игнорирует вызовы  DIOCWDINFO  и  DIOCSDINFO , поскольку менять нечего.
В результате, любая попытка изменить метку диска будет молча проигнорирована. 

 СОЗДАНИЕ ФАЙЛОВЫХ СИСТЕМ 

 Поскольку тома  vinum  не содержат разделов, их имена не должны следовать
стандартным правилам именования разделов диска. Для физического раздела диска 
последняя буква в имени устройства задает идентификатор раздела (от  a  до  h ).
Тома  vinum  не обязаны следовать этому соглашению, но в этом случае программа 
 newfs(8)  будет сообщать о том, что не может определить раздел.
Для решения этой проблемы указывайте флаг  -v  при вызове  newfs(8) . Например,
при наличии тома  concat  используйте следующую команду для создания на нем файловой
системы UFS: 
     newfs -v /dev/vinum/concat
 

 ИМЕНОВАНИЕ ОБЪЕКТОВ 

 Утилита  vinum  присваивает стандартные имена сплетениям и поддискам, хотя их можно изменить,
задав явно. Мы не рекомендуем изменять стандартные имена. Опыт использования
диспетчера томов Veritas™, позволяющего именовать объекты произвольным образом, показал,
что такая гибкость не дает существенных преимуществ и может сбивать с толку. 

 Имена могут содержать любые непробельные символы, но рекомендуется ограничится буквами,
цифрами и символами подчеркивания. Имена томов, сплетений и поддисков могут быть длиной до
64 символов, а имена дисков - до 32 символов. При выборе имен томов и сплетений помните,
что автоматически генерируемые имена сплетений и поддисков длинее имен, на основании
которых они построены. 

 
 Когда  vinum  создает или удаляет объекты, он создает каталог  /dev/vinum ,
в котором он создает специальные файлы устройств для каждого найденного тома. Он также
создает подкаталоги  /dev/vinum/plex  и  /dev/vinum/sd , в которых создает
специальные файлы устройств для сплетений и поддисков. Кроме того, он создает еще
два подкаталога,  /dev/vinum/vol  и  /dev/vinum/drive , в которых сохраняется
информация об иерархических отношениях между томами и дисками. 
 Кроме того,  vinum  создает три суперустройства:  /dev/vinum/control ,
 /dev/vinum/Control  и  /dev/vinum/controld .  Устройство  /dev/vinum/control  
используется утилитой  vinum(8) , когда она скомпилирована
без опции  VINUMDEBUG , устройство  /dev/vinum/Control  используется утилитой 
 vinum(8) , когда она скомпилирована
с опцией  VINUMDEBUG , а  /dev/vinum/controld  используется демоном  vinum .
Два управляющих устройства для  vinum(8)  используются для синхронизации состояния
отладки ядра и пользовательских модулей. 
 В оличие от дисков UNIX, тома  vinum  не делятся на разделы и поэтому не содержат
метки диска. К сожалению, это сбивает с толку ряд утилит, в частности, 
 newfs(8) , которая обычно пытается интерпретировать последнюю
букву в имени тома  vinum  как идентификатор раздела. Если вы используете имя тома,
не заканчивающееся буквами от ' a ' до ' c ', необходимо использовать флаг  -v 
команды  newfs(8) , чтобы она игнорировала это соглашение. 
 Сплетениям явно задавать имена не нужно. По умолчанию, имя сплетения строится как имя
тома, после которого идут символы  .p  и номер сплетения. Например, сплетения тома 
 vol3  называются  vol3.p0 ,  vol3.p1  и т.п. Эти имена можно изменить,
но это не рекомендуется. 
 Как и сплетения, поддиски получают имена автоматически, и явное их именование не рекомендуется.
Имя поддиска строится как имя сплетения, за которым идут символы  .s  и число, идентифицирующее поддиск.
Например, поддиски сплетения  vol3.p0  называются  vol3.p0.s0 ,  vol3.p0.s1  и т.д. 
 В отличие от этого, диски надо именовать явно. Это позволяет переносить диск в другое место
и, тем не менее, автоматически распознавать его. Имена дисков должны быть длиной до 32 символов. 
 

   Пример 

 Пусть созданы объекты, описанные в разделе  ФАЙЛ 
КОНФИГУРАЦИИ  страницы справочного руководства  vinum(8) . Каталог  /dev/vinum  
будет иметь вид: 

    # ls -lR /dev/vinum
   total 5
   brwxr-xr--  1 root  wheel   25,   2 Mar 30 16:08 concat
   brwx------  1 root  wheel   25, 0x40000000 Mar 30 16:08 control
   brwx------  1 root  wheel   25, 0x40000001 Mar 30 16:08 controld
   drwxrwxrwx  2 root  wheel   512 Mar 30 16:08 drive
   drwxrwxrwx  2 root  wheel   512 Mar 30 16:08 plex
   drwxrwxrwx  2 root  wheel   512 Mar 30 16:08 rvol
   drwxrwxrwx  2 root  wheel   512 Mar 30 16:08 sd
   brwxr-xr--  1 root  wheel   25,   3 Mar 30 16:08 strcon
   brwxr-xr--  1 root  wheel   25,   1 Mar 30 16:08 stripe
   brwxr-xr--  1 root  wheel   25,   0 Mar 30 16:08 tinyvol
   drwxrwxrwx  7 root  wheel   512 Mar 30 16:08 vol
   brwxr-xr--  1 root  wheel   25,   4 Mar 30 16:08 vol5

   /dev/vinum/drive:
   total 0
   brw-r-----  1 root  operator    4,  15 Oct 21 16:51 drive2
   brw-r-----  1 root  operator    4,  31 Oct 21 16:51 drive4

   /dev/vinum/plex:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x10000002 Mar 30 16:08 concat.p0
   brwxr-xr--  1 root  wheel   25, 0x10010002 Mar 30 16:08 concat.p1
   brwxr-xr--  1 root  wheel   25, 0x10000003 Mar 30 16:08 strcon.p0
   brwxr-xr--  1 root  wheel   25, 0x10010003 Mar 30 16:08 strcon.p1
   brwxr-xr--  1 root  wheel   25, 0x10000001 Mar 30 16:08 stripe.p0
   brwxr-xr--  1 root  wheel   25, 0x10000000 Mar 30 16:08 tinyvol.p0
   brwxr-xr--  1 root  wheel   25, 0x10000004 Mar 30 16:08 vol5.p0
   brwxr-xr--  1 root  wheel   25, 0x10010004 Mar 30 16:08 vol5.p1

   /dev/vinum/sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20000002 Mar 30 16:08 concat.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100002 Mar 30 16:08 concat.p0.s1
   brwxr-xr--  1 root  wheel   25, 0x20010002 Mar 30 16:08 concat.p1.s0
   brwxr-xr--  1 root  wheel   25, 0x20000003 Mar 30 16:08 strcon.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100003 Mar 30 16:08 strcon.p0.s1
   brwxr-xr--  1 root  wheel   25, 0x20010003 Mar 30 16:08 strcon.p1.s0
   brwxr-xr--  1 root  wheel   25, 0x20110003 Mar 30 16:08 strcon.p1.s1
   brwxr-xr--  1 root  wheel   25, 0x20000001 Mar 30 16:08 stripe.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100001 Mar 30 16:08 stripe.p0.s1
   brwxr-xr--  1 root  wheel   25, 0x20000000 Mar 30 16:08 tinyvol.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100000 Mar 30 16:08 tinyvol.p0.s1
   brwxr-xr--  1 root  wheel   25, 0x20000004 Mar 30 16:08 vol5.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100004 Mar 30 16:08 vol5.p0.s1
   brwxr-xr--  1 root  wheel   25, 0x20010004 Mar 30 16:08 vol5.p1.s0
   brwxr-xr--  1 root  wheel   25, 0x20110004 Mar 30 16:08 vol5.p1.s1

   /dev/vinum/vol:
   total 5
   brwxr-xr--  1 root  wheel   25,   2 Mar 30 16:08 concat
   drwxr-xr-x  4 root  wheel   512 Mar 30 16:08 concat.plex
   brwxr-xr--  1 root  wheel   25,   3 Mar 30 16:08 strcon
   drwxr-xr-x  4 root  wheel   512 Mar 30 16:08 strcon.plex
   brwxr-xr--  1 root  wheel   25,   1 Mar 30 16:08 stripe
   drwxr-xr-x  3 root  wheel   512 Mar 30 16:08 stripe.plex
   brwxr-xr--  1 root  wheel   25,   0 Mar 30 16:08 tinyvol
   drwxr-xr-x  3 root  wheel   512 Mar 30 16:08 tinyvol.plex
   brwxr-xr--  1 root  wheel   25,   4 Mar 30 16:08 vol5
   drwxr-xr-x  4 root  wheel   512 Mar 30 16:08 vol5.plex

   /dev/vinum/vol/concat.plex:
   total 2
   brwxr-xr--  1 root  wheel   25, 0x10000002 Mar 30 16:08 concat.p0
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 concat.p0.sd
   brwxr-xr--  1 root  wheel   25, 0x10010002 Mar 30 16:08 concat.p1
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 concat.p1.sd

   /dev/vinum/vol/concat.plex/concat.p0.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20000002 Mar 30 16:08 concat.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100002 Mar 30 16:08 concat.p0.s1

   /dev/vinum/vol/concat.plex/concat.p1.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20010002 Mar 30 16:08 concat.p1.s0

   /dev/vinum/vol/strcon.plex:
   total 2
   brwxr-xr--  1 root  wheel   25, 0x10000003 Mar 30 16:08 strcon.p0
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 strcon.p0.sd
   brwxr-xr--  1 root  wheel   25, 0x10010003 Mar 30 16:08 strcon.p1
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 strcon.p1.sd

   /dev/vinum/vol/strcon.plex/strcon.p0.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20000003 Mar 30 16:08 strcon.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100003 Mar 30 16:08 strcon.p0.s1

   /dev/vinum/vol/strcon.plex/strcon.p1.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20010003 Mar 30 16:08 strcon.p1.s0
   brwxr-xr--  1 root  wheel   25, 0x20110003 Mar 30 16:08 strcon.p1.s1

   /dev/vinum/vol/stripe.plex:
   total 1
   brwxr-xr--  1 root  wheel   25, 0x10000001 Mar 30 16:08 stripe.p0
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 stripe.p0.sd

   /dev/vinum/vol/stripe.plex/stripe.p0.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20000001 Mar 30 16:08 stripe.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100001 Mar 30 16:08 stripe.p0.s1

   /dev/vinum/vol/tinyvol.plex:
   total 1
   brwxr-xr--  1 root  wheel   25, 0x10000000 Mar 30 16:08 tinyvol.p0
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 tinyvol.p0.sd

   /dev/vinum/vol/tinyvol.plex/tinyvol.p0.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20000000 Mar 30 16:08 tinyvol.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100000 Mar 30 16:08 tinyvol.p0.s1

   /dev/vinum/vol/vol5.plex:
   total 2
   brwxr-xr--  1 root  wheel   25, 0x10000004 Mar 30 16:08 vol5.p0
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 vol5.p0.sd
   brwxr-xr--  1 root  wheel   25, 0x10010004 Mar 30 16:08 vol5.p1
   drwxr-xr-x  2 root  wheel   512 Mar 30 16:08 vol5.p1.sd

   /dev/vinum/vol/vol5.plex/vol5.p0.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20000004 Mar 30 16:08 vol5.p0.s0
   brwxr-xr--  1 root  wheel   25, 0x20100004 Mar 30 16:08 vol5.p0.s1

   /dev/vinum/vol/vol5.plex/vol5.p1.sd:
   total 0
   brwxr-xr--  1 root  wheel   25, 0x20010004 Mar 30 16:08 vol5.p1.s0
   brwxr-xr--  1 root  wheel   25, 0x20110004 Mar 30 16:08 vol5.p1.s1
 

 В случае неподключенных сплетений и поддисков, именование выполняется наоборт.
Имена поддисков строятся на основе имен дисков, на которых они находятся, а сплетения
именуются на базе соответствующего поддиска.  Это соответствие еще надо  определеить. 

   Состояния объекта 

 Каждый объект  vinum  находится в определенном состоянии.  vinum  использует это
состояние для определения того, что можно делать с объектом. 

   Состояния тома 

 Тома могут находиться в следующих состояниях: 
 
 down 
Том полностью недоступен. 
 up 
Том запущен и хотя бы частично работоспособен. Могут быть доступны не все сплетения. 
 

   Состояния сплетения 

 Сплетения могут быть в следующих состояниях: 
 
 referenced 
Сплетение, на которое ссылаются как на часть тома, но которое сейчас не известно. 
 
 faulty 
Сплетение, полностью отключенное из-за ошибок ввода/вывода.
 
 down 
Сплетение, отключенное администратором.
 
 initializing 
Сплетение в процессен инициализации. 
 

 Остальные состояния представляют сплетения, которые хотя бы частично работают. 

 
 corrupt 
Сплетение, как минимум, частично работает. Не все поддиски доступны и произошло рассогласование.
Если не осталось ни одного неповрежденного сплетения, том больше не является согласованным.
 
 degraded 
Достпуное сплетение типа RAID-5, но один из его поддисков не работает, что требует восстановления
многих запросов ввода/вывода.
 
 flaky 
Работающее фактически сплетение, один из поддисков которого находится в состоянии  reborn  и не
заслуживает полного доверия, и с которого, по возможности. не хотелось бы читать данные.
 
 up 
Полностью работающее сплетение. Все поддиски находятся в состоянии  up . 
 

   Состояния поддиска 

 Поддиски могут находиться в следующих состояниях: 
 
 empty 
Полностью созданный поддиск. Все поля корректны и диск был обновлен, но ... 
( but the on the disk is not valid  - что бы это значило?  Прим. В.К. ).
 
 referenced 
Поддиск, на который ссылаются как на часть сплетения, но который сейчас не известен.
 
 initializing 
Поддиск, который был полностью создан и находится в процессе инициализации. 
 

 Следующие состояния представляют некорректные данные. 
 
 obsolete 
Поддиск был полностью создан. Все поля корректны, конфигурация на диске была
обновлена и данные были корректными, но после этого диск был отключен, и, в результате,
обновления были утеряны.
 
 stale 
Поддиск был полностью создан. Все поля корректны, диск был обновлен и данные были
корректными, но после этого произошел сбой диска и обновления были утеряны. 
 

 Следуюшие состояния представляют корректные, но недоступные данные. 
 
 crashed 
Поддиск был полностью создан. Все поля корректны, диск был обновлен и данные были
корректными, но после этого диск перестал работать. Никаких попыток записи на поддиск после
сбоя не было, поэтому данные на нем корректны.
 
 down 
Поддиск работал, содержал корректные данные и был отключен администратором. Данные на нем корректны.
 
 reviving 
Поддиск находится в процессе восстановления ("оживления"). На него можно записывать, но
нельзя читать. 
 

 Следующие состояния представляют доступные поддиски с корректными данными. 
 
 reborn 
Поддиск был полностью создан. Все поля корректны, диск был обновлен и данные корректны, но,
после этого диск останавливался и снова запускался. Обновления не были потеряны, но возможно,
что поддиск был поврежден. Мы не будем, по возможности, читать с этого поддиска. Если это
единственный поддиск, покрывающий соответствующих фрагмент адресного пространства сплетения,
при таких обстоятельствах ему устанавливается состояние  up , поэтому данное состояние
предполагает, что для выполнения запроса доступен другой поддиск.
 
 up 
Поддиск был полностью создан. Все поля корректны, диск был обновлен и данные корректны. 
 

   Состояния диска 

 Диски могут находиться в следующих состояниях: 
 
 referenced 
Как минимум, один поддиск ссылается на диск, но он сейчас недоступен для системы.
Имя устройства неизвестно.
 
 down 
Диск недоступен.
 
 up 
Диск доступен и работает. 
 

 ОШИБКИ 

 vinum  - новый продукт. Ошибки в нем вполне ожидаемы. Механизм конфигурирования
еще работает не полнстью. Если вы столкнетесь с трудностями, обратитесь к разделу 
 РЕШЕНИЕ ПРОБЛЕМ С VINUM  прежде чем сообщать об ошибках. 

 Ядра с устройством  vinum , похоже, работают, но не поддерживаются. Если в такой
конфигурации возникают проблемы, сначала, пожалуйста, замените ядро не не содержащее
 vinum  и протестируйте работу с модулем KLD. 

 Выявление отличий между версией ядра и версией модуля KLD пока не реализовано. 

 Поддержка RAID-5 появилась в версии FreeBSD 3.3. Сообщали о некоторых проблемах при
использовании  vinum  в сочетании с soft updates, но они воспроизводятся не на
всех системах. Если вы предполагаете использовать  vinum  в производственной среде,
пожалуйста, тщательно протестируйте систему. 

 РЕШЕНИЕ ПРОБЛЕМ С VINUM 

 Решение проблем с драйвером  vinum  может оказаться делом сложным. В этом разделе
предлагаются некоторые подходы. 

   Проблемы конфигурации 

 Проблемы конфигурации  vinum  возникают достаточно легко (слишком легко). Если вы столкнетесь
с такой проблемой, прежде всего, прекратите изменения конфигурации: 
 vinum setdaemon 4
 
 Эта команда остановит изменения и дальнейшие повреждения конфигурации на диске. 

 Далее, получите конфигурацию с диска, с помощью следующих команд в командном 
интерпретаторе Bourne-style: 

 rm -f log
for i in /dev/da0s1h /dev/da1s1h /dev/da2s1h /dev/da3s1h; do
  (dd if=$i skip=8 count=6|tr -d '\000-\011\200-\377'; echo) >> log
done
 

 Имена устройств - это имена всех секций  vinum . Файл  log  должен, в результате,
содержать что-то вроде следующего: 

 IN VINOpanic.lemis.comdrive1}6E7~^K6T^Yfoovolume obj state up
volume src state up
volume raid state down
volume r state down
volume foo state up
plex name obj.p0 state corrupt org concat vol obj
plex name obj.p1 state corrupt org striped 128b vol obj
plex name src.p0 state corrupt org striped 128b vol src
plex name src.p1 state up org concat vol src
plex name raid.p0 state faulty org disorg vol raid
plex name r.p0 state faulty org disorg vol r
plex name foo.p0 state up org concat vol foo
plex name foo.p1 state faulty org concat vol foo
sd name obj.p0.s0 drive drive2 plex obj.p0 state reborn len 409600b driveoffset 265b plexoffset 0b
sd name obj.p0.s1 drive drive4 plex obj.p0 state up len 409600b driveoffset 265b plexoffset 409600b
sd name obj.p1.s0 drive drive1 plex obj.p1 state up len 204800b driveoffset 265b plexoffset 0b
sd name obj.p1.s1 drive drive2 plex obj.p1 state reborn len 204800b driveoffset 409865b plexoffset 128b
sd name obj.p1.s2 drive drive3 plex obj.p1 state up len 204800b driveoffset 265b plexoffset 256b
sd name obj.p1.s3 drive drive4 plex obj.p1 state up len 204800b driveoffset 409865b plexoffset 384b
 

 Первая строка содержит метку  vinum  и должна начинаться с текста " IN VINO ". Она
также содержит имя системы. Точное определение содержится в заголовчном файле 
 /usr/src/sys/dev/vinum/vinumvar.h . Сохраненная конфигурация начинается в середине строки,
с текста " volume obj state up ", а на диске - с 9 сектора. Отсаток результатов
показывает то, что осталось от конфигурации на диске. Чтобы увидеть всю конфигурацию, может 
понадобиться увеличить аргумент  count  команды  dd(1) . 

 Конфгурация на всех дисках должна быть одинаковой. Если это не так, пожалуйста,
сообщите о проблеме, представив точное содержимое файла  log . Мало что реально можно
сделать для восстановления конфигурации на диске, но если есть копия файлов, которые
использовались для создания объектов, вы всегда сможете их пересоздать. Команда  create 
не изменяет данные на поддиске, так что она не может привести к повреждению данных.
Если вы столкнетесь с такого рода проблемой, может потребоваться использование команды 
 resetconfig . 

   Остановка системы 

 Чтобы проанализировать причины остановки, которые, как вы думаете, связаны с  vinum , надо построить
отладочное ядро (debug kernel). Подробнее о том, как это сделать, написано в руководстве разработчика
 /usr/share/doc/en/books/developers-handbook/kerneldebug.html  (если оно установлено) или
 http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/developers-handbook/kerneldebug.html . 

 Для анализа проблем  vinum  выполните следующие шаги: 
 
 Скопируйте файлы
 /usr/src/sys/modules/vinum/.gdbinit.crash ,
 /usr/src/sys/modules/vinum/.gdbinit.kernel ,
 /usr/src/sys/modules/vinum/.gdbinit.serial ,
 /usr/src/sys/modules/vinum/.gdbinit.vinum  и
 /usr/src/sys/modules/vinum/.gdbinit.vinum.paths  
в каталог, в котором вы будете выполнять анализ, обычно -  /var/crash . 

 Убедитесь, что модуль  vinum  собран с отладочной информацией. 
Стандартный  Makefile  по умолчанию создает модуль с отладочной информацией.
Если версия  vinum  в каталоге  /boot/kernel  не содержит символьной информации,
вы не получите сообщения об ошибке, но при трассировке стека символьной информации не увидите.
Проверьте модуль, прежде чем запускать  gdb(1) :
 $ file /boot/kernel/vinum.ko
/boot/kernel/vinum.ko: ELF 32-bit LSB shared object, Intel 80386,
  version 1 (FreeBSD), not stripped
 
 Если результат показывает, что из  /boot/kernel/vinum.ko  символьная информация удалена,
надо будет найти версию, в которой она есть. Обычно это будет либо 
 /usr/obj/sys/modules/vinum/vinum.ko  (если  vinum  был создан с помощью команды 
" make world "), либо  /usr/src/sys/modules/vinum/vinum.ko  (если вы собирали  vinum 
в этом каталоге). Измените файл  .gdbinit.vinum.paths  соответствующим образом. 
 
 Возьмите дамп или используйте удаленный отладчик (remote serial debugger)  gdb(1)  для
анализа проблемы. Чтобы проанализировать дамп, скажем,  /var/crash/vmcore.5 , создайте
связь  /var/crash/.gdbinit.crash  с  /var/crash/.gdbinit  и выполните команды:
 cd /var/crash
gdb -k kernel.debug vmcore.5
 
 В этом примере предполагается, что вы установили подходящее отладочное ядро в файл 
 /var/crash/kernel.debug . Если нет, укажите соответствующее имя отладочного ядра. 

 Для выполнения удаленной отладки через последовательный интерфейс (remote serial debugging),
создайте связь  /var/crash/.gdbinit.serial  с  /var/crash/.gdbinit  и выполните
команды: 
 cd /var/crash
gdb -k kernel.debug
 
 В этом случае, файл  .gdbinit  выполняет функции, необходимые для
установки соединения. Удаленная машина уже должна быть в режиме откладки:
войдите в отладчик ядра и выберите  gdb  (подробнее см. на странице
справочного руководства  ddb(4) ). Файл 
 .gdbinit.serial  предполагает, что последовательное соединение работает
со скоростью 38400 бит в секунду; если вы работаете на другой скорости, отредактируйте
файл соответствующим образом (ищите спецификацию  remotebaud ).
Следующий пример показывает сеанс удаленной отладки с помощью команды  debug 
утилиты  vinum(8) : 
 GDB 4.16 (i386-unknown-freebsd), Copyright 1996 Free Software Foundation, Inc.
Debugger (msg=0xf1093174 "vinum debug") at ../../i386/i386/db_interface.c:318
318      in_Debugger = 0;
#1  0xf108d9bc in vinumioctl (dev=0x40001900, cmd=0xc008464b, data=0xf6dedee0 "",
    flag=0x3, p=0xf68b7940) at
    /usr/src/sys/modules/Vinum/../../dev/Vinum/vinumioctl.c:102
102  Debugger ("vinum debug");
(kgdb) bt
#0  Debugger (msg=0xf0f661ac "vinum debug") at ../../i386/i386/db_interface.c:318
#1  0xf0f60a7c in vinumioctl (dev=0x40001900, cmd=0xc008464b, data=0xf6923ed0 "",
    flag=0x3, p=0xf688e6c0) at
    /usr/src/sys/modules/vinum/../../dev/vinum/vinumioctl.c:109
#2  0xf01833b7 in spec_ioctl (ap=0xf6923e0c) at ../../miscfs/specfs/spec_vnops.c:424
#3  0xf0182cc9 in spec_vnoperate (ap=0xf6923e0c) at ../../miscfs/specfs/spec_vnops.c:129
#4  0xf01eb3c1 in ufs_vnoperatespec (ap=0xf6923e0c) at ../../ufs/ufs/ufs_vnops.c:2312
#5  0xf017dbb1 in vn_ioctl (fp=0xf1007ec0, com=0xc008464b, data=0xf6923ed0 "",
      p=0xf688e6c0) at vnode_if.h:395
#6  0xf015dce0 in ioctl (p=0xf688e6c0, uap=0xf6923f84) at ../../kern/sys_generic.c:473
#7  0xf0214c0b in syscall (frame={tf_es = 0x27, tf_ds = 0x27, tf_edi = 0xefbfcff8,
      tf_esi = 0x1, tf_ebp = 0xefbfcf90, tf_isp = 0xf6923fd4, tf_ebx = 0x2,
      tf_edx = 0x804b614, tf_ecx = 0x8085d10, tf_eax = 0x36, tf_trapno = 0x7,
      tf_err = 0x2, tf_eip = 0x8060a34, tf_cs = 0x1f, tf_eflags = 0x286,
      tf_esp = 0xefbfcf78, tf_ss = 0x27}) at ../../i386/i386/trap.c:1100
#8  0xf020a1fc in Xint0x80_syscall ()
#9  0x804832d in ?? ()
#10 0x80482ad in ?? ()
#11 0x80480e9 in ?? ()
 
 При входе из отладчика важно, чтобы исходный текст фрейма 1 
(выдаваемый файлом  .gdbinit  вверху представленного примера)
содержит текст  Debugger ("vinum debug"); . 

 Это признак того, что спецификации адресо правильны. Если вы получаете
какой-то другой результат, ваша символьная информация и модуль ядра 
рассинхронизированы, и трассировка будет бессмысленной. 
 
 
 Для начального ислледования наиболее важная информация - результат представленной
выше команды  bt  ( backtrace ). 

   Информирование о проблемах с Vinum 

 Если вы обнаружите любые ошибки в  vinum , пожалуйста, 
сообщайте о них Грегу Лихи (Greg Lehey) <grog@lemis.com>. 
Предоставьте следующую информацию: 
 
 Результат, выдаваемый командой  vinum list  (см. 
 vinum(8) ). 
 Любые сообщения, выданные в файл  /var/log/messages . Все соответствующие
сообщения будут начинаться с текста " vinum ". 
 Если возникла паника ядра, - трассировку стека, которая получается
как описано выше. 
 

 АВТОРЫ 
 
Грег Лихи (Greg Lehey) <grog@lemis.com>
 

 ИСТОРИЯ 

 Утилита  vinum  впервые появилась в ОС FreeBSD 3.0. Компонент RAID-5 системы 
 vinum  был разработан для корпорации  Cybernet Inc.  ( http://www.cybernet.com ),
для ее продукта NetMAX. 

 SEE ALSO 
 
     disklabel(5) ,
     loader.conf(5) ,
     disklabel(8) ,
     loader(8) ,
     newfs(8) ,
     vinum(8) 
 

 FreeBSD 4.9, 16 мая 2003 года 

 Copyleft (no c) - Fuck copyright! 
2004  В. Кравчук ,
 OpenXS Initiative , перевод на русский язык
 

 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename