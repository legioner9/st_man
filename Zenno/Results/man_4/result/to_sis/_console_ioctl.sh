#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 console_ioctl (4) >>  console_ioctl  (4)   ( Русские man: Специальные файлы /dev/* )   console_ioctl  (4)   ( Linux man: Специальные файлы /dev/* ) 
   
 НАЗВАНИЕ 

console ioctl - ioctl для консольных терминалов и виртуальных консолей
   
 ОПИСАНИЕ 

Поддерживаются Linux-ориентированные запросы  ioctl() .  
Каждый запрос определяется третьим аргументом, далее именуемым  argp .
 
 KDGETLED 
Получить состояние индикаторов.  argp  указывает на длинное целое (long int). Младшие 
три бита  *argp  устанавливают состояние индикаторов следующим образом:
     LED_CAP       0x04   индикатор caps lock
     LEC_NUM       0x02   индикатор num lock
     LED_SCR       0x01   индикатор scroll lock
 KDSETLED 
Устанавливает состояние индикаторов. Состояние индикаторов устанавливается в соответствии с 
тремя младшими битами  argp . Однако, если установлен старший бит, индикаторы 
возвращаются в исходное состояние: отображают статус функций клавиатуры caps lock, num lock 
и scroll lock.
 
 

До появления ядра 1.1.54 индикаторы состояния отражали только состояние флагов клавиатуры, 
которые также могли быть изменены KDGETLED/KDSETLED. После появления 1.1.54 они могли отображать 
уже произвольную информацию, но по умолчанию показывали флаги клавиатуры. Описанные ниже 
два запроса ioctl используются для доступа к флагам клавиатуры.
 
 KDGKBLED 
Считывает флаги клавиатуры: CapsLock, NumLock, ScrollLock (не индикаторы).
 argp  указывает на символ (char), который получает состояния флагов.
Младшие три бита (маска 0x7) получают текущее состояние флагов, следующие три
бита (маска 0x70) присваивают устанавливаемое состояние флагам по умолчанию. 
(Со времени появления ядра 1.1.54).
 KDSKBLED 
Устанавливает флаги клавиатуры: CapsLock, NumLock, ScrollLock (не индикаторы).
 argp  содержит требуемые состояния флагов.
Три младших бита (маска 0x7) содержит состояния флагов, следующие три бита (маска 0x70)
содержат состояния флагов по умолчанию. (Со времени появления ядра 1.1.54).
 KDGKBTYPE 
Считывает тип клавиатуры. Возвращается значение, равное KB_101, определено как 0x02.
 KDADDIO 
Добавляет порт ввода/вывода (I/O) как допустимый. Эквивалентно вызову ioperm(arg,1,1).
 KDDELIO 
Удаляет порт ввода/вывода (I/O) как недопустимый. Эквивалентно вызову ioperm(arg,1,0).
 KDENABIO 
Разрешает ввод/вывод на видеокарту. Эквивалентно вызову ioperm(0x3b4, 0x3df-0x3b4+1, 1).
 KDDISABIO 
Запрещает ввод/вывод на видеокарту. Эквивалентно вызову ioperm(0x3b4, 0x3df-0x3b4+1, 0).
 KDSETMODE 
Установить текстовый/графический режим.  argp  содержит одно из двух значений:
     KD_TEXT       0x00
     KD_GRAPHICS   0x01
 KDGETMODE 
Устанавливает режим (текстовый/графический).  argp  указывает на длинное целое, 
которому присваивается одно из вышеперечисленных устанавливаемых значений.
 KDMKTONE 
Генерирует тон заданной длительности.  
Младшие 16 битов  argp  задают частоту тона (период в тактах), старшие 16 битов 
устанавливают его длительность в мсек. Если длительность равна нулю, звук выключается.
Управление возвращается 
немедленно. Например,  argp  = (125<<16) + 0x637 определяет звук, обычно 
связанный с ctrl-G. (Работает с 0.99pl1; не работает в 2.1.49-50).
 KIOCSOUND 
Начинает и останавливает генерацию звука. Младшие 16 битов  argp  определяют период 
в тактах (то есть  argp  = 1193180/частота). Значение  argp  = 0 выключает звук. 
В обоих случаях управление возвращается немедленно.
 GIO_CMAP 
Считывает текущую цветовую карту по умолчанию из ядра.  argp  указывает на массив
из 48-и байтов. (Со времени появления ядра 1.3.3).
 PIO_CMAP 
Изменяет цветовую карту по умолчанию для текстового режима.   argp  указывает на массив из 48-и 
байтов, который содержит, по порядку, значения красного, зеленого и синего для 
16-и доступных экранных цветов: 0 - составляющая выключена, 255 - полная интенсивность. 
Цвета по умолчанию, по порядку: black, dark red, dark green, brown, dark blue, dark purple, 
dark cyan, light grey, dark grey, bright red, bright green, yellow, bright blue,
bright purple, bright cyan и white.  (Со времени появления ядра 1.3.3).
 GIO_FONT 
Получить экранный шрифт (256 символов) в расширенной форме.  argp  указывает на массив из 
8192 байтов. Возвращает код ошибки  EINVAL , если текущий загруженный шрифт содержит 
512 символов или консоль находится не в текстовом режиме.
 GIO_FONTX 
Считывает экранный шрифт и связанную с ним информацию.  argp  указывает на структуру
consolefontdesc (смотри  PIO_FONTX ). При вызове поле  charcount  должно иметь 
максимальное число символов в качестве установленного значения, которое помещается в буфер, 
указываемый как 
 chardata . При возврате  charcount  и  charheight  содержат полученную 
информацию о текущем загруженном  шрифте, массив  chardata  содержит данные шрифта,
если начальное значение  charcount  показывало доступное пространство; в противном 
случае буфер остается неизменным и установленное значение  errno  равно  ENOMEM . 
(Со времени появления ядра 1.3.1).
 PIO_FONT 
Устанавливает экранный шрифт в объеме 256 символов. Шрифт загружается в знакогенератор EGA/VGA. 
 argp  указывает на карту размером 8192 байта (32 байта на символ).
Только первые  N  из них используются для шрифта 8x N  (0 <  N  <= 32).
Этот вызов также отменяет установленные соответствия символов Unicode шрифту.
 PIO_FONTX 
Устанавливает экранный шрифт и соответствующую информацию для изображения.  argp  
указывает на структуру:
 struct consolefontdesc {
   u_short  charcount ;  /* число символов в шрифте (256 или 512) */
   u_short  charheight ; /* число линий сканирования символа (1-32) */
   char * chardata ;     /* данные шрифта в расширенной форме */
};
 

Если требуется, соответственно изменяются размеры экрана и  SIGWINCH  
посылается соответствующим процессам. Этот вызов также отменяет установленные 
соответствия символов Unicode и шрифта. (Со времени появления ядра 1.3.1).
 PIO_FONTRESET 
Пересылает экранный шрифт, размер и соответствие символов Unicode шрифту в установки по 
умолчанию при загрузке.  argp  не используется, но установленное значение ее
должно быть  NULL , чтобы эта версия была совместима с будущими версиями Linux.  
(Со времени появления ядра 1.3.28).
 GIO_SCRNMAP 
Считывает разметку экрана из ядра.  argp  указывает на область размером E_TABSZ, которая
заполняется позициями символов шрифта, используемыми при отображении. Вызов возвращает бесполезную 
информацию, если текущий загруженный шрифт содержит более 256 символов.
 GIO_UNISCRNMAP 
Считывает полное экранное соответствие символов Unicode шрифту из ядра.  argp  
указывает на область размером E_TABSZ*sizeof(unsigned short), которая заполняется представлением 
в Unicode каждого символа. Специальный набор Unicode, начинающийся с U+F000, 
используется для представления перевод символов ``напрямую в шрифт''. 
(Со времени появления ядра 1.3.1).
 PIO_SCRNMAP 
Загружает ``определенную пользователем'' (четвертую) таблицу, которая отображает байты в
символах на экране консоли из ядра.  argp  указывает на область размером E_TABSZ.
 PIO_UNISCRNMAP 
Загружает ``определенную пользователем'' (четвертую) таблицу из ядра, которая переводит байты в
символы Unicode, преобразующиеся затем в экранные символы согласно текущей загруженной карте 
соответствия символов Unicode и шрифта. Специальные коды Unicode, начинающиеся с U+F000, 
могут использоваться для прямого перевода байтов в символы шрифта.  (Со времени появления 
ядра 1.3.1).
 GIO_UNIMAP 
Проверяет соответствие символов Unicode шрифту из ядра.  argp  указывает на структуру
 struct unimapdesc {
        u_short  entry_ct ;
        struct unipair * entries ;
};
 

где  entries  указывает на массив структур
 struct unipair {
        u_short  unicode ;
        u_short  fontpos ;
};
 

(Со времени появления ядра 1.1.92).
 PIO_UNIMAP 
Помещает соответствие символов Unicode и экранного шрифта в ядро.  argp  указывает 
на структуру unimapdesc. (Со времени появления ядра 1.1.92).
 PIO_UNIMAPCLR 
Сбрасывает таблицу знакогенератора (возможно использовать алгоритм хэширования). 
 argp  указывает на структуру
 struct unimapinit {
      u_short  advised_hashsize ;  /* 0, если не использовать */
      u_short  advised_hashstep ;  /* 0, если не использовать */
      u_short  advised_hashlevel ; /* 0, если не использовать */
};
 

(Со времени появления ядра 1.1.92).
 KDGKBMODE 
Считывает текущий режим клавиатуры.   argp  указывает на длинное целое 
(long), устанавливаемое значение которого равно одному из:
     K_RAW         0x00   
     K_XLATE       0x01   
     K_MEDIUMRAW   0x02   
     K_UNICODE     0x03
 KDSKBMODE 
Устанавливает текущий режим клавиатуры. 
 argp  - длинное целое (long), равное одному из значений, указанных выше.
 KDGKBMETA 
Считывает режим обработки метаклавиш.  argp  указывает на 
длинное целое (long), устанавливаемое значение которого равно одному из:
     K_METABIT     0x03   установить старший бит 
     K_ESCPREFIX   0x04   префикс escape
 KDSKBMETA 
Устанавливает режим обработки метаклавиш.
 argp  - длинное целое (long), равное одному из значений, указанных выше.
 KDGKBENT 
Считывает одну запись из таблицы трансляции клавиш (код клавиши для кода действия).  
 argp  указывает на структуру
 struct kbentry {
    u_char  kb_table ;
    u_char  kb_index ;
    u_short  kb_value ;
};
 

с двумя первыми полями, установленные значения которых представляют собой: 
 kb_table  - выбранную таблицу клавиш (0 <=  kb_table  < MAX_NR_KEYMAPS),
 kb_index  - код клавиши (0 <=  kb_index  < NR_KEYS).  
 kb_value , которой присваивается соответствующий код действия или K_HOLE, если нет такой 
клавиши, или K_NOSUCHMAP, если значение  kb_table  неверно.
 KDSKBENT 
Делает запись в таблице трансляции клавиш.  argp  указывает на структуру kbentry.
 KDGKBSENT 
Считывает запись строки одной функциональной клавиши.  argp  указывает на структуру
 struct kbsentry {
    u_char  kb_func ;
    u_char  kb_string [512];
};
 

 kb_string  равна строке, заканчивающейся нулем и соответствующей 
коду действия функциональной клавиши  kb_func .
 KDSKBSENT 
Делает запись строки одной функциональной клавиши.  argp  
указывает на структуру kbsentry.
 KDGKBDIACR 
Считывает таблицу акцентов ядра.  argp  указывает на структуру
 struct kbdiacrs { 
    unsigned int  kb_cnt ;
    struct kbdiacr  kbdiacr [256];
};
 

где  kb_cnt  - это число записей в массиве, каждая из которых является структурой
struct kbdiacr { u_char  diacr ,  base ,  result ;
};
 KDGETKEYCODE 
Считывает запись таблицы кодов клавиш ядра (сканкоды - коды клавиш).  
 argp  указывает на структуру
 struct kbkeycode { unsigned int  scancode ,  keycode ; };
 

 keycode  устанавливается в соответствии с заданным  scancode .
(Допускается 89 <=  scancode  <= 255. Для сканкодов 1 <=  scancode  <= 88, 
 keycode == scancode ). (Со времени появления ядра 1.1.63).
 KDSETKEYCODE 
Производит запись в таблицу кодов клавиш ядра.  argp  указывает на структуру kbkeycode.
(Со времени появления ядра 1.1.63).
 KDSIGACCEPT 
Вызываемый процесс показывает свою готовность к приему сигнала  argp , если он генерируется
нажатием соответствующей комбинации клавиш. (1 <=  argp  <= NSIG).  
(Смотри функцию spawn_console() в linux/drivers/char/keyboard.c).
 VT_OPENQRY 
Возвращает первую доступную (неоткрытую) консоль.
 argp  указывает на целое (int), устанавливаемое значение которого равно номеру виртуального 
терминала 
(1 <=  *argp  <= MAX_NR_CONSOLES).
 VT_GETMODE 
Считывает режим активного виртуального терминала.  argp  указывает на структуру
 struct vt_mode {
   char  mode ;    /* режим терминала */
   char  waitv ;   /* при установленном; остановка при записи, если терминал неактивен */
   short  relsig ; /* сигнал для восстановления при освобождении */
   short  acqsig ; /* сигнал для восстановления при захвате */
   short  frsig ;  /* не используется (устанавливается равным нулю) */
};
 


 mode  приобретает одно из устанавливаемых значений: 
     VT_AUTO       автоматическое переключение виртуального терминала
     VT_PROCESS    переключение контролирует процесс
     VT_ACKACQ     подтверждение переключения
 VT_SETMODE 
Устанавливает режим активного виртуального терминала.  argp  указывает на структуру vt_mode.
 VT_GETSTATE 
Считывает общую информацию о состоянии виртуального терминала.  argp  указывает на структуру
 struct vt_stat {
    ushort  v_active ;  /* активный виртуальный терминал */
    ushort  v_signal ;  /* посылаемый сигнал */
    ushort  v_state ;   /* битовая маска виртуального терминала */
};
 

Для каждого используемого виртуального терминала устанавливается соответствующий бит 
в поле  v_state . (В версиях с 1.0 до 1.1.92).
 VT_RELDISP 
Освобождает дисплей.
 VT_ACTIVATE 
Переключается на виртуальный терминал  argp  (1 <=  argp  <= MAX_NR_CONSOLES).
 VT_WAITACTIVE 
Ожидает, пока виртуальный терминал  argp  не станет активным.
 VT_DISALLOCATE 
Освобождает выделенную виртуальному терминалу  argp  память.
(Со времени появления ядра 1.1.54).
 VT_RESIZE 
Устанавливает представление размера экрана в ядре.  argp  указывает на структуру
 struct vt_sizes {
    ushort  v_rows ;       /* число строк */
    ushort  v_cols ;       /* число колонок */
    ushort  v_scrollsize ; /* больше не используется */
};
 

Этот вызов не изменяет видеорежим.
Смотрите руководство  resizecons (8). (Со времени появления ядра 1.1.54). 
 VT_RESIZEX 
Устанавливает значение различных параметров экрана в ядре.  argp  указывает на структуру
 struct vt_consize {
     ushort  v_rows ;  /* число строк */
     ushort  v_cols ;  /* число колонок */
     ushort  v_vlin ;  /* число строк экрана в пикселях */
     ushort  v_clin ;  /* число строк в пикселях на символ */
     ushort  v_vcol ;  /* число колонок экрана в пикселях */
     ushort  v_ccol ;  /* число колонок в пикселях на символ */
};
 

Любому параметру может быть присвоено установленное нулевое значение, то есть
он может быть оставлен ``без изменений'', но, если 
установлено несколько параметров, они должны быть согласованы. Этот вызов не 
изменяет видеорежим. Смотрите руководство  resizecons (8). 
(Со времени появления ядра 1.3.3).
 
 

Действие следующих ioctl зависит от первого байта структуры, указываемой  argp ,
далее называемого  subcode . Доступны только суперпользователю или владельцу
текущего tty.
 
 TIOCLINUX, subcode=0 
Выгружает дамп экрана.
Исчезло в 1.1.92.  (В ядре 1.1.92 и более поздних версий используется чтение из /dev/vcsN 
или /dev/vcsaN).  
 TIOCLINUX, subcode=1 
Считывает информацию о задании. Исчезло в 1.1.92.
 TIOCLINUX, subcode=2 
Производит выделение блока.
 argp  указывает на структуру
    struct {char  subcode ;
        short  xs ,  ys ,  xe ,  ye ;
        short  sel_mode ;
    }
 xs  и  ys  - начальные колонка и строка.  xe  и  ye  - конечные колонка и строка. 
(Левый верхний угол - строка = колонке = 1).
 sel_mode  равен нулю для выделения "символ за символом", единице для выделения 
"слово за словом" или двум для выделения "строки за строкой". Выделенные символы подсвечиваются 
и сохраняются в статическом массиве sel_buffer, определенном в devices/char/console.c.
 TIOCLINUX, subcode=3 
Вставляет выделенный блок.
Символы в буфере выделения записываются в  fd .
 TIOCLINUX, subcode=4 
Выводит экран из режима энергосбережения.
 TIOCLINUX, subcode=5 
Устанавливает содержимое 256-битной таблицы определения символов в "word" для выделения
"слово за словом". (Со времени появления ядра 1.1.32).
 TIOCLINUX, subcode=6 
 argp  указывает на символ (char), который устанавливает значение 
переменной ядра  shift_state . (Со времени появления ядра 1.1.32).
 TIOCLINUX, subcode=7 
 argp  указывает на символ (char), который устанавливает значение переменной 
ядра  report_mouse .  (Со времени появления ядра 1.1.33).
 TIOCLINUX, subcode=8 
Выгружает ширину и высоту экрана, позицию курсора и все пары символ-атрибут.
(Только в версиях с 1.1.67 по 1.1.91. В ядре 1.1.92 и более поздних версий используется 
чтение из /dev/vcsa*).
 TIOCLINUX, subcode=9 
Восстанавливает ширину и высоту экрана, позицию курсора и все пары символ-атрибут.
(Только в версиях с 1.1.67 по 1.1.91. В ядре 1.1.92 и более поздних версий используется 
запись в /dev/vcsa*).
 TIOCLINUX, subcode=10 
Обработчик функций энергосбережения для нового поколения мониторов.  
Режим погашения экрана VESA устанавливается равным  argp [1], который определяет тип гашения:
      0 : гашение экрана запрещено.
      1 : текущие установки регистров видеоадаптера сохраняются, когда контроллер 
программируется на выключение вертикальной синхронизации. Происходит перевод монитора в 
режим "резерв". Если на мониторе есть таймер Off_Mode, то он может в итоге сам выключить питание.
      2 : текущие установки сохраняются, когда и вертикальная, и 
горизонтальная развертки отключаются. Происходит перевод в режим "выключено". 
Если на мониторе нет таймера Off_Mode или Вы хотите отключить питание 
сразу же по истечении времени blank_timer, Вы можете выбрать эту опцию.  
( Внимание:  частое выключение питания может повредить монитор.)  
(Со времени появления ядра 1.1.76).
 
   
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 

При нормальном завершении работы возвращается 0, а при ошибке возвращается
значение -1 и переменной  errno  присваивается соответствующий код ошибки.
   
 НАЙДЕННЫЕ ОШИБКИ 

 errno  может принимать следующие значения:
 
 EBADF 

 
(неверный описатель файла);
 ENOTTY 

 
(описатель файла не связан со специальным 
символьным устройством, или заданный запрос не может быть выполнен);
 EINVAL 

 
(описатель файла или  argp  неверен);
 EPERM 

 
(ошибка доступа).
 
   
 ПРЕДУПРЕЖДЕНИЯ 

Не рассматривайте эту страницу руководства как документацию об ioctl консоли 
Linux. Она предназначена только для любознательных как альтернатива  
исходных текстов. Ioctl - неописанные ранее возможности Linux,  
которые могут изменяться без предупреждения. 
На самом деле, это руководство более или менее полно описывает параметры ядра версии 1.1.94; 
они несколько отличаются от параметров ядра более ранних версий.
Очень часто ioctl вводится для совместной работы ядра с какой-либо 
конкретной программой (fdisk, hdparm, setserial, tunelp, loadkeys, 
selection, setfont и т.д.), и его поведение изменяется по требованию этой программы.
Программы, использующие такие ioctl, не могут быть перенесены в другие версии
Unix, не будут работать в старых версиях Linux и могут не работать в будущих версия Linux.
Рекомендуется работать с функциями POSIX.
   
 СМ. ТАКЖЕ 

 kbd_mode (1),

 loadkeys (1),

 dumpkeys (1),

 mknod (1),

 setleds (1),

 setmetamode (1),

 ioperm (2),

 execve (2),

 fcntl (2),

 termios (3),

 console (4),

 console_codes (4),

 mt (4),

 sd (4),

 tty (4),

 ttys (4),

 vcs (4),

 vcsa (4),

 charsets (7),

 mapscrn (8),

 setfont (8),

 resizecons (8),

 /usr/include/linux/kd.h ,

 /usr/include/linux/vt.h 

 

 
   Index 
 
 НАЗВАНИЕ 
 ОПИСАНИЕ 
 ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 ПРЕДУПРЕЖДЕНИЯ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename