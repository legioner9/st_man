#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 socket (7)   socket  (2)   ( FreeBSD man: Системные вызовы )   socket  (2)   ( Русские man: Системные вызовы )   socket  (2)   ( Linux man: Системные вызовы )   socket  (3)   ( Solaris man: Библиотечные вызовы )   socket  (3)   ( POSIX man: Библиотечные вызовы )   socket  (4)   ( Linux man: Специальные файлы /dev/* ) >>  socket  (7)   ( Русские man: Макропакеты и соглашения )   socket  (7)   ( Linux man: Макропакеты и соглашения )   socket  (9)   ( FreeBSD man: Ядро ) Ключ  socket  обнаружен в базе ключевых слов. 
   
 НАЗВАНИЕ 

socket - сокетный интерфейс Linux
   
 СИНТАКСИС 

 #include < sys/socket.h > 

 

 mysocket  = socket(int  socket_family , int  socket_type , int  protocol ); 

   
 ОПИСАНИЕ 

Эта страница документации описывает пользовательский интерфейс уровня сетевых
сокетов (от англ. "socket" - разъем, гнездо) Linux. Совместимые с BSD сокеты -
это унифицированный интерфейс, служащий посредником между процессами пользователя
и стеком сетевых протоколов в ядре. Модули протоколов группируются по
 семействам протоколов ,

таким, как
 PF_INET ,  PF_IPX ,  PF_PACKET ,

и 
 типам сокетов ,

таким, как
 SOCK_STREAM 

или
 SOCK_DGRAM .

Более подробная информация о семействах и типах приведена в 
 socket (2).

   
 ФУНКЦИИ УРОВНЯ СОКЕТОВ 

Эти функции используются процессами пользователя для передачи или приема
пакетов и выполнения других операций над сокетами. Более подробная информация
приведена на соответствующих страницах руководства.
 socket (2)

создает сокет,
 connect (2)

присваивает сокету удаленный сокетный адрес, функция
 bind (2)

присваивает сокету локальный адрес,
 listen (2)

сообщает сокету, что должны приниматься новые соединения, а
 accept (2)

используется для получения нового сокета для нового входящего соединения.
 socketpair (2)

возвращает два соединенных анонимных сокета (справедливо только для некоторых
локальных семейств, таких, как:
 PF_UNIX ).

 

 send (2),

 sendto (2),

и
 sendmsg (2)

передают данные через сокет, а
 recv (2),

 recvfrom (2)

и
 recvmsg (2)

принимают данные из сокета.
 poll (2)

и
 select (2)

ожидают прихода данных или готовятся к передаче данных.
Кроме того, для чтения и записи данных могут использоваться стандартные
операции ввода-вывода, такие, как:
 write (2),

 writev (2),

 sendfile (2),

 read (2),

и
 readv (2).

 

 getsockname (2) ,- 

возвращает локальный адрес сокета, а
 getpeername (2)

возвращает удаленный адрес сокета.
 getsockopt (2)

и
 setsockopt (2)

используются для установки или считывания опций протокола или уровня сокетов.
 ioctl (2)

может быть использована для установки или чтения некоторых других опций.
 

 close (2)

используется для закрытия сокета.
 shutdown (2)

закрывает части полнодуплексного сокетного соединения.
 

Поиск (seeking) или вызов
 pread (2)

и
 pwrite (2)

(с ненулевой позицией) для сокетов программой не поддерживается.
 

Для сокетов возможно создание неблокируемого ввода/вывода путем установки
в файловый описатель сокета с помощью
 fcntl (2) - 

флага
 O_NONBLOCK .

При этом все операции, которые будут
блокироваться, будут (обычно) возвращать
 EAGAIN 

(операция должна быть повторена позднее);
 connect (2)

возвратит ошибку
 EINPROGRESS .

Пользователь может подождать прихода различных событий через
 poll (2)

или
 select (2).

 

 
 События ввода/вывода 
 Событие Флаг poll когда происходит 
 Чтение POLLIN 
пришли новые данные.
 
 Чтение POLLIN 
Установка соединения завершена
(для сокетов, ориентированных на соединения)
 
 Чтение POLLHUP 
Другая сторона инициировала запрос на разъединение.
 
 Read POLLHUP 
Соединение разорвано (только для протоколов, ориентированных на соединение).
Если производится запись в сокет, то также посылается сигнал
 SIGPIPE .

 
 Запись POLLOUT 
Сокет имеет достаточно места в буфере передачи для записи в него новых данных.
 
 Чтение/запись 
POLLIN|
 

POLLOUT
 
Исходящий
 connect (2)

завершен.
 
 Чтение/запись POLLERR произошла асинхронная ошибка. 
 Чтение/запись POLLHUP другая сторона закрыла (shut down) одно направление. 
 Исключение POLLPRI 
Пришли неотложные данные. При этом посылается сигнал
 SIGURG .

 
 

 

Альтернативой poll/select является возможность ядру информировать приложение
о событиях с помощью сигнала
 SIGIO . 

Для этого необходимо установить с помощью
 fcntl (2)

в файловом описателе сокета флаг
 FASYNC ,

а также назначить с помощью
 sigaction (2)

корректный обработчик сигнала
 SIGIO .

См. ниже раздел
 СИГHАЛЫ 

   
 ОПЦИИ СОКЕТОВ 

Следующие опции сокета могут быть установлены с помощью
 setsockopt (2)

или считаны с помощью 
 getsockopt (2)

при уровне сокета, установленном для всех сокетов и равным
 SOL_SOCKET :

 
 SO_KEEPALIVE 

 
Разрешить посылку "оживляющих" (keep-alive) сообщений на сокетах, 
ориентированных на соединение. Ожидается целочисленный логический флаг.
 SO_OOBINLINE 

 
Если эта опция запущена, то внепоточные данные помещаются непосредственно во входящий
поток данных. В противном случае внепоточные данные передаются, только если во
время приема установлен флаг
 MSG_OOB .

 SO_RCVLOWAT  и  SO_SNDLOWAT 

 
Указать минимальное количество байтов в буфере при приеме до того, как сокет определенного
уровня передаст данные протоколу
( SO_SNDLOWAT )

или пользователю
( SO_RCVLOWAT ).

Эти два значения невозможно изменить в Linux, и размер их аргумента фиксирован:
он составляет 1 байт.  
 getsockopt  

может считывать их.
 setsockopt  

всегда будет возвращать значение
 ENOPROTOOPT .

 SO_RCVTIMEO  и  SO_SNDTIMEO 

 
Указать время ожидания (при передаче или приеме) сообщения об ошибке. 
Значения этих опций в Linux зависят от протокола и не 
могут быть записаны или считаны. Их функциональность может быть эмулирована
с помощью
 alarm (2)

или
 setitimer (2).

 SO_BSDCOMPAT 

 
Разрешить совместимость ошибок (bug-to-bug) c ошибками BSD. Используется только 
модулем протокола UDP и в будущем будет удалена. Если функция запущена, то полученные
UDP-сокетом ошибки ICMP не будут передаваться программе пользователя. В Linux 2.0
эта опция также включала совместимость ошибок raw-сокетов (произвольное
изменение заголовка, пропуск флага многоадресной передачи), но в Linux 2.2 
того уже не происходит. Лучше исправить пользовательские программы, нежели приводить
в действие этот флаг.
 SO_PASSCRED 

 
Запустить или отключить прием управляющих сообщений
 SCM_CREDENTIALS .

За дополнительной информацией обращайтесь к
 unix (7).

 SO_PEERCRED 

 
Возвращает информацию о процессе, подключенном к сокету, с другой стороны.
Эффективно только для сокетов
 PF_UNIX ;

см. 
 unix (7).

Аргументом является структура
 ucred .

Эту опцию можно использовать только с
 getsockopt .

 SO_BINDTODEVICE 

 
Подключить сокет к определенному устройству, например, к lqeth0rq,
в соответствии с переданным именем интерфейса. Если имя является пустой 
строкой или длина опции равна нулю, то подключение сокета к устройствам будет 
снято. В качестве опции передается оканчивающаяся нулем строка переменной 
длины с именем интерфейса, максимальная длина которой не превышает
 IFNAMSIZ .

Если сокет подключен к интерфейсу, то им обрабатываются только пакеты этого
интерфейса. Заметим, что он сработает только для некоторых типов сокетов,
в частности, для
 AF_INET 

сокетов. Он не поддерживает пакетные сокеты (для них используйте 
 bind (8)

).
 SO_DEBUG  

 
Начать отладку сокета. Разрешено только процессам с возможностью
 CAP_NET_ADMIN 

или имеющих нулевой идентификатор эффективного пользователя.
 SO_REUSEADDR 

 
Указывает, что правила проверки адресов, передаваемых с помощью вызова
 bind (2),

должны позволять повторное использование локального адреса.
В случае с сокетами
 PF_INET 

это означает, что сокет может быть подключен, но не в тех случаях, когда 
активному слушающему сокету присвоен адрес. Если существует слушающий
сокет, подключенный к определенному порту, с адресом
 INADDR_ANY ,

то к этому порту невозможно будет подключится с любого локального адреса.
 SO_TYPE 

 
Получает тип сокета в виде целого числа (как 
 SOCK_STREAM ).

Может использоваться только с 
 getsockopt .



 SO_ACCEPTCONN 

 
Возвращает значение, обозначающее был или не был данный сокет
помечен для прослушивания и приема соединений с помощью
 listen ().

Значение 0 обозначает, что это не прослушивающий сокет.
Значение 1 обозначает, что это прослушивающий сокет.
Может использоваться только с 
 getsockopt .

 SO_DONTROUTE 

 
Hе посылать сокеты через шлюз, посылать только на машины, соединенные напрямую.
Тот же эффект может быть достигнут путем установки флага
 MSG_DONTROUTE 

во время операции
 send (2)

в сокете. В качестве параметра ожидается целочисленный логический флаг.
 SO_BROADCAST 

 
Задать или считать флаг широкого вещания. Если он установлен, то датаграммные
сокеты принимают пакеты, отправленные по широковещательному адресу, и могут
сами посылать пакеты по этому адресу. Эта опция не воздействует на
сокеты, ориентированные на потоки.
 SO_SNDBUF  

 
Задает или считывает максимальный размер буфера передачи сокета в байтах. 
Значение по умолчанию устанавливается sysctl-вызовом
 wmem_default ,

а максимальное значение устанавливается sysctl-вызовом
 wmem_max .

 SO_RCVBUF 

 
Hазначает или считывает максимальный буфер приема сокета в байтах. Значение по
умолчанию устанавливается sysctl-вызовом
 rmem_default ,

а максимальное возможное значение устанавливается sysctl-вызовом
 rmem_max .

 SO_LINGER 

 
Задает или считывает опцию
 SO_LINGER .

Аргументом является структура 
 linger .

 
 

 
 
struct linger {
    int   l_onoff;    /* задержка начата */
    int   l_linger;   /* задержать на сколько секунд  */
};

 

 

 
 
Если опция запущена, то вызовы
 close (2)

или
 shutdown (2)

приведут к задержке процесса до отправки всех сообщений в очереди сокета или до 
истечения времени задержки. В противном случае выход из вызовов будет 
произведен немедленно и закрытие будет произведено в фоновом режиме. Если сокет 
закрывается как часть вызова 
 exit (2),

то задержка всегда происходит в фоновом режиме.
 SO_PRIORITY 

 
Установить определенный для протокола приоритет всех пакетов, передаваемых из
этого сокета. Linux использует это значение для управления сетевыми очередями: 
пакеты с более высоким приоритетом могут быть обработаны раньше (в зависимости
от выбранного для устройства способа постановки в очередь). Для
 ip (7)

эта опция также устанавливает поле IP type-of-service (TOS - тип службы)
исходящих пакетов.
 SO_ERROR 

 
Получить и "сбросить" ожидающую обработки ошибку сокета. Используется только с
 getsockopt .

Ожидает целое число.
 
   
 СИГНАЛЫ 

При записи локальной или удаленной стороной информации в локальный сокет, 
ориентированный на соединение, записывающему процессу посылается сигнал
 SIGPIPE ,

а функция возвращает
 EPIPE .

Сигнал не посылается, если была вызвана функция записи с флагом
 MSG_NOSIGNAL .

 

Если был произведен fcntl-вызов 
 FIOSETOWN  

или ioctl-вызов
 SIOCSPGRP ,

то при появлении событий ввода/вывода посылается сигнал
 SIGIO .

Для определения сокета, в котором произошло событие, в обработчике можно
воспользоваться 
 poll (2)

или
 select (2).

Альтернативным способом в Linux 2.2 является установка сигналов реального 
времени с помощью fcntl-вызова
 F_SETSIG ;

будет вызван обработчик сигнала реального времени с файловым описателем,
обозначенным в поле
 si_fd 

его структуры
 siginfo_t .

Дополнительная информация приведена в
 fcntl (2).

 

В некоторых случаях (например, при наличии доступа нескольких процессов к 
одному сокету) условие, вызвавшее
 SIGIO ,

может исчезнуть на момент обработки процессом сигнала.
Если это происходит, то процесс должен подождать сигнала еще какое-то время, 
так как Linux позже снова пошлет его.
   
 СИСТЕМНЫЕ ВЫЗОВЫ 

Доступ к базовым сетевым вызовам sysctl-сокетов можно получить с помощью файлов
 /proc/sys/net/core/*  

или через интерфейс
 sysctl (2).

 
 rmem_default 

 
содержит значение буфера приема сокета в байтах, используемое по умолчанию.
 rmem_max 

 
содержит максимальное значение буфера приема сокета в байтах, которое может
установить пользователь с помощью опции сокета
 SO_RCVBUF .

 wmem_default 

 
содержит значение буфера приема сокета в байтах, используемое по умолчанию.
 wmem_max 

 
содержит максимальное значение буфера приема сокета в байтах, которое может
установить пользователь с помощью опции сокета
 SO_SNDBUF .

 message_cost  и  message_burst 

 
настраивают буферный фильтр, используемый для ограничения нагрузки сети 
предупреждающими сообщениями, вызванными внешними сетевыми событиями.
 netdev_max_backlog  

 
Максимальное количество пакетов в глобальной входящей очереди.
 optmem_max 

 
Максимальная длина вспомогательных данных и управляющих данных пользователя,
таких, как iovec, в сокете.
 
   
 СИСТЕМНЫЕ ВЫЗОВЫ 

Доступ к вызовам ioctl можно получить с помощью
 ioctl (2):

 
 error  = ioctl( ip_socket ,  ioctl_type ,  &value_result ); 
 

 

 
 SIOCGSTAMP 

 
Возвратить структуру
 struct timeval  

с меткой времени приема последнего пакета, переданного пользователю. Это полезно
для точного вычисления времени. Описание 
 struct timeval 

приведено в 
 setitimer (2).

 SIOCSPGRP 

 
Задать процесс или группу процессов, которым будут посылаться сигналы
 SIGIO 

или
 SIGURG 

по окончании выполнения асинхронной операции или при появлении срочных данных.
Аргумент является указателем на
 pid_t .

Если аргумент положителен, то сигналы будут посылаться этому процессу. Если
аргумент отрицателен, то сигналы будут посылаться группе процессов
идентификатором, равным модулю аргумента.
Если процесс не имеет возможности
 CAP_KILL 

или его эффективный идентификатор не равен нулю, то он может указывать только на себя
или свою группу процессов.
 FIOASYNC 

 
Изменить флаг
 O_ASYNC 

для запуска или отключения асинхронного режима ввода/вывода сокета. В
асинхронном режиме при появлении событий ввода/вывода посылается сигнал
 SIGIO  

или сигнал, установленный с помощью
 F_SETSIG .

 
Аргументом является целочисленный логический флаг.
 SIOCGPGRP 

 
Возвращает процесс или группу процессов, получающих сигналы
 SIGIO  

или
 SIGURG .

Если такой процесс не задан, то возвращается нулевое значение.
 
 

Возможные вызовы fcntls:
 
 FIOGETOWN 

 
То же, что и ioctl-вызов SIOCGPGRP.
 FIOSETOWN 

 
То же, что и ioctl-вызов SIOCSPGRP.
 
   
 ЗАМЕЧАНИЯ 

Linux предполагает, что половина буфера приема/передачи используется для размещения 
внутренних структур ядра; поэтому вызовы sysctl в два раза больше,
чем они кажутся.
   
 НАЙДЕННЫЕ ОШИБКИ 

Опции
 SO_ATTACH_FILTER  

и
 SO_DETACH_FILTER  

сокета
 CONFIG_FILTER  

не описаны. Рекомендуется использовать их с помощью библиотеки libcap.
   
 ВЕРСИИ 

 SO_BINDTODEVICE  

появилась в Linux 2.0.30. 
 SO_PASSCRED  

появилась в Linux 2.2.
Вызовы sysctl появились в Linux 2.2.
   
 АВТОРЫ 

Эта страница руководства была написана Энди Клином (Andi Kleen).
   
 СМ. ТАКЖЕ 

 socket (2),

 ip (7),

 setsockopt (2),

 getsockopt (2),

 packet (7),

 ddp (7)

 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 ФУНКЦИИ УРОВНЯ СОКЕТОВ 
 ОПЦИИ СОКЕТОВ 
 СИГНАЛЫ 
 СИСТЕМНЫЕ ВЫЗОВЫ 
 СИСТЕМНЫЕ ВЫЗОВЫ 
 ЗАМЕЧАНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 ВЕРСИИ 
 АВТОРЫ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename