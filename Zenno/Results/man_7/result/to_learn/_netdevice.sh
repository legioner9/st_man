#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 netdevice (7)   netdevice  (4)   ( Linux man: Специальные файлы /dev/* ) >>  netdevice  (7)   ( Русские man: Макропакеты и соглашения )   netdevice  (7)   ( Linux man: Макропакеты и соглашения ) 
   
 НАЗВАНИЕ 

netdevice - функция низкоуровневого доступа к сетевым устройствам Linux.
   
 СИНТАКСИС 

 #include < sys/ioctl.h > 

 

 #include < net/if.h > 

   
 ОПИСАНИЕ 

Эта страница руководства описывает интерфейс сокетов, используемый для
настройки сетевых устройств.
 

Linux поддерживает несколько стандартных вызовов ioctl для настройки сетевых
устройств. Они могут применяться для любого файлового описателя сокета
независимо от семейства или типа сокета. В качестве параметра передается структура
 ifreq :

 
struct ifreq {
    char            ifr_name[IFNAMSIZ];   /* Имя интерфейса */
    union {
                    struct sockaddr       ifr_addr;
                    struct sockaddr       ifr_dstaddr;
                    struct sockaddr       ifr_broadaddr;
                    struct sockaddr       ifr_netmask;
                    struct sockaddr       ifr_hwaddr;
                    short                 ifr_flags;
                    int                   ifr_ifindex;
                    int                   ifr_metric;
                    int                   ifr_mtu;
                    struct ifmap          ifr_map;
                    char                  ifr_slave[IFNAMSIZ];
                    char                  ifr_newname[IFNAMSIZ];
                    char *                ifr_data;
    };
};

struct ifconf { 
    int ifc_len;                          /* размер буфера */
    union {            
                    char *                ifc_buf; /* адрес буфера */ 
                    struct ifreq *ifc_req; /* массив структур */
    };  
};     

 

Обычно пользователь обозначает устройство, присваивая ему имя интерфейса 
 ifr_name. 

Все остальные поля структуры могут использоваться совместно.
   
 СИСТЕМНЫЕ ВЫЗОВЫ 

Если вызов ioctl считается привилегированным, то для его использования
необходим эффективный идентификатор пользователя 0 или наличие возможности
 CAP_NET_ADMIN .

В противном случае будет возвращено значение
 EPERM .

 
 SIOCGIFNAME 

 
Возвращает в
 ifr_name 

имя интерфейса с индексом
 ifr_ifindex .

Это единственный вызов ioctl, возвращающий реезультат в
 ifr_name .

 SIOCGIFINDEX 

 
Возвращает индекс интерфейса в
 ifr_ifindex .

 SIOCGIFFLAGS ,  SIOCSIFFLAGS 

 
Считывает или устанавливает слово о состоянии устройства.
 ifr_flags 

Содержит битовую маску из следующих значений:
 
 Флаги устройства 
 IFF_UP Интерфейс активен. 
 IFF_BROADCAST Установлен правильный широковещательный адрес. 
 IFF_DEBUG Флаг внутренней отладки. 
 IFF_LOOPBACK Интерфейс является устройством обратной петли. 
 IFF_POINTOPOINT Интерфейс является point-to-point соединением. 
 IFF_RUNNING Ресурсы выделены. 
 IFF_NOARP Hет протокола arp, адрес назначения 2-ого уровня (L2) не установлен. 
 IFF_PROMISC Интерфейс в "смешанном" (promiscuous) режиме. 
 IFF_NOTRAILERS Избегать использования trailers. 
 IFF_ALLMULTI Принимать все многоадресные пакеты. 
 IFF_MASTER Мастер связки балансирования загрузкой (load balancing bundle). 
 IFF_SLAVE Подчиненный связки балансирования нагрузкой. 
 IFF_MULTICAST Поддерживает многоадресное вещание. 
 IFF_PORTSEL Может выбирать тип носителя с помощью ifmap. 
 IFF_AUTOMEDIA Запущен автоматический выбор носителя. 
 IFF_DYNAMIC 
Эти адреса потеряны, если интерфейс неактивен.
 
 

Установка слова состояния устройства является привилегированной операцией, но
считывать его может любой процесс.
 SIOCGIFMETRIC ,  SIOCSIFMETRIC 

 
Считывать или установить метрику устройства с помощью
 ifr_metric .

В данный момент возможность не реализована; при считывании
 ifr_metric 

присваивается значение, равное нулю, а при попытке установки возвращается значение
 EOPNOTSUPP .

 SIOCGIFMTU ,  SIOCSIFMTU 

 
Считывает или устанавливет MTU (Maximum Transfer Unit - максимальную порцию
данных) с помощью
 ifr_mtu .

Установка MTU является привилегированной операцией. Установка слишком
маленьких значений может привести к авариям в ядре.
 SIOCGIFHWADDR ,  SIOCSIFHWADDR 

 
Считывает или устанавливает аппаратный адрес устройства из
 ifr_hwaddr .

Аппаратный адрес определяется в структуре 
 sockaddr .

 sa_family  

содержит тип устройства ARPHRD_*, 
 sa_data 

содержит аппаратный адрес L2, начиная с байта 0. 
Установка аппаратного адреса является привилегированной операцией.
 SIOCSIFHWBROADCAST 

 
Устанавливает аппаратный широковещательный адрес устройства из
 ifr_hwaddr .

Это привилегированная операция.
 SIOCGIFMAP ,  SIOCSIFMAP 

 
Считывает или устанавливает аппаратные параметры интерфейса из
 ifr_map .

Установка параметров является привилегированной операцией.
 
struct ifmap 
{
    unsigned long   mem_start;
    unsigned long   mem_end;
    unsigned short  base_addr; 
    unsigned char   irq;                  
    unsigned char   dma; 
    unsigned char   port; 
};

 

Интерпретация структуры ifmap зависит от драйвера устройства и архитектуры системы.
 SIOCADDMULTI ,  SIOCDELMULTI 

 
Добавить адрес или удалить адрес из фильтров многоадресной передачи уровня
связи устройства с помощью
 ifr_hwaddr .

Это привилегированная операция.
Альтернативный способ приведен в
 packet (7).

 SIOCGIFTXQLEN ,  SIOCSIFTXQLEN 

 
Считывать или установить размер очереди передачи устройства из
 ifr_qlen .

Установка размера очереди передачи является привилегированной операцией.
 SIOCSIFNAME 

 
Изменяет имя интерфейса, указанного в
 ifr_name ,

на
 ifr_newname .

Это привилегированная операция. Она разрешена только тогда,
когда интерфейс не активен.
 SIOCGIFCONF 

 
Возвращает список адресов интерфейса (транспортный уровень). Для поддержки 
совместимости в данный момент возвращаются только адреса семейства AF_INET 
(IPv4). Пользователь передает в качестве аргумента вызова ioctl структуру
 ifconf .

Она содержит в поле 
 ifc_req 

указатель на массив структур
 ifreq ,

а в поле 
 ifc_len 

- его длину.
Ядро заполняет структуры ifreq всеми текущими адресами третьего уровня (L3),
связанными с интерфейсом и являющимися активными: 
 ifr_name  

содержит имя интерфейса (eth0:1 и т.п.),
 ifr_addr 

содержит адрес.
Ядра устанавливают длину массива равной
 ifc_len .

Если 
 ifc_len 

равно начальной длине, то пользователь должен предположить, что
буфер переполнен, и попробовать еще раз проделать то же самое с буфером
большего размера, чтобы в него поместились все адреса. 
Если ошибок не было, то ioctl возвращает 0, в противном случае -1.
Переполнение не является ошибкой.
 
 

Большинство протоколов поддерживают свои собственные вызовы ioctl для настройки
предназначенных только для протокола параметров интерфейса. Подробности приведены
на страницах руководства о протоколах. Hастройка адресов IP описывается в
 ip (7).

 

В дополнение ко всему, некоторые устройства поддерживают частные (private)
вызовы ioctl. Здесь они не описаны.
   
 ЗАМЕЧАНИЯ 

Строго говоря, 
 SIOCGIFCONF 

является особенностью IP и принадлежит 
 ip (7).

 

Имена интерфейсов, не имеющих адресов или установленного флага
 IFF_RUNNING ,

можно определить с помощью
 /proc/net/dev .

 

Местные IP-адреса IPv6 могут быть найдены через /proc/net или по 
 rtnetlink (7).

   
 НАЙДЕННЫЕ ОШИБКИ 

glibc 2.1 не находит макрос
 ifr_newname  

в файле net/if.h. Добавьте следующие строки в вашу программу 
(как искусственный прием):
 
 
 
#ifndef ifr_newname
#define ifr_newname     ifr_ifru.ifru_slave
#endif

 

 

   
 СМ. ТАКЖЕ 

 ip (7),

 proc (7),

 rtnetlink (7)

 

 
   Index 
 
 НАЗВАНИЕ 
 СИНТАКСИС 
 ОПИСАНИЕ 
 СИСТЕМНЫЕ ВЫЗОВЫ 
 ЗАМЕЧАНИЯ 
 НАЙДЕННЫЕ ОШИБКИ 
 СМ. ТАКЖЕ 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename