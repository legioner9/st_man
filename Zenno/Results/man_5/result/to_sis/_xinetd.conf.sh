#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 xinetd.conf (5) >>  xinetd.conf  (5)   ( Русские man: Форматы файлов )   xinetd.conf  (5)   ( Linux man: Форматы файлов ) 

   
 ИМЯ 

xinetd.conf - файл с настройками xinetd

   
 ОПИСАНИЕ 

 xinetd.conf 

это файл с настройками, который определяет службы, предоставляемые  xinetd .
Любая строка, у которой первый, не являющийся пробелом символ, это '#'
считается строкой с комментарием. Пустые строки игнорируются.
 

Файл содержит блоки описания служб в виде:
 
 
service <имя_службы>
{
 <атрибут> <assign_op> <значение> <значение> ...
 ... 
 
}
 

 

 

Оператор назначения,
 assign_op, 

может принимать значения 
 '=',  

 '+=', 

 '-='. 

Главные атрибуты поддерживают только простой оператор назначения,
 '='. 

Атрибуты, которые представляют собой список значений, поддерживают все
операторы назначения. Для таких атрибутов
 '+='  

означает добавление значения в список, а
 '-=' 

означает удаление значения из списка.
Список таких атрибутов будет сформирован после того, как описаны все
атрибуты.
 

Каждый блок задает службу, которая идентифицируется через  имя_службы .
Далее идет список доступных атрибутов:
 
 id 

 
Этот атрибут используется для уникальной идентификации службы. Он полезен,
поскольку существуют службы, которые могут использовать разные протоколы,
и которые необходимо описывать в разных блоках в файле настройки.
По умолчанию, id службы имеет то же значение, что и имя службы.
 type 

 
Могут быть использованы любые комбинации следующих значений:
 
 
 RPC 

 
если служба является службой RPC
 INTERNAL 

 
если служба предоставляется  xinetd .
 UNLISTED 

 
если служба не указана в стандартном системном файле
(таком как
 /etc/rpc  

для служб RPC, или
 /etc/services 

для не-RPC служб).
 
 

 flags 

 
Могут быть использованы любые комбинации следующих флагов:
 
 
 REUSE 

 
Установить флаг
 SO_REUSEADDR 

на сокет службы (смотрите подробности в
 setsockopt (2) 

).
 INTERCEPT 

 
Перехватывать пакеты или разрешенные соединения для проверки что они
пришли с допустимых адресов (внутренние или многопоточные (multi-thread)
службы не могут быть перехвачены).
 NORETRY 

 
Не допускать попыток повтора в случае ошибки разветвления (fork).
 IDONLY 

 
Разрешать соединения только, когда удаленная сторона идентифицирует удаленного
пользователя (т.е. удаленный узел может запустить какой-либо сервер
идентификации).
Данный флаг неэффективен если не используется опция протоколирования
 USERID .

 NAMEINARGS 

 
При запуске сервера, заданного в "server", первый аргумент в "server_args"
будет argv[0] для сервера. Это позволяет вам использовать tcpd как в обычном
inetd, поместив tcpd в "server" и имя сервера в "server_args".
 NODELAY 

 
Если служба является tcp-службой и установлен флаг NODELAY, то на сокет
службы будет установлен флаг TCP_NODELAY. Если служба не является tcp-службой,
то опция не оказывает никакого влияния.
 DISABLE 

 
Флаг DISABLE задает службу, которая будет запрещена. Данный флаг перекрывает
директиву "enabled", которая включена по умолчанию.  Это значит, если вы
скажете "enabled = foo", но foo имеет флаг DISABLE, то служба foo не будет
запущена. Использование этого флага с директивой службы "disable" не
рекомендуется, так как результат непредсказуем.
 KEEPALIVE 

 
Если служба является tcp-службой и флаг KEEPALIVE установлен, то на сокет
службы будет установлен флаг SO_KEEPALIVE. Если служба не является tcp-службой,
то опция не оказывает никакого влияния.
 NOLIBWRAP 

 
Флаг зпрещает внутренний вызов библиотеки tcpwrap для определения возможности
доступа к службе. Это может понадобится для использования функциональности
libwrap недоступной для долгозапускающихся процессов, таких как xinetd;
в этом случае, программа tcpd может быть вызвана явно (смотрите флаг
NAMEINARGS).
 SENSOR 

 
Флаг заменяет службу на сенсор, который служит детектором доступа на заданный
порт. ЗАМЕЧАНИЕ: Сенсор НЕ определяет скрытое сканирование. Этот флаг
должен использоваться только для служб, которые вам не понадобятся. Когда
осуществляет доступ на порт службы, IP адрес добавляется в общий список
no_access. Это приводит к тому, что все прочие попытки с этого IP адреса
будут запрещены пока не истечет время, устанавливаемое в атрибуте deny_time.
Флаг SENSOR также заставляет xinetd установить атрибут server в значение
INTERNAL не зависимо от того, что было указано в строке с этим атрибутом.
Также важно помнить, что если socket_type установлено в значение stream,
то атрибут wait установлен быть не должен.
 
 

 disable 

 
Принимает значения "yes" или "no". В зависимости от значения служба может
быть запрещена и не будет запускаться. Смотрите описание флага DISABLE.

 socket_type 

 
Возможные значения этого атрибута включают:
 
 
 stream 

 
служба основанная на потоках данных
 dgram 

 
служба основанная на датаграммах
 raw 

 
служба, которая требует прямого доступа к IP
 seqpacket 

 
служба, которая требует надежной передачи последовательных датаграмм
 
 

 protocol 

 
определяет протокол, который обслуживается службой.
Этот протокол должен присутствовать в файле
 /etc/protocols. 

Если этот атрибут не задан, то службой будет исплользован протокол по
умолчанию.
 wait 

 
Этот атрибут отпределят, является ли служба однопоточная (single-threaded) или
многопоточная (multi-threaded). Если значение атрибута  yes , то
служба однопоточная; это означает, что  xinetd  будет запускать сервер
службы и затем не будет управлять запросами к этой службе пока сервер не
завершит свою работу. Если атрибут имеет значение  no , то служба
считается многопоточной и  xinetd  будет продолжать управлять запросами
к службе.
 user 

 
задает uid для серверного процесса. Пользователь с заданным uid должен
сушествовать в 
 /etc/passwd. 

Данный атрибут неэффективен, если эффективный ID пользователя
 xinetd  не является ID суперпользователя.
 group 

 
задает gid для серверного процесса. Группа с заданным gid должна существовать в
 /etc/group. 

Если группа не задана, будет использована группа
пользователя  user  (взятая из
 /etc/passwd). 

Данный атрибут неэффективен, если эффективный ID пользователя
 xinetd  не является ID суперпользователя.
 instances 

 
задает для какой-либо службы количество копий сервера, которое может быть
одновременно активно (по умолчанию неограничено). Значение этого атрибута
может быть или числом или
 UNLIMITED 

что означает отсутствие ограничения.
 nice 

 
задает приоритет сервера. Это значение является числом (возможно отрицательным);
смотрите подробности в  nice (3).
 server 

 
определяет программу для запуска службы.
 server_args 

 
определяет аргументы, передаваемые серверу. В отличие от  inetd ,
имя сервера  не  включается в  server_args .
 only_from 

 
определяет удаленные узлы, для которых доступна указанная служба.
Значением данного аргумента является список IP адресов, которые могут быть
заданы в любых следующих комбинациях:
 
 
 a) 

 
числовой адрес в форме %d.%d.%d.%d. Если правый компоненты это 0, то они
считаются шаблонами (например, 128.138.12.0 означает все узлы подсети
128.138.12). 0.0.0.0 означает все Интернет адреса.
 b) 

 
факторизованные адреса в виде %d.%d.%d.{%d,%d,...}.
Нет необходимости указывать все 4 компонента (т.е. %d.%d.{%d,%d,...%d} 
также правильно).
Однако, факторизованная часть должна идти в конце адреса.
 c) 

 
имя сети (из файла
 /etc/networks) 

 d) 

 
имя узла. Когда осуществляется соединение с xinetd, выполняется обратный
поиск (имени по адресу -- прим. пер.) и полученное в результате поиска
каноническое имя сравнивается с заданным именем узла. Вы можете также
использовать имена доменов в виде .domain.com.  Если обратный поиск
показал, что узел с клиентским IP находится внтури .domain.com, узел
попадет под правило.
 e) 

 
Диапазон адресов в виде IP адрес/маска, например 1.2.3.4/32.
 
 

 

 
Задание этого атрибута без значения приведет к тому, что служба не будет
доступна никому.
 no_access 

 
определяет удаленные узлы для которых указанная служба будет недоступна.
Значение этого аргумента может быть задано несколькими способами, также как
и значение атрибута  only_from . Эти два атрибута определяют как 
 xinetd  будет управлять доступом к службе с удаленных адресов.
Если для службы не задан ни один из двух атрибутов, то служба будет
доступна всем. Если заданы оба атрибута, то доступность службы определяет
тот, который лучше совпадает с адресом удаленного узла (например, если 
список  only_from  содержит 128.138.209.0 а список
 no_access  содержит 128.138.209.10, то узел с адресом
128.138.209.10 не будет иметь доступа к службе).
 access_times 

 
задает временные интервалы в течении которых служба будет доступна.
Интервал должен быть в виде  hour:min-hour:min  (соединения 
 будут  

доступны внтури этого интервала). Часы могут быть в дипазоне от 0 до 23, а
минуты от 0 до 59.
 log_type 

 
определяет, куда будет осуществляться протоколирование вывода, осуществляемого
сервером службы. Существует два формата:
 
 
 SYSLOG   syslog_facility [syslog_level] 

 
Вывод будет отправляться к syslog с заданным facility. Возможными значениями
facility являются:
 daemon, 

 auth, 

 authpriv, 

 user, 

 local0-7. 

Возможные имена уровней включают:
 emerg, 

 alert, 

 crit, 

 err, 

 warning, 

 notice, 

 info, 

 debug. 

Если уровень не задан, то сообщения будут записываться с уровнем
 info .

 FILE   файл [soft_limit [hard_limit]] 

 
Вывод будет добавляться в  файл , который будет создан, если он не
существует. Дополнительно могут быть заданы два ограничения на размер файла.
Первое ограничение является мягким;
 xinetd  

будет протоколировать сообщение первое время, когда лимит исчерпается
(если
 xinetd 

протоколирует в syslog, то сообщение будет отправлено с уровнем приоритета 
 alert 

).
Второе ограничение является жестким;
 xinetd  

будет останавливать протоколирование для соответствующей службы (если
это обычный файл, то может быть остановлено протоколирование по нескольким
службам) и если протоколирование осуществляется в syslog, то сообщение
будет отправлено с уровнем приоритета
 alert 

).
Если жесткое ограничение не задано, то по умочанию оно равняется мягкому
ограничению плюс 1%, но дополнительный размер не должен выходить за
переделы параметров
 LOG_EXTRA_MIN 
и
 LOG_EXTRA_MAX 
которые по умолчанию установлены в 5K и 20K соответственно (эти константы
задаются в  config.h ).
 
 

 log_on_success 

 
определяет какая информация протоколируется, когда сервер запускается и
когда сервер завершает работу (id службы всегда включается в протокол).
Могут быть заданы любые комбинации следующих значений:
 
 
 PID 

 
проколировать идентификатор серверного процесса (если служба реализована
через  xinetd  без разветвления другого процесса, то протоколируемый
идентификатор процесса будет 0)
 HOST 

 
протоколировать адрес удаленного узла
 USERID 

 
протоколировать идентификатор удаленного пользователя, используя протокол
идентификации RFC 1413. Данная опция доступна только для многопотоковых
служб.
 EXIT 

 
протоколировать сам факт завершения работы сервера вместе с состоянием
выхода или сигналом завершения
(если используется опция
 PID ,

то id процесса также протоколируется)
 DURATION  

 
протоколировать продолжительность сессии службы
 
 

 log_on_failure 

 
определяет какая информация протоколируется, когда сервер не может быть
запущен (или потому что нехватает ресурсов или потому что он попадает
под ограничения управления доступом). В протокол всегда включается
идентификатор службы, а также причина отказа. Могут быть заданы любые
комбинации следующих значений:
 
 
 HOST 

 
протоколировать адрес узла.
 USERID 

 
протоколировать идентификатор удаленного пользователя, используя протокол
идентификации RFC 1413. Данная опция доступна только для многопотоковых
служб.
 ATTEMPT 

 
пролоколировать факт неудачной попытки установить соединение
(эта опция неявно включается всеми другими).
 RECORD 

 
записывать информацию от удаленной стороны в случае, когда сервер не был
запущен. Это позволяет отслеживать попытки использования заданной службы.
Например, служба login протоколирует локального пользователя, удаленного
пользователя и тип терминала.
Вот список служб, которые поддерживают эту опцию в данный момент:         
 login, 

 shell, 

 exec, 

 finger. 

 
 

 rpc_version 

 
определяет версию RPC для службы RPC. Эта версия может быть одной цифрой
или диапазоном в виде  число - число .
 rpc_number 

 
определяет количество для службы RPC
 UNLISTED 

(данный атрибут игнорируется если служба не является unlisted).
 env 

 
Значение этого атрибута - это список строк в виде 'name=value'.
Данные строки будут добавлены к окружению перед запуском сервера
(таким образом окружение сервера будет включать окружение
 xinetd  плюс заданные строки).
 passenv 

 
Значение этого атрибута - это список переменных окружения из окружения
 xinetd  которые будут переданы серверу. Пустой список неявно означает
серверу не будет передано никаких переменных за исключением тех, которые
явно заданы атрибутом
 env .

(заметим что вы можете использовать данный атрибут совместо с атрибутом
 env 

чтобы задать для передачи серверу точно те аргументы, которые нужны).
 port 

 
задает порт службы. Если этот атрибут задается для службы, указанной в
 /etc/services, 

он должен быть таким же как и порт в этом файле.
 redirect 

 
Позволяет перенаправить службу tcp на другой узел. Когда xinetd получает
tcp соединение на этот порт, вызывается процесс, который устанавливает
соединение к указанному узлу и номеру порта и который пересылает все
данные между двумя узлами. Данная опция полезна, когда ваши внутренние
машины не видны снаружи. Ситаксис такой: redirect = (ip адрес) 
(порт). Вы также можете использовать в данном поле имя узла, вместо IP
адреса. Поиск адреса по имени узла выполняется только один раз, когда
xinetd запускается и пока xinetd не будет перезапущен будет использован
первый IP адрес, возвращенный при этом поиске. Атрибут "server" при задании
этой опции не требуется. Если же атрибут "server" задан, то он имеет
приоритет.
 bind 

 
Позволяет службе привязаться к заданному интерфейсу машины. Это означает,
что вы можете получить telnet сервер слушающий на локальном, безопасном
интерфейсе, а не на внешнем. Или на порте, на одном интерфейсе может
висеть что-либо одно и в то же время, на этом же порте, на другом интерфейсе
может висеть полностью другое.
Синтаксис: bind = (ip адрес интерфейса).
 interface 

 
Синоним для bind.
 banner 

 
Использует имя файла, который будет высвечиваться на удаленном узле, когда
будет установлено соединение со службой. Этот банер выдается
независимо от управления доступом. Он должнен *всегда* выдаваться,
когда установлено соединение.
 banner_success 

 
Использует имя файла, который будет высвечиваться на удаленном узле, когда
будет предоставлено соединение со службой. Этот банер выдается как
только произошло успешное подключение к службе.
 banner_fail 

 
Использует имя файла, который будет высвечиваться на удаленном узле, когда
будет соединение со службой запрещено. Этот банер выдается как
только произошел отказ подключения к службе. Это полезно для информирования
пользователей, которые делают что-либо неправильно, что они не должны
делать этого.
 per_source 

 
В качестве аргумента указвается число или "UNLIMITED". Задает максимальное
количество копий службы на исходный IP адрес. Это может также быть задано
в секции настроек по умолчанию.
 cps 

 
Ограничение частоты входящих соединений. Имеет два аргумента. Первый
аргумент - это количество соединений в секунду. Если частота входящих
соединений будет выше, служба будет временно запрещена. Второй аргумент -
это количество секунд ожидания перед тем как служба будет разрешена
после того как она была запрещена.
 max_load 

 
Использует число с плавающей точкой как величину загрузки, при достижении
которой служба будет останавливать прием соединений. Например:
2 или 2.5.  Служба остановит прием соединений при достижении этой загрузки
(load average). Эта особенность зависит от реализации операционной системы
и в данный момент поддерживается только на Linux и Solaris.
 groups 

 
Может принимать значения "yes" или "no". Если атрибут groups установлен в
"yes", то сервер запускается с доступом для групп, к которым имеет доступ
эффективный UID сервера. Если атрибут groups установлен в "no", то сервер
запускается без дополнительных групп. Данный аттрибут должен быть установлен
в "yes" для большинства BSD систем. Данный аттрибут может быть также
установлен и в секции настроек по умочанию.
 umask 

 
Унаследовать umask для этой службы. Ожидается восьмеричное значение.
Данная опция может быть установлена в секции "по умолчанию" для установки
umask для всех служб. xinetd устанавливает свои собственные umask на
предыдущую umask логически складывая ее с 022. Это umask, которая
наследуется всеми процессами-потомками, если не использована опция umask.
 enabled 

 
Разрешает список служб. Будут разрешены только те службы, которые перечислены
как аргументы данного атрибута; остальные службы будут запрещены. Если у
службы установлен атрибут "disable" или флаг "DISABLE", то эта служба 
разрешена не будет.
 include 

 
В качестве аргумента указывается имя файла в виде "include /etc/xinetd/service".
Указанный файл затем будет обработан как новый файл с настройками. Это не
тоже самое - включить содержимое данного файла в xinetd.conf на место
директивы include. Подключаемый файл должен быть в то же виде, что и
xinetd.conf. Он должен содержать внутри описание какой-либо службы. Данная
директива должна быть вне блока описания службы.
 includedir 

 
В качестве аргумента указывается каталог в виде "includedir /etc/xinetd.d".
Каждый файл внтури этого каталога, за исключением файлов с именами,
содержащими точку ('.') или заканчивающимися на ('~'), будут обработаны
как файлы с настройками для xinetd. Файлы будут обработаны в алфавитном
порядке, согласно локали C. Это позволяет вам задавать службы по одной на
файл внутри каталога. Директива
 includedir 

не может находится внутри блока описания службы.
 rlimit_as 

 
Устанавливает ограничение ресурса Адресного Пространства для указанной
службы. Директива требует один параметр, который является либо положительным
целым числом, представляющим собой количество байт, которое определяет
ограничение (для задания килобайт/мегабайт могут использоваться K или M)
или значение "UNLIMITED".  Исходя из способа реализации malloc в Linux libc,
данная директива более полезна для установки ограничения, чем rlimit_data,
rlimit_rss и rlimit_stack. Ограничение ресурса реализовано только в Linux.
 rlimit_cpu 

 
Устанавливает максимальное количество секунд CPU, которое может использовать
данная служба. Директива требует один параметр, который должен быть либо
целым положительным числом, представляющим количество секунд CPU или
значением "UNLIMITED".
 rlimit_data 

 
Устанавливает ограничение максимального размера данных для данной
службы. Директива требует один параметр, который должен быть либо
целым положительным числом, представляющим количество байт, или
значением "UNLIMITED".
 rlimit_rss 

 
Устанавливает ограничение максимального резидентного размера для данной
службы. Установка малого значения приведет к тому, что процесс будет
ближайшим кандидатом на выгрузку в своппинг на диске, когда останется
мало памяти.
Директива требует один параметр, который должен быть либо
целым положительным числом, представляющим количество байт, или
значением "UNLIMITED".
 rlimit_stack 

 
Устанавливает ограничение максимального размера стека для данной
службы. Директива требует один параметр, который должен быть либо
целым положительным числом, представляющим количество байт, или
значением "UNLIMITED".
 deny_time 

 
Устанавливает промежуток времени, в который будет запрещен доступ ко
всем службам на все IP адреса для тех, у кого сброшен флаг SENSOR.
Время указывается в минутах. Допустимы опции: FOREVER, NEVER и числовое
значение. FOREVER говорит, что данный IP адрес не будет удален пока
xinetd не будет перезапущен. NEVER оказывает влияение только на протоколирование
обиженного IP адреса. Обычно значение времени должно быть 60. Это
должно остановить большинство DOS атак и в тоже время разрешить IP адреса
который приходят из пула для легитимных целей. Данная опция должна
использоваться совместо с флагом SENSOR.
 
 

Вам не нужно задавать все из данных выше атрибутов для каждой службы.
Необходимыми атрибутами для службы являются:
 

 
 
 socket_type 

 
 user 

 
(только не- internal  службы)
 server 

 
(только не- internal  службы)
 wait 

 
 protocol 

 
(только службы  RPC  и  unlisted )
 rpc_version 

 
(только службы  RPC )
 rpc_number 

 
(только  unlisted  RPC службы)
 port 

 
(только  unlisted  не-RPC службы)
 
 


 

Следующие атрибуты поддерживают все операторы назначения:
 

 
 
 only_from 

 
 no_access 

 
 log_on_success 

 
 log_on_failure 

 
 passenv 

 
 env 

 
(не поддерживает оператор
 '-=' 

)
 
 


 

Эти атрибуты могут также встречаться более чем один раз в описании
службы. Остальные атрибуты поддерживают только оператор
 '=' 

и могут встречаться в описании службы не более одного раза.
 

Файл с настройками может также сожержать одно описание службы по умолчанию
в виде
 

 
 defaults
{
 <attribute> = <value> <value> ...
 ... 
 
 }
 

 

 

Данное описание предоставляет значения атрибутов по умолчанию для
тех служб, в которых эти атрибуты не заданы. Возможны следующие
атрибуты по умолчанию:
 

 
 
 log_type 

 
 log_on_success 

 
(накопительный эффект)
 log_on_failure 

 
(накопительный эффект)
 only_from 

 
(накопительный эффект)
 no_access 

 
(накопительный эффект)
 passenv 

 
(накопительный эффект)
 instances 

 
 disabled 

 
(накопительный эффект)
 enabled 

 
(накопительный эффект)
 
 


 

Атрибуты с накопительным эффектом могут быть заданы несколько раз, а
заданных значения каждый раз складываются (т.е. '=' не тоже самое
что '+=').
За исключением
 disabled 

все эти атрибуты означают тоже самое, как если бы они были заданы в блоке
описания службы.
 disabled 

определяет службы, которые запрещаются даже если если они описаны в
файле с настройками. Это позволяет через задание запрещенных служб в атрибуте
 disabled 

произвести быструю перенастройку, вместо того, чтобы комментировать описания
служб.
Значение этого атробута - это список разделенных пробелами идентификаторов
служб.
 enabled  

задается также как и disabled. Различие в том, что
 enabled  

является списком разрешенных служб. Если задан атрибут
 enabled  

то будут разрешены только службы, которые переислены в нем. Если
 enabled  

не задан, то будут разрешены все службы, описанные в файле с настройками,
за исключением тех, что заданы в атрибуте
 disabled. 

 

   
 ВНТУРЕННИЕ СЛУЖБЫ 

 

 xinetd  предоставляет следующие службы внутренне (основанные как
на потоках так и на датаграммах):
 echo, 

 time, 

 daytime, 

 chargen, 

и
 discard. 

Эти службы имеют такие же ограничения доступа как и все другие службы,
за исключением того, что у  xinetd  нет необходиомости производить
разветвление (fork) для них. Также ( time ,  daytime ,
и основанные на датаграммах  echo ,  chargen  и  discard ) 
не имеют ограничений по количеству
 копий. 

 

 xinetd 

также предоставляет две внутренние
 UNLISTED 

основанные на потоках службы:
 servers 

и
 services. 

Первая формирует списки информации о запущенных серверах, а вторая
предоставляет список активных в данный момент служб. Информация
выдается по одной службе на строку и каждая строка содержит имя
службы, протокол (например "tcp") и номер порта.
 

Также теперь существует административный интерфейс, который является
внтуренней службой. Зарезервировано имя службы "xadmin" и эта служба
всегда будет внутренней. Вы должны задать номер порта для этой службы
и предположительно также какое-нибудь основанное на IP управление
доступом, так чтобы в тоже время там не было никаких ограничений
по паролю. Вы можете использовать telnet на этот порт и таким образом,
по запросу, получать от xinetd какую-нибудь информацию.

   
 ЗАМЕЧАНИЯ 

 
 1. 
Следующие атрибуты служб  не могут  быть изменены или перенастроены:
 socket_type, 

 wait, 

 protocol, 

 type. 

 2. 
Когда атрибуты
 only_from 

и
 no_access 

для какой-либо службы не заданы (непосредственно или через  defaults )
то проверка адреса считается успешной (т.е. доступ запрещен не будет).
 3. 
Проверка адреса основывается на IP адресе удаленного узла, а не на
адресе его домена. Мы сделали так, чтобы мы могли не учитывать поиск
удаленного имени по адресу, который может занять много времени (так как
 xinetd 

является однопоточным, поиск имени приведет к тому, что демон не сможет
обработать другие запросы пока не осуществится поиск). С другой стороны,
если IP адрес удаленного узла изменился, то доступ к этому узлу будет
запрещен пока 
 xinetd 

не будет перенастроен.
Чтобы доступ не был запрещен независимо от изменения адреса, можно
задать сеть. Например, если IP адрес узла изменился с 1.2.3.4 на 1.2.3.5,
а only_from задан как 1.2.3.0 то доступ запрещен не будет.
 4. 
Если задана опция протоколирования
 USERID 

и на удаленный узле или не запущен сервер идентификации или приходит плохой
ответ, то доступ не будет запрещен, пока не используется флаг службы
 IDONLY .

 5. 
Перехват работает через разветвление процесса, который работает как
фильтр между удаленным узлом(узлами) и локальным сервером. Такая
реализация дает увеличение производительности и вы можете найти
для каждой службы компромисс между безопастностью и производельностью.
Следующие таблицы показывают overhead перехватов.
Первая таблица показывает время overhead-на-датаграмму для службы, основанной
на UDP, при использовании разных размеров датаграмм.
Для служб, основанных на TCP, мы измеряли уменьшение пропускной способности,
потому что перехват происходит во время отправки определенного количества
данных от клиента к серверу (время overhead должно быть таким же как и
для служб, основанных на UDP, но оно влияет только на первый пакет
продолжительной передачи данных). Количество данных дается в таблице
как  системные_вызовы x отправленные_данные_на_вызов , т.е.
как много каждый системный вызов
 send (2) 

передает байт данных.
Уменьшение пропускной способности дается в терминах байт в секунду
и как проценты от пропускной способности, когда перехват не выполняется.
Все измерения были выполнены на SparcStation IPC с запущенной SunOS 4.1.
 
 
 

 
 Размер датаграммы (байты) 
Время (миллисек)
 --------------------- 
--------------
 64 
1.19
 256 
1.51
 1024 
1.51
 4096 
3.58
 
 Байт отправлено 
Уменьшение пропускной способности
 ---------- 
-------------------
 10000x64 
941 (1.2%)
 10000x256 
4,231 (1.8%)
 10000x1024 
319,300 (39.5%)
 10000x4096 
824,461 (62.1%)
 
 

 

 

 
   
 ПРИМЕР 

 


 
 #
# Простой файл с настройками для xinetd
#

defaults
{
 
 log_type = FILE /var/log/servicelog
 log_on_success = PID
 log_on_failure = HOST RECORD
 only_from = 128.138.193.0 128.138.204.0 128.138.209.0 
 only_from = 128.138.252.1 
 instances = 10
 disabled = rstatd
 
 
}

#
# Замечание 1: атрибут protocol не требуется
# Замечание 2: атрибут instances перекрывает установки по умолчанию
#
service login
{
 
 socket_type = stream
 protocol = tcp
 wait = no
 user = root
 server = /usr/etc/in.rlogind
 instances = UNLIMITED
 
 
}

#
# Замечение 1: атрибут instances перекрывает установки по умолчанию
# Замечение 2: флаги log_on_success прибавляются
#
service shell
{
 
 socket_type = stream
 wait = no
 user = root
 instances = UNLIMITED
 server = /usr/etc/in.rshd
 log_on_success += HOST RECORD
 
 
}

service ftp
{
 
 socket_type = stream
 wait = no
 nice = 10
 user = root
 server = /usr/etc/in.ftpd
 server_args = -l
 instances = 4
 log_on_success += DURATION HOST USERID
 access_times = 2:00-9:00 12:00-24:00
 
 
}

# Ограничение сессий telnet до 8 мегабайт памяти и 20 секунд процессорного
# времени для дочерних процессов
service telnet
{
 
 socket_type = stream
 wait = no
 nice = 10
 user = root
 server = /usr/etc/in.telnetd
 rlimit_as = 8M
 rlimit_cpu = 20
 
 
}

#
# Данный блок описания службы, а также следующий, задают внутренние службы.
# Поскольку та же служба использует другой тип сокета, для создания
# уникальности описания используется разный атрибут id
service echo
{
 
 id = echo-stream
 type = INTERNAL
 socket_type = stream
 user = root
 wait = no
 
 
}

service echo
{
 
 id = echo-dgram
 type = INTERNAL
 socket_type = dgram
 user = root
 wait = no
 
 
}

service servers
{
 
 type = INTERNAL UNLISTED
 protocol = tcp
 port = 9099
 socket_type = stream
 wait = no
 
 
}

#
# Простая служба RPC
#
service rstatd
{
 
 type = RPC
 socket_type = dgram
 protocol = udp
 server = /usr/etc/rpc.rstatd
 wait = yes
 user = root
 rpc_version = 2-4
 env = LD_LIBRARY_PATH=/etc/securelib
 
 
}

#
# Простая служба unlisted
#
service unlisted
{
 
 type = UNLISTED
 socket_type = stream
 protocol = tcp
 wait = no
 server = /home/user/some_server
 port = 20020
 
 
}
 
   
 СМОТРИ ТАКЖЕ 

 xinetd (1L), 

 

 xinetd.log (5) 

 

Postel J.,
 Echo Protocol, 

RFC 862,
May 1983
 

Postel J.,
 Discard Protocol, 

RFC 863,
May 1983
 

Postel J.,
 Character Generator Protocol, 

RFC 864,
May 1983
 

Postel J.,
 Daytime Protocol, 

RFC 867,
May 1983
 

Postel J., Harrenstien K.,
 Time Protocol, 

RFC 868,
May 1983
 

StJohns M.,
  Identification Protocol, 

RFC 1413,
February 1993

   
 ОШИБКИ 

 

Если флаг
 INTERCEPT 

не используется, то управление доступом по адресу удаленного узла не
осуществляется, когда
 wait  в  yes  и  socket_type  в  stream .
 

Если флаг 
 INTERCEPT 

не используется, то управление доступом по адресу удаленного узла для
служб, у которых  wait  в  yes  и  socket_type  в  dgram 
выполняется только на первый пакет. Сервер может затем принимать пакеты
от узлов, которых нет в списке управления доступом. Это может происходить
со службами
 RPC .

 

Не существует способа поместить
 SPACE 
в какую-либо переменную окружения.
 

Когда  wait  в  yes  и  socket_type  в  stream ,
сокет передаваемый серверу может только принимать соединения.
 

Флаг
 INTERCEPT 

не поддерживается для внутренних служб или многопоточных служб.
   
 ПЕРЕВОД 

Перевод с английского выполнил Виктор Вислобоков < victor_v@permonline.ru >
 

 
   Index 
 
 ИМЯ 
 ОПИСАНИЕ 
 ВНТУРЕННИЕ СЛУЖБЫ 
 ЗАМЕЧАНИЯ 
 ПРИМЕР 
 СМОТРИ ТАКЖЕ 
 ОШИБКИ 
 ПЕРЕВОД 
 
 
 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename