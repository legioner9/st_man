#!/bin/bash

#. "$HOME/.bashrc"

filename="$HOME/"

echo -e "${HLIGHT}---start file: $filename---${NORMAL}" # start file

#---------------------------------------
:<<end_of_comments


 
 
 
 
 
Профиль:  Аноним  ( вход  |  регистрация ) 

 
 
 
 
 
 

 
 
 
 
  НОВОСТИ  ( + )
 
   КОНТЕНТ 
 
   WIKI 
 
    MAN'ы 
 
    ФОРУМ 
 
 Поиск  ( теги )
 
 
 

 

           
 
 

 
 
 
 
 
 
 
 [  новости  / +++  |  форум  |  wiki  |  теги 
|  
] 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 Интерактивная система просмотра системных руководств (man-ов) 
  
 
 
 

 
   Тема Набор Категория   
 

  
 Solaris man
 FreeBSD man
 Разные man
 Русские man
 Linux man
 POSIX man
 
 
	   All
	   1
	   2
	   3
	   4
	   5
	   6
	   7
	   8
	   9
 

 
 
  [ Cписок руководств  |  Печать ] 
 
 
 
 pdnsd.conf (5) >>  pdnsd.conf  (5)   ( Русские man: Форматы файлов ) 


 ИМЯ 
 

 

pdnsd.conf - конфигурационный файл pdnsd
 

 

 ОПИСАНИЕ 
 

 

Эта страница руководства описывает структуру конфигурационного файла  pdnsd_8  и доступные опции настройки. По умолчанию файл находится в /etc/pdnsd.conf. Это может быть изменено с помощью опции -c командной строки. Пример файла pdnsd.conf имеется в составе дистрибутива pdnsd в каталоге с документацией или в файле /etc/pdnsd.conf.sample.
 

 

 ФОРМАТ ФАЙЛА 
 

 

Конфигурационный файл разделён на секции. Каждая секция начинается с имени секции и открывающейся фигурной скобки ({) и завершается закрывающей фигурной скобкой (}). В каждой секции опции конфигурации могут быть заданы в виде
 

 
имя_опции=значение_опции;
 

 
Значением опции может быть последовательность символов, число, спецификация времени или константа. В предыдущих версиях pdnsd строки должны были заключаться в кавычки (), но начиная с версии 1.1.10 это больше не требуется, за исключением тех случаев, когда строка содержит специальный символ, такой как пробел, символ, который обычно начинает комментарий, или один из символов ,;{}.
 

 
Спецификация времени состоит из последовательности цифр с последующим однобуквенным суффиксом. Доступны следующие суффиксы: s (секунды), m (минуты), h (часы), d (дни) и w (недели). Если суффикс пропущен, предполагаются секунды. Если несколько спецификаций времени сцеплены, их значения складываются; например 2h30m интерпретируется как 2*60*60 + 30*60 = 9000 секунд.
 

 
Некоторые опции принимают больше чем одно значение; в этом случае, значения разделяются запятыми.
 

 
Если Вы можете использовать одно из множества доступных значений опции, это записывается в документации как (опция1|опция3|опция3|)
 

 
Константы true|false (истина/ложь) и yes|no (да|нет) распознаются как синонимы констант on|off (включено|выключено).
 

 
Комментарии могут быть заключены в /* и */, возможны вложенные комментарии. Если символ # или две косые черты (//) появляются в конфигурационном файле, всё от этих символов до конца текущей строки расценивается как комментарий и игнорируется.
 

 
Примеры для большинства опций находятся в образце конфигурационного файла.
 

 

 Секция global 
 

 

Секция global указывает параметры, которые затрагивают общее поведение сервера. Если вы укажете несколько секций global, более поздние настройки в файле заменят более ранние значения.
 

 
Здесь возможны опции:
 

 

 perm_cache=(число|off); 
 

 

Выключает дисковый кэш или задаёт максимальный размер кэша в килобайтах. Если дисковый кэш отключен, 8 байт всё-же будут записаны на диск. Кэш в памяти всегда на 10 килобайт больше, чем файл кэша. Значение по умолчанию - 2048 (2 мегабайта).
 

 

 cache_dir=строка; 
 

 

Задаёт каталог, в котором Вы хотите хранить кэш. По умолчанию это /var/cache/pdnsd (кроме случаев, когда pdnsd был скомпилирован с другим значением по умолчанию).
 

 

 server_port=число; 
 

 

Задаёт порт сервера. Это особенно полезно, когда Вы хотите запустить сервер и не являетесь пользователем root. Отметим, что Вы можете также не указывать uptest=ping в секции server, если вы не пользователь root.
 

 
Порт по умолчанию - 53, в соответствие с стандартом RFC. Отметим, что Вы можете использовать нестандартные порты, только если Вам нужны клиенты на Вашей машине для связи с сервером; другие вероятно дадут сбой, если попытаются связаться с сервером, используя запись NS, поскольку запись A предоставляющая адрес (среди прочего) для серверов имён не имеет спецификации номера порта.
 

 

 server_ip=строка; 
 

 

или
 

 

 interface=строка; 
 

 

Устанавливает IP-адрес на котором pdnsd будет ожидать запросы. Это может быть полезно когда узел имеет несколько интерфейсов и вы хотите, чтобы pdnsd не ожидал соединений на всех интерфейсах. Например, можно заставить pdnsd ожидать соединений на 127.0.0.1, чтобы позволить pdnsd обслуживать запросы от BIND. По умолчанию эта опция установлена в server_ip=any, что позволяет pdnsd ожидать соединений на всех локальных интерфейсах. В настоящее время Вы можете указать здесь только один адрес; если Вы хотите, чтобы pdnsd ожидал соединений на нескольких интерфейсах, но не на всех, Вы можете указать server_ip=any и использовать правила пакетного фильтра для ограничения доступа.
 

 
Используемый IP-адрес нужно помещать в кавычки, но начиная с версии 1.1.10 это больше не обязательно.
 

 
Если pdnsd был скомпилирован с одновременной поддержкой IPv4 и IPv6, но pdnsd не был скомпилирован для запуска в IPv6 режиме по умолчанию, и Вы хотите указать здесь адрес IPv6, тогда Вы должны использовать опцию командной строки -6 или сначала установить run_ipv4=off (см. ниже), чтобы быть уверенным, что IPv6 адрес был разобран правильно.
 

 
Если pdnsd запущен в режиме IPv6 и Вы указали здесь адрес IPv4, он будет автоматически преобразован в адрес IPv6.
 

 
Новое в версии 1.2: Вы можете указать здесь имя интерфейса, такое как lo или eth0, вместо IP-адреса (это было проверено на Linux и может работать или не работать на других платформах). pdnsd не привязывается к имени интерфейса, но определит адрес интерфейса при запуске и будет ожидать соединений на этом адресе. Если адрес интерфейса поменяется во время работы pdnsd, pdnsd не заметит этого. В этом случае Вам может потребоваться перезапустить pdnsd.
 

 

 linkdown_kluge=(on|off); 
 

 

Эта опция включает kluge, который может понадобиться некоторомы людям: когда все серверы недоступны, а эта опциея включена, кэш не используется при получении запроса, и в любом случае будет возвращена ошибка  DNS . Исключением из этого являются только локальные записи (которые указаны в секциях rr и source), которые продолжают нормально обслуживаться. В общем, если сеть отключена, то Вы вероятно хотите получать также и кэшированные записи, поэтому эта опция по умолчанию отключена.
 

 

 max_ttl=время; 
 

 

Эта опция устанавливает максимальное время удержания записи в кэше. Все ресурсные записи  DNS  имеют поле времени жизни, которое говорит какой период времени запись может находиться в кэше, перед тем как её потребуется перезапросить. Если оно больше значения указанного в max_ttl, то значение времени жизни будет установлено в max_ttl. Это сделано для предотвращения кэширования записей на неоправданно длинный период времени, потому что это почти никогда не бывает правильно. По умолчанию это 604800 секунд (одна неделя).
 

 

 min_ttl=время; 
 

 

Эта опция устанавливает минимальное время удержания записи в кэше. Все ресурсные записи  DNS  имеют поле времени жизни, которое говорит о том, какой период времени запись может находиться в кэше, перед тем как её потребуется перезапросить. Если время жизни ресурсной записи меньше значения указанного в min_ttl, то значение времени жизни будет установлено в min_ttl. По умолчанию это 120 секунд.
 

 

 neg_ttl=время; 
 

 

Эта опция устанавливает время, в течение которого отрицательно кэшированные записи будут оставаться действительными, если время их жизни не может быть определено. В любом случае, весь домен будет кэширован отрицательно, включая отрицательное кэширование тех записей, для доменнов которых pdnsd не имеет записей SOA. Если SOA существует, будет принято время жизни SOA.
 

 

 neg_rrs_pol=(on|off|auth); 
 

 

Задаёт набор политик отрицательного кэширования ресурсных записей; это указывает pdnsd при каких обстоятельствах он должен применять отрицательный тип кэширования записей для определённого домена. off выключает отрицательное кэширование типов записей, on всегда добавляет в кэш отрицательные записи, если сервер имён не вернул запись запрошенного нами типа, и auth добавляет только такие записи, которые приняты в ответе полномочного сервера имён этого домена. Предустановлено auth. Обычно это правильно, потому что некоторые кэширующие серверы ведут себя странно.
 

 

 neg_domain_pol=(on|off|auth); 
 

 

Это аналог neg_rss_pol для отрицательного кэширования всего домена. Включение этой опции должно быть безопасным, потому что я не видел кэширующих серверов, которые ложно заявляют, что домен не существует.
 

 
По умолчанию auth.
 

 

 run_as=строка; 
 

 

Эта опция позволяет Вам заставить pdnsd сменить идентификатор пользователя и группы после того как будут выполнены все необходимые привилегированные операции. Позволяет уменьшить риски безопасности и поэтому рекомендуется. Данная строка задаёт имя пользователя, идентификаторы имени и первичной группы которого будут выбраны.
 

 
Немного больше подробностей: после чтения конфигурационного файла, переключения в режим демона (если указано) и запуска нити статуса сервера, главная нить меняет свои gid и uid, а также uid и gid всех нитей вновь создаваемых после этого. При выборе других uid и gid, эти нити запускаются с привилегиями указанного пользователя. Под Linux и FreeBSD, нить статуса сервера запускается с начальными привилегиями, только если выключена опция strict_setuid (см. ниже, включено по умолчанию), потому что это может потребоваться для исполнения тестов. Управляющая нить также удерживает исходные привилегии в этом случае. Вы должны позаботиться о том, чтобы пользователь, которого Вы указали, имел разрешения на запись в Ваш кэш-файл и канал статуса (если Вам требуется канал статуса). Вы должны просмотреть сообщения об ошибках, подобные permission denied (отказано в доступе) и operation not permitted (операция запрещена), чтобы обнаружить проблемы с разрешениями.
 

 

 strict_setuid=(on|off); 
 

 

Будучи использованной одновременно с опцией run_as, эта опция позволяет Вам указать, что все без исключения нити программы должны быть запущены с привилегиями пользователя run_as. Эта опция предоставляет более высокую степень безопасности по сравнению с обычной опцией run_as, но она не всегда доступна. См. опцию run_as для дальнейших размышлений.
 

 
Эта опция включена по умолчанию.
 

 
Замечание: эта опция не имеет эффекта на не-Linux системах.
 

 

 paranoid=(on|off); 
 

 

Обычно pdnsd запрашивает все серверы в рекурсивном режиме (то есть просит серверы запрашивать другие серверы самим, если возможно и возвращать ответы для доменов которые могут не быть их полномочными), и принимать дополнительные записи с информацией для серверов, которые не полномочны для запрашиваемого сервера. Это открывает возможность так называемого отравления кэша: злонамеренные атакующие могут настроить  DNS  сервер так, что когда его спрашивают, он возвращает поддельные дополнительные записи. Таким образом, можно заменить доверенные серверы на его собственные, которые заставляют ваш  DNS  сервер возвращать неправильные IP-адреса. Эта опция защищает ваш кэш от заражения, отклоняя дополнительные записи, которые не описывают домены в запрошенном пространстве полномочных серверов и не делает более рекурсивные запросы. Исключение из этого правила - это серверы, которые Вы указали в Вашем конфигурационном файле, которые являются доверенными.
 

 
Минусом является возможное падение производительности, в частности, для тех же операций может потребоваться большее количество запросов.
 

 
Вы должны также помнить, что здесь могут быть другие подобные проблемы безопасности, которые являются по существу проблемами  DNS , так как любой традиционный сервер имеет их (расширения безопасности  DNS  решают эти проблемы, но они не широко распространены). Одна из таких уязвимостей - это атакующий может бомбардировать Вас поддельными ответами, один из которых может совпасть с запросом, который Вы выполнили. Если Вы выполнили такой запрос, один из 65536 поддельных пакетов будет удачным (то есть среднее число пакетов, необходимых для атаки - 32768). pdnsd может использовать для запросов TCP-соединения, что будет слегка более затратно, но они гораздо менее подвержены таким атакам на нормальных операционных системах. Также pdnsd выбирает случайные идентификаторы запросов, так что у атакующего не получится сделать это быстро. Эта атака всё же относительно легка, если атакующий может прослушивать Ваш сетевой трафик.
 

 
Эта уязвимость - не ошибка pdnsd, она возможна при использовании стандартных серверов имён (pdnsd может быть немного более безопасен против атак этого типа, если Вы заставите его использовать TCP).
 

 
Опция paranoid отключена по умолчанию.
 

 

 scheme_file=строка; 
 

 

В дополнение к нормальным тестам, Вы можете указать что некоторые серверы должны запрашиваться, когда активна определённая схема pcmcia-cs (только под Linux). Для этого pdnsd нужно знать в каком файле располагается информация о схеме pcmcia. Обычно это /var/lib/pcmcia/scheme или /var/state/pcmcia/scheme.
 

 

 status_ctl=(on|off); 
 

 

Имеет тот же эффект, что и опция -s командной строки: включает управление статусом, если указана.
 

 
Добавлено Полом Ромбаутсом: Имейте в виду, что pdnsd-ctl позволяет конфигурирование pdnsd во время выполнения, может быть даже изменён IP-адрес сервера имён. Если Вы не используете pdnsd-ctl и Вы хотите максимальной безопасности, Вы не должны включать эту опцию. Она отключена по умолчанию.
 

 

 daemon=(on|off); 
 

 

Имеет тот же эффект, что и опция -d командной строки: режим демона включен, если указана.
 

 
По умолчанию выключен.
 

 

 tcp_server=(on|off); 
 

 

tcp_server=on имеет тот же эффект, что и -t или --tcp опция командной строки: включает обслуживание TCP. Аналогично, tcp_server=off, подобно опции командной строки --notcp.
 

 
По умолчанию включено.
 

 

 pid_file=строка; 
 

 

Имеет тот же эффект, что и опция -p командной строки: Вы можете указать файл, в который pdnsd запишет свой PID при запуске в режиме демона.
 

 

 verbosity=число; 
 

 

Это имеет тот же эффект, что и опция -v командной строки: Вы можете установить информативность сообщений pdnsd. Аргумент - это число между 0 (мало сообщений) и 3 (наибольшее количество сообщений).
 

 

 query_method=(tcp_only|udp_only|tcp_udp); 
 

 

Эта опция имеет тот же эффект, что и опция -m командной строки. Прочитайте документацию этой опции командной строки. tcp_only указывает аргумент командной строки to, udp_only - uo и tcp_udp - tu.
 

 
Если Вы используете query_method=tcp_udp, рекомендуется также чтобы Вы установили опцию глобального тайм-аута по меньшей мере в два раза больше самого длинного тайм-аута сервера.
 

 

 run_ipv4=(on|off); 
 

 

Имеет тот же эффект, что опции -4 или -6 командной строки: если указано on, включается поддержка IPv4, а поддержка IPv6 выключается (если она доступна). Если указано off, IPv4 будет отключена и IPv6 будет включена. Для этой опции важно, чтобы pdnsd был скомпилирован с поддержкой протокола, который Вы выбрали. Если pdnsd был скомпилирован с одновременной поддержкой IPv4 и IPv6, и Вы хотите включить IPv6-адреса в конфигурационный файл, вероятно Вам потребуется указать сначала опцию run_ipv4=off, чтобы быть уверенным, что IPv6-адреса были корректно распознаны.
 

 

 debug=(on|off); 
 

 

Имеет тот же эффект, что и опция -g командной строки: включает отладочные сообщения, если указано on.
 

 

 ctl_perms=число; 
 

 

Эта опция позволяет Вам устанавливать файловые разрешения, которые будет иметь сокет, управляющий статусом pdnsd. Владельцем файла будет пользователь run_as, или, если ничего не указано, пользователь, запустивший pdnsd. Если Вы хотите указать разрешения в восьмеричной системе (как обычно), не забудьте добавить в начале ноль (0600 вместо 600!). Для использования управления статусом требуется доступ на запись. По умолчанию это 0600 (только владелец может читать или писать).
 

 
Пожалуйста помните, что сокет сохраняется в каталоге кэша, и может потребоваться также настройка разрешений на доступ к каталогу. Удостоверьтесь, что каталог кэша не доступен на запись для недоверенных пользователей.
 

 

 proc_limit=число; 
 

 

С этой опцией Вы можете установить предел количества нитей pdnsd активных одновременно. Если это число превышено, запросы встают в очередь и могут быть откложены на некоторое время. См. также опцию procq_limit.
 

 
По умолчанию 40.
 

 

 procq_limit=число; 
 

 

Когда будет достигнут предел proc_limit запрашивающих нитей, попытки соединения к pdnsd будут вставать в очередь. С этой опцией Вы можете задать максимальную длину очереди. Если длина очереди тоже будет превышена, входящие запросы будут отбрасываться. Это означает, что TCP-соединения будут закрыты, а UDP-запросы будут просто отброшены, что, возможно, вызовет ожидание  DNS -клиента, инициировавшего запрос до тех пор, пока не будет достигнут тайм-аут ожидания ответа.
 

 
См. также опцию proc_limit. Максимум proc_limit+procq_limit нитей запросов будет существовать в любой момент времени (в добавок от 3 до 6 нитей всегда будут существовать, в зависимости от Вашей конфигурации).
 

 
По умолчанию 60.
 

 

 tcp_qtimeout=время; 
 

 

Эта опция устанавливает тайм-аут для TCP-запросов. Если через TCP-соединение не был принят полный запрос, через указанный промежуток времени соединение будет закрыто. По умолчанию это время устанавливается перед компиляцией, с помощью опции --with-tcp-qtimeout скрипта configure.
 

 

 par_queries=число; 
 

 

Эта опция используется для задания максимального числа удалённых серверов, которые могут опрашиваться одновременно, для каждого запроса, который принял pdnsd.
 

 
Начиная с версии 1.1.11, значение этой опции слегка изменилось. Теперь это приращение, на которое увеличивается число параллельных запросов, если предыдущий набор серверов превысил время ожидания. Например, если имеется список сервер1, сервер2, сервер3, и т.д. доступных серверов и par_queries=2, то pdnsd сначала отправит запросы на сервер1 и сервер2, и будет ждать ответа от этих серверов.
 

 
Если эти серверы не отправят ответ в течение периода тайм-аута, pdnsd отправит дополнительные запросы на сервер3 и сервер4, и будет ждать ответа от сервера1, сервера2, сервера3 и сервера4, и так далее до тех пор, пока не получит полезный ответ или список не будет исчерпан.
 

 
В наихудшем случае запросы ко всем серверам в списке доступных серверов не будут завершены. Может быть таким образом мы используем больше системных ресурсов (но только если первые серверы в списке медленные или неотзывчивые), но преимущество этого - мы имеем больший шанс получить ответ. Кроме того, раз уж ждать и так долго, почему бы не ждать больше серверов.
 

 
См. также ниже объяснение опции глобального тайм-аута.
 

 
1 или 2 - хорошие значения для этой опции. Значение по умолчанию устанавливается при компиляции, с помощью опции --with-par-queries скрипта configure.
 

 

 timeout=время; 
 

 

Это глобальный параметр тайм-аута для  DNS -запросов. Он указывает минимальный период времени, которое pdnsd будет ждать после отправки первого запроса удалённому серверу перед тем как решит, что не принял ответ. Опции тайм-аута в конфигурационном файле теперь задают только минимальные интервалы тайм-аута. Установка опции глобального таймаута даёт возможность указывать совсем короткие интервалы тайм-аута в секции server (см. ниже). Это приводит к тому, что pdnsd довольно быстро начнёт запрашивать дополнительные серверы, если первые серверы долго отвечают (но всё ещё продолжит ожидать ответа от первого из них). Это позволяет pdnsd в определённых ситуациях быстрее получать ответ.
 

 
Если Вы используете query_method=tcp_udp, рекомендуется, чтобы Вы установили глобальный тайм-аут по меньшей мере в двое большим самого большого тайм-аута сервера, иначе pdnsd может не успеть сделать UDP-запрос, если истекло время TCP-соединения.
 

 
По умолчанию, значение - 0.
 

 

 randomize_recs=(on|off); 
 

 

Если эта опция включена, pdnsd случайно переупорядочивает кэшированные записи одного типа, когда создаёт ответ. Это поддерживает карусельную схему  DNS  и увеличивает устойчивость от сбоев для узлов с множеством IP-адресов, поэтому обычно это хорошая идея.
 

 
Включено по умолчанию.
 

 

 query_port_start=число; 
 

 

Если задано, определяет начало диапазона портов, используемых pdnsd для запросов. Данное значение должно быть >=1024. Назначение этой опции - помощь определённым конфигурациям пакетных фильтров, которые основываются на фильтрации порта источника. Пожалуйста, помните о том, что другое приложение может быть связано с портом в этом диапазоне, так что пакетные фильтры с учётом состояний, использующие целевой порт и/или идентификатор процесса могут быть более эффективным. В таком случае, если задан начальный порт для запросов, pdnsd использует этот порт как первый порт указанного диапазона портов (см. query_port_end), используемый для запросов. pdnsd будет пытаться выбирать свободный порт в случайном порядке из этого диапазона в качестве локального порта для запросов.
 

 
Чтобы убедиться, что портов для использования pdnsd достаточно, диапазон между query_port_start и query_port_end должен быть установлен как минимум равным (par_queries * proc_limit). Рекомендуется большее значение, так как другие приложения могут также выделять порты в этом диапазоне. По возможности, этот диапазон не должен содержать пространства, которые обычно используют другие приложения.
 

 

 query_port_end=число; 
 

 

Используется только в случае, когда определена опция query_port_start. Определяет последний порт диапазона, начинающегося с query_port_start, используемого для запросов pdnsd. По умолчанию равен 65535, это же число является максимально допустимым для этой опции. Подробнее об этом см. в описании query_port_start.
 

 

 delegation_only=строка; 
 

 

Добавлено Полом Ромбаутсом: Эта опция указывает зону только делегировать. Это означает, что если pdnsd принимает запрос на имя, которое находится в поддомене зоны только делегировать, но удалённый сервер имён возвращает ответ с секцией нехватки полномочий для любых ресурсных записей NS поддомена этой зоны, pdnsd будет отвечать NXDOMAIN (неизвестный домен). Эта возможность может быть использована для избежания нежелательных эффектов шаблонов  DNS . Различные зоны только делегировать могут быть указаны вместе. Если Вы укажете корневые серверы в секции server, важно чтобы Вы установили в такой секции root_server=on.
 

 
Пример:
 

 
delegation_only=com,net;
 

 
Эта возможность отключена по умолчанию. Рекомендуется, чтобы Вы использовали эту возможность, только если она Вам действительно нужна. При использовании этой опции существует риск того, что некоторые законные имена будут заблокированы, особенно если запрошенные pdnsd удалённые серверы имён возвращают ответы с пустой секцией полномочий.
 

 

 ipv4_6_prefix=строка; 
 

 

Эта опция имеет тот же эффект, что и опция -i командной строки. Когда pdnsd запущен в режиме IPv6, эта опция указывает pdnsd использовать префикс для преобразования адресов IPv4, указанных в конфигурационном файле (или адреса, указанные с помощью pdnsd-ctl), в отображённые адреса IPv6. Строка должна быть правильным адресом IPv6. Будут использованы только первые 96 бит . Заметим, что эта опция имеет эффект только при разборе адресов IPv4, перечисленных после неё.
 

 
По умолчанию ::ffff.0.0.0.0.
 

 

 Секция server 
 

 

Каждая секция server указывает набор серверов имён, для которых pdnsd должен попытаться получить записи ресурсов или получить от них информацию о полномочиях. Серверы опрашиваются в порядке их появления (или параллельно до ограниченного предела). Если один сбоит, пробуется следующий и так далее.
 

 
Вероятно Вы хотите указать  DNS  сервер в Вашей локальной сети, кэширующие серверы Вашего интернет-провайдера или даже список корневых серверов в одной или более секциях server.
 

 
В этой секции поддерживаются следующие опции:
 

 

 label=строка; 
 

 

Указывает метку для секции server. Она может использоваться для ссылки на эту секцию при использовании pdnsd-ctl, управляющей утилиты pdnsd.
 

 
Вы можете задать различные секции server с одинаковой меткой, но если Вы хотите изменить адреса в секции server (см. далее опцию ip) во время работы с помощью pdnsd-ctl server label up dns1,dns2,, метка должна быть уникальной.
 

 

 ip=строка; 
 

 

Задаёт IP (IP, не имя узла) сервера.
 

 
Множество IP-адресов может быть задано в одной секции server. Это может быть сделано введением нескольких строк в форме ip=строка; или одной строкой подобной этой:
 

 
ip=строка,строка,строка;
 

 
Хотя бы один IP-адрес обязательно должен быть указан в конфигурационном файле. Секция server без IP-адресов будет оставаться неактивной до тех пор, пока не будет назначен один или более адресов с помощью pdnsd-ctl, утилиты для управления pdnsd.
 

 
Если pdnsd был скомпилирован с одновременной поддержкой IPv4 и IPv6, любые адреса IPv6 указанные здесь, будут пропущены с предупреждающим сообщением, если pdnsd запускается в режиме IPv6. Таким образом, если pdnsd был скомпилирован для загрузки в режиме IPv6 по умолчанию, Вы должны сначала использовать опцию командной строки -6 или установить run_ipv4=off (см. секцию global), чтобы удостовериться, что адреса IPv6 были правильно разобраны.
 

 
Если pdnsd запущен в режиме IPv6 и Вы указали здесь адрес IPv4, он будет автоматически отображён в адрес IPv6.
 

 

 file=строка; 
 

 

Новое в версии 1.2: Эта опция позволяет Вам задать имя файла в стиле resolv.conf. Из строк, начинающихся с ключевого слова nameserver, второе поле будет разобрано как IP-адрес, как если бы он был указан опцией ip=. Остальные строки будут пропущены. Если содержимое файла меняется во время работы pdnsd, Вы можете заставить pdnsd узнать об изменениях воспользовавшись pdnsd-ctl, управляющей утилитой pdnsd. В большинстве случаев будет удобно поместить команду pdnsd-ctl config в скрипт, который автоматически запускается после изменений конфигурации  DNS .
 

 
Например, допустим у Вас есть PPP-клиент, который записывает конфигурацию  DNS  вашего интернет-провайдера в файл /etc/ppp/resolv.conf и запускает скрипт /etc/ppp/ip-up, когда устанавливает новое соединение. Одним из способов, гарантирующих, что pdnsd будет автоматически переконфигурирован, является добавление file=/etc/ppp/resolv.conf в секцию server конфигурационного файла и добавление команды pdnsd-ctl config в /etc/ppp/ip-up.
 

 

 port=число; 
 

 

Задаёт порт, на котором удалённый сервер имён ожидает соединений. По умолчанию это 53 (официальный порт  DNS ).
 

 

 uptest=(ping|none|if|dev|diald|exec|query); 
 

 

Определяет метод независимой проверки доступности сервера. В настоящее время определены методы:
 

 

 ping 
 

 

Посылает серверу запрос ICMP_ECHO. Если сервер не отвечает в течение тайм-аута, он считается недоступным до следующей пробы.
 

 

 none 
 

 

Статус доступности не меняется, обновляется только отметка времени.
 

 

 if 
 

 

Проверяет, что интерфейс (указанный в опции interface  существует, подключен и активен. В настоящее время работает для всех обычных сетевых интерфейсов, интерфейсов, которые не исчезают при отключении (например ppp?), и дополнительно для Linux интерфейсов ISDN (как в ядре 2.2). Отметим, что Вам нужен файл устройства /dev/isdninfo (старший 45, младший 255), в противном случае тест ISDN всегда будет сбоить.
 

 

 dev и diald 
 

 

Проводит тест и, если он был удачнен, производит дополнительную независимую проверку программ, заблокировавших заданное (modem-) устройство. Необходимые параметры - интерфейс (указывается как для теста доступности, например ppp0) и устройство относительно /dev (например modem для /dev/modem) указывается с помощью опции device=. pdnsd будет просматривать PID-файл для заданного интерфейса в /var/lock (например /ver/run/ppp0.pid) и для файла блокировки заданного устройства (например /var/lock/LCK..modem). Затем независимо проверяет, что блокирущий процесс, создавший PID-файл, всё ещё доступен. В этом случае для заданного интерфейса будут проведены обычные тесты доступности.
 

 
Опция dev используется для pppd с дозвоном по требованию. diald - то же самое для пользователей diald.
 

 

 exec 
 

 

Испоняет заданную команду в оболочке /bin/sh (как /bin/sh -c <команда>) и оценивает результат (код, возвращённый последней командой) в стиле обработки оболочкой кодов возврата. То есть 0 обозначает успех, все другие значения обозначают ошибку. Имя оболочки задаётся опцией uptest_sh. Команда задаётся опцией uptest_cmd (см. далее). По соображениям безопасности см. тот же абзац.
 

 

 query 
 

 

Новое в версии 1.2: Работает подобно тесту ping, но отправляет пустой запроса  DNS . Если сервер отправляет обратно хорошо оформленный ответ до истечения периода тайм-аута (исключая SERVFAIL), сервер будет считаться доступным. Этот тест полезен, если удалённый сервер никогда не отвечает на запросы ICMP_ECHO, к несчастью в последнее время это становится повсеместным. Во многих случаях этот тест может быть более надёжным индикатором доступности, чем остальные упомянутые до него.
 

 
По умолчанию none.
 

 
ЗАМЕЧАНИЕ: Если Вы используете дозвон по требованию, используйте none, if, dev, diald или exec, поскольку ping или query отправляют пакеты с указанным интервалом и из-за этого начнётся установка коммутируемого соединения!
 

 

 ping_timeout=число; 
 

 

Устанавливает тайм-аут для теста ping в десятых секунд. По умолчанию 600 (одна минута).
 

 

 ping_ip=строка; 
 

 

IP для теста ping. По умолчанию это IP сервера имён.
 

 

 uptest_cmd=строка,строка; 
 

 

или
 

 

 uptest_cmd=строка; 
 

 

Устанавливает команду для функции uptest=exec в первой строке. Если задана вторая строка, она указывает пользователя, у которого для выполнения команды будут взяты идентификатор пользователя и первичной группы.
 

 
Это особенно полезно, если Вы исполняете сервер как пользователь root, но не хотите, чтобы тест производился с привилегиями пользователя root. Фактически, Вы никогда не должны исполнять тест как пользователь root, если Вы можете способствовать этому.
 

 
Если сервер запущен с setuid или setgid, то происходит попытка увеличения привилегий, чтобы затем отбросить их до привилегий указанного пользователя. Это сделано для предотвращения дыр безопасности setuid/gid (иначе любой пользователь сможет исполнять команды как пользователь root, если Вы установили на выполняемый файл бит setuid).
 

 
Заметьте, что это не всегда возможно, и поэтому pdnsd никогда не должен иметь установленный бит setuid или setgid. Команда, исполняется с помощью /bin/sh, так что Вам должны быть доступны встроенные команды оболочки.
 

 

 interval=(время|onquery|ontimeout); 
 

 

Устанавливает интервал для теста доступности сервера. По умолчанию 900 секунд; однако если истёк тайм-аут запроса, тест будет повторён, и лишь затем отметка времени будет сброшена.
 

 
Если вы укажете onquery вместо тайм-аута, интерфейс будет проверяться перед каждым запросом. Это предотвращает автоматический дозвон коммутируемых интерфейсов (diald/pppd или ppp) при появлении запросов  DNS . Предполагается использование совместно с тестом интерфейса  
 

 
Отметим, что если Вы используете uptest=exec, Вы можете инициировать проблемы производительности на медленных компьютерах, если в добавок к ней будете использовать опцию interval=onquery. НЕ ИСПОЛЬЗУЙТЕ onquery совместно с uptest=ping или uptest=query, это может вызвать задержки, если сервер не отвечает (поскольку это не делает восприимчивым в любом случае ). Отметим также, что использование onquery не гарантирует, что интерфейс не будет использован. Когда другой (достижимый)  DNS -сервер сообщит pdnsd, что нужно спросить данные у третьего  DNS -сервера, pdnsd сделает это и не имеет занчения независимая проверка, является ли коммутируемый интерфейс включенным или нет. Это однако должно быть редкой ситуацией.
 

 
Новое в версии 1.2.3: Третья возможность - указать interval=ontimeout. В этом случае сервер не проверяется при запуске/переконфигурации, ни через регулярные интервалы, но проверяется только после того, как истёк тайм-аут  DNS -запроса. Определённые типы сетевых проблем, такие как отброшенные соединения, могут также вызывать решение о недоступности сервера. Однако, если сервер однажды обявлен недоступным, он никогда не будет использован снова, если не будет восстановлен с использованием pdnsd-ctl config или командой server. Идея этой опции в уменьшении количества тестов, предполагая что все серверы доступны, потому что нет причин верить в обратное.
 

 

 interface=строка; 
 

 

Сетевой интерфейс (или сетевое устройство, например eth0) для опции uptest=if. Должен быть указан, если задано uptest=if.
 

 

 device=строка; 
 

 

Устройство (modem-), которое используется для опции uptest=dev. Если Вы используете это для теста PPP-соединения по требованию (совместно с uptest=dev), Вам нужно ввести здесь устройство, которое используется вашим pppd, например modem для /dev/modem.
 

 
Должно быть указано, если задано uptest=dev.
 

 

 timeout=время; 
 

 

Устанавливает тайм-аут для  DNS -запроса. По умолчанию 120 секунд. Вы вероятно захотите установить его меньше.
 

 
Тайм-ауты, указанные в конфигурационном файле, используются не только как минимальный период времени ожидания ответа. Запросы к удалённому серверу не отменяются до тех пор, пока не будет принят полезный ответ, или все другие запросы превысят время ожидания или вернут ошибку.
 

 
Если Вы уже установили опцию глобального тайм-аута, может быть Вы захотите здесь уставновить довольно маленькое значение. См. объяснение назначения опции таймаута в секции global.
 

 

 purge_cache=(on|off); 
 

 

Для каждой полученной  DNS -записи задаётся время устаревания в кэше, которое указывает - как долго полученные данные могут быть кэшированы до тех пор, пока не потребуется их перезагрузка. Если purge_cache установлена в off, кэшированные записи не очищаются (до тех пор, пока не превышен размер кэша, в этом случае самые старые записи очищаются). Вместо этого, они всё ещё обслуживаются, если не могут быть удачно обновлены (например, потому что все серверы недоступны).
 

 

 caching=(on|off); 
 

 

Указывает, должно ли вообще производиться кэширование для этого сервера. По умолчанию включено.
 

 

 lean_query=(on|off); 
 

 

Указывает независимо использовать тощий режим запросов. В этом режиме будет решаться и кешироваться только информация действительно запрошенная у pdnsd. Это выгодно тем, что обычно уменьшает пространство, используемое кэшем и запросы обычно быстрее. В 90% случаев требуются только адресные (A) записи. Если выключить, pdnsd будет всегда кэшировать все данные об узле, которые смог найти и запрашивает особо все доступные записи (ладно, по меньшей мере это хорошее приближение к тому, что происходит в действительности   Этот ход увеличивает общий размер пакета.
 

 
Отрицательное кэширование эффективно только с включенной опцией lean_qeury.
 

 
Некоторые глючные серверы имён могут не доставлять записи CNAME, если не запросить все записи. Я не знаю, распространены ли такие серверы повсеместно, но если Вы имеете проблему решения имён определённого узла, попытайтесь выключить эту опцию.
 

 
Последнее замечание: Если Вы используете множество pdnsd, каждый из которых доступен другому, включение этой опции вероятно будет большой победой.
 

 
По умолчанию включено.
 

 

 scheme=строка; 
 

 

Вы можете указать схему pcmcia-cs, которая используется в дополнение к тестам. Если Вы укажете схему здесь, сервер этой секции будет запрашиваться только если заданная схема активна. Шаблоны оболочки (* и ?) доступны в строке под их особыми значениями. Вам нужно использовать опцию scheme_file в секции global, чтобы эта опция заработала.
 

 

 preset=(on|off); 
 

 

Позволяет Вам указать начальное состояние сервера, перед тем как будут производиться какие-либо тесты. on указывает, что сервер считается доступным (это поведение по умолчанию). Это особенно полезно, когда Вы установили uptest=none; и хотите управлять сервером только посредством pdnsd-ctl.
 

 

 proxy_only=(on|off); 
 

 

Когда эта опция установлена в on, ответы полученные от серверов всегда принимаются, друге серверы не запрашиваются (например, указанные в записи NS запрошенного домена). Если Вы не включаете эту опцию, pdnsd будет выполнять такие запросы в некоторых случаях (в частности при обработке запросов ANY).
 

 
Эта опция полезна, когда Вы не хотите чтобы pdnsd соединялся с внешними серверами по некоторым причинам (например если пакетный фильтр блокирует такие запросы).
 

 
Я рекомендую чтобы Вы включили lean_query при использовании этой опции.
 

 
По умолчанию выключено.
 

 

 root_server=(on|off); 
 

 

Новое в версии 1.2: Установите эту опцию, если серверы, указанные в секции - корневые серверы. Корневой сервер в своём ответе обычно предоставляет серверы имён для доменов верхнего уровня. Установка root_server=on заставляет pdnsd попытаться использовать кэшированную информацию о доменах верхнего уровня для уменьшения количества запросов к корневым серверам, выполняя решение новых имён более эффективно. Вы можете получить список доступных корневых серверов, запустив команду dig -t ns ..
 

 
Эта опция также необходима если Вы используете опцию delegation_only.
 

 
По умолчанию выключено.
 

 

 policy=(included|excluded|simple_only|fqdn_only); 
 

 

pdnsd поддерживает включающие/исключающие списки для секции server: с помощью include= и exclude= (см. ниже) Вы можете указать имена доменов, для которых данный сервер будет или напротив - не будет использоваться. Применяется первое по счёту совпадение (то есть будет применено первое правило include или exclude в секции server, которое совпадает с именем домена). Если нет правила, совпадающего с заданными именем домена, опция policy= всё-же определяет, будет ли данный сервер использован для поиска этого доменного имени. Когда задано included, сервер будет запрошен; когда задано excluded - не будет. Если задано значение simple_only, сервер будет использован только для просмотра простого имени узла. В другом случае, если задано значение fqdn_only, сервер будет использоваться для просмотра только полностью определённых доменных имён (то есть имён, имеющих внутри по меньшей мере одну точку).
 

 
Если нет серверов, доступных для запрошенного домена, pdnsd возвращает клиенту сообщение об ошибке, которое обычно останавливает попытки клиента решить указанный домен с использованием этого сервера (решатель libc, например, возвращает ошибку приложению, которое пыталось решить домен, если нет других доступных серверов в resolv.conf). Иногда это может быть полезным.
 

 
Замечание: константы simple_only и fqdn_only были добавлены Полом Ромбаутсом. Они полезны для управления тем, какие серверы имён будут использованы pdnsd для простых имён узлов.
 

 
Умолчание для этой опции - included.
 

 

 include=строка; 
 

 

Эта опция добавляет запись в список исключений/включений. Если домен совпадает с именем, заданным в строке, сервер запрашивается, если это было первое совпадающее правило (см. также опцию policy).
 

 
Если заданное имя начинается с точки, целый поддомен заданного имени, включается если совпало одно из имён, например .foo.bar. будет совпадать с доменными именами a.foo.bar., a.b.c.foo.bar. и foo.bar.
 

 
Если оно не начинается с точки, только точное заданное имя (игнорируя регистр, конечно) будет совпадать. Подсказка: если Вы хотите включить все поддомены, но не само заданное имя домена, поместите искючающее правило только-совпадение перед включающим правилом, например: exclude=foo.bar.; include=.foo.bar.;
 

 
Предыдущие версии pdnsd требовали, чтобы заданные имена в этой и следующей опции оканчивались точкой. Но начиная с версии 1.1.8b1-par8, pdnsd автоматически добавляет точку в конце, если она пропущена.
 

 
pdnsd теперь также принимает более компактную нотацию для добавления нескольких записей include в одну строку, например:
 

 
include=.foo,.bar,.my.dom;
 

 

 exclude=строка; 
 

 

Эта опция добавляет запись к списку исключений/включений. Если домен совпадает с именем заданным в строке, сервер не запрашивается, если это было первое совпадающее правило (см. также опцию policy).
 

 
Если заданное имя начинается с точки, будет совпадать целый поддомен заданного имени. Например .foo.bar. совпадает с именами домена a.foo.bar.,a.b.c.foo.bar. and foo.bar.
 

 
Если имя не начинается с точки, тобудет совпадать исключительно заданное имя (игнорируя регистр, разумеется). Подсказка: если Вы хотите исключить все поддомены, но не сам домен с заданными именем, поместите правило только-совпадение перед исключающим правилом, например: include=foo.bar.;exclude=.foo.bar.;
 

 
pdnsd теперь также принимает более компактную нотацию для добавления нескольких записей exclude в одну строку, например:
 

 
exclude=.foo,.bar,.my.dom;
 

 

 Секция rr 
 

 

Каждая секция rr указывает ресурсную запись  DNS , которая хранится локально. Это позволяет Вам указывать собственные записи  DNS , которые обслуживаются pdnsd ограниченным образом. Реализованы только записи A, PTR, CNAME, MX, NS и SOA.
 

 
Эта опция предоставляет Вам возможность определять ресурсные записи для 1.0.0.127.in-addr.arpa. и localhost. (и возможно даже одного или двух узлов) без запуска дополнительного сервера имён, если Ваши кэширующие серверы имён не обслуживают эти записи. Предполагается, что он НЕ способен работать, как полноценный сервер имён.
 

 

 name=строка; 
 

 

Указывает имя ресурсной записи, то есть описывает доменное имя ресурсной записи . Эта опция должна быть указана перед любыми записями A, PTR, CNAME, MX, NS или SOA. Имена интерпретируются как абсолютные доменные имена (то есть pdnsd подразумевает, что они оканчиваются корневым доменом). Для этих и всех последующих аргументов, которые требуют доменные имена, Вы должны указывать доменные имена в точечной нотации (например venera.isi.edu.).
 

 
Предыдущая версия pdnsd требовала, чтобы доменные имена, заданные в конфигурационном файле, оканчивались точкой. Но начиная с версии 1.1.8b1-par8, pdnsd автоматически добавляет точку в конце, если она пропущена.
 

 
Новое в версии 1.2: Также возможно указать имя, начинающееся с метки *. Такие имена называются шаблонами. * в шаблоне может совпадать одна или более меток в запрашиваемом имени, но только метки целиком. Любые другие символы * в шаблоне, отдельно от ведущего, совпадают только буквально с *.
 

 
Например, *.mydomain совпадёт с a.mydomain или  www.a.mydomain , но не с mydomain. *.a*.mydomain совпадёт только с www.a*.mydomain, но не с  www.ab.mydomain . *a.mydomain совпадёт только с самим собой.
 

 
Перед тем как Вы сможете указать секцию rr с name=*.mydomain, Вы должны определить некоторые записи для mydomain, обычно NS и/или SOA записи. Например:
 
 rr
{
    name= mydomain;
    ns = localhost;
    soa = localhost, root.localhost, 42, 86400, 900, 86400, 86400;
}
rr
{
    name = *.mydomain;
    a = 192.168.1.10;
} 

 
В этом примере, www.mydomain и ftp.mydomain будут решаться в числовой адрес 192.168.1.10 (если Вы не добавили секции rr явно указывающие различные адреса для www.mydomain или ftp.mydomain). Если Вы хотите, чтобы mydomain также решался в числовой адрес, добавьте запись A в первой секции rr.
 

 

 ttl=время; 
 

 

Указывает ttl (время жизни) для всех ресурсных записей в этой секции после этой опции. По умолчанию это 86400 секунд (=1 день).
 

 

 authrec=(on|off); 
 

 

Если эта опция включена, pdnsd будет создавать полномочные локальные записи для этой секции rr. Это означает, что pdnsd помечает доменную запись, так что записи этого домена, не представленые в кэше, будут обрабатываться как несуществующие. То есть pdnsd будет считать, что нет других серверов, у которых может быть запрошена запись этого типа. При этом возвращается ответ, не содержащий записей запрошенного типа. Это чаще всего то, чего хотят люди: если Вы добавили запись A для узла, и он не имеет записи AAAA (и нет адресов IPv6), Вы обычно не хотите, чтобы для решения записи этого типа запрашивались другие серверы имён.
 

 
Эта опция включена по умолчанию.
 

 
Пожалуйста заметьте, что эта опция имеет эффект, только если ей предшествует опция name!
 

 

 reverse=(on|off); 
 

 

Новое в версии 1.2: Если Вы хотите, чтобы локально определённые имена решались в числовой адрес и наоборот, Вы можете достигнуть этого установкой reverse=on перед определением записи A (см. ниже). Альтернатива - определить отдельную запись PTR, но Вы вероятно найдёте эту опцию намного более удобной.
 

 
По умолчанию выключено.
 

 

 a=строка; 
 

 

Определяет запись A (адрес узла). Аргумент - IP в точечной нотации. pdnsd будет обслуживать этот адрес для заданного в опции name имени узла.
 

 

 ptr=строка; 
 

 

Определяет запись PTR (указатель доменного имени). Аргумент - имя узла в точечной нотации (см. name). Запись PTR для решения адресов в имена. Например, если Вы хотите, чтобы адрес 127.0.0.1 решался в localhost, и localhost в 127.0.0.1, Вам нужно нечто подобное следующим секциям:
 
 rr
{
    name = localhost;
    a = 127.0.0.1;
    owner = localhost;
    soa = localhost; root.localhost, 42, 86400, 900, 86400, 86400;
}
rr
{
    name = 1.0.0.127.in-addr.arpa;
    ptr = locahlost;
    owner = localhost;
    soa = localhost, localhost, root.localhost, 42, 86400, 900, 86400, 86400;
} 

 
Вторая секция предназначен для обратного решения и использует опцию ptr. Заметьте, что Вы можете достигнуть того же эффекта, указав только первую секцию с reverse=on.
 

 
Здесь есть кое-что особое об имени во второй секции: когда решатель хочет получить имя узла по интернет-адресу, он формирует адрес, который будет построен из байтов IP-адреса в обратном порядке (1.0.0.127 вместо 127.0.0.1), где каждый байт адреса записывается как число, составляющее поддомен домена in-addr.arpa.
 

 
Так, если Вы хотите сформировать адрес для обратного решения, возьмите Ваш IP в точечной нотации (например 1.2.3.4), обратите порядок байтов (4.3.2.1) и дополните in-addr.arpa. (4.3.2.1.in-addr.arpa.). Теперь, определите секцию rr, задающую в опции ptr этот адрес в виде имени и доменное имя соответствующее IP.
 

 

 cname=строка; 
 

 

Определяет запись CNAME (каноническое имя). Аргумент должен быть полностью определённым именем узла в точечной нотации (см. name). CNAME - это  DNS -эквивалент псевдонима или символической ссылки.
 

 
Полезное применение для CNAME - задание коротких, легко запоминающихся имён для узлов со сложными именами. Например, Вы можете создать имя news для ссылки на сервер новостей nntp2.myisp.com вашего провайдера. Вместо добавления записи A для news с тем же адресом, что у nntp2.myisp.com, Вы можете задать CNAME указывющий на nntp2.myisp.com, так что если IP-адрес сервера новостей изменится, не возникнет необходимости обновлять запись для news.
 

 
Чтобы осуществить это в pdnsd, Вы можете добавить следующую секцию в Ваш конфигурационный файл:
 
 rr
{
    name = news;
    cname = nntp2.myisp.com;
    owner = localhost;
} 

 

 mx=строка,число; 
 

 

Определяет запись MX (почтовый обмен). Строка - это имя узла почтового сервера в точечной нотации (см. name). Число указывает уровень предпочтения.
 

 
Когда Вы отправляете письмо кому-либо, Ваше письмо обычно идёт от вашего клиента электронной почты к вашему  SMTP -серверу. Ваш  SMTP -сервер проверяет MX-запись домена в почтовом адресе. Например, для joe@example.com, будет просматриваться запись MX для example.com и будет найдено имя почтового сервера для этого домена, скажем, mail.example.com. Затем Ваш  SMTP -сервер получит A-запись для mail.example.com, и соединится с почтовым сервером адресата.
 

 
Если есть множество MX-записей, Ваш  SMTP -сервер будет выбирать одну из них, основываясь на уровнях предпочтений (начиная с наименьшего уровня предпочтения, учитывая работоспособность).
 

 
Не определяйте записи MX в pdnsd если Вы не знаете что Вы делаете.
 

 

 owner=строка; 
 

 

или
 

 

 ns=строка; 
 

 

Определяет запись NS (сервер имён). Указывает имя узла, который должен быть полномочным для записей, определённхы Вами в секции rr. Обычно это узел, где запущен pdnsd.
 

 
Замечание: В предыдущих версиях pdnsd эта опция должна была указываться перед любой записью A, PTR, CNAME, MX или SOA. В версии 1.2, ограничения на эту опцию такие же, как у только что упомянутых опций, она должна быть указана после опции name=. Это может быть неприятно, если Вы используете старый конфигурационный файл, в котором указывается owner= перед name= (сожалею об этом). Кроме большей согласованности, преимущество этого в том, что теперь Вы можете указать столько записей NS, сколько Вам нужно (включая ноль).
 

 

 soa=строка,строка,число,время,время,время,время; 
 

 

Определяет запись SOA (начало полномочий). Первая строка - это доменное имя сервера и должна совпадать с именем, которое Вы указали в качестве владельца.
 

 
Вторая строка указывает почтовый адрес администратора сервера имён. Он тоже указывается как доменное имя, поэтому Вы должны заменить знак @ в имени на точку (.) чтобы получить имя, которое Вы должны здесь указать. Следующий параметр (первое число) - это серийный номер записи. Вы должны увеличивать это число при изменении записи.
 

 
Четвёртый параметр - это период обновления. Он указывает время, по прошествии ккоторого кэширующий сервер должен попытаться обновить кэшированную запись.
 

 
Пятый параметр указывает время, через которое кэширующий сервер должен попытатья обновить запись после ошибки обновления.
 

 
Шестой параметр определяет тайм-аут, после которого кэшированная запись устареет, если она не была обновлена.
 

 
Седьмой параметр - это время жизни, которое указывается в каждой ресурсной записи и должно быть таким же, как заданное с помощью опции ttl (если Вы не указали ttl, используйте по умолчанию 86400).
 

 

 Секция neg 
 

 

Каждая секция neg указывает ресурсные записи  DNS  или домен  DNS , который должен локально кэшироваться отрицательно. Запросы отрицательно кэшированных записей всегда будут возвращать немедленный ответ с ошибкой или пустой ответ, без запроса других узлов до тех пор, пока запись правильна. Записи, определённые в секции neg, остаются действующими до тех пор, пока явно не будут аннулированы или удалены пользователем с помощью pdnsd-ctl.
 

 
Это полезно в тех случаях, когда определённое приложение периодически запрашивает несуществующие узлы или типы ресурсных записей, и Вы не хотите чтобы запрос отправлялся каждый раз, когда кэшированная запись устарела. Например: ненастроенный Netscape Communicator запрашивает серверы новостей и почты при каждом запуске. Если Вы не имеете списка поиска  DNS  для вашей сети, Вы можете предотвратить исходящие запросы к ним, указав
 
 neg
{
    name = news;
    types = domain;
}
neg
{
    name = mail;
    types = domain;
} 

 
в вашем конфигурационном файле. Если Вы имеете список поиска, Вы можете повторить эту запись в Вашем списке поиска в дополнение вышеуказанным записям!
 

 
В версии 1.1.11 и позже, если Вы отрицаете целый домен таким образом, все поддомены также будут отрицательными. Таким образом если Вы укажете
 
 neg
{
    name=example.com;
    types=domain;
} 

 
в конфигурационном файле, это также сделает отрицательным  www.example.com , xxx.adserver.example.com, и т.п.
 

 

 name=строка; 
 

 

Указывает имя домена, для которого будут созданы отрицательные записи в кэше. Эта опция должна быть указана перед опцией types. Имена интерпретируются как абсолютные имена доменов (то есть pdnsd принимает, что они оканчиваются корневым доменом). Вам нужно указывать имена доменов в точечной нотации (например venera.isi.edu.).
 

 
Предыдущие версии pdnsd требовали, чтобы эти имена доменов задавались в конфигурационном файле оканчивающимися точкой, но начиная с версии 1.1.8b1-par8, pdnsd автоматически подразумевает точку в конце, если она пропущена.
 

 

 ttl=время; 
 

 

Указывает время жизни для всех ресурсных записей в секции после этой записи. Это может быть переопределено. По умолчанию 86400 секунд (=1 день).
 

 

 types=(domain|rr_type[,rr_type[,rr_type[,...]]]); 
 

 

Указывает, что будет кэшироваться отрицательно: domain будет кэшировать отрицательно весь домен; кроме того, Вы можете указать через запятую список типов ресурсных записей, которые будут кэшироваться отрицательно. Вы можете указать несколько опций types, но домен и типы ресурсых записей взаимоисключают друг друга.
 

 
Типы ресурсных записей указываются используя их официальные имена, по RFC - заглавными буквами, то есть A, CNAME, NS, PTR, MX, AAAA, 
 

 
Команда pdnsd-ctl list-rrtypes позволяет Вам задать полный список этих типов. pdnsd-ctl компилируется вместе с pdnsd и устанавливается в тот же каталог, что и двоичный pdnsd, во время установки.
 

 

 Секция source 
 

 

Каждая секция source позволяет Вам заставить pdnsd прочитать записи из файла в формате похожем на /etc/hosts. pdnsd сгенерирует записи для решения адресной записи из имени его узла и напротив, для каждой записи в этом файле. Обычно это проще, чем определить ресурсную запись для каждого из Ваших адресов, поскольку localhost и другие Ваши полностью определённые доменные имена обычно уже заданы в /etc/hosts.
 

 
Принимаемый формат следующий: знак # начинает комментарий, остаток строки начиная с первого вхождения этого символа пропускается. Пустые строки так же пропускаются.
 

 
Первая запись в строке (предварённая произвольным числом табуляций и пробелов) - это IP в точечной нотации, вторая запись в строке (отделённая от первой произвольным числом табуляций или пробелов) - это полностью определённое доменное имя (FQDN) этого IP. Остаток строки по умолчанию пропускается (в оригинальном /etc/hosts, он может содержать информацию, которая не требуется pdnsd).
 

 

 owner=строка; 
 

 

Указывает имя узла, на котором запущен pdnsd и который указывается в  DNS -ответах (особые записи nameserver). Должен быть указан до любой опции file.
 

 
Имена интерпретируются как абсолютные доменные имена (то есть pdnsd подразумевает, что они оканчиваются корневым доменом). Вам нужно указать доменные имена в точечной нотации (например venera.isi.edu.).
 

 
Предыдущие версии pdnsd требуют чтобы доменные имена заданные в конфигурационном файле оканчивались точкой, но начиная с версии 1.1.8b1-par8, pdnsd автоматически подазумевает точку в конце, если она пропущена.
 

 

 ttl=время; 
 

 

Указывает время жизни для всех ресурсных записей в этой секции после этой опции. По умолчанию 86400 секунд (=1 день).
 

 

 file=строка; 
 

 

Строка указывает имя файла. Для каждой записи file в секции source, pdnsd будет пытаться загрузить заданный файл, как описано выше. Ошибка проявляется только если файл не может быть открыт, повреждённые записи будут пропущены.
 

 

 serve_aliases=(on|off); 
 

 

Если эта опция включена, pdnsd будет обслуживать псевдонимы, заданные в стиле файла hosts. Это третья запись в строке файла в стиле hosts, которая обычно задаёт короткое имя узла. Это может быть использовано для поддержки сломанных клиентов без соответствующей опции domain-search. Если нет псевдонимов, заданных в строке файла, pdnsd ведёт себя, как будто эта опция отключена для этой строки файла.
 

 
Эта возможность была предложена Бертом Фредериком (Bert Frederik).
 

 
Отключено по умолчанию.
 

 

 authrec=(on|off); 
 

 

Если опция включена, pdnsd будет создавать полномочные локальные записи с данными из файла hosts. Пожалуйста посмотрите описание опции с тем же названием в секции rr для более подробного описания её назначения. Пожалуйста заметьте, что эта опция влияет только на следующие за ней исходные файлы, указанные в опциях file.
 

 
Включено по умолчанию.
 

 

 ВЕРСИЯ 
 

 

Эта страница руководства корректна для версии 1.2.4-par pdnsd.
 

 

 СМ. ТАКЖЕ 
 

 

 pdnsd_8 ,  pdnsd-ctl_8 
 

 
Больше документации доступно в подкаталоге doc/ исходных текстов, или в /usr/share/doc/pdnsd/, если Вы используете двоичный пакет.
 

 

 АВТОРЫ 
 

 

pdnsd изначально написан Томасом Моэстлом (Thomas Moestl)  tmoestl@gmx.net  и был существенно доработан Полом Ромбаутсом (Paul Rombouts)  p.a.rombouts@home.nl  (для версии 1.1.8b1-par и более поздних).
 

 
Кое-что ещё было использовано в pdnsd; см. файлы в исходных текстах или в каталоге /usr/share/doc/pdnsd/
 

 
Эта страница руководства была автоматически сгенерирована из  HTML -документации pdnsd, с помощью модифицированного  Perl -скрипта, написанного Полом Ромбаутсом (Paul Rombouts).
 

 
Последняя проверка: 07 января 2006, Пол Ромбаутс (Paul Rombouts)
 

 

 АВТОР ПЕРЕВОДА 
 

 

Перевод на русский язык выполнил Владимир Ступин  wheelof@gmail.com 

 

 

        
      
    
       
         
           
                     
           
          man/pdnsd.conf_5.txt · Последние изменения: 2009-02-05 20:24 (внешнее изменение)           
         
       

 
 
 
 Поиск по тексту MAN-ов:  
 
 
 
 
 
 
 
 
 
 
 


 
 


 
 
 
 
 
Спонсоры:
 
 
 
 
 
 
 
 
Хостинг:
 

 

 


 
 
 
 Закладки на сайте 
 Проследить за страницей 
 
 
Created 1996-2021 by  Maxim Chirkov 
 Добавить ,  Поддержать ,  Вебмастеру 
 
 
 
 


 
 
 






end_of_comments
#---------------------------------------

unset filename